Module(body=[Expr(value=Constant(value="\nCreate a wheel that, when installed, will make the source package 'editable'\n(add it to the interpreter's path, including metadata) per PEP 660. Replaces\n'setup.py develop'.\n\n.. note::\n   One of the mechanisms briefly mentioned in PEP 660 to implement editable installs is\n   to create a separated directory inside ``build`` and use a .pth file to point to that\n   directory. In the context of this file such directory is referred as\n   *auxiliary build directory* or ``auxiliary_dir``.\n")), Import(names=[alias(name='logging')]), Import(names=[alias(name='io')]), Import(names=[alias(name='os')]), Import(names=[alias(name='shutil')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='traceback')]), ImportFrom(module='contextlib', names=[alias(name='suppress')], level=0), ImportFrom(module='enum', names=[alias(name='Enum')], level=0), ImportFrom(module='inspect', names=[alias(name='cleandoc')], level=0), ImportFrom(module='itertools', names=[alias(name='chain')], level=0), ImportFrom(module='pathlib', names=[alias(name='Path')], level=0), ImportFrom(module='tempfile', names=[alias(name='TemporaryDirectory')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Dict'), alias(name='Iterable'), alias(name='Iterator'), alias(name='List'), alias(name='Mapping'), alias(name='Optional'), alias(name='Tuple'), alias(name='TypeVar'), alias(name='Union')], level=0), ImportFrom(names=[alias(name='Command'), alias(name='_normalization'), alias(name='_path'), alias(name='errors'), alias(name='namespaces')], level=2), ImportFrom(module='discovery', names=[alias(name='find_package_path')], level=2), ImportFrom(module='dist', names=[alias(name='Distribution')], level=2), ImportFrom(module='warnings', names=[alias(name='InformationOnly'), alias(name='SetuptoolsDeprecationWarning'), alias(name='SetuptoolsWarning')], level=2), ImportFrom(module='build_py', names=[alias(name='build_py', asname='build_py_cls')], level=1), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='wheel.wheelfile', names=[alias(name='WheelFile')], level=0)], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[ImportFrom(module='typing', names=[alias(name='Protocol')], level=0)], orelse=[If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='typing_extensions', names=[alias(name='Protocol')], level=0)], orelse=[ImportFrom(module='abc', names=[alias(name='ABC', asname='Protocol')], level=0)])]), Assign(targets=[Name(id='_Path', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Path', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='_P', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_P')], keywords=[keyword(arg='bound', value=Name(id='_Path', ctx=Load()))])), Assign(targets=[Name(id='_logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='_EditableMode', bases=[Name(id='Enum', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Possible editable installation modes:\n    `lenient` (new files automatically added to the package - DEFAULT);\n    `strict` (requires a new installation when files are added/removed); or\n    `compat` (attempts to emulate `python setup.py develop` - DEPRECATED).\n    ')), Assign(targets=[Name(id='STRICT', ctx=Store())], value=Constant(value='strict')), Assign(targets=[Name(id='LENIENT', ctx=Store())], value=Constant(value='lenient')), Assign(targets=[Name(id='COMPAT', ctx=Store())], value=Constant(value='compat')), FunctionDef(name='convert', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='mode', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='mode', ctx=Load())), body=[Return(value=Attribute(value=Name(id='_EditableMode', ctx=Load()), attr='LENIENT', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='_mode', ctx=Store())], value=Call(func=Attribute(value=Name(id='mode', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='_mode', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='_EditableMode', ctx=Load()), attr='__members__', ctx=Load())]), body=[Raise(exc=Call(func=Attribute(value=Name(id='errors', ctx=Load()), attr='OptionError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid editable mode: '), FormattedValue(value=Name(id='mode', ctx=Load()), conversion=114), Constant(value=". Try: 'strict'.")])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='_mode', ctx=Load()), ops=[Eq()], comparators=[Constant(value='COMPAT')]), body=[Expr(value=Call(func=Attribute(value=Name(id='SetuptoolsDeprecationWarning', ctx=Load()), attr='emit', ctx=Load()), args=[Constant(value='Compat editable installs'), Constant(value="\n                The 'compat' editable mode is transitional and will be removed\n                in future versions of `setuptools`.\n                Please adapt your code accordingly to use either the 'strict' or the\n                'lenient' modes.\n                ")], keywords=[keyword(arg='see_docs', value=Constant(value='userguide/development_mode.html'))]))], orelse=[]), Return(value=Subscript(value=Name(id='_EditableMode', ctx=Load()), slice=Name(id='_mode', ctx=Load()), ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='_EditableMode'))], decorator_list=[]), Assign(targets=[Name(id='_STRICT_WARNING', ctx=Store())], value=Constant(value='\nNew or renamed files may not be automatically picked up without a new installation.\n')), Assign(targets=[Name(id='_LENIENT_WARNING', ctx=Store())], value=Constant(value='\nOptions like `package-data`, `include/exclude-package-data` or\n`packages.find.exclude/include` may have no effect.\n')), ClassDef(name='editable_wheel', bases=[Name(id='Command', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Build 'editable' wheel for development.\n    This command is private and reserved for internal use of setuptools,\n    users should rely on ``setuptools.build_meta`` APIs.\n    ")), Assign(targets=[Name(id='description', ctx=Store())], value=Constant(value='DO NOT CALL DIRECTLY, INTERNAL ONLY: create PEP 660 editable wheel')), Assign(targets=[Name(id='user_options', ctx=Store())], value=List(elts=[Tuple(elts=[Constant(value='dist-dir='), Constant(value='d'), Constant(value='directory to put final built distributions in')], ctx=Load()), Tuple(elts=[Constant(value='dist-info-dir='), Constant(value='I'), Constant(value='path to a pre-build .dist-info directory')], ctx=Load()), Tuple(elts=[Constant(value='mode='), Constant(value=None), Call(func=Name(id='cleandoc', ctx=Load()), args=[BoolOp(op=Or(), values=[Attribute(value=Name(id='_EditableMode', ctx=Load()), attr='__doc__', ctx=Load()), Constant(value='')])], keywords=[])], ctx=Load())], ctx=Load())), FunctionDef(name='initialize_options', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_dir', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_info_dir', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='project_dir', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mode', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='finalize_options', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='dist', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='project_dir', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='dist', ctx=Load()), attr='src_root', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='curdir', ctx=Load())])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='package_dir', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='dist', ctx=Load()), attr='package_dir', ctx=Load()), Dict(keys=[], values=[])])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_dir', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_dir', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='project_dir', ctx=Load()), Constant(value='dist')], keywords=[])])], keywords=[]))], decorator_list=[]), FunctionDef(name='run', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist_dir', ctx=Load()), attr='mkdir', ctx=Load()), args=[], keywords=[keyword(arg='exist_ok', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_ensure_dist_info', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='reinitialize_command', ctx=Load()), args=[Constant(value='bdist_wheel')], keywords=[])), Assign(targets=[Name(id='bdist_wheel', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_finalized_command', ctx=Load()), args=[Constant(value='bdist_wheel')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='bdist_wheel', ctx=Load()), attr='write_wheelfile', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_info_dir', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_create_wheel_file', ctx=Load()), args=[Name(id='bdist_wheel', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='print_exc', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='project', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load()), attr='name', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load()), attr='get_name', ctx=Load()), args=[], keywords=[])])), Expr(value=Call(func=Attribute(value=Name(id='_DebuggingTips', ctx=Load()), attr='emit', ctx=Load()), args=[], keywords=[keyword(arg='project', value=Name(id='project', ctx=Load()))])), Raise()])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='_ensure_dist_info', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='dist_info_dir', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='dist_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='reinitialize_command', ctx=Load()), args=[Constant(value='dist_info')], keywords=[])), Assign(targets=[Attribute(value=Name(id='dist_info', ctx=Load()), attr='output_dir', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='dist_dir', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='dist_info', ctx=Load()), attr='ensure_finalized', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='dist_info', ctx=Load()), attr='run', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_info_dir', ctx=Store())], value=Attribute(value=Name(id='dist_info', ctx=Load()), attr='dist_info_dir', ctx=Load()))], orelse=[Assert(test=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_info_dir', ctx=Load())], keywords=[]), attr='endswith', ctx=Load()), args=[Constant(value='.dist-info')], keywords=[])), Assert(test=Call(func=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_info_dir', ctx=Load()), Constant(value='METADATA')], keywords=[]), attr='exists', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='_install_namespaces', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='installation_dir'), arg(arg='pth_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='dist', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='dist', ctx=Load()), attr='namespace_packages', ctx=Load())), body=[Return()], orelse=[]), Assign(targets=[Name(id='src_root', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='project_dir', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='package_dir', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value=''), Constant(value='.')], keywords=[])], keywords=[]), attr='resolve', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='installer', ctx=Store())], value=Call(func=Name(id='_NamespaceInstaller', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='installation_dir', ctx=Load()), Name(id='pth_prefix', ctx=Load()), Name(id='src_root', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='installer', ctx=Load()), attr='install_namespaces', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_find_egg_info_dir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parent_dir', ctx=Store())], value=IfExp(test=Attribute(value=Name(id='self', ctx=Load()), attr='dist_info_dir', ctx=Load()), body=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_info_dir', ctx=Load())], keywords=[]), attr='parent', ctx=Load()), orelse=Call(func=Name(id='Path', ctx=Load()), args=[], keywords=[]))), Assign(targets=[Name(id='candidates', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Call(func=Attribute(value=Name(id='parent_dir', ctx=Load()), attr='glob', ctx=Load()), args=[Constant(value='*.egg-info')], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='candidates', ctx=Load()), Constant(value=None)], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_configure_build', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='unpacked_wheel', annotation=Name(id='_Path', ctx=Load())), arg(arg='build_lib', annotation=Name(id='_Path', ctx=Load())), arg(arg='tmp_dir', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Configure commands to behave in the following ways:\n\n        - Build commands can write to ``build_lib`` if they really want to...\n          (but this folder is expected to be ignored and modules are expected to live\n          in the project directory...)\n        - Binary extensions should be built in-place (editable_mode = True)\n        - Data/header/script files are not part of the "editable" specification\n          so they are written directly to the unpacked_wheel directory.\n        ')), Assign(targets=[Name(id='dist', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load())), Assign(targets=[Name(id='wheel', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='unpacked_wheel', ctx=Load())], keywords=[])), Assign(targets=[Name(id='build_lib', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='build_lib', ctx=Load())], keywords=[])), Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='Path', ctx=Load()), args=[Name(id='unpacked_wheel', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='.data')]), Constant(value='data')], keywords=[])], keywords=[])), Assign(targets=[Name(id='headers', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='Path', ctx=Load()), args=[Name(id='unpacked_wheel', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='.data')]), Constant(value='headers')], keywords=[])], keywords=[])), Assign(targets=[Name(id='scripts', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='Path', ctx=Load()), args=[Name(id='unpacked_wheel', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='.data')]), Constant(value='scripts')], keywords=[])], keywords=[])), Assign(targets=[Name(id='egg_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='reinitialize_command', ctx=Load()), args=[Constant(value='egg_info')], keywords=[keyword(arg='reinit_subcommands', value=Constant(value=True))])), Assign(targets=[Attribute(value=Name(id='egg_info', ctx=Load()), attr='egg_base', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='tmp_dir', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='egg_info', ctx=Load()), attr='ignore_egg_info_in_manifest', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='build', ctx=Store())], value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='reinitialize_command', ctx=Load()), args=[Constant(value='build')], keywords=[keyword(arg='reinit_subcommands', value=Constant(value=True))])), Assign(targets=[Name(id='install', ctx=Store())], value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='reinitialize_command', ctx=Load()), args=[Constant(value='install')], keywords=[keyword(arg='reinit_subcommands', value=Constant(value=True))])), Assign(targets=[Attribute(value=Name(id='build', ctx=Load()), attr='build_platlib', ctx=Store()), Attribute(value=Name(id='build', ctx=Load()), attr='build_purelib', ctx=Store()), Attribute(value=Name(id='build', ctx=Load()), attr='build_lib', ctx=Store())], value=Name(id='build_lib', ctx=Load())), Assign(targets=[Attribute(value=Name(id='install', ctx=Load()), attr='install_purelib', ctx=Store()), Attribute(value=Name(id='install', ctx=Load()), attr='install_platlib', ctx=Store()), Attribute(value=Name(id='install', ctx=Load()), attr='install_lib', ctx=Store())], value=Name(id='wheel', ctx=Load())), Assign(targets=[Attribute(value=Name(id='install', ctx=Load()), attr='install_scripts', ctx=Store()), Attribute(value=Name(id='build', ctx=Load()), attr='build_scripts', ctx=Store())], value=Name(id='scripts', ctx=Load())), Assign(targets=[Attribute(value=Name(id='install', ctx=Load()), attr='install_headers', ctx=Store())], value=Name(id='headers', ctx=Load())), Assign(targets=[Attribute(value=Name(id='install', ctx=Load()), attr='install_data', ctx=Store())], value=Name(id='data', ctx=Load())), Assign(targets=[Name(id='install_scripts', ctx=Store())], value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='get_command_obj', ctx=Load()), args=[Constant(value='install_scripts')], keywords=[])), Assign(targets=[Attribute(value=Name(id='install_scripts', ctx=Load()), attr='no_ep', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='build', ctx=Load()), attr='build_temp', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='tmp_dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='build_py', ctx=Store())], value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='get_command_obj', ctx=Load()), args=[Constant(value='build_py')], keywords=[])), Assign(targets=[Attribute(value=Name(id='build_py', ctx=Load()), attr='compile', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='build_py', ctx=Load()), attr='existing_egg_info_dir', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_egg_info_dir', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_set_editable_mode', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='build', ctx=Load()), attr='ensure_finalized', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='install', ctx=Load()), attr='ensure_finalized', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_set_editable_mode', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Set the ``editable_mode`` flag in the build sub-commands')), Assign(targets=[Name(id='dist', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load())), Assign(targets=[Name(id='build', ctx=Store())], value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='get_command_obj', ctx=Load()), args=[Constant(value='build')], keywords=[])), For(target=Name(id='cmd_name', ctx=Store()), iter=Call(func=Attribute(value=Name(id='build', ctx=Load()), attr='get_sub_commands', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='cmd', ctx=Store())], value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='get_command_obj', ctx=Load()), args=[Name(id='cmd_name', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cmd', ctx=Load()), Constant(value='editable_mode')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='cmd', ctx=Load()), attr='editable_mode', ctx=Store())], value=Constant(value=True))], orelse=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cmd', ctx=Load()), Constant(value='inplace')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='cmd', ctx=Load()), attr='inplace', ctx=Store())], value=Constant(value=True))], orelse=[])])], orelse=[])], decorator_list=[]), FunctionDef(name='_collect_build_outputs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='files', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='mapping', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), Assign(targets=[Name(id='build', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_finalized_command', ctx=Load()), args=[Constant(value='build')], keywords=[])), For(target=Name(id='cmd_name', ctx=Store()), iter=Call(func=Attribute(value=Name(id='build', ctx=Load()), attr='get_sub_commands', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='cmd', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_finalized_command', ctx=Load()), args=[Name(id='cmd_name', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cmd', ctx=Load()), Constant(value='get_outputs')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='files', ctx=Load()), attr='extend', ctx=Load()), args=[BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='cmd', ctx=Load()), attr='get_outputs', ctx=Load()), args=[], keywords=[]), List(elts=[], ctx=Load())])], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cmd', ctx=Load()), Constant(value='get_output_mapping')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='mapping', ctx=Load()), attr='update', ctx=Load()), args=[BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='cmd', ctx=Load()), attr='get_output_mapping', ctx=Load()), args=[], keywords=[]), Dict(keys=[], values=[])])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='files', ctx=Load()), Name(id='mapping', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_run_build_commands', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist_name', annotation=Name(id='str', ctx=Load())), arg(arg='unpacked_wheel', annotation=Name(id='_Path', ctx=Load())), arg(arg='build_lib', annotation=Name(id='_Path', ctx=Load())), arg(arg='tmp_dir', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_configure_build', ctx=Load()), args=[Name(id='dist_name', ctx=Load()), Name(id='unpacked_wheel', ctx=Load()), Name(id='build_lib', ctx=Load()), Name(id='tmp_dir', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_run_build_subcommands', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='files', ctx=Store()), Name(id='mapping', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_collect_build_outputs', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_run_install', ctx=Load()), args=[Constant(value='headers')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_run_install', ctx=Load()), args=[Constant(value='scripts')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_run_install', ctx=Load()), args=[Constant(value='data')], keywords=[])), Return(value=Tuple(elts=[Name(id='files', ctx=Load()), Name(id='mapping', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_run_build_subcommands', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Issue #3501 indicates that some plugins/customizations might rely on:\n\n        1. ``build_py`` not running\n        2. ``build_py`` always copying files to ``build_lib``\n\n        However both these assumptions may be false in editable_wheel.\n        This method implements a temporary workaround to support the ecosystem\n        while the implementations catch up.\n        ')), AnnAssign(target=Name(id='build', ctx=Store()), annotation=Name(id='Command', ctx=Load()), value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_finalized_command', ctx=Load()), args=[Constant(value='build')], keywords=[]), simple=1), For(target=Name(id='name', ctx=Store()), iter=Call(func=Attribute(value=Name(id='build', ctx=Load()), attr='get_sub_commands', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='cmd', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_finalized_command', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='build_py')]), Compare(left=Call(func=Name(id='type', ctx=Load()), args=[Name(id='cmd', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='build_py_cls', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_safely_run', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='run_command', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))])], orelse=[])], decorator_list=[]), FunctionDef(name='_safely_run', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cmd_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='run_command', ctx=Load()), args=[Name(id='cmd_name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='SetuptoolsDeprecationWarning', ctx=Load()), attr='emit', ctx=Load()), args=[Constant(value='Customization incompatible with editable install'), JoinedStr(values=[Constant(value='\n                '), FormattedValue(value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='format_exc', ctx=Load()), args=[], keywords=[]), conversion=-1), Constant(value='\n\n                If you are seeing this warning it is very likely that a setuptools\n                plugin or customization overrides the `'), FormattedValue(value=Name(id='cmd_name', ctx=Load()), conversion=-1), Constant(value='` command, without\n                taking into consideration how editable installs run build steps\n                starting from setuptools v64.0.0.\n\n                Plugin authors and developers relying on custom build steps are\n                encouraged to update their `'), FormattedValue(value=Name(id='cmd_name', ctx=Load()), conversion=-1), Constant(value='` implementation considering the\n                information about editable installs in\n                https://setuptools.pypa.io/en/latest/userguide/extension.html.\n\n                For the time being `setuptools` will silence this error and ignore\n                the faulty command, but this behaviour will change in future versions.\n                ')])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='_create_wheel_file', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='bdist_wheel')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='wheel.wheelfile', names=[alias(name='WheelFile')], level=0), Assign(targets=[Name(id='dist_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_finalized_command', ctx=Load()), args=[Constant(value='dist_info')], keywords=[])), Assign(targets=[Name(id='dist_name', ctx=Store())], value=Attribute(value=Name(id='dist_info', ctx=Load()), attr='name', ctx=Load())), Assign(targets=[Name(id='tag', ctx=Store())], value=Call(func=Attribute(value=Constant(value='-'), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='bdist_wheel', ctx=Load()), attr='get_tag', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='build_tag', ctx=Store())], value=Constant(value='0.editable')), Assign(targets=[Name(id='archive_name', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='dist_name', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='build_tag', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='tag', ctx=Load()), conversion=-1), Constant(value='.whl')])), Assign(targets=[Name(id='wheel_path', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_dir', ctx=Load()), Name(id='archive_name', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='wheel_path', ctx=Load()), attr='exists', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='wheel_path', ctx=Load()), attr='unlink', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='unpacked_wheel', ctx=Store())], value=Call(func=Name(id='TemporaryDirectory', ctx=Load()), args=[], keywords=[keyword(arg='suffix', value=Name(id='archive_name', ctx=Load()))])), Assign(targets=[Name(id='build_lib', ctx=Store())], value=Call(func=Name(id='TemporaryDirectory', ctx=Load()), args=[], keywords=[keyword(arg='suffix', value=Constant(value='.build-lib'))])), Assign(targets=[Name(id='build_tmp', ctx=Store())], value=Call(func=Name(id='TemporaryDirectory', ctx=Load()), args=[], keywords=[keyword(arg='suffix', value=Constant(value='.build-temp'))])), With(items=[withitem(context_expr=Name(id='unpacked_wheel', ctx=Load()), optional_vars=Name(id='unpacked', ctx=Store())), withitem(context_expr=Name(id='build_lib', ctx=Load()), optional_vars=Name(id='lib', ctx=Store())), withitem(context_expr=Name(id='build_tmp', ctx=Load()), optional_vars=Name(id='tmp', ctx=Store()))], body=[Assign(targets=[Name(id='unpacked_dist_info', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='unpacked', ctx=Load()), Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_info_dir', ctx=Load())], keywords=[]), attr='name', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='copytree', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_info_dir', ctx=Load()), Name(id='unpacked_dist_info', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_install_namespaces', ctx=Load()), args=[Name(id='unpacked', ctx=Load()), Name(id='dist_name', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='files', ctx=Store()), Name(id='mapping', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_run_build_commands', ctx=Load()), args=[Name(id='dist_name', ctx=Load()), Name(id='unpacked', ctx=Load()), Name(id='lib', ctx=Load()), Name(id='tmp', ctx=Load())], keywords=[])), Assign(targets=[Name(id='strategy', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_select_strategy', ctx=Load()), args=[Name(id='dist_name', ctx=Load()), Name(id='tag', ctx=Load()), Name(id='lib', ctx=Load())], keywords=[])), With(items=[withitem(context_expr=Name(id='strategy', ctx=Load())), withitem(context_expr=Call(func=Name(id='WheelFile', ctx=Load()), args=[Name(id='wheel_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='wheel_obj', ctx=Store()))], body=[Expr(value=Call(func=Name(id='strategy', ctx=Load()), args=[Name(id='wheel_obj', ctx=Load()), Name(id='files', ctx=Load()), Name(id='mapping', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='wheel_obj', ctx=Load()), attr='write_files', ctx=Load()), args=[Name(id='unpacked', ctx=Load())], keywords=[]))])]), Return(value=Name(id='wheel_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='_run_install', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='category', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='has_category', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load()), JoinedStr(values=[Constant(value='has_'), FormattedValue(value=Name(id='category', ctx=Load()), conversion=-1)]), Constant(value=None)], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='has_category', ctx=Load()), Call(func=Name(id='has_category', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='_logger', ctx=Load()), attr='info', ctx=Load()), args=[JoinedStr(values=[Constant(value='Installing '), FormattedValue(value=Name(id='category', ctx=Load()), conversion=-1), Constant(value=' as non editable')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='run_command', ctx=Load()), args=[JoinedStr(values=[Constant(value='install_'), FormattedValue(value=Name(id='category', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_select_strategy', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='tag', annotation=Name(id='str', ctx=Load())), arg(arg='build_lib', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Decides which strategy to use to implement an editable installation.')), Assign(targets=[Name(id='build_name', ctx=Store())], value=JoinedStr(values=[Constant(value='__editable__.'), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='tag', ctx=Load()), conversion=-1)])), Assign(targets=[Name(id='project_dir', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='project_dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='mode', ctx=Store())], value=Call(func=Attribute(value=Name(id='_EditableMode', ctx=Load()), attr='convert', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='mode', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='mode', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='_EditableMode', ctx=Load()), attr='STRICT', ctx=Load())]), body=[Assign(targets=[Name(id='auxiliary_dir', ctx=Store())], value=Call(func=Name(id='_empty_dir', ctx=Load()), args=[Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='project_dir', ctx=Load()), Constant(value='build'), Name(id='build_name', ctx=Load())], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='_LinkTree', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load()), Name(id='name', ctx=Load()), Name(id='auxiliary_dir', ctx=Load()), Name(id='build_lib', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='packages', ctx=Store())], value=Call(func=Name(id='_find_packages', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load())], keywords=[])), Assign(targets=[Name(id='has_simple_layout', ctx=Store())], value=Call(func=Name(id='_simple_layout', ctx=Load()), args=[Name(id='packages', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='package_dir', ctx=Load()), Name(id='project_dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='is_compat_mode', ctx=Store())], value=Compare(left=Name(id='mode', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='_EditableMode', ctx=Load()), attr='COMPAT', ctx=Load())])), If(test=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='package_dir', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Set(elts=[Constant(value='')])]), Name(id='has_simple_layout', ctx=Load())]), Name(id='is_compat_mode', ctx=Load())]), body=[Assign(targets=[Name(id='src_dir', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='package_dir', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value=''), Constant(value='.')], keywords=[])), Return(value=Call(func=Name(id='_StaticPth', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load()), Name(id='name', ctx=Load()), List(elts=[Call(func=Name(id='Path', ctx=Load()), args=[Name(id='project_dir', ctx=Load()), Name(id='src_dir', ctx=Load())], keywords=[])], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='_TopLevelFinder', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='EditableStrategy'))], decorator_list=[]), ClassDef(name='EditableStrategy', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='wheel', annotation=Constant(value='WheelFile')), arg(arg='files', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='mapping', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_exc_type'), arg(arg='_exc_value'), arg(arg='_traceback')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[])], decorator_list=[]), ClassDef(name='_StaticPth', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist', annotation=Name(id='Distribution', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='path_entries', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Store())], value=Name(id='dist', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='path_entries', ctx=Store())], value=Name(id='path_entries', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='wheel', annotation=Constant(value='WheelFile')), arg(arg='files', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='mapping', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='entries', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='resolve', ctx=Load()), args=[], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='path_entries', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='contents', ctx=Store())], value=Call(func=Name(id='_encode_pth', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='entries', ctx=Load()), conversion=-1), Constant(value='\n')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='wheel', ctx=Load()), attr='writestr', ctx=Load()), args=[JoinedStr(values=[Constant(value='__editable__.'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value='.pth')]), Name(id='contents', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='\n        Editable install will be performed using .pth file to extend `sys.path` with:\n        '), FormattedValue(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='fspath', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='path_entries', ctx=Load())], keywords=[])], keywords=[]), conversion=114), Constant(value='\n        ')])), Expr(value=Call(func=Attribute(value=Name(id='_logger', ctx=Load()), attr='warning', ctx=Load()), args=[BinOp(left=Name(id='msg', ctx=Load()), op=Add(), right=Name(id='_LENIENT_WARNING', ctx=Load()))], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_exc_type'), arg(arg='_exc_value'), arg(arg='_traceback')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[])], decorator_list=[]), ClassDef(name='_LinkTree', bases=[Name(id='_StaticPth', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Creates a ``.pth`` file that points to a link tree in the ``auxiliary_dir``.\n\n    This strategy will only link files (not dirs), so it can be implemented in\n    any OS, even if that means using hardlinks instead of symlinks.\n\n    By collocating ``auxiliary_dir`` and the original source code, limitations\n    with hardlinks should be avoided.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist', annotation=Name(id='Distribution', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='auxiliary_dir', annotation=Name(id='_Path', ctx=Load())), arg(arg='build_lib', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='auxiliary_dir', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='auxiliary_dir', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='build_lib', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='build_lib', ctx=Load())], keywords=[]), attr='resolve', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_file', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='get_command_obj', ctx=Load()), args=[Constant(value='build_py')], keywords=[]), attr='copy_file', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='name', ctx=Load()), List(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='auxiliary_dir', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='wheel', annotation=Constant(value='WheelFile')), arg(arg='files', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='mapping', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_create_links', ctx=Load()), args=[Name(id='files', ctx=Load()), Name(id='mapping', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__call__', ctx=Load()), args=[Name(id='wheel', ctx=Load()), Name(id='files', ctx=Load()), Name(id='mapping', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_normalize_output', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='file', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='suppress', ctx=Load()), args=[Name(id='ValueError', ctx=Load())], keywords=[]))], body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[]), attr='resolve', ctx=Load()), args=[], keywords=[]), attr='relative_to', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='build_lib', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), attr='replace', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), Constant(value='/')], keywords=[]))]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_create_file', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='relative_output', annotation=Name(id='str', ctx=Load())), arg(arg='src_file', annotation=Name(id='str', ctx=Load())), arg(arg='link')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='dest', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='auxiliary_dir', ctx=Load()), op=Div(), right=Name(id='relative_output', ctx=Load()))), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='dest', ctx=Load()), attr='parent', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='dest', ctx=Load()), attr='parent', ctx=Load()), attr='mkdir', ctx=Load()), args=[], keywords=[keyword(arg='parents', value=Constant(value=True))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_file', ctx=Load()), args=[Name(id='src_file', ctx=Load()), Name(id='dest', ctx=Load())], keywords=[keyword(arg='link', value=Name(id='link', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_create_links', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='outputs'), arg(arg='output_mapping')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='auxiliary_dir', ctx=Load()), attr='mkdir', ctx=Load()), args=[], keywords=[keyword(arg='parents', value=Constant(value=True)), keyword(arg='exist_ok', value=Constant(value=True))])), Assign(targets=[Name(id='link_type', ctx=Store())], value=IfExp(test=Call(func=Name(id='_can_symlink_files', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='auxiliary_dir', ctx=Load())], keywords=[]), body=Constant(value='sym'), orelse=Constant(value='hard'))), Assign(targets=[Name(id='mappings', ctx=Store())], value=DictComp(key=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_normalize_output', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), value=Name(id='v', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='output_mapping', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='mappings', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value=None), Constant(value=None)], keywords=[])), For(target=Name(id='output', ctx=Store()), iter=Name(id='outputs', ctx=Load()), body=[Assign(targets=[Name(id='relative', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_normalize_output', ctx=Load()), args=[Name(id='output', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='relative', ctx=Load()), Compare(left=Name(id='relative', ctx=Load()), ops=[NotIn()], comparators=[Name(id='mappings', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_create_file', ctx=Load()), args=[Name(id='relative', ctx=Load()), Name(id='output', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), For(target=Tuple(elts=[Name(id='relative', ctx=Store()), Name(id='src', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='mappings', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_create_file', ctx=Load()), args=[Name(id='relative', ctx=Load()), Name(id='src', ctx=Load())], keywords=[keyword(arg='link', value=Name(id='link_type', ctx=Load()))]))], orelse=[])], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Strict editable install will be performed using a link tree.\n')), Expr(value=Call(func=Attribute(value=Name(id='_logger', ctx=Load()), attr='warning', ctx=Load()), args=[BinOp(left=Name(id='msg', ctx=Load()), op=Add(), right=Name(id='_STRICT_WARNING', ctx=Load()))], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_exc_type'), arg(arg='_exc_value'), arg(arg='_traceback')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='\n\n        Strict editable installation performed using the auxiliary directory:\n            '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='auxiliary_dir', ctx=Load()), conversion=-1), Constant(value='\n\n        Please be careful to not remove this directory, otherwise you might not be able\n        to import/use your package.\n        ')])), Expr(value=Call(func=Attribute(value=Name(id='InformationOnly', ctx=Load()), attr='emit', ctx=Load()), args=[Constant(value='Editable installation.'), Name(id='msg', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='_TopLevelFinder', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist', annotation=Name(id='Distribution', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Store())], value=Name(id='dist', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='wheel', annotation=Constant(value='WheelFile')), arg(arg='files', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='mapping', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='src_root', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='src_root', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='curdir', ctx=Load())])), Assign(targets=[Name(id='top_level', ctx=Store())], value=Call(func=Name(id='chain', ctx=Load()), args=[Call(func=Name(id='_find_packages', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load())], keywords=[]), Call(func=Name(id='_find_top_level_modules', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='package_dir', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='package_dir', ctx=Load()), Dict(keys=[], values=[])])), Assign(targets=[Name(id='roots', ctx=Store())], value=Call(func=Name(id='_find_package_roots', ctx=Load()), args=[Name(id='top_level', ctx=Load()), Name(id='package_dir', ctx=Load()), Name(id='src_root', ctx=Load())], keywords=[])), AnnAssign(target=Name(id='namespaces_', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='chain', ctx=Load()), args=[Call(func=Name(id='_find_namespaces', ctx=Load()), args=[BoolOp(op=Or(), values=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Load()), List(elts=[], ctx=Load())]), Name(id='roots', ctx=Load())], keywords=[]), GeneratorExp(elt=Tuple(elts=[Name(id='ns', ctx=Load()), List(elts=[], ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='ns', ctx=Store()), iter=Call(func=Name(id='_find_virtual_namespaces', ctx=Load()), args=[Name(id='roots', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])], keywords=[]), simple=1), Assign(targets=[Name(id='legacy_namespaces', ctx=Store())], value=DictComp(key=Name(id='pkg', ctx=Load()), value=Call(func=Name(id='find_package_path', ctx=Load()), args=[Name(id='pkg', ctx=Load()), Name(id='roots', ctx=Load()), BoolOp(op=Or(), values=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='src_root', ctx=Load()), Constant(value='')])], keywords=[]), generators=[comprehension(target=Name(id='pkg', ctx=Store()), iter=BoolOp(op=Or(), values=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='namespace_packages', ctx=Load()), List(elts=[], ctx=Load())]), ifs=[], is_async=0)])), Assign(targets=[Name(id='mapping', ctx=Store())], value=Dict(keys=[None, None], values=[Name(id='roots', ctx=Load()), Name(id='legacy_namespaces', ctx=Load())])), Assign(targets=[Name(id='name', ctx=Store())], value=JoinedStr(values=[Constant(value='__editable__.'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value='.finder')])), Assign(targets=[Name(id='finder', ctx=Store())], value=Call(func=Attribute(value=Name(id='_normalization', ctx=Load()), attr='safe_identifier', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Name(id='bytes', ctx=Load()), args=[Call(func=Name(id='_finder_template', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='mapping', ctx=Load()), Name(id='namespaces_', ctx=Load())], keywords=[]), Constant(value='utf-8')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='wheel', ctx=Load()), attr='writestr', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='finder', ctx=Load()), conversion=-1), Constant(value='.py')]), Name(id='content', ctx=Load())], keywords=[])), Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Name(id='_encode_pth', ctx=Load()), args=[JoinedStr(values=[Constant(value='import '), FormattedValue(value=Name(id='finder', ctx=Load()), conversion=-1), Constant(value='; '), FormattedValue(value=Name(id='finder', ctx=Load()), conversion=-1), Constant(value='.install()')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='wheel', ctx=Load()), attr='writestr', ctx=Load()), args=[JoinedStr(values=[Constant(value='__editable__.'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value='.pth')]), Name(id='content', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Editable install will be performed using a meta path finder.\n')), Expr(value=Call(func=Attribute(value=Name(id='_logger', ctx=Load()), attr='warning', ctx=Load()), args=[BinOp(left=Name(id='msg', ctx=Load()), op=Add(), right=Name(id='_LENIENT_WARNING', ctx=Load()))], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_exc_type'), arg(arg='_exc_value'), arg(arg='_traceback')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='\n\n        Please be careful with folders in your working directory with the same\n        name as your package as they may take precedence during imports.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='InformationOnly', ctx=Load()), attr='emit', ctx=Load()), args=[Constant(value='Editable installation.'), Name(id='msg', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='_encode_pth', args=arguments(posonlyargs=[], args=[arg(arg='content', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='.pth files are always read with \'locale\' encoding, the recommendation\n    from the cpython core developers is to write them as ``open(path, "w")``\n    and ignore warnings (see python/cpython#77102, pypa/setuptools#3937).\n    This function tries to simulate this behaviour without having to create an\n    actual file, in a way that supports a range of active Python versions.\n    (There seems to be some variety in the way different version of Python handle\n    ``encoding=None``, not all of them use ``locale.getpreferredencoding(False)``).\n    ')), Assign(targets=[Name(id='encoding', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=10)], ctx=Load())]), body=Constant(value='locale'), orelse=Constant(value=None))), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='io', ctx=Load()), attr='BytesIO', ctx=Load()), args=[], keywords=[]), optional_vars=Name(id='buffer', ctx=Store()))], body=[Assign(targets=[Name(id='wrapper', ctx=Store())], value=Call(func=Attribute(value=Name(id='io', ctx=Load()), attr='TextIOWrapper', ctx=Load()), args=[Name(id='buffer', ctx=Load()), Name(id='encoding', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='wrapper', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='wrapper', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='buffer', ctx=Load()), attr='seek', ctx=Load()), args=[Constant(value=0)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='buffer', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])], decorator_list=[], returns=Name(id='bytes', ctx=Load())), FunctionDef(name='_can_symlink_files', args=arguments(posonlyargs=[], args=[arg(arg='base_dir', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='TemporaryDirectory', ctx=Load()), args=[], keywords=[keyword(arg='dir', value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='base_dir', ctx=Load()), attr='resolve', ctx=Load()), args=[], keywords=[])], keywords=[]))]), optional_vars=Name(id='tmp', ctx=Store()))], body=[Assign(targets=[Tuple(elts=[Name(id='path1', ctx=Store()), Name(id='path2', ctx=Store())], ctx=Store())], value=Tuple(elts=[Call(func=Name(id='Path', ctx=Load()), args=[Name(id='tmp', ctx=Load()), Constant(value='file1.txt')], keywords=[]), Call(func=Name(id='Path', ctx=Load()), args=[Name(id='tmp', ctx=Load()), Constant(value='file2.txt')], keywords=[])], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='path1', ctx=Load()), attr='write_text', ctx=Load()), args=[Constant(value='file1')], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))])), With(items=[withitem(context_expr=Call(func=Name(id='suppress', ctx=Load()), args=[Name(id='AttributeError', ctx=Load()), Name(id='NotImplementedError', ctx=Load()), Name(id='OSError', ctx=Load())], keywords=[]))], body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='symlink', ctx=Load()), args=[Name(id='path1', ctx=Load()), Name(id='path2', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='path2', ctx=Load()), attr='is_symlink', ctx=Load()), args=[], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='path2', ctx=Load()), attr='read_text', ctx=Load()), args=[], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), ops=[Eq()], comparators=[Constant(value='file1')])]), body=[Return(value=Constant(value=True))], orelse=[])]), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='link', ctx=Load()), args=[Name(id='path1', ctx=Load()), Name(id='path2', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='ex', body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='File system does not seem to support either symlinks or hard links. Strict editable installs require one of them to be supported.')), Raise(exc=Call(func=Name(id='LinksNotSupported', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[]), Return(value=Constant(value=False))])], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_simple_layout', args=arguments(posonlyargs=[], args=[arg(arg='packages', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='package_dir', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='project_dir', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return ``True`` if:\n    - all packages are contained by the same parent directory, **and**\n    - all packages become importable if the parent directory is added to ``sys.path``.\n\n    >>> _simple_layout([\'a\'], {"": "src"}, "/tmp/myproj")\n    True\n    >>> _simple_layout([\'a\', \'a.b\'], {"": "src"}, "/tmp/myproj")\n    True\n    >>> _simple_layout([\'a\', \'a.b\'], {}, "/tmp/myproj")\n    True\n    >>> _simple_layout([\'a\', \'a.a1\', \'a.a1.a2\', \'b\'], {"": "src"}, "/tmp/myproj")\n    True\n    >>> _simple_layout([\'a\', \'a.a1\', \'a.a1.a2\', \'b\'], {"a": "a", "b": "b"}, ".")\n    True\n    >>> _simple_layout([\'a\', \'a.a1\', \'a.a1.a2\', \'b\'], {"a": "_a", "b": "_b"}, ".")\n    False\n    >>> _simple_layout([\'a\', \'a.a1\', \'a.a1.a2\', \'b\'], {"a": "_a"}, "/tmp/myproj")\n    False\n    >>> _simple_layout([\'a\', \'a.a1\', \'a.a1.a2\', \'b\'], {"a.a1.a2": "_a2"}, ".")\n    False\n    >>> _simple_layout([\'a\', \'a.b\'], {"": "src", "a.b": "_ab"}, "/tmp/myproj")\n    False\n    >>> # Special cases, no packages yet:\n    >>> _simple_layout([], {"": "src"}, "/tmp/myproj")\n    True\n    >>> _simple_layout([], {"a": "_a", "": "src"}, "/tmp/myproj")\n    False\n    ')), Assign(targets=[Name(id='layout', ctx=Store())], value=DictComp(key=Name(id='pkg', ctx=Load()), value=Call(func=Name(id='find_package_path', ctx=Load()), args=[Name(id='pkg', ctx=Load()), Name(id='package_dir', ctx=Load()), Name(id='project_dir', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='pkg', ctx=Store()), iter=Name(id='packages', ctx=Load()), ifs=[], is_async=0)])), If(test=UnaryOp(op=Not(), operand=Name(id='layout', ctx=Load())), body=[Return(value=Compare(left=Call(func=Name(id='set', ctx=Load()), args=[Name(id='package_dir', ctx=Load())], keywords=[]), ops=[In()], comparators=[Tuple(elts=[Dict(keys=[], values=[]), Set(elts=[Constant(value='')])], ctx=Load())]))], orelse=[]), Assign(targets=[Name(id='parent', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='commonpath', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='_parent_path', ctx=Load()), args=[Name(id='k', ctx=Load()), Name(id='v', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='layout', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Return(value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='_path', ctx=Load()), attr='same_path', ctx=Load()), args=[Call(func=Name(id='Path', ctx=Load()), args=[Name(id='parent', ctx=Load()), Starred(value=Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]), ctx=Load())], keywords=[]), Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='layout', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_parent_path', args=arguments(posonlyargs=[], args=[arg(arg='pkg'), arg(arg='pkg_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Infer the parent path containing a package, that if added to ``sys.path`` would\n    allow importing that package.\n    When ``pkg`` is directly mapped into a directory with a different name, return its\n    own path.\n    >>> _parent_path("a", "src/a")\n    \'src\'\n    >>> _parent_path("b", "src/c")\n    \'src/c\'\n    ')), Assign(targets=[Name(id='parent', ctx=Store())], value=IfExp(test=Call(func=Attribute(value=Name(id='pkg_path', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='pkg', ctx=Load())], keywords=[]), body=Subscript(value=Name(id='pkg_path', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pkg', ctx=Load())], keywords=[]))), ctx=Load()), orelse=Name(id='pkg_path', ctx=Load()))), Return(value=Call(func=Attribute(value=Name(id='parent', ctx=Load()), attr='rstrip', ctx=Load()), args=[BinOp(left=Constant(value='/'), op=Add(), right=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='_find_packages', args=arguments(posonlyargs=[], args=[arg(arg='dist', annotation=Name(id='Distribution', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=YieldFrom(value=Call(func=Name(id='iter', ctx=Load()), args=[BoolOp(op=Or(), values=[Attribute(value=Name(id='dist', ctx=Load()), attr='packages', ctx=Load()), List(elts=[], ctx=Load())])], keywords=[]))), Assign(targets=[Name(id='py_modules', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='dist', ctx=Load()), attr='py_modules', ctx=Load()), List(elts=[], ctx=Load())])), Assign(targets=[Name(id='nested_modules', ctx=Store())], value=ListComp(elt=Name(id='mod', ctx=Load()), generators=[comprehension(target=Name(id='mod', ctx=Store()), iter=Name(id='py_modules', ctx=Load()), ifs=[Compare(left=Constant(value='.'), ops=[In()], comparators=[Name(id='mod', ctx=Load())])], is_async=0)])), If(test=Attribute(value=Name(id='dist', ctx=Load()), attr='ext_package', ctx=Load()), body=[Expr(value=Yield(value=Attribute(value=Name(id='dist', ctx=Load()), attr='ext_package', ctx=Load())))], orelse=[Assign(targets=[Name(id='ext_modules', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='dist', ctx=Load()), attr='ext_modules', ctx=Load()), List(elts=[], ctx=Load())])), AugAssign(target=Name(id='nested_modules', ctx=Store()), op=Add(), value=ListComp(elt=Attribute(value=Name(id='x', ctx=Load()), attr='name', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='ext_modules', ctx=Load()), ifs=[Compare(left=Constant(value='.'), ops=[In()], comparators=[Attribute(value=Name(id='x', ctx=Load()), attr='name', ctx=Load())])], is_async=0)]))]), For(target=Name(id='module', ctx=Store()), iter=Name(id='nested_modules', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='package', ctx=Store()), Name(id='_', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='module', ctx=Load()), attr='rpartition', ctx=Load()), args=[Constant(value='.')], keywords=[])), Expr(value=Yield(value=Name(id='package', ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_find_top_level_modules', args=arguments(posonlyargs=[], args=[arg(arg='dist', annotation=Name(id='Distribution', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='py_modules', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='dist', ctx=Load()), attr='py_modules', ctx=Load()), List(elts=[], ctx=Load())])), Expr(value=YieldFrom(value=GeneratorExp(elt=Name(id='mod', ctx=Load()), generators=[comprehension(target=Name(id='mod', ctx=Store()), iter=Name(id='py_modules', ctx=Load()), ifs=[Compare(left=Constant(value='.'), ops=[NotIn()], comparators=[Name(id='mod', ctx=Load())])], is_async=0)]))), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='dist', ctx=Load()), attr='ext_package', ctx=Load())), body=[Assign(targets=[Name(id='ext_modules', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='dist', ctx=Load()), attr='ext_modules', ctx=Load()), List(elts=[], ctx=Load())])), Expr(value=YieldFrom(value=GeneratorExp(elt=Attribute(value=Name(id='x', ctx=Load()), attr='name', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='ext_modules', ctx=Load()), ifs=[Compare(left=Constant(value='.'), ops=[NotIn()], comparators=[Attribute(value=Name(id='x', ctx=Load()), attr='name', ctx=Load())])], is_async=0)])))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_find_package_roots', args=arguments(posonlyargs=[], args=[arg(arg='packages', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='package_dir', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='src_root', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='pkg_roots', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), value=DictComp(key=Name(id='pkg', ctx=Load()), value=Call(func=Name(id='_absolute_root', ctx=Load()), args=[Call(func=Name(id='find_package_path', ctx=Load()), args=[Name(id='pkg', ctx=Load()), Name(id='package_dir', ctx=Load()), Name(id='src_root', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='pkg', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='packages', ctx=Load())], keywords=[]), ifs=[], is_async=0)]), simple=1), Return(value=Call(func=Name(id='_remove_nested', ctx=Load()), args=[Name(id='pkg_roots', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_absolute_root', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Works for packages and top-level modules')), Assign(targets=[Name(id='path_', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='parent', ctx=Store())], value=Attribute(value=Name(id='path_', ctx=Load()), attr='parent', ctx=Load())), If(test=Call(func=Attribute(value=Name(id='path_', ctx=Load()), attr='exists', ctx=Load()), args=[], keywords=[]), body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='path_', ctx=Load()), attr='resolve', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='parent', ctx=Load()), attr='resolve', ctx=Load()), args=[], keywords=[]), op=Div(), right=Attribute(value=Name(id='path_', ctx=Load()), attr='name', ctx=Load()))], keywords=[]))])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_find_virtual_namespaces', args=arguments(posonlyargs=[], args=[arg(arg='pkg_roots', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='By carefully designing ``package_dir``, it is possible to implement the logical\n    structure of PEP 420 in a package without the corresponding directories.\n\n    Moreover a parent package can be purposefully/accidentally skipped in the discovery\n    phase (e.g. ``find_packages(include=["mypkg.*"])``, when ``mypkg.foo`` is included\n    by ``mypkg`` itself is not).\n    We consider this case to also be a virtual namespace (ignoring the original\n    directory) to emulate a non-editable installation.\n\n    This function will try to find these kinds of namespaces.\n    ')), For(target=Name(id='pkg', ctx=Store()), iter=Name(id='pkg_roots', ctx=Load()), body=[If(test=Compare(left=Constant(value='.'), ops=[NotIn()], comparators=[Name(id='pkg', ctx=Load())]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='pkg', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1)), Constant(value=0), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), body=[Assign(targets=[Name(id='partial_name', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Subscript(value=Name(id='parts', ctx=Load()), slice=Slice(upper=Name(id='i', ctx=Load())), ctx=Load())], keywords=[])), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Call(func=Name(id='find_package_path', ctx=Load()), args=[Name(id='partial_name', ctx=Load()), Name(id='pkg_roots', ctx=Load()), Constant(value='')], keywords=[])], keywords=[])), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='exists', ctx=Load()), args=[], keywords=[])), Compare(left=Name(id='partial_name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='pkg_roots', ctx=Load())])]), body=[Expr(value=Yield(value=Name(id='partial_name', ctx=Load())))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_find_namespaces', args=arguments(posonlyargs=[], args=[arg(arg='packages', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='pkg_roots', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='pkg', ctx=Store()), iter=Name(id='packages', ctx=Load()), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='find_package_path', ctx=Load()), args=[Name(id='pkg', ctx=Load()), Name(id='pkg_roots', ctx=Load()), Constant(value='')], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), attr='exists', ctx=Load()), args=[], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='__init__.py')], keywords=[]), attr='exists', ctx=Load()), args=[], keywords=[]))]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='pkg', ctx=Load()), List(elts=[Name(id='path', ctx=Load())], ctx=Load())], ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='_remove_nested', args=arguments(posonlyargs=[], args=[arg(arg='pkg_roots', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='output', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pkg_roots', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='pkg', ctx=Store()), Name(id='path', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pkg_roots', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]), body=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Compare(left=Name(id='pkg', ctx=Load()), ops=[NotEq()], comparators=[Name(id='other', ctx=Load())]), Call(func=Name(id='_is_nested', ctx=Load()), args=[Name(id='pkg', ctx=Load()), Name(id='path', ctx=Load()), Name(id='other', ctx=Load()), Name(id='other_path', ctx=Load())], keywords=[])]), generators=[comprehension(target=Tuple(elts=[Name(id='other', ctx=Store()), Name(id='other_path', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='pkg_roots', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='output', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='pkg', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='output', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_is_nested', args=arguments(posonlyargs=[], args=[arg(arg='pkg', annotation=Name(id='str', ctx=Load())), arg(arg='pkg_path', annotation=Name(id='str', ctx=Load())), arg(arg='parent', annotation=Name(id='str', ctx=Load())), arg(arg='parent_path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return ``True`` if ``pkg`` is nested inside ``parent`` both logically and in the\n    file system.\n    >>> _is_nested("a.b", "path/a/b", "a", "path/a")\n    True\n    >>> _is_nested("a.b", "path/a/b", "a", "otherpath/a")\n    False\n    >>> _is_nested("a.b", "path/a/b", "c", "path/c")\n    False\n    >>> _is_nested("a.a", "path/a/a", "a", "path/a")\n    True\n    >>> _is_nested("b.a", "path/b/a", "a", "path/a")\n    False\n    ')), Assign(targets=[Name(id='norm_pkg_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='_path', ctx=Load()), attr='normpath', ctx=Load()), args=[Name(id='pkg_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='rest', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pkg', ctx=Load()), attr='replace', ctx=Load()), args=[Name(id='parent', ctx=Load()), Constant(value=''), Constant(value=1)], keywords=[]), attr='strip', ctx=Load()), args=[Constant(value='.')], keywords=[]), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), Return(value=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='pkg', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='parent', ctx=Load())], keywords=[]), Compare(left=Name(id='norm_pkg_path', ctx=Load()), ops=[Eq()], comparators=[Call(func=Attribute(value=Name(id='_path', ctx=Load()), attr='normpath', ctx=Load()), args=[Call(func=Name(id='Path', ctx=Load()), args=[Name(id='parent_path', ctx=Load()), Starred(value=Name(id='rest', ctx=Load()), ctx=Load())], keywords=[])], keywords=[])])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_empty_dir', args=arguments(posonlyargs=[], args=[arg(arg='dir_', annotation=Name(id='_P', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a directory ensured to be empty. Existing files may be removed.')), Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='rmtree', ctx=Load()), args=[Name(id='dir_', ctx=Load())], keywords=[keyword(arg='ignore_errors', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='makedirs', ctx=Load()), args=[Name(id='dir_', ctx=Load())], keywords=[])), Return(value=Name(id='dir_', ctx=Load()))], decorator_list=[], returns=Name(id='_P', ctx=Load())), ClassDef(name='_NamespaceInstaller', bases=[Attribute(value=Name(id='namespaces', ctx=Load()), attr='Installer', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='distribution'), arg(arg='installation_dir'), arg(arg='editable_name'), arg(arg='src_root')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='distribution', ctx=Store())], value=Name(id='distribution', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='src_root', ctx=Store())], value=Name(id='src_root', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='installation_dir', ctx=Store())], value=Name(id='installation_dir', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='editable_name', ctx=Store())], value=Name(id='editable_name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='outputs', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dry_run', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='_get_nspkg_file', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Installation target.')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='installation_dir', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='editable_name', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='nspkg_ext', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='_get_root', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Where the modules/packages should be loaded from.')), Return(value=Call(func=Name(id='repr', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='src_root', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='_FINDER_TEMPLATE', ctx=Store())], value=Constant(value='import sys\nfrom importlib.machinery import ModuleSpec, PathFinder\nfrom importlib.machinery import all_suffixes as module_suffixes\nfrom importlib.util import spec_from_file_location\nfrom itertools import chain\nfrom pathlib import Path\n\nMAPPING = {mapping!r}\nNAMESPACES = {namespaces!r}\nPATH_PLACEHOLDER = {name!r} + ".__path_hook__"\n\n\nclass _EditableFinder:  # MetaPathFinder\n    @classmethod\n    def find_spec(cls, fullname, path=None, target=None):\n        extra_path = []\n\n        # Top-level packages and modules (we know these exist in the FS)\n        if fullname in MAPPING:\n            pkg_path = MAPPING[fullname]\n            return cls._find_spec(fullname, Path(pkg_path))\n\n        # Handle immediate children modules (required for namespaces to work)\n        # To avoid problems with case sensitivity in the file system we delegate\n        # to the importlib.machinery implementation.\n        parent, _, child = fullname.rpartition(".")\n        if parent and parent in MAPPING:\n            return PathFinder.find_spec(fullname, path=[MAPPING[parent], *extra_path])\n\n        # Other levels of nesting should be handled automatically by importlib\n        # using the parent path.\n        return None\n\n    @classmethod\n    def _find_spec(cls, fullname, candidate_path):\n        init = candidate_path / "__init__.py"\n        candidates = (candidate_path.with_suffix(x) for x in module_suffixes())\n        for candidate in chain([init], candidates):\n            if candidate.exists():\n                return spec_from_file_location(fullname, candidate)\n\n\nclass _EditableNamespaceFinder:  # PathEntryFinder\n    @classmethod\n    def _path_hook(cls, path):\n        if path == PATH_PLACEHOLDER:\n            return cls\n        raise ImportError\n\n    @classmethod\n    def _paths(cls, fullname):\n        # Ensure __path__ is not empty for the spec to be considered a namespace.\n        return NAMESPACES[fullname] or MAPPING.get(fullname) or [PATH_PLACEHOLDER]\n\n    @classmethod\n    def find_spec(cls, fullname, target=None):\n        if fullname in NAMESPACES:\n            spec = ModuleSpec(fullname, None, is_package=True)\n            spec.submodule_search_locations = cls._paths(fullname)\n            return spec\n        return None\n\n    @classmethod\n    def find_module(cls, fullname):\n        return None\n\n\ndef install():\n    if not any(finder == _EditableFinder for finder in sys.meta_path):\n        sys.meta_path.append(_EditableFinder)\n\n    if not NAMESPACES:\n        return\n\n    if not any(hook == _EditableNamespaceFinder._path_hook for hook in sys.path_hooks):\n        # PathEntryFinder is needed to create NamespaceSpec without private APIS\n        sys.path_hooks.append(_EditableNamespaceFinder._path_hook)\n    if PATH_PLACEHOLDER not in sys.path:\n        sys.path.append(PATH_PLACEHOLDER)  # Used just to trigger the path hook\n')), FunctionDef(name='_finder_template', args=arguments(posonlyargs=[], args=[arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='mapping', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='namespaces', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a string containing the code for the``MetaPathFinder`` and\n    ``PathEntryFinder``.\n    ')), Assign(targets=[Name(id='mapping', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Name(id='mapping', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='p')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Subscript(value=Name(id='p', ctx=Load()), slice=Constant(value=0), ctx=Load())))])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='_FINDER_TEMPLATE', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='mapping', value=Name(id='mapping', ctx=Load())), keyword(arg='namespaces', value=Name(id='namespaces', ctx=Load()))]))], decorator_list=[], returns=Name(id='str', ctx=Load())), ClassDef(name='LinksNotSupported', bases=[Attribute(value=Name(id='errors', ctx=Load()), attr='FileError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='File system does not seem to support either symlinks or hard links.'))], decorator_list=[]), ClassDef(name='_DebuggingTips', bases=[Name(id='SetuptoolsWarning', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='_SUMMARY', ctx=Store())], value=Constant(value='Problem in editable installation.')), Assign(targets=[Name(id='_DETAILS', ctx=Store())], value=Constant(value='\n    An error happened while installing `{project}` in editable mode.\n\n    The following steps are recommended to help debug this problem:\n\n    - Try to install the project normally, without using the editable mode.\n      Does the error still persist?\n      (If it does, try fixing the problem before attempting the editable mode).\n    - If you are using binary extensions, make sure you have all OS-level\n      dependencies installed (e.g. compilers, toolchains, binary libraries, ...).\n    - Try the latest version of setuptools (maybe the error was already fixed).\n    - If you (or your project dependencies) are using any setuptools extension\n      or customization, make sure they support the editable mode.\n\n    After following the steps above, if the problem still persists and\n    you think this is related to how setuptools handles editable installations,\n    please submit a reproducible example\n    (see https://stackoverflow.com/help/minimal-reproducible-example) to:\n\n        https://github.com/pypa/setuptools/issues\n    ')), Assign(targets=[Name(id='_SEE_DOCS', ctx=Store())], value=Constant(value='userguide/development_mode.html'))], decorator_list=[])], type_ignores=[])