Module(body=[Expr(value=Constant(value='Automatic discovery of Python modules and packages (for inclusion in the\ndistribution) and other config values.\n\nFor the purposes of this module, the following nomenclature is used:\n\n- "src-layout": a directory representing a Python project that contains a "src"\n  folder. Everything under the "src" folder is meant to be included in the\n  distribution when packaging the project. Example::\n\n    .\n    ├── tox.ini\n    ├── pyproject.toml\n    └── src/\n        └── mypkg/\n            ├── __init__.py\n            ├── mymodule.py\n            └── my_data_file.txt\n\n- "flat-layout": a Python project that does not use "src-layout" but instead\n  have a directory under the project root for each package::\n\n    .\n    ├── tox.ini\n    ├── pyproject.toml\n    └── mypkg/\n        ├── __init__.py\n        ├── mymodule.py\n        └── my_data_file.txt\n\n- "single-module": a project that contains a single Python script direct under\n  the project root (no directory used)::\n\n    .\n    ├── tox.ini\n    ├── pyproject.toml\n    └── mymodule.py\n\n')), Import(names=[alias(name='itertools')]), Import(names=[alias(name='os')]), ImportFrom(module='fnmatch', names=[alias(name='fnmatchcase')], level=0), ImportFrom(module='glob', names=[alias(name='glob')], level=0), ImportFrom(module='pathlib', names=[alias(name='Path')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Dict'), alias(name='Iterable'), alias(name='Iterator'), alias(name='List'), alias(name='Mapping'), alias(name='Optional'), alias(name='Tuple'), alias(name='Union')], level=0), Import(names=[alias(name='_distutils_hack.override')]), ImportFrom(module='distutils', names=[alias(name='log')], level=0), ImportFrom(module='distutils.util', names=[alias(name='convert_path')], level=0), Assign(targets=[Name(id='_Path', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='PathLike', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='StrIter', ctx=Store())], value=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='chain_iter', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load())), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='setuptools', names=[alias(name='Distribution')], level=0)], orelse=[]), FunctionDef(name='_valid_name', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), attr='isidentifier', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), ClassDef(name='_Filter', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Given a list of patterns, create a callable that will be true only if\n    the input matches at least one of the patterns.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='patterns', annotation=Name(id='str', ctx=Load())), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_patterns', ctx=Store())], value=Call(func=Attribute(value=Name(id='dict', ctx=Load()), attr='fromkeys', ctx=Load()), args=[Name(id='patterns', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='fnmatchcase', ctx=Load()), args=[Name(id='item', ctx=Load()), Name(id='pat', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='pat', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_patterns', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Name(id='item', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_patterns', ctx=Load())]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='_Finder', bases=[], keywords=[], body=[Expr(value=Constant(value='Base class that exposes functionality for module/package finders')), AnnAssign(target=Name(id='ALWAYS_EXCLUDE', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), value=Tuple(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='DEFAULT_EXCLUDE', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), value=Tuple(elts=[], ctx=Load()), simple=1), FunctionDef(name='find', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='where', annotation=Name(id='_Path', ctx=Load())), arg(arg='exclude', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='include', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='.'), Tuple(elts=[], ctx=Load()), Tuple(elts=[Constant(value='*')], ctx=Load())]), body=[Expr(value=Constant(value='Return a list of all Python items (packages or modules, depending on\n        the finder implementation) found within directory \'where\'.\n\n        \'where\' is the root directory which will be searched.\n        It should be supplied as a "cross-platform" (i.e. URL-style) path;\n        it will be converted to the appropriate local path syntax.\n\n        \'exclude\' is a sequence of names to exclude; \'*\' can be used\n        as a wildcard in the names.\n        When finding packages, \'foo.*\' will exclude all subpackages of \'foo\'\n        (but not \'foo\' itself).\n\n        \'include\' is a sequence of names to include.\n        If it\'s specified, only the named items will be included.\n        If it\'s not specified, all found items will be included.\n        \'include\' can contain shell style wildcard patterns just like\n        \'exclude\'.\n        ')), Assign(targets=[Name(id='exclude', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='exclude', ctx=Load()), Attribute(value=Name(id='cls', ctx=Load()), attr='DEFAULT_EXCLUDE', ctx=Load())])), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_find_iter', ctx=Load()), args=[Call(func=Name(id='convert_path', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='where', ctx=Load())], keywords=[])], keywords=[]), Call(func=Name(id='_Filter', ctx=Load()), args=[Starred(value=Attribute(value=Name(id='cls', ctx=Load()), attr='ALWAYS_EXCLUDE', ctx=Load()), ctx=Load()), Starred(value=Name(id='exclude', ctx=Load()), ctx=Load())], keywords=[]), Call(func=Name(id='_Filter', ctx=Load()), args=[Starred(value=Name(id='include', ctx=Load()), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_find_iter', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='where', annotation=Name(id='_Path', ctx=Load())), arg(arg='exclude', annotation=Name(id='_Filter', ctx=Load())), arg(arg='include', annotation=Name(id='_Filter', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='StrIter', ctx=Load()))], decorator_list=[]), ClassDef(name='PackageFinder', bases=[Name(id='_Finder', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Generate a list of all Python packages found within a directory\n    ')), Assign(targets=[Name(id='ALWAYS_EXCLUDE', ctx=Store())], value=Tuple(elts=[Constant(value='ez_setup'), Constant(value='*__pycache__')], ctx=Load())), FunctionDef(name='_find_iter', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='where', annotation=Name(id='_Path', ctx=Load())), arg(arg='exclude', annotation=Name(id='_Filter', ctx=Load())), arg(arg='include', annotation=Name(id='_Filter', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        All the packages found in 'where' that pass the 'include' filter, but\n        not the 'exclude' filter.\n        ")), For(target=Tuple(elts=[Name(id='root', ctx=Store()), Name(id='dirs', ctx=Store()), Name(id='files', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='walk', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='where', ctx=Load())], keywords=[])], keywords=[keyword(arg='followlinks', value=Constant(value=True))]), body=[Assign(targets=[Name(id='all_dirs', ctx=Store())], value=Subscript(value=Name(id='dirs', ctx=Load()), slice=Slice(), ctx=Load())), Assign(targets=[Subscript(value=Name(id='dirs', ctx=Load()), slice=Slice(), ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='dir', ctx=Store()), iter=Name(id='all_dirs', ctx=Load()), body=[Assign(targets=[Name(id='full_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='rel_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='relpath', ctx=Load()), args=[Name(id='full_path', ctx=Load()), Name(id='where', ctx=Load())], keywords=[])), Assign(targets=[Name(id='package', ctx=Store())], value=Call(func=Attribute(value=Name(id='rel_path', ctx=Load()), attr='replace', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='sep', ctx=Load()), Constant(value='.')], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Constant(value='.'), ops=[In()], comparators=[Name(id='dir', ctx=Load())]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_looks_like_package', ctx=Load()), args=[Name(id='full_path', ctx=Load()), Name(id='package', ctx=Load())], keywords=[]))]), body=[Continue()], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='include', ctx=Load()), args=[Name(id='package', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='exclude', ctx=Load()), args=[Name(id='package', ctx=Load())], keywords=[]))]), body=[Expr(value=Yield(value=Name(id='package', ctx=Load())))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=JoinedStr(values=[FormattedValue(value=Name(id='package', ctx=Load()), conversion=-1), Constant(value='*')]), ops=[In()], comparators=[Name(id='exclude', ctx=Load())]), Compare(left=JoinedStr(values=[FormattedValue(value=Name(id='package', ctx=Load()), conversion=-1), Constant(value='.*')]), ops=[In()], comparators=[Name(id='exclude', ctx=Load())])]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='dirs', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='dir', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='StrIter', ctx=Load())), FunctionDef(name='_looks_like_package', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='_Path', ctx=Load())), arg(arg='_package_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Does a directory look like a package?')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='__init__.py')], keywords=[])], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='PEP420PackageFinder', bases=[Name(id='PackageFinder', ctx=Load())], keywords=[], body=[FunctionDef(name='_looks_like_package', args=arguments(posonlyargs=[], args=[arg(arg='_path', annotation=Name(id='_Path', ctx=Load())), arg(arg='_package_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=True))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='ModuleFinder', bases=[Name(id='_Finder', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Find isolated Python modules.\n    This function will **not** recurse subdirectories.\n    ')), FunctionDef(name='_find_iter', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='where', annotation=Name(id='_Path', ctx=Load())), arg(arg='exclude', annotation=Name(id='_Filter', ctx=Load())), arg(arg='include', annotation=Name(id='_Filter', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='file', ctx=Store()), iter=Call(func=Name(id='glob', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='where', ctx=Load()), Constant(value='*.py')], keywords=[])], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='module', ctx=Store()), Name(id='_ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_looks_like_module', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[])), body=[Continue()], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='include', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='exclude', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[]))]), body=[Expr(value=Yield(value=Name(id='module', ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='StrIter', ctx=Load())), Assign(targets=[Name(id='_looks_like_module', ctx=Store())], value=Call(func=Name(id='staticmethod', ctx=Load()), args=[Name(id='_valid_name', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='FlatLayoutPackageFinder', bases=[Name(id='PEP420PackageFinder', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='_EXCLUDE', ctx=Store())], value=Tuple(elts=[Constant(value='ci'), Constant(value='bin'), Constant(value='debian'), Constant(value='doc'), Constant(value='docs'), Constant(value='documentation'), Constant(value='manpages'), Constant(value='news'), Constant(value='newsfragments'), Constant(value='changelog'), Constant(value='test'), Constant(value='tests'), Constant(value='unit_test'), Constant(value='unit_tests'), Constant(value='example'), Constant(value='examples'), Constant(value='scripts'), Constant(value='tools'), Constant(value='util'), Constant(value='utils'), Constant(value='python'), Constant(value='build'), Constant(value='dist'), Constant(value='venv'), Constant(value='env'), Constant(value='requirements'), Constant(value='tasks'), Constant(value='fabfile'), Constant(value='site_scons'), Constant(value='benchmark'), Constant(value='benchmarks'), Constant(value='exercise'), Constant(value='exercises'), Constant(value='htmlcov'), Constant(value='[._]*')], ctx=Load())), Assign(targets=[Name(id='DEFAULT_EXCLUDE', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='chain_iter', ctx=Load()), args=[GeneratorExp(elt=Tuple(elts=[Name(id='p', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='p', ctx=Load()), conversion=-1), Constant(value='.*')])], ctx=Load()), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='_EXCLUDE', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[])), Expr(value=Constant(value='Reserved package names')), FunctionDef(name='_looks_like_package', args=arguments(posonlyargs=[], args=[arg(arg='_path', annotation=Name(id='_Path', ctx=Load())), arg(arg='package_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='names', ctx=Store())], value=Call(func=Attribute(value=Name(id='package_name', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), Assign(targets=[Name(id='root_pkg_is_valid', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Subscript(value=Name(id='names', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='isidentifier', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Subscript(value=Name(id='names', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='-stubs')], keywords=[])])), Return(value=BoolOp(op=And(), values=[Name(id='root_pkg_is_valid', ctx=Load()), Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='isidentifier', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='name', ctx=Store()), iter=Subscript(value=Name(id='names', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), ifs=[], is_async=0)])], keywords=[])]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='FlatLayoutModuleFinder', bases=[Name(id='ModuleFinder', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='DEFAULT_EXCLUDE', ctx=Store())], value=Tuple(elts=[Constant(value='setup'), Constant(value='conftest'), Constant(value='test'), Constant(value='tests'), Constant(value='example'), Constant(value='examples'), Constant(value='build'), Constant(value='toxfile'), Constant(value='noxfile'), Constant(value='pavement'), Constant(value='dodo'), Constant(value='tasks'), Constant(value='fabfile'), Constant(value='[Ss][Cc]onstruct'), Constant(value='conanfile'), Constant(value='manage'), Constant(value='benchmark'), Constant(value='benchmarks'), Constant(value='exercise'), Constant(value='exercises'), Constant(value='[._]*')], ctx=Load())), Expr(value=Constant(value='Reserved top-level module names'))], decorator_list=[]), FunctionDef(name='_find_packages_within', args=arguments(posonlyargs=[], args=[arg(arg='root_pkg', annotation=Name(id='str', ctx=Load())), arg(arg='pkg_dir', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='nested', ctx=Store())], value=Call(func=Attribute(value=Name(id='PEP420PackageFinder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='pkg_dir', ctx=Load())], keywords=[])), Return(value=BinOp(left=List(elts=[Name(id='root_pkg', ctx=Load())], ctx=Load()), op=Add(), right=ListComp(elt=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Tuple(elts=[Name(id='root_pkg', ctx=Load()), Name(id='n', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='n', ctx=Store()), iter=Name(id='nested', ctx=Load()), ifs=[], is_async=0)])))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), ClassDef(name='ConfigDiscovery', bases=[], keywords=[], body=[Expr(value=Constant(value='Fill-in metadata and options that can be automatically derived\n    (from other metadata/options, the file system or conventions)\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='distribution', annotation=Constant(value='Distribution'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Store())], value=Name(id='distribution', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_called', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_disabled', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_skip_ext_modules', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='_disable', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Internal API to disable automatic discovery')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_disabled', ctx=Store())], value=Constant(value=True))], decorator_list=[]), FunctionDef(name='_ignore_ext_modules', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Internal API to disregard ext_modules.\n\n        Normally auto-discovery would not be triggered if ``ext_modules`` are set\n        (this is done for backward compatibility with existing packages relying on\n        ``setup.py`` or ``setup.cfg``). However, ``setuptools`` can call this function\n        to ignore given ``ext_modules`` and proceed with the auto-discovery if\n        ``packages`` and ``py_modules`` are not given (e.g. when using pyproject.toml\n        metadata).\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_skip_ext_modules', ctx=Store())], value=Constant(value=True))], decorator_list=[]), FunctionDef(name='_root_dir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='src_root', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='curdir', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='_Path', ctx=Load())), FunctionDef(name='_package_dir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='package_dir', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Dict(keys=[], values=[]))], orelse=[]), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='package_dir', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='force'), arg(arg='name'), arg(arg='ignore_ext_modules')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=True), Constant(value=False)]), body=[Expr(value=Constant(value='Automatically discover missing configuration fields\n        and modifies the given ``distribution`` object in-place.\n\n        Note that by default this will only have an effect the first time the\n        ``ConfigDiscovery`` object is called.\n\n        To repeatedly invoke automatic discovery (e.g. when the project\n        directory changes), please use ``force=True`` (or create a new\n        ``ConfigDiscovery`` instance).\n        ')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='force', ctx=Load()), ops=[Is()], comparators=[Constant(value=False)]), BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_called', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_disabled', ctx=Load())])]), body=[Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_analyse_package_layout', ctx=Load()), args=[Name(id='ignore_ext_modules', ctx=Load())], keywords=[])), If(test=Name(id='name', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='analyse_name', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_called', ctx=Store())], value=Constant(value=True))], decorator_list=[]), FunctionDef(name='_explicitly_specified', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ignore_ext_modules', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='``True`` if the user has specified some form of package/module listing')), Assign(targets=[Name(id='ignore_ext_modules', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='ignore_ext_modules', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_skip_ext_modules', ctx=Load())])), Assign(targets=[Name(id='ext_modules', ctx=Store())], value=UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='ext_modules', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Name(id='ignore_ext_modules', ctx=Load())]))), Return(value=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='py_modules', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Name(id='ext_modules', ctx=Load()), BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), Constant(value='configuration')], keywords=[]), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='configuration', ctx=Load())])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_analyse_package_layout', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ignore_ext_modules', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_explicitly_specified', ctx=Load()), args=[Name(id='ignore_ext_modules', ctx=Load())], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='No `packages` or `py_modules` configuration, performing automatic discovery.')], keywords=[])), Return(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_analyse_explicit_layout', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_analyse_src_layout', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_analyse_flat_layout', ctx=Load()), args=[], keywords=[])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_analyse_explicit_layout', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The user can explicitly give a package layout via ``package_dir``')), Assign(targets=[Name(id='package_dir', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_package_dir', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='package_dir', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value=''), Constant(value=None)], keywords=[])), Assign(targets=[Name(id='root_dir', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_root_dir', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='package_dir', ctx=Load())), body=[Return(value=Constant(value=False))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[JoinedStr(values=[Constant(value='`explicit-layout` detected -- analysing '), FormattedValue(value=Name(id='package_dir', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='pkgs', ctx=Store())], value=Call(func=Name(id='chain_iter', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_find_packages_within', ctx=Load()), args=[Name(id='pkg', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root_dir', ctx=Load()), Name(id='parent_dir', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='pkg', ctx=Store()), Name(id='parent_dir', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='package_dir', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='pkgs', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[JoinedStr(values=[Constant(value='discovered packages -- '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_analyse_src_layout', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Try to find all packages or modules under the ``src`` directory\n        (or anything pointed by ``package_dir[""]``).\n\n        The "src-layout" is relatively safe for automatic discovery.\n        We assume that everything within is meant to be included in the\n        distribution.\n\n        If ``package_dir[""]`` is not given, but the ``src`` directory exists,\n        this function will set ``package_dir[""] = "src"``.\n        ')), Assign(targets=[Name(id='package_dir', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_package_dir', ctx=Load())), Assign(targets=[Name(id='src_dir', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_root_dir', ctx=Load()), Call(func=Attribute(value=Name(id='package_dir', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value=''), Constant(value='src')], keywords=[])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='src_dir', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[JoinedStr(values=[Constant(value='`src-layout` detected -- analysing '), FormattedValue(value=Name(id='src_dir', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='package_dir', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value=''), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='src_dir', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='package_dir', ctx=Store())], value=Name(id='package_dir', ctx=Load())), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Store())], value=Call(func=Attribute(value=Name(id='PEP420PackageFinder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='src_dir', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='py_modules', ctx=Store())], value=Call(func=Attribute(value=Name(id='ModuleFinder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='src_dir', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[JoinedStr(values=[Constant(value='discovered packages -- '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[JoinedStr(values=[Constant(value='discovered py_modules -- '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='py_modules', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_analyse_flat_layout', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Try to find all packages and modules under the project root.\n\n        Since the ``flat-layout`` is more dangerous in terms of accidentally including\n        extra files/directories, this function is more conservative and will raise an\n        error if multiple packages or modules are found.\n\n        This assumes that multi-package dists are uncommon and refuse to support that\n        use case in order to be able to prevent unintended errors.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[JoinedStr(values=[Constant(value='`flat-layout` detected -- analysing '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_root_dir', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_analyse_flat_packages', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_analyse_flat_modules', ctx=Load()), args=[], keywords=[])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_analyse_flat_packages', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Store())], value=Call(func=Attribute(value=Name(id='FlatLayoutPackageFinder', ctx=Load()), attr='find', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_root_dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_level', ctx=Store())], value=Call(func=Name(id='remove_nested_packages', ctx=Load()), args=[Call(func=Name(id='remove_stubs', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[JoinedStr(values=[Constant(value='discovered packages -- '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_ensure_no_accidental_inclusion', ctx=Load()), args=[Name(id='top_level', ctx=Load()), Constant(value='packages')], keywords=[])), Return(value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='top_level', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_analyse_flat_modules', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='py_modules', ctx=Store())], value=Call(func=Attribute(value=Name(id='FlatLayoutModuleFinder', ctx=Load()), attr='find', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_root_dir', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[JoinedStr(values=[Constant(value='discovered py_modules -- '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='py_modules', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_ensure_no_accidental_inclusion', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='py_modules', ctx=Load()), Constant(value='modules')], keywords=[])), Return(value=Call(func=Name(id='bool', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='py_modules', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_ensure_no_accidental_inclusion', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='detected', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='kind', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='detected', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=[ImportFrom(module='inspect', names=[alias(name='cleandoc')], level=0), ImportFrom(module='setuptools.errors', names=[alias(name='PackageDiscoveryError')], level=0), Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='Multiple top-level '), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1), Constant(value=' discovered in a flat-layout: '), FormattedValue(value=Name(id='detected', ctx=Load()), conversion=-1), Constant(value='.\n\n            To avoid accidental inclusion of unwanted files or directories,\n            setuptools will not proceed with this build.\n\n            If you are trying to create a single distribution with multiple '), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1), Constant(value='\n            on purpose, you should not rely on automatic discovery.\n            Instead, consider the following options:\n\n            1. set up custom discovery (`find` directive with `include` or `exclude`)\n            2. use a `src-layout`\n            3. explicitly set `py_modules` or `packages` with a list of names\n\n            To find more information, look for "package discovery" on setuptools docs.\n            ')])), Raise(exc=Call(func=Name(id='PackageDiscoveryError', ctx=Load()), args=[Call(func=Name(id='cleandoc', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='analyse_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The packages/modules are the essential contribution of the author.\n        Therefore the name of the distribution can be derived from them.\n        ')), If(test=BoolOp(op=Or(), values=[Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='metadata', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='name', ctx=Load())]), body=[Return(value=Constant(value=None))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='No `name` configuration, performing automatic discovery')], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_name_single_package_or_module', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_name_from_packages', ctx=Load()), args=[], keywords=[])])), If(test=Name(id='name', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='metadata', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='_find_name_single_package_or_module', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Exactly one module or package')), For(target=Name(id='field', ctx=Store()), iter=Tuple(elts=[Constant(value='packages'), Constant(value='py_modules')], ctx=Load()), body=[Assign(targets=[Name(id='items', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), Name(id='field', ctx=Load()), Constant(value=None)], keywords=[]), List(elts=[], ctx=Load())])), If(test=BoolOp(op=And(), values=[Name(id='items', ctx=Load()), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)])]), body=[Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[JoinedStr(values=[Constant(value='Single module/package detected, name: '), FormattedValue(value=Subscript(value=Name(id='items', ctx=Load()), slice=Constant(value=0), ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Subscript(value=Name(id='items', ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_find_name_from_packages', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Try to find the root package that is not a PEP 420 namespace')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='packages', ctx=Store())], value=Call(func=Name(id='remove_stubs', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='packages', ctx=Load())], keywords=[keyword(arg='key', value=Name(id='len', ctx=Load()))])], keywords=[])), Assign(targets=[Name(id='package_dir', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='package_dir', ctx=Load()), Dict(keys=[], values=[])])), Assign(targets=[Name(id='parent_pkg', ctx=Store())], value=Call(func=Name(id='find_parent_package', ctx=Load()), args=[Name(id='packages', ctx=Load()), Name(id='package_dir', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_root_dir', ctx=Load())], keywords=[])), If(test=Name(id='parent_pkg', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[JoinedStr(values=[Constant(value='Common parent package detected, name: '), FormattedValue(value=Name(id='parent_pkg', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='parent_pkg', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='No parent package detected, impossible to derive `name`')], keywords=[])), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='remove_nested_packages', args=arguments(posonlyargs=[], args=[arg(arg='packages', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove nested packages from a list of packages.\n\n    >>> remove_nested_packages(["a", "a.b1", "a.b2", "a.b1.c1"])\n    [\'a\']\n    >>> remove_nested_packages(["a", "b", "c.d", "c.d.e.f", "g.h", "a.a1"])\n    [\'a\', \'b\', \'c.d\', \'g.h\']\n    ')), Assign(targets=[Name(id='pkgs', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='packages', ctx=Load())], keywords=[keyword(arg='key', value=Name(id='len', ctx=Load()))])), Assign(targets=[Name(id='top_level', ctx=Store())], value=Subscript(value=Name(id='pkgs', ctx=Load()), slice=Slice(), ctx=Load())), Assign(targets=[Name(id='size', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pkgs', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='name', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='pkgs', ctx=Load())], keywords=[])], keywords=[]), body=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='startswith', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='other', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]), generators=[comprehension(target=Name(id='other', ctx=Store()), iter=Name(id='top_level', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='top_level', ctx=Load()), attr='pop', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='size', ctx=Load()), op=Sub(), right=Name(id='i', ctx=Load())), op=Sub(), right=Constant(value=1))], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='top_level', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='remove_stubs', args=arguments(posonlyargs=[], args=[arg(arg='packages', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove type stubs (:pep:`561`) from a list of packages.\n\n    >>> remove_stubs(["a", "a.b", "a-stubs", "a-stubs.b.c", "b", "c-stubs"])\n    [\'a\', \'a.b\', \'b\']\n    ')), Return(value=ListComp(elt=Name(id='pkg', ctx=Load()), generators=[comprehension(target=Name(id='pkg', ctx=Store()), iter=Name(id='packages', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='pkg', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='-stubs')], keywords=[]))], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='find_parent_package', args=arguments(posonlyargs=[], args=[arg(arg='packages', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='package_dir', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='root_dir', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find the parent package that is not a namespace.')), Assign(targets=[Name(id='packages', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='packages', ctx=Load())], keywords=[keyword(arg='key', value=Name(id='len', ctx=Load()))])), Assign(targets=[Name(id='common_ancestors', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='name', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='packages', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='n', ctx=Load()), attr='startswith', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]), generators=[comprehension(target=Name(id='n', ctx=Store()), iter=Subscript(value=Name(id='packages', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='common_ancestors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='name', ctx=Store()), iter=Name(id='common_ancestors', ctx=Load()), body=[Assign(targets=[Name(id='pkg_path', ctx=Store())], value=Call(func=Name(id='find_package_path', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='package_dir', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='init', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='pkg_path', ctx=Load()), Constant(value='__init__.py')], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='init', ctx=Load())], keywords=[]), body=[Return(value=Name(id='name', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='find_package_path', args=arguments(posonlyargs=[], args=[arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='package_dir', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='root_dir', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Given a package name, return the path where it should be found on\n    disk, considering the ``package_dir`` option.\n\n    >>> path = find_package_path("my.pkg", {"": "root/is/nested"}, ".")\n    >>> path.replace(os.sep, "/")\n    \'./root/is/nested/my/pkg\'\n\n    >>> path = find_package_path("my.pkg", {"my": "root/is/nested"}, ".")\n    >>> path.replace(os.sep, "/")\n    \'./root/is/nested/pkg\'\n\n    >>> path = find_package_path("my.pkg", {"my.pkg": "root/is/nested"}, ".")\n    >>> path.replace(os.sep, "/")\n    \'./root/is/nested\'\n\n    >>> path = find_package_path("other.pkg", {"my.pkg": "root/is/nested"}, ".")\n    >>> path.replace(os.sep, "/")\n    \'./other/pkg\'\n    ')), Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]), Constant(value=0), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), body=[Assign(targets=[Name(id='partial_name', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Subscript(value=Name(id='parts', ctx=Load()), slice=Slice(upper=Name(id='i', ctx=Load())), ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='partial_name', ctx=Load()), ops=[In()], comparators=[Name(id='package_dir', ctx=Load())]), body=[Assign(targets=[Name(id='parent', ctx=Store())], value=Subscript(value=Name(id='package_dir', ctx=Load()), slice=Name(id='partial_name', ctx=Load()), ctx=Load())), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root_dir', ctx=Load()), Name(id='parent', ctx=Load()), Starred(value=Subscript(value=Name(id='parts', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load())), ctx=Load()), ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='parent', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='package_dir', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='')], keywords=[]), Constant(value='')])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root_dir', ctx=Load()), Starred(value=Call(func=Attribute(value=Name(id='parent', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='/')], keywords=[]), ctx=Load()), Starred(value=Name(id='parts', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='construct_package_dir', args=arguments(posonlyargs=[], args=[arg(arg='packages', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='package_path', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parent_pkgs', ctx=Store())], value=Call(func=Name(id='remove_nested_packages', ctx=Load()), args=[Name(id='packages', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prefix', ctx=Store())], value=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='package_path', ctx=Load())], keywords=[]), attr='parts', ctx=Load())), Return(value=DictComp(key=Name(id='pkg', ctx=Load()), value=Call(func=Attribute(value=Constant(value='/'), attr='join', ctx=Load()), args=[List(elts=[Starred(value=Name(id='prefix', ctx=Load()), ctx=Load()), Starred(value=Call(func=Attribute(value=Name(id='pkg', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]), ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='pkg', ctx=Store()), iter=Name(id='parent_pkgs', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], type_ignores=[])