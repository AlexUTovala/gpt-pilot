Module(body=[Import(names=[alias(name='re')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='distutils.core')]), Import(names=[alias(name='distutils.errors')]), Import(names=[alias(name='distutils.extension')]), ImportFrom(module='monkey', names=[alias(name='get_unpatched')], level=1), FunctionDef(name='_have_cython', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return True if Cython can be imported.\n    ')), Assign(targets=[Name(id='cython_impl', ctx=Store())], value=Constant(value='Cython.Distutils.build_ext')), Try(body=[Expr(value=Attribute(value=Call(func=Name(id='__import__', ctx=Load()), args=[Name(id='cython_impl', ctx=Load())], keywords=[keyword(arg='fromlist', value=List(elts=[Constant(value='build_ext')], ctx=Load()))]), attr='build_ext', ctx=Load())), Return(value=Constant(value=True))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Constant(value=False))], decorator_list=[]), Assign(targets=[Name(id='have_pyrex', ctx=Store())], value=Name(id='_have_cython', ctx=Load())), Assign(targets=[Name(id='_Extension', ctx=Store())], value=Call(func=Name(id='get_unpatched', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='core', ctx=Load()), attr='Extension', ctx=Load())], keywords=[])), ClassDef(name='Extension', bases=[Name(id='_Extension', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Describes a single extension module.\n\n    This means that all source files will be compiled into a single binary file\n    ``<module path>.<suffix>`` (with ``<module path>`` derived from ``name`` and\n    ``<suffix>`` defined by one of the values in\n    ``importlib.machinery.EXTENSION_SUFFIXES``).\n\n    In the case ``.pyx`` files are passed as ``sources and`` ``Cython`` is **not**\n    installed in the build environment, ``setuptools`` may also try to look for the\n    equivalent ``.cpp`` or ``.c`` files.\n\n    :arg str name:\n      the full name of the extension, including any packages -- ie.\n      *not* a filename or pathname, but Python dotted name\n\n    :arg list[str] sources:\n      list of source filenames, relative to the distribution root\n      (where the setup script lives), in Unix form (slash-separated)\n      for portability.  Source files may be C, C++, SWIG (.i),\n      platform-specific resource files, or whatever else is recognized\n      by the "build_ext" command as source for a Python extension.\n\n    :keyword list[str] include_dirs:\n      list of directories to search for C/C++ header files (in Unix\n      form for portability)\n\n    :keyword list[tuple[str, str|None]] define_macros:\n      list of macros to define; each macro is defined using a 2-tuple:\n      the first item corresponding to the name of the macro and the second\n      item either a string with its value or None to\n      define it without a particular value (equivalent of "#define\n      FOO" in source or -DFOO on Unix C compiler command line)\n\n    :keyword list[str] undef_macros:\n      list of macros to undefine explicitly\n\n    :keyword list[str] library_dirs:\n      list of directories to search for C/C++ libraries at link time\n\n    :keyword list[str] libraries:\n      list of library names (not filenames or paths) to link against\n\n    :keyword list[str] runtime_library_dirs:\n      list of directories to search for C/C++ libraries at run time\n      (for shared extensions, this is when the extension is loaded).\n      Setting this will cause an exception during build on Windows\n      platforms.\n\n    :keyword list[str] extra_objects:\n      list of extra files to link with (eg. object files not implied\n      by \'sources\', static library that must be explicitly specified,\n      binary resource files, etc.)\n\n    :keyword list[str] extra_compile_args:\n      any extra platform- and compiler-specific information to use\n      when compiling the source files in \'sources\'.  For platforms and\n      compilers where "command line" makes sense, this is typically a\n      list of command-line arguments, but for other platforms it could\n      be anything.\n\n    :keyword list[str] extra_link_args:\n      any extra platform- and compiler-specific information to use\n      when linking object files together to create the extension (or\n      to create a new static Python interpreter).  Similar\n      interpretation as for \'extra_compile_args\'.\n\n    :keyword list[str] export_symbols:\n      list of symbols to be exported from a shared extension.  Not\n      used on all platforms, and not generally necessary for Python\n      extensions, which typically export exactly one symbol: "init" +\n      extension_name.\n\n    :keyword list[str] swig_opts:\n      any extra options to pass to SWIG if a source file has the .i\n      extension.\n\n    :keyword list[str] depends:\n      list of files that the extension depends on\n\n    :keyword str language:\n      extension language (i.e. "c", "c++", "objc"). Will be detected\n      from the source extensions if not provided.\n\n    :keyword bool optional:\n      specifies that a build failure in the extension should not abort the\n      build process, but simply not install the failing extension.\n\n    :keyword bool py_limited_api:\n      opt-in flag for the usage of :doc:`Python\'s limited API <python:c-api/stable>`.\n\n    :raises setuptools.errors.PlatformError: if \'runtime_library_dirs\' is\n      specified on Windows. (since v63)\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='sources')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='py_limited_api', ctx=Store())], value=Call(func=Attribute(value=Name(id='kw', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='py_limited_api'), Constant(value=False)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='sources', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_convert_pyx_sources_to_lang', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Replace sources with .pyx extensions to sources with the target\n        language extension. This mechanism allows language authors to supply\n        pre-converted sources but to prefer the .pyx sources.\n        ')), If(test=Call(func=Name(id='_have_cython', ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), Assign(targets=[Name(id='lang', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='language', ctx=Load()), Constant(value='')])), Assign(targets=[Name(id='target_ext', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='lang', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='c++')]), body=Constant(value='.cpp'), orelse=Constant(value='.c'))), Assign(targets=[Name(id='sub', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), Constant(value='.pyx$'), Name(id='target_ext', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='sources', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='sub', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='sources', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Library', bases=[Name(id='Extension', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Just like a regular Extension, but built as a library instead'))], decorator_list=[])], type_ignores=[])