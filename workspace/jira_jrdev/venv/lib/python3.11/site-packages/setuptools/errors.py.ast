Module(body=[Expr(value=Constant(value='setuptools.errors\n\nProvides exceptions used by setuptools modules.\n')), ImportFrom(module='distutils', names=[alias(name='errors', asname='_distutils_errors')], level=0), Assign(targets=[Name(id='ByteCompileError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsByteCompileError', ctx=Load())), Assign(targets=[Name(id='CCompilerError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='CCompilerError', ctx=Load())), Assign(targets=[Name(id='ClassError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsClassError', ctx=Load())), Assign(targets=[Name(id='CompileError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='CompileError', ctx=Load())), Assign(targets=[Name(id='ExecError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsExecError', ctx=Load())), Assign(targets=[Name(id='FileError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsFileError', ctx=Load())), Assign(targets=[Name(id='InternalError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsInternalError', ctx=Load())), Assign(targets=[Name(id='LibError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='LibError', ctx=Load())), Assign(targets=[Name(id='LinkError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='LinkError', ctx=Load())), Assign(targets=[Name(id='ModuleError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsModuleError', ctx=Load())), Assign(targets=[Name(id='OptionError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsOptionError', ctx=Load())), Assign(targets=[Name(id='PlatformError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsPlatformError', ctx=Load())), Assign(targets=[Name(id='PreprocessError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='PreprocessError', ctx=Load())), Assign(targets=[Name(id='SetupError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsSetupError', ctx=Load())), Assign(targets=[Name(id='TemplateError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsTemplateError', ctx=Load())), Assign(targets=[Name(id='UnknownFileError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='UnknownFileError', ctx=Load())), Assign(targets=[Name(id='BaseError', ctx=Store())], value=Attribute(value=Name(id='_distutils_errors', ctx=Load()), attr='DistutilsError', ctx=Load())), ClassDef(name='RemovedCommandError', bases=[Name(id='BaseError', ctx=Load()), Name(id='RuntimeError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Error used for commands that have been removed in setuptools.\n\n    Since ``setuptools`` is built on ``distutils``, simply removing a command\n    from ``setuptools`` will make the behavior fall back to ``distutils``; this\n    error is raised if a command exists in ``distutils`` but has been actively\n    removed in ``setuptools``.\n    '))], decorator_list=[]), ClassDef(name='PackageDiscoveryError', bases=[Name(id='BaseError', ctx=Load()), Name(id='RuntimeError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Impossible to perform automatic discovery of packages and/or modules.\n\n    The current project layout or given discovery options can lead to problems when\n    scanning the project directory.\n\n    Setuptools might also refuse to complete auto-discovery if an error prone condition\n    is detected (e.g. when a project is organised as a flat-layout but contains\n    multiple directories that can be taken as top-level packages inside a single\n    distribution [*]_). In these situations the users are encouraged to be explicit\n    about which packages to include or to make the discovery parameters more specific.\n\n    .. [*] Since multi-package distributions are uncommon it is very likely that the\n       developers did not intend for all the directories to be packaged, and are just\n       leaving auxiliary code in the repository top-level, such as maintenance-related\n       scripts.\n    '))], decorator_list=[])], type_ignores=[])