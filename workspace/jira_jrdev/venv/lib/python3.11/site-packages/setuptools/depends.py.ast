Module(body=[Import(names=[alias(name='sys')]), Import(names=[alias(name='marshal')]), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='dis')]), ImportFrom(names=[alias(name='_imp')], level=1), ImportFrom(module='_imp', names=[alias(name='find_module'), alias(name='PY_COMPILED'), alias(name='PY_FROZEN'), alias(name='PY_SOURCE')], level=1), ImportFrom(module='extern.packaging.version', names=[alias(name='Version')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Require'), Constant(value='find_module'), Constant(value='get_module_constant'), Constant(value='extract_constant')], ctx=Load())), ClassDef(name='Require', bases=[], keywords=[], body=[Expr(value=Constant(value='A prerequisite to building or installing a distribution')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='requested_version'), arg(arg='module'), arg(arg='homepage'), arg(arg='attribute'), arg(arg='format')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=None), Constant(value=None)]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='format', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='requested_version', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Name(id='format', ctx=Store())], value=Name(id='Version', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='format', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='requested_version', ctx=Store())], value=Call(func=Name(id='format', ctx=Load()), args=[Name(id='requested_version', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='attribute', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='attribute', ctx=Store())], value=Constant(value='__version__'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[])], keywords=[])), Delete(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='self', ctx=Del())])], decorator_list=[]), FunctionDef(name='full_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return full package/distribution name, w/version')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='requested_version', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=BinOp(left=Constant(value='%s-%s'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='requested_version', ctx=Load())], ctx=Load())))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))], decorator_list=[]), FunctionDef(name='version_ok', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='version')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Is 'version' sufficiently up-to-date?")), Return(value=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='attribute', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='format', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='str', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value='unknown')]), Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='format', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]), ops=[GtE()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='requested_version', ctx=Load())])])]))], decorator_list=[]), FunctionDef(name='get_version', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='paths'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value='unknown')]), body=[Expr(value=Constant(value="Get version number of installed module, 'None', or 'default'\n\n        Search 'paths' for module.  If not found, return 'None'.  If found,\n        return the extracted version attribute, or 'default' if no version\n        attribute was specified, or the value cannot be determined without\n        importing the module.  The version is formatted according to the\n        requirement's version format (if any), unless it is 'None' or the\n        supplied 'default'.\n        ")), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='attribute', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='f', ctx=Store()), Name(id='p', ctx=Store()), Name(id='i', ctx=Store())], ctx=Store())], value=Call(func=Name(id='find_module', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module', ctx=Load()), Name(id='paths', ctx=Load())], keywords=[])), If(test=Name(id='f', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='default', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Return(value=Constant(value=None))])], orelse=[], finalbody=[])], orelse=[]), Assign(targets=[Name(id='v', ctx=Store())], value=Call(func=Name(id='get_module_constant', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='attribute', ctx=Load()), Name(id='default', ctx=Load()), Name(id='paths', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='v', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='v', ctx=Load()), ops=[IsNot()], comparators=[Name(id='default', ctx=Load())]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='format', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='format', ctx=Load()), args=[Name(id='v', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='v', ctx=Load()))], decorator_list=[]), FunctionDef(name='is_present', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='paths')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Return true if dependency is present on 'paths'")), Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_version', ctx=Load()), args=[Name(id='paths', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)]))], decorator_list=[]), FunctionDef(name='is_current', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='paths')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Return true if dependency is present and up-to-date on 'paths'")), Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_version', ctx=Load()), args=[Name(id='paths', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='version', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='version_ok', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='maybe_close', args=arguments(posonlyargs=[], args=[arg(arg='f')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='empty', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Yield()), Return()], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), If(test=UnaryOp(op=Not(), operand=Name(id='f', ctx=Load())), body=[Return(value=Call(func=Name(id='empty', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='closing', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_module_constant', args=arguments(posonlyargs=[], args=[arg(arg='module'), arg(arg='symbol'), arg(arg='default'), arg(arg='paths')], kwonlyargs=[], kw_defaults=[], defaults=[UnaryOp(op=USub(), operand=Constant(value=1)), Constant(value=None)]), body=[Expr(value=Constant(value="Find 'module' by searching 'paths', and extract 'symbol'\n\n    Return 'None' if 'module' does not exist on 'paths', or it does not define\n    'symbol'.  If the module defines 'symbol' as a constant, return the\n    constant.  Otherwise, return 'default'.")), Try(body=[Assign(targets=[Tuple(elts=[Name(id='f', ctx=Store()), Name(id='path', ctx=Store()), Tuple(elts=[Name(id='suffix', ctx=Store()), Name(id='mode', ctx=Store()), Name(id='kind', ctx=Store())], ctx=Store())], ctx=Store()), Name(id='info', ctx=Store())], value=Call(func=Name(id='find_module', ctx=Load()), args=[Name(id='module', ctx=Load()), Name(id='paths', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Return(value=Constant(value=None))])], orelse=[], finalbody=[]), With(items=[withitem(context_expr=Call(func=Name(id='maybe_close', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]))], body=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[Eq()], comparators=[Name(id='PY_COMPILED', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[Constant(value=8)], keywords=[])), Assign(targets=[Name(id='code', ctx=Store())], value=Call(func=Attribute(value=Name(id='marshal', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[Eq()], comparators=[Name(id='PY_FROZEN', ctx=Load())]), body=[Assign(targets=[Name(id='code', ctx=Store())], value=Call(func=Attribute(value=Name(id='_imp', ctx=Load()), attr='get_frozen_object', ctx=Load()), args=[Name(id='module', ctx=Load()), Name(id='paths', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[Eq()], comparators=[Name(id='PY_SOURCE', ctx=Load())]), body=[Assign(targets=[Name(id='code', ctx=Store())], value=Call(func=Name(id='compile', ctx=Load()), args=[Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]), Name(id='path', ctx=Load()), Constant(value='exec')], keywords=[]))], orelse=[Assign(targets=[Name(id='imported', ctx=Store())], value=Call(func=Attribute(value=Name(id='_imp', ctx=Load()), attr='get_module', ctx=Load()), args=[Name(id='module', ctx=Load()), Name(id='paths', ctx=Load()), Name(id='info', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='imported', ctx=Load()), Name(id='symbol', ctx=Load()), Constant(value=None)], keywords=[]))])])])]), Return(value=Call(func=Name(id='extract_constant', ctx=Load()), args=[Name(id='code', ctx=Load()), Name(id='symbol', ctx=Load()), Name(id='default', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='extract_constant', args=arguments(posonlyargs=[], args=[arg(arg='code'), arg(arg='symbol'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Expr(value=Constant(value='Extract the constant value of \'symbol\' from \'code\'\n\n    If the name \'symbol\' is bound to a constant value by the Python code\n    object \'code\', return that value.  If \'symbol\' is bound to an expression,\n    return \'default\'.  Otherwise, return \'None\'.\n\n    Return value is based on the first assignment to \'symbol\'.  \'symbol\' must\n    be a global, or at least a non-"fast" local in the code block.  That is,\n    only \'STORE_NAME\' and \'STORE_GLOBAL\' opcodes are checked, and \'symbol\'\n    must be present in \'code.co_names\'.\n    ')), If(test=Compare(left=Name(id='symbol', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='code', ctx=Load()), attr='co_names', ctx=Load())]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='name_idx', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='code', ctx=Load()), attr='co_names', ctx=Load())], keywords=[]), attr='index', ctx=Load()), args=[Name(id='symbol', ctx=Load())], keywords=[])), Assign(targets=[Name(id='STORE_NAME', ctx=Store())], value=Constant(value=90)), Assign(targets=[Name(id='STORE_GLOBAL', ctx=Store())], value=Constant(value=97)), Assign(targets=[Name(id='LOAD_CONST', ctx=Store())], value=Constant(value=100)), Assign(targets=[Name(id='const', ctx=Store())], value=Name(id='default', ctx=Load())), For(target=Name(id='byte_code', ctx=Store()), iter=Call(func=Attribute(value=Name(id='dis', ctx=Load()), attr='Bytecode', ctx=Load()), args=[Name(id='code', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Attribute(value=Name(id='byte_code', ctx=Load()), attr='opcode', ctx=Load())), Assign(targets=[Name(id='arg', ctx=Store())], value=Attribute(value=Name(id='byte_code', ctx=Load()), attr='arg', ctx=Load())), If(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Name(id='LOAD_CONST', ctx=Load())]), body=[Assign(targets=[Name(id='const', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='code', ctx=Load()), attr='co_consts', ctx=Load()), slice=Name(id='arg', ctx=Load()), ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='arg', ctx=Load()), ops=[Eq()], comparators=[Name(id='name_idx', ctx=Load())]), BoolOp(op=Or(), values=[Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Name(id='STORE_NAME', ctx=Load())]), Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Name(id='STORE_GLOBAL', ctx=Load())])])]), body=[Return(value=Name(id='const', ctx=Load()))], orelse=[Assign(targets=[Name(id='const', ctx=Store())], value=Name(id='default', ctx=Load()))])])], orelse=[])], decorator_list=[]), FunctionDef(name='_update_globals', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Patch the globals to remove the objects not available on some platforms.\n\n    XXX it'd be better to test assertions about bytecode instead.\n    ")), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='java')], keywords=[])), Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='cli')])]), body=[Return()], orelse=[]), Assign(targets=[Name(id='incompatible', ctx=Store())], value=Tuple(elts=[Constant(value='extract_constant'), Constant(value='get_module_constant')], ctx=Load())), For(target=Name(id='name', ctx=Store()), iter=Name(id='incompatible', ctx=Load()), body=[Delete(targets=[Subscript(value=Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[]), slice=Name(id='name', ctx=Load()), ctx=Del())]), Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), Expr(value=Call(func=Name(id='_update_globals', ctx=Load()), args=[], keywords=[]))], type_ignores=[])