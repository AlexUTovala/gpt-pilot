Module(body=[Expr(value=Constant(value='\nMonkey patching of distutils.\n')), Import(names=[alias(name='functools')]), Import(names=[alias(name='inspect')]), Import(names=[alias(name='platform')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='types')]), ImportFrom(module='importlib', names=[alias(name='import_module')], level=0), Import(names=[alias(name='distutils.filelist')]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Constant(value='\nEverything is private. Contact the project team\nif you think you need this functionality.\n')), FunctionDef(name='_get_mro', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Returns the bases classes for cls sorted by the MRO.\n\n    Works around an issue on Jython where inspect.getmro will not return all\n    base classes if multiple classes share the same name. Instead, this\n    function will return a tuple containing the class itself, and the contents\n    of cls.__bases__. See https://github.com/pypa/setuptools/issues/1024.\n    ')), If(test=Compare(left=Call(func=Attribute(value=Name(id='platform', ctx=Load()), attr='python_implementation', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='Jython')]), body=[Return(value=BinOp(left=Tuple(elts=[Name(id='cls', ctx=Load())], ctx=Load()), op=Add(), right=Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load())))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='getmro', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_unpatched', args=arguments(posonlyargs=[], args=[arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='lookup', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='item', ctx=Load()), Name(id='type', ctx=Load())], keywords=[]), body=Name(id='get_unpatched_class', ctx=Load()), orelse=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='item', ctx=Load()), Attribute(value=Name(id='types', ctx=Load()), attr='FunctionType', ctx=Load())], keywords=[]), body=Name(id='get_unpatched_function', ctx=Load()), orelse=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=None))))), Return(value=Call(func=Name(id='lookup', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_unpatched_class', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Protect against re-patching the distutils if reloaded\n\n    Also ensures that no other distutils extension monkeypatched the distutils\n    first.\n    ')), Assign(targets=[Name(id='external_bases', ctx=Store())], value=GeneratorExp(elt=Name(id='cls', ctx=Load()), generators=[comprehension(target=Name(id='cls', ctx=Store()), iter=Call(func=Name(id='_get_mro', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), ifs=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__module__', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='setuptools')], keywords=[]))], is_async=0)])), Assign(targets=[Name(id='base', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='external_bases', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__module__', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='distutils')], keywords=[])), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=BinOp(left=Constant(value='distutils has already been patched by %r'), op=Mod(), right=Name(id='cls', ctx=Load()))), Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='base', ctx=Load()))], decorator_list=[]), FunctionDef(name='patch_all', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Import(names=[alias(name='setuptools')]), Assign(targets=[Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='core', ctx=Load()), attr='Command', ctx=Store())], value=Attribute(value=Name(id='setuptools', ctx=Load()), attr='Command', ctx=Load())), Assign(targets=[Name(id='has_issue_12885', ctx=Store())], value=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[LtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=5), Constant(value=3)], ctx=Load())])), If(test=Name(id='has_issue_12885', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='filelist', ctx=Load()), attr='findall', ctx=Store())], value=Attribute(value=Name(id='setuptools', ctx=Load()), attr='findall', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='needs_warehouse', ctx=Store())], value=BoolOp(op=Or(), values=[Compare(left=Tuple(elts=[Constant(value=3), Constant(value=4)], ctx=Load()), ops=[Lt(), Lt()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), Tuple(elts=[Constant(value=3), Constant(value=4), Constant(value=6)], ctx=Load())]), Compare(left=Tuple(elts=[Constant(value=3), Constant(value=5)], ctx=Load()), ops=[Lt(), LtE()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), Tuple(elts=[Constant(value=3), Constant(value=5), Constant(value=3)], ctx=Load())])])), If(test=Name(id='needs_warehouse', ctx=Load()), body=[Assign(targets=[Name(id='warehouse', ctx=Store())], value=Constant(value='https://upload.pypi.org/legacy/')), Assign(targets=[Attribute(value=Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='config', ctx=Load()), attr='PyPIRCCommand', ctx=Load()), attr='DEFAULT_REPOSITORY', ctx=Store())], value=Name(id='warehouse', ctx=Load()))], orelse=[]), Expr(value=Call(func=Name(id='_patch_distribution_metadata', ctx=Load()), args=[], keywords=[])), For(target=Name(id='module', ctx=Store()), iter=Tuple(elts=[Attribute(value=Name(id='distutils', ctx=Load()), attr='dist', ctx=Load()), Attribute(value=Name(id='distutils', ctx=Load()), attr='core', ctx=Load()), Attribute(value=Name(id='distutils', ctx=Load()), attr='cmd', ctx=Load())], ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='module', ctx=Load()), attr='Distribution', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='setuptools', ctx=Load()), attr='dist', ctx=Load()), attr='Distribution', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='core', ctx=Load()), attr='Extension', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='setuptools', ctx=Load()), attr='extension', ctx=Load()), attr='Extension', ctx=Load())), Assign(targets=[Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='extension', ctx=Load()), attr='Extension', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='setuptools', ctx=Load()), attr='extension', ctx=Load()), attr='Extension', ctx=Load())), If(test=Compare(left=Constant(value='distutils.command.build_ext'), ops=[In()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load())]), body=[Assign(targets=[Attribute(value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Constant(value='distutils.command.build_ext'), ctx=Load()), attr='Extension', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='setuptools', ctx=Load()), attr='extension', ctx=Load()), attr='Extension', ctx=Load()))], orelse=[]), Expr(value=Call(func=Name(id='patch_for_msvc_specialized_compiler', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_patch_distribution_metadata', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(names=[alias(name='_core_metadata')], level=1), Expr(value=Constant(value='Patch write_pkg_file and read_pkg_file for higher metadata standards')), For(target=Name(id='attr', ctx=Store()), iter=Tuple(elts=[Constant(value='write_pkg_info'), Constant(value='write_pkg_file'), Constant(value='read_pkg_file'), Constant(value='get_metadata_version')], ctx=Load()), body=[Assign(targets=[Name(id='new_val', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='_core_metadata', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='dist', ctx=Load()), attr='DistributionMetadata', ctx=Load()), Name(id='attr', ctx=Load()), Name(id='new_val', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='patch_func', args=arguments(posonlyargs=[], args=[arg(arg='replacement'), arg(arg='target_mod'), arg(arg='func_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Patch func_name in target_mod with replacement\n\n    Important - original must be resolved by name to avoid\n    patching an already patched function.\n    ')), Assign(targets=[Name(id='original', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='target_mod', ctx=Load()), Name(id='func_name', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='replacement', ctx=Load())], keywords=[]), attr='setdefault', ctx=Load()), args=[Constant(value='unpatched'), Name(id='original', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='target_mod', ctx=Load()), Name(id='func_name', ctx=Load()), Name(id='replacement', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_unpatched_function', args=arguments(posonlyargs=[], args=[arg(arg='candidate')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='candidate', ctx=Load()), Constant(value='unpatched')], keywords=[]))], decorator_list=[]), FunctionDef(name='patch_for_msvc_specialized_compiler', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Patch functions in distutils to use standalone Microsoft Visual C++\n    compilers.\n    ')), Assign(targets=[Name(id='msvc', ctx=Store())], value=Call(func=Name(id='import_module', ctx=Load()), args=[Constant(value='setuptools.msvc')], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='platform', ctx=Load()), attr='system', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Constant(value='Windows')]), body=[Return()], orelse=[]), FunctionDef(name='patch_params', args=arguments(posonlyargs=[], args=[arg(arg='mod_name'), arg(arg='func_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Prepare the parameters for patch_func to patch indicated function.\n        ')), Assign(targets=[Name(id='repl_prefix', ctx=Store())], value=Constant(value='msvc14_')), Assign(targets=[Name(id='repl_name', ctx=Store())], value=BinOp(left=Name(id='repl_prefix', ctx=Load()), op=Add(), right=Call(func=Attribute(value=Name(id='func_name', ctx=Load()), attr='lstrip', ctx=Load()), args=[Constant(value='_')], keywords=[]))), Assign(targets=[Name(id='repl', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='msvc', ctx=Load()), Name(id='repl_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='mod', ctx=Store())], value=Call(func=Name(id='import_module', ctx=Load()), args=[Name(id='mod_name', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='mod', ctx=Load()), Name(id='func_name', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ImportError', ctx=Load()), args=[Name(id='func_name', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='repl', ctx=Load()), Name(id='mod', ctx=Load()), Name(id='func_name', ctx=Load())], ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='msvc14', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Name(id='patch_params', ctx=Load()), Constant(value='distutils._msvccompiler')], keywords=[])), Try(body=[Expr(value=Call(func=Name(id='patch_func', ctx=Load()), args=[Starred(value=Call(func=Name(id='msvc14', ctx=Load()), args=[Constant(value='_get_vc_env')], keywords=[]), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], decorator_list=[])], type_ignores=[])