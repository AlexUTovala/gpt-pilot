Module(body=[Expr(value=Constant(value='distutils.ccompiler\n\nContains CCompiler, an abstract base class that defines the interface\nfor the Distutils compiler abstraction model.')), Import(names=[alias(name='sys')]), Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), Import(names=[alias(name='warnings')]), ImportFrom(module='errors', names=[alias(name='CompileError'), alias(name='LinkError'), alias(name='UnknownFileError'), alias(name='DistutilsPlatformError'), alias(name='DistutilsModuleError')], level=1), ImportFrom(module='spawn', names=[alias(name='spawn')], level=1), ImportFrom(module='file_util', names=[alias(name='move_file')], level=1), ImportFrom(module='dir_util', names=[alias(name='mkpath')], level=1), ImportFrom(module='dep_util', names=[alias(name='newer_group')], level=1), ImportFrom(module='util', names=[alias(name='split_quoted'), alias(name='execute')], level=1), ImportFrom(module='_log', names=[alias(name='log')], level=1), ClassDef(name='CCompiler', bases=[], keywords=[], body=[Expr(value=Constant(value='Abstract base class to define the interface that must be implemented\n    by real compiler classes.  Also has some utility methods used by\n    several compiler classes.\n\n    The basic idea behind a compiler abstraction class is that each\n    instance can be used for all the compile/link steps in building a\n    single project.  Thus, attributes common to all of those compile and\n    link steps -- include directories, macros to define, libraries to link\n    against, etc. -- are attributes of the compiler instance.  To allow for\n    variability in how individual files are treated, most of those\n    attributes may be varied on a per-compilation or per-link basis.\n    ')), Assign(targets=[Name(id='compiler_type', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='src_extensions', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='obj_extension', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='static_lib_extension', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='shared_lib_extension', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='static_lib_format', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='shared_lib_format', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='exe_extension', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='language_map', ctx=Store())], value=Dict(keys=[Constant(value='.c'), Constant(value='.cc'), Constant(value='.cpp'), Constant(value='.cxx'), Constant(value='.m')], values=[Constant(value='c'), Constant(value='c++'), Constant(value='c++'), Constant(value='c++'), Constant(value='objc')])), Assign(targets=[Name(id='language_order', ctx=Store())], value=List(elts=[Constant(value='c++'), Constant(value='objc'), Constant(value='c')], ctx=Load())), Assign(targets=[Name(id='include_dirs', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Constant(value='\n    include dirs specific to this compiler class\n    ')), Assign(targets=[Name(id='library_dirs', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Constant(value='\n    library dirs specific to this compiler class\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='verbose'), arg(arg='dry_run'), arg(arg='force')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=0), Constant(value=0)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dry_run', ctx=Store())], value=Name(id='dry_run', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='force', ctx=Store())], value=Name(id='force', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='verbose', ctx=Store())], value=Name(id='verbose', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='output_dir', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='macros', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='include_dirs', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='libraries', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='library_dirs', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='runtime_library_dirs', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='objects', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='key', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='executables', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_executable', ctx=Load()), args=[Name(id='key', ctx=Load()), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='executables', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='set_executables', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value="Define the executables (and options for them) that will be run\n        to perform the various stages of compilation.  The exact set of\n        executables that may be specified here depends on the compiler\n        class (via the 'executables' class attribute), but most will have:\n          compiler      the C/C++ compiler\n          linker_so     linker used to create shared objects and libraries\n          linker_exe    linker used to create binary executables\n          archiver      static library creator\n\n        On platforms with a command-line (Unix, DOS/Windows), each of these\n        is a string that will be split into executable name and (optional)\n        list of arguments.  (Splitting the string is done similarly to how\n        Unix shells operate: words are delimited by spaces, but quotes and\n        backslashes can override this.  See\n        'distutils.util.split_quoted()'.)\n        ")), For(target=Name(id='key', ctx=Store()), iter=Name(id='kwargs', ctx=Load()), body=[If(test=Compare(left=Name(id='key', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='executables', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value="unknown executable '%s' for class %s"), op=Mod(), right=Tuple(elts=[Name(id='key', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_executable', ctx=Load()), args=[Name(id='key', ctx=Load()), Subscript(value=Name(id='kwargs', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='set_executable', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='key', ctx=Load()), Call(func=Name(id='split_quoted', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='key', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='_find_macro', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='i', ctx=Store())], value=Constant(value=0)), For(target=Name(id='defn', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='macros', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='defn', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Name(id='name', ctx=Load())]), body=[Return(value=Name(id='i', ctx=Load()))], orelse=[]), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='_check_macro_definitions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='definitions')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Ensures that every element of 'definitions' is a valid macro\n        definition, ie. either (name,value) 2-tuple or a (name,) tuple.  Do\n        nothing if all definitions are OK, raise TypeError otherwise.\n        ")), For(target=Name(id='defn', ctx=Store()), iter=Name(id='definitions', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='defn', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='defn', ctx=Load())], keywords=[]), ops=[In()], comparators=[Tuple(elts=[Constant(value=1), Constant(value=2)], ctx=Load())]), BoolOp(op=Or(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='defn', ctx=Load()), slice=Constant(value=1), ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), Compare(left=Subscript(value=Name(id='defn', ctx=Load()), slice=Constant(value=1), ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])])]), Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='defn', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='str', ctx=Load())], keywords=[])])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value="invalid macro definition '%s': "), op=Mod(), right=Name(id='defn', ctx=Load())), op=Add(), right=Constant(value='must be tuple (string,), (string, string), or ')), op=Add(), right=Constant(value='(string, None)'))], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='define_macro', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Define a preprocessor macro for all compilations driven by this\n        compiler object.  The optional parameter 'value' should be a\n        string; if it is not supplied, then the macro will be defined\n        without an explicit value and the exact outcome depends on the\n        compiler used (XXX true? does ANSI say anything about this?)\n        ")), Assign(targets=[Name(id='i', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_macro', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='macros', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Del())])], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='macros', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='undefine_macro', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Undefine a preprocessor macro for all compilations driven by\n        this compiler object.  If the same macro is defined by\n        'define_macro()' and undefined by 'undefine_macro()' the last call\n        takes precedence (including multiple redefinitions or\n        undefinitions).  If the macro is redefined/undefined on a\n        per-compilation basis (ie. in the call to 'compile()'), then that\n        takes precedence.\n        ")), Assign(targets=[Name(id='i', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_macro', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='macros', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Del())])], orelse=[]), Assign(targets=[Name(id='undefn', ctx=Store())], value=Tuple(elts=[Name(id='name', ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='macros', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='undefn', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='add_include_dir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dir')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Add 'dir' to the list of directories that will be searched for\n        header files.  The compiler is instructed to search directories in\n        the order in which they are supplied by successive calls to\n        'add_include_dir()'.\n        ")), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='include_dirs', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='dir', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='set_include_dirs', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dirs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Set the list of directories that will be searched to 'dirs' (a\n        list of strings).  Overrides any preceding calls to\n        'add_include_dir()'; subsequence calls to 'add_include_dir()' add\n        to the list passed to 'set_include_dirs()'.  This does not affect\n        any list of standard include directories that the compiler may\n        search by default.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='include_dirs', ctx=Store())], value=Subscript(value=Name(id='dirs', ctx=Load()), slice=Slice(), ctx=Load()))], decorator_list=[]), FunctionDef(name='add_library', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='libname')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Add 'libname' to the list of libraries that will be included in\n        all links driven by this compiler object.  Note that 'libname'\n        should *not* be the name of a file containing a library, but the\n        name of the library itself: the actual filename will be inferred by\n        the linker, the compiler, or the compiler class (depending on the\n        platform).\n\n        The linker will be instructed to link against libraries in the\n        order they were supplied to 'add_library()' and/or\n        'set_libraries()'.  It is perfectly valid to duplicate library\n        names; the linker will be instructed to link against libraries as\n        many times as they are mentioned.\n        ")), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='libraries', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='libname', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='set_libraries', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='libnames')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Set the list of libraries to be included in all links driven by\n        this compiler object to 'libnames' (a list of strings).  This does\n        not affect any standard system libraries that the linker may\n        include by default.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='libraries', ctx=Store())], value=Subscript(value=Name(id='libnames', ctx=Load()), slice=Slice(), ctx=Load()))], decorator_list=[]), FunctionDef(name='add_library_dir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dir')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Add 'dir' to the list of directories that will be searched for\n        libraries specified to 'add_library()' and 'set_libraries()'.  The\n        linker will be instructed to search for libraries in the order they\n        are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.\n        ")), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='library_dirs', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='dir', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='set_library_dirs', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dirs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Set the list of library search directories to 'dirs' (a list of\n        strings).  This does not affect any standard library search path\n        that the linker may search by default.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='library_dirs', ctx=Store())], value=Subscript(value=Name(id='dirs', ctx=Load()), slice=Slice(), ctx=Load()))], decorator_list=[]), FunctionDef(name='add_runtime_library_dir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dir')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Add 'dir' to the list of directories that will be searched for\n        shared libraries at runtime.\n        ")), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='runtime_library_dirs', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='dir', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='set_runtime_library_dirs', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dirs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Set the list of directories to search for shared libraries at\n        runtime to 'dirs' (a list of strings).  This does not affect any\n        standard search path that the runtime linker may search by\n        default.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='runtime_library_dirs', ctx=Store())], value=Subscript(value=Name(id='dirs', ctx=Load()), slice=Slice(), ctx=Load()))], decorator_list=[]), FunctionDef(name='add_link_object', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='object')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add \'object\' to the list of object files (or analogues, such as\n        explicitly named library files or the output of "resource\n        compilers") to be included in every link driven by this compiler\n        object.\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='objects', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='object', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='set_link_objects', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='objects')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Set the list of object files (or analogues) to be included in\n        every link to 'objects'.  This does not affect any standard object\n        files that the linker may include by default (such as system\n        libraries).\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='objects', ctx=Store())], value=Subscript(value=Name(id='objects', ctx=Load()), slice=Slice(), ctx=Load()))], decorator_list=[]), FunctionDef(name='_setup_compile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='outdir'), arg(arg='macros'), arg(arg='incdirs'), arg(arg='sources'), arg(arg='depends'), arg(arg='extra')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Process arguments and decide which source files to compile.')), Assign(targets=[Tuple(elts=[Name(id='outdir', ctx=Store()), Name(id='macros', ctx=Store()), Name(id='incdirs', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fix_compile_args', ctx=Load()), args=[Name(id='outdir', ctx=Load()), Name(id='macros', ctx=Load()), Name(id='incdirs', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='extra', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='extra', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='objects', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='object_filenames', ctx=Load()), args=[Name(id='sources', ctx=Load())], keywords=[keyword(arg='strip_dir', value=Constant(value=0)), keyword(arg='output_dir', value=Name(id='outdir', ctx=Load()))])), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='objects', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='sources', ctx=Load())], keywords=[])])), Assign(targets=[Name(id='pp_opts', ctx=Store())], value=Call(func=Name(id='gen_preprocess_options', ctx=Load()), args=[Name(id='macros', ctx=Load()), Name(id='incdirs', ctx=Load())], keywords=[])), Assign(targets=[Name(id='build', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='sources', ctx=Load())], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='src', ctx=Store())], value=Subscript(value=Name(id='sources', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='obj', ctx=Store())], value=Subscript(value=Name(id='objects', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='ext', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='src', ctx=Load())], keywords=[]), slice=Constant(value=1), ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='mkpath', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Subscript(value=Name(id='build', ctx=Load()), slice=Name(id='obj', ctx=Load()), ctx=Store())], value=Tuple(elts=[Name(id='src', ctx=Load()), Name(id='ext', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[Name(id='macros', ctx=Load()), Name(id='objects', ctx=Load()), Name(id='extra', ctx=Load()), Name(id='pp_opts', ctx=Load()), Name(id='build', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_get_cc_args', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pp_opts'), arg(arg='debug'), arg(arg='before')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='cc_args', ctx=Store())], value=BinOp(left=Name(id='pp_opts', ctx=Load()), op=Add(), right=List(elts=[Constant(value='-c')], ctx=Load()))), If(test=Name(id='debug', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='cc_args', ctx=Load()), slice=Slice(upper=Constant(value=0)), ctx=Store())], value=List(elts=[Constant(value='-g')], ctx=Load()))], orelse=[]), If(test=Name(id='before', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='cc_args', ctx=Load()), slice=Slice(upper=Constant(value=0)), ctx=Store())], value=Name(id='before', ctx=Load()))], orelse=[]), Return(value=Name(id='cc_args', ctx=Load()))], decorator_list=[]), FunctionDef(name='_fix_compile_args', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='output_dir'), arg(arg='macros'), arg(arg='include_dirs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Typecheck and fix-up some of the arguments to the 'compile()'\n        method, and return fixed-up values.  Specifically: if 'output_dir'\n        is None, replaces it with 'self.output_dir'; ensures that 'macros'\n        is a list, and augments it with 'self.macros'; ensures that\n        'include_dirs' is a list, and augments it with 'self.include_dirs'.\n        Guarantees that the returned values are of the correct type,\n        i.e. for 'output_dir' either string or None, and for 'macros' and\n        'include_dirs' either list or None.\n        ")), If(test=Compare(left=Name(id='output_dir', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='output_dir', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='output_dir', ctx=Load()))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='output_dir', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="'output_dir' must be a string or None")], keywords=[]))], orelse=[])]), If(test=Compare(left=Name(id='macros', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='macros', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='macros', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='macros', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='macros', ctx=Store())], value=BinOp(left=Name(id='macros', ctx=Load()), op=Add(), right=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='macros', ctx=Load()), List(elts=[], ctx=Load())])))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="'macros' (if supplied) must be a list of tuples")], keywords=[]))])]), If(test=Compare(left=Name(id='include_dirs', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='include_dirs', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='include_dirs', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='include_dirs', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='include_dirs', ctx=Store())], value=BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Name(id='include_dirs', ctx=Load())], keywords=[]), op=Add(), right=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='include_dirs', ctx=Load()), List(elts=[], ctx=Load())])))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="'include_dirs' (if supplied) must be a list of strings")], keywords=[]))])]), AugAssign(target=Name(id='include_dirs', ctx=Store()), op=Add(), value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='include_dirs', ctx=Load())), Return(value=Tuple(elts=[Name(id='output_dir', ctx=Load()), Name(id='macros', ctx=Load()), Name(id='include_dirs', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_prep_compile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='sources'), arg(arg='output_dir'), arg(arg='depends')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Decide which source files must be recompiled.\n\n        Determine the list of object files corresponding to 'sources',\n        and figure out which ones really need to be recompiled.\n        Return a list of all object files and a dictionary telling\n        which source files can be skipped.\n        ")), Assign(targets=[Name(id='objects', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='object_filenames', ctx=Load()), args=[Name(id='sources', ctx=Load())], keywords=[keyword(arg='output_dir', value=Name(id='output_dir', ctx=Load()))])), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='objects', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='sources', ctx=Load())], keywords=[])])), Return(value=Tuple(elts=[Name(id='objects', ctx=Load()), Dict(keys=[], values=[])], ctx=Load()))], decorator_list=[]), FunctionDef(name='_fix_object_args', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='objects'), arg(arg='output_dir')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Typecheck and fix up some arguments supplied to various methods.\n        Specifically: ensure that 'objects' is a list; if output_dir is\n        None, replace with self.output_dir.  Return fixed versions of\n        'objects' and 'output_dir'.\n        ")), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='objects', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="'objects' must be a list or tuple of strings")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='objects', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='objects', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='output_dir', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='output_dir', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='output_dir', ctx=Load()))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='output_dir', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="'output_dir' must be a string or None")], keywords=[]))], orelse=[])]), Return(value=Tuple(elts=[Name(id='objects', ctx=Load()), Name(id='output_dir', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_fix_lib_args', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='libraries'), arg(arg='library_dirs'), arg(arg='runtime_library_dirs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Typecheck and fix up some of the arguments supplied to the\n        'link_*' methods.  Specifically: ensure that all arguments are\n        lists, and augment them with their permanent versions\n        (eg. 'self.libraries' augments 'libraries').  Return a tuple with\n        fixed versions of all arguments.\n        ")), If(test=Compare(left=Name(id='libraries', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='libraries', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='libraries', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='libraries', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='libraries', ctx=Store())], value=BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Name(id='libraries', ctx=Load())], keywords=[]), op=Add(), right=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='libraries', ctx=Load()), List(elts=[], ctx=Load())])))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="'libraries' (if supplied) must be a list of strings")], keywords=[]))])]), If(test=Compare(left=Name(id='library_dirs', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='library_dirs', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='library_dirs', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='library_dirs', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='library_dirs', ctx=Store())], value=BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Name(id='library_dirs', ctx=Load())], keywords=[]), op=Add(), right=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='library_dirs', ctx=Load()), List(elts=[], ctx=Load())])))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="'library_dirs' (if supplied) must be a list of strings")], keywords=[]))])]), AugAssign(target=Name(id='library_dirs', ctx=Store()), op=Add(), value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='library_dirs', ctx=Load())), If(test=Compare(left=Name(id='runtime_library_dirs', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='runtime_library_dirs', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='runtime_library_dirs', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='runtime_library_dirs', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='runtime_library_dirs', ctx=Store())], value=BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Name(id='runtime_library_dirs', ctx=Load())], keywords=[]), op=Add(), right=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='runtime_library_dirs', ctx=Load()), List(elts=[], ctx=Load())])))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="'runtime_library_dirs' (if supplied) must be a list of strings")], keywords=[]))])]), Return(value=Tuple(elts=[Name(id='libraries', ctx=Load()), Name(id='library_dirs', ctx=Load()), Name(id='runtime_library_dirs', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_need_link', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='objects'), arg(arg='output_file')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return true if we need to relink the files listed in 'objects'\n        to recreate 'output_file'.\n        ")), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='force', ctx=Load()), body=[Return(value=Constant(value=True))], orelse=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='dry_run', ctx=Load()), body=[Assign(targets=[Name(id='newer', ctx=Store())], value=Call(func=Name(id='newer_group', ctx=Load()), args=[Name(id='objects', ctx=Load()), Name(id='output_file', ctx=Load())], keywords=[keyword(arg='missing', value=Constant(value='newer'))]))], orelse=[Assign(targets=[Name(id='newer', ctx=Store())], value=Call(func=Name(id='newer_group', ctx=Load()), args=[Name(id='objects', ctx=Load()), Name(id='output_file', ctx=Load())], keywords=[]))]), Return(value=Name(id='newer', ctx=Load()))])], decorator_list=[]), FunctionDef(name='detect_language', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='sources')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Detect the language of a given file, or list of files. Uses\n        language_map, and language_order to do the job.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='sources', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='sources', ctx=Store())], value=List(elts=[Name(id='sources', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='lang', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='index', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='language_order', ctx=Load())], keywords=[])), For(target=Name(id='source', ctx=Store()), iter=Name(id='sources', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='base', ctx=Store()), Name(id='ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])), Assign(targets=[Name(id='extlang', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='language_map', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='ext', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='extindex', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='language_order', ctx=Load()), attr='index', ctx=Load()), args=[Name(id='extlang', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='extindex', ctx=Load()), ops=[Lt()], comparators=[Name(id='index', ctx=Load())]), body=[Assign(targets=[Name(id='lang', ctx=Store())], value=Name(id='extlang', ctx=Load())), Assign(targets=[Name(id='index', ctx=Store())], value=Name(id='extindex', ctx=Load()))], orelse=[])], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Return(value=Name(id='lang', ctx=Load()))], decorator_list=[]), FunctionDef(name='preprocess', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source'), arg(arg='output_file'), arg(arg='macros'), arg(arg='include_dirs'), arg(arg='extra_preargs'), arg(arg='extra_postargs')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Preprocess a single C/C++ source file, named in 'source'.\n        Output will be written to file named 'output_file', or stdout if\n        'output_file' not supplied.  'macros' is a list of macro\n        definitions as for 'compile()', which will augment the macros set\n        with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a\n        list of directory names that will be added to the default list.\n\n        Raises PreprocessError on failure.\n        ")), Pass()], decorator_list=[]), FunctionDef(name='compile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='sources'), arg(arg='output_dir'), arg(arg='macros'), arg(arg='include_dirs'), arg(arg='debug'), arg(arg='extra_preargs'), arg(arg='extra_postargs'), arg(arg='depends')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Compile one or more source files.\n\n        \'sources\' must be a list of filenames, most likely C/C++\n        files, but in reality anything that can be handled by a\n        particular compiler and compiler class (eg. MSVCCompiler can\n        handle resource files in \'sources\').  Return a list of object\n        filenames, one per source filename in \'sources\'.  Depending on\n        the implementation, not all source files will necessarily be\n        compiled, but all corresponding object filenames will be\n        returned.\n\n        If \'output_dir\' is given, object files will be put under it, while\n        retaining their original path component.  That is, "foo/bar.c"\n        normally compiles to "foo/bar.o" (for a Unix implementation); if\n        \'output_dir\' is "build", then it would compile to\n        "build/foo/bar.o".\n\n        \'macros\', if given, must be a list of macro definitions.  A macro\n        definition is either a (name, value) 2-tuple or a (name,) 1-tuple.\n        The former defines a macro; if the value is None, the macro is\n        defined without an explicit value.  The 1-tuple case undefines a\n        macro.  Later definitions/redefinitions/ undefinitions take\n        precedence.\n\n        \'include_dirs\', if given, must be a list of strings, the\n        directories to add to the default include file search path for this\n        compilation only.\n\n        \'debug\' is a boolean; if true, the compiler will be instructed to\n        output debug symbols in (or alongside) the object file(s).\n\n        \'extra_preargs\' and \'extra_postargs\' are implementation- dependent.\n        On platforms that have the notion of a command-line (e.g. Unix,\n        DOS/Windows), they are most likely lists of strings: extra\n        command-line arguments to prepend/append to the compiler command\n        line.  On other platforms, consult the implementation class\n        documentation.  In any event, they are intended as an escape hatch\n        for those occasions when the abstract compiler framework doesn\'t\n        cut the mustard.\n\n        \'depends\', if given, is a list of filenames that all targets\n        depend on.  If a source file is older than any file in\n        depends, then the source file will be recompiled.  This\n        supports dependency tracking, but only at a coarse\n        granularity.\n\n        Raises CompileError on failure.\n        ')), Assign(targets=[Tuple(elts=[Name(id='macros', ctx=Store()), Name(id='objects', ctx=Store()), Name(id='extra_postargs', ctx=Store()), Name(id='pp_opts', ctx=Store()), Name(id='build', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_setup_compile', ctx=Load()), args=[Name(id='output_dir', ctx=Load()), Name(id='macros', ctx=Load()), Name(id='include_dirs', ctx=Load()), Name(id='sources', ctx=Load()), Name(id='depends', ctx=Load()), Name(id='extra_postargs', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cc_args', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_cc_args', ctx=Load()), args=[Name(id='pp_opts', ctx=Load()), Name(id='debug', ctx=Load()), Name(id='extra_preargs', ctx=Load())], keywords=[])), For(target=Name(id='obj', ctx=Store()), iter=Name(id='objects', ctx=Load()), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='src', ctx=Store()), Name(id='ext', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='build', ctx=Load()), slice=Name(id='obj', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Continue()])], orelse=[], finalbody=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compile', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='src', ctx=Load()), Name(id='ext', ctx=Load()), Name(id='cc_args', ctx=Load()), Name(id='extra_postargs', ctx=Load()), Name(id='pp_opts', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='objects', ctx=Load()))], decorator_list=[]), FunctionDef(name='_compile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj'), arg(arg='src'), arg(arg='ext'), arg(arg='cc_args'), arg(arg='extra_postargs'), arg(arg='pp_opts')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Compile 'src' to product 'obj'.")), Pass()], decorator_list=[]), FunctionDef(name='create_static_lib', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='objects'), arg(arg='output_libname'), arg(arg='output_dir'), arg(arg='debug'), arg(arg='target_lang')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value='Link a bunch of stuff together to create a static library file.\n        The "bunch of stuff" consists of the list of object files supplied\n        as \'objects\', the extra object files supplied to\n        \'add_link_object()\' and/or \'set_link_objects()\', the libraries\n        supplied to \'add_library()\' and/or \'set_libraries()\', and the\n        libraries supplied as \'libraries\' (if any).\n\n        \'output_libname\' should be a library name, not a filename; the\n        filename will be inferred from the library name.  \'output_dir\' is\n        the directory where the library file will be put.\n\n        \'debug\' is a boolean; if true, debugging information will be\n        included in the library (note that on most platforms, it is the\n        compile step where this matters: the \'debug\' flag is included here\n        just for consistency).\n\n        \'target_lang\' is the target language for which the given objects\n        are being compiled. This allows specific linkage time treatment of\n        certain languages.\n\n        Raises LibError on failure.\n        ')), Pass()], decorator_list=[]), Assign(targets=[Name(id='SHARED_OBJECT', ctx=Store())], value=Constant(value='shared_object')), Assign(targets=[Name(id='SHARED_LIBRARY', ctx=Store())], value=Constant(value='shared_library')), Assign(targets=[Name(id='EXECUTABLE', ctx=Store())], value=Constant(value='executable')), FunctionDef(name='link', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='target_desc'), arg(arg='objects'), arg(arg='output_filename'), arg(arg='output_dir'), arg(arg='libraries'), arg(arg='library_dirs'), arg(arg='runtime_library_dirs'), arg(arg='export_symbols'), arg(arg='debug'), arg(arg='extra_preargs'), arg(arg='extra_postargs'), arg(arg='build_temp'), arg(arg='target_lang')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Link a bunch of stuff together to create an executable or\n        shared library file.\n\n        The "bunch of stuff" consists of the list of object files supplied\n        as \'objects\'.  \'output_filename\' should be a filename.  If\n        \'output_dir\' is supplied, \'output_filename\' is relative to it\n        (i.e. \'output_filename\' can provide directory components if\n        needed).\n\n        \'libraries\' is a list of libraries to link against.  These are\n        library names, not filenames, since they\'re translated into\n        filenames in a platform-specific way (eg. "foo" becomes "libfoo.a"\n        on Unix and "foo.lib" on DOS/Windows).  However, they can include a\n        directory component, which means the linker will look in that\n        specific directory rather than searching all the normal locations.\n\n        \'library_dirs\', if supplied, should be a list of directories to\n        search for libraries that were specified as bare library names\n        (ie. no directory component).  These are on top of the system\n        default and those supplied to \'add_library_dir()\' and/or\n        \'set_library_dirs()\'.  \'runtime_library_dirs\' is a list of\n        directories that will be embedded into the shared library and used\n        to search for other shared libraries that *it* depends on at\n        run-time.  (This may only be relevant on Unix.)\n\n        \'export_symbols\' is a list of symbols that the shared library will\n        export.  (This appears to be relevant only on Windows.)\n\n        \'debug\' is as for \'compile()\' and \'create_static_lib()\', with the\n        slight distinction that it actually matters on most platforms (as\n        opposed to \'create_static_lib()\', which includes a \'debug\' flag\n        mostly for form\'s sake).\n\n        \'extra_preargs\' and \'extra_postargs\' are as for \'compile()\' (except\n        of course that they supply command-line arguments for the\n        particular linker being used).\n\n        \'target_lang\' is the target language for which the given objects\n        are being compiled. This allows specific linkage time treatment of\n        certain languages.\n\n        Raises LinkError on failure.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[]), FunctionDef(name='link_shared_lib', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='objects'), arg(arg='output_libname'), arg(arg='output_dir'), arg(arg='libraries'), arg(arg='library_dirs'), arg(arg='runtime_library_dirs'), arg(arg='export_symbols'), arg(arg='debug'), arg(arg='extra_preargs'), arg(arg='extra_postargs'), arg(arg='build_temp'), arg(arg='target_lang')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='link', ctx=Load()), args=[Attribute(value=Name(id='CCompiler', ctx=Load()), attr='SHARED_LIBRARY', ctx=Load()), Name(id='objects', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='library_filename', ctx=Load()), args=[Name(id='output_libname', ctx=Load())], keywords=[keyword(arg='lib_type', value=Constant(value='shared'))]), Name(id='output_dir', ctx=Load()), Name(id='libraries', ctx=Load()), Name(id='library_dirs', ctx=Load()), Name(id='runtime_library_dirs', ctx=Load()), Name(id='export_symbols', ctx=Load()), Name(id='debug', ctx=Load()), Name(id='extra_preargs', ctx=Load()), Name(id='extra_postargs', ctx=Load()), Name(id='build_temp', ctx=Load()), Name(id='target_lang', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='link_shared_object', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='objects'), arg(arg='output_filename'), arg(arg='output_dir'), arg(arg='libraries'), arg(arg='library_dirs'), arg(arg='runtime_library_dirs'), arg(arg='export_symbols'), arg(arg='debug'), arg(arg='extra_preargs'), arg(arg='extra_postargs'), arg(arg='build_temp'), arg(arg='target_lang')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='link', ctx=Load()), args=[Attribute(value=Name(id='CCompiler', ctx=Load()), attr='SHARED_OBJECT', ctx=Load()), Name(id='objects', ctx=Load()), Name(id='output_filename', ctx=Load()), Name(id='output_dir', ctx=Load()), Name(id='libraries', ctx=Load()), Name(id='library_dirs', ctx=Load()), Name(id='runtime_library_dirs', ctx=Load()), Name(id='export_symbols', ctx=Load()), Name(id='debug', ctx=Load()), Name(id='extra_preargs', ctx=Load()), Name(id='extra_postargs', ctx=Load()), Name(id='build_temp', ctx=Load()), Name(id='target_lang', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='link_executable', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='objects'), arg(arg='output_progname'), arg(arg='output_dir'), arg(arg='libraries'), arg(arg='library_dirs'), arg(arg='runtime_library_dirs'), arg(arg='debug'), arg(arg='extra_preargs'), arg(arg='extra_postargs'), arg(arg='target_lang')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='link', ctx=Load()), args=[Attribute(value=Name(id='CCompiler', ctx=Load()), attr='EXECUTABLE', ctx=Load()), Name(id='objects', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='executable_filename', ctx=Load()), args=[Name(id='output_progname', ctx=Load())], keywords=[]), Name(id='output_dir', ctx=Load()), Name(id='libraries', ctx=Load()), Name(id='library_dirs', ctx=Load()), Name(id='runtime_library_dirs', ctx=Load()), Constant(value=None), Name(id='debug', ctx=Load()), Name(id='extra_preargs', ctx=Load()), Name(id='extra_postargs', ctx=Load()), Constant(value=None), Name(id='target_lang', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='library_dir_option', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dir')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the compiler option to add 'dir' to the list of\n        directories searched for libraries.\n        ")), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[]), FunctionDef(name='runtime_library_dir_option', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dir')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the compiler option to add 'dir' to the list of\n        directories searched for runtime libraries.\n        ")), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[]), FunctionDef(name='library_option', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lib')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the compiler option to add 'lib' to the list of libraries\n        linked into the shared library or executable.\n        ")), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[]), FunctionDef(name='has_function', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='funcname'), arg(arg='includes'), arg(arg='include_dirs'), arg(arg='libraries'), arg(arg='library_dirs')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Return a boolean indicating whether funcname is provided as\n        a symbol on the current platform.  The optional arguments can\n        be used to augment the compilation environment.\n\n        The libraries argument is a list of flags to be passed to the\n        linker to make additional symbol definitions available for\n        linking.\n\n        The includes and include_dirs arguments are deprecated.\n        Usually, supplying include files with function declarations\n        will cause function detection to fail even in cases where the\n        symbol is available for linking.\n\n        ')), Import(names=[alias(name='tempfile')]), If(test=Compare(left=Name(id='includes', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='includes', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='includes is deprecated'), Name(id='DeprecationWarning', ctx=Load())], keywords=[]))]), If(test=Compare(left=Name(id='include_dirs', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='include_dirs', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='include_dirs is deprecated'), Name(id='DeprecationWarning', ctx=Load())], keywords=[]))]), If(test=Compare(left=Name(id='libraries', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='libraries', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='library_dirs', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='library_dirs', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='fd', ctx=Store()), Name(id='fname', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='tempfile', ctx=Load()), attr='mkstemp', ctx=Load()), args=[Constant(value='.c'), Name(id='funcname', ctx=Load())], keywords=[keyword(arg='text', value=Constant(value=True))])), Assign(targets=[Name(id='f', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='fdopen', ctx=Load()), args=[Name(id='fd', ctx=Load()), Constant(value='w')], keywords=[])), Try(body=[For(target=Name(id='incl', ctx=Store()), iter=Name(id='includes', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[BinOp(left=Constant(value='#include "%s"\n'), op=Mod(), right=Name(id='incl', ctx=Load()))], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='includes', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[BinOp(left=Constant(value='#ifdef __cplusplus\nextern "C"\n#endif\nchar %s(void);\n'), op=Mod(), right=Name(id='funcname', ctx=Load()))], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[BinOp(left=Constant(value='int main (int argc, char **argv) {\n    %s();\n    return 0;\n}\n'), op=Mod(), right=Name(id='funcname', ctx=Load()))], keywords=[]))], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))]), Try(body=[Assign(targets=[Name(id='objects', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compile', ctx=Load()), args=[List(elts=[Name(id='fname', ctx=Load())], ctx=Load())], keywords=[keyword(arg='include_dirs', value=Name(id='include_dirs', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='CompileError', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='fname', ctx=Load())], keywords=[]))]), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='link_executable', ctx=Load()), args=[Name(id='objects', ctx=Load()), Constant(value='a.out')], keywords=[keyword(arg='libraries', value=Name(id='libraries', ctx=Load())), keyword(arg='library_dirs', value=Name(id='library_dirs', ctx=Load()))]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='LinkError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='executable_filename', ctx=Load()), args=[Constant(value='a.out')], keywords=[keyword(arg='output_dir', value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='output_dir', ctx=Load()), Constant(value='')]))])], keywords=[]))], finalbody=[For(target=Name(id='fn', ctx=Store()), iter=Name(id='objects', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='fn', ctx=Load())], keywords=[]))], orelse=[])]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='find_library_file', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dirs'), arg(arg='lib'), arg(arg='debug')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value="Search the specified list of directories for a static or shared\n        library file 'lib' and return the full path to that file.  If\n        'debug' true, look for a debugging version (if that makes sense on\n        the current platform).  Return None if 'lib' wasn't found in any of\n        the specified directories.\n        ")), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[]), FunctionDef(name='object_filenames', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source_filenames'), arg(arg='strip_dir'), arg(arg='output_dir')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value='')]), body=[If(test=Compare(left=Name(id='output_dir', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='output_dir', ctx=Store())], value=Constant(value=''))], orelse=[]), Return(value=Call(func=Name(id='list', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_out_path', ctx=Load()), args=[Name(id='output_dir', ctx=Load()), Name(id='strip_dir', ctx=Load()), Name(id='src_name', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='src_name', ctx=Store()), iter=Name(id='source_filenames', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='out_extensions', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='dict', ctx=Load()), attr='fromkeys', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='src_extensions', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='obj_extension', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_make_out_path', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='output_dir'), arg(arg='strip_dir'), arg(arg='src_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='base', ctx=Store()), Name(id='ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='src_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='base', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_relative', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='new_ext', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='out_extensions', ctx=Load()), slice=Name(id='ext', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='LookupError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='UnknownFileError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="unknown file type '{}' (from '{}')"), attr='format', ctx=Load()), args=[Name(id='ext', ctx=Load()), Name(id='src_name', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[]), If(test=Name(id='strip_dir', ctx=Load()), body=[Assign(targets=[Name(id='base', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='output_dir', ctx=Load()), BinOp(left=Name(id='base', ctx=Load()), op=Add(), right=Name(id='new_ext', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='_make_relative', args=arguments(posonlyargs=[], args=[arg(arg='base')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        In order to ensure that a filename always honors the\n        indicated output_dir, make sure it's relative.\n        Ref python/cpython#37775.\n        ")), Assign(targets=[Name(id='no_drive', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitdrive', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[]), slice=Constant(value=1), ctx=Load())), Return(value=Subscript(value=Name(id='no_drive', ctx=Load()), slice=Slice(lower=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isabs', ctx=Load()), args=[Name(id='no_drive', ctx=Load())], keywords=[])), ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='shared_object_filename', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='basename'), arg(arg='strip_dir'), arg(arg='output_dir')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value='')]), body=[Assert(test=Compare(left=Name(id='output_dir', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), If(test=Name(id='strip_dir', ctx=Load()), body=[Assign(targets=[Name(id='basename', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='basename', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='output_dir', ctx=Load()), BinOp(left=Name(id='basename', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='shared_lib_extension', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='executable_filename', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='basename'), arg(arg='strip_dir'), arg(arg='output_dir')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value='')]), body=[Assert(test=Compare(left=Name(id='output_dir', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), If(test=Name(id='strip_dir', ctx=Load()), body=[Assign(targets=[Name(id='basename', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='basename', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='output_dir', ctx=Load()), BinOp(left=Name(id='basename', ctx=Load()), op=Add(), right=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='exe_extension', ctx=Load()), Constant(value='')]))], keywords=[]))], decorator_list=[]), FunctionDef(name='library_filename', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='libname'), arg(arg='lib_type'), arg(arg='strip_dir'), arg(arg='output_dir')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='static'), Constant(value=0), Constant(value='')]), body=[Assert(test=Compare(left=Name(id='output_dir', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='expected', ctx=Store())], value=Constant(value='"static", "shared", "dylib", "xcode_stub"')), If(test=Compare(left=Name(id='lib_type', ctx=Load()), ops=[NotIn()], comparators=[Call(func=Name(id='eval', ctx=Load()), args=[Name(id='expected', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value="'lib_type' must be "), FormattedValue(value=Name(id='expected', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='fmt', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), BinOp(left=Name(id='lib_type', ctx=Load()), op=Add(), right=Constant(value='_lib_format'))], keywords=[])), Assign(targets=[Name(id='ext', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), BinOp(left=Name(id='lib_type', ctx=Load()), op=Add(), right=Constant(value='_lib_extension'))], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='dir', ctx=Store()), Name(id='base', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='libname', ctx=Load())], keywords=[])), Assign(targets=[Name(id='filename', ctx=Store())], value=BinOp(left=Name(id='fmt', ctx=Load()), op=Mod(), right=Tuple(elts=[Name(id='base', ctx=Load()), Name(id='ext', ctx=Load())], ctx=Load()))), If(test=Name(id='strip_dir', ctx=Load()), body=[Assign(targets=[Name(id='dir', ctx=Store())], value=Constant(value=''))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='output_dir', ctx=Load()), Name(id='dir', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='announce', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='msg'), arg(arg='level')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='debug_print', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='msg')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='distutils.debug', names=[alias(name='DEBUG')], level=0), If(test=Name(id='DEBUG', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='warn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='msg')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Load()), attr='write', ctx=Load()), args=[BinOp(left=Constant(value='warning: %s\n'), op=Mod(), right=Name(id='msg', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='execute', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='func'), arg(arg='args'), arg(arg='msg'), arg(arg='level')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=1)]), body=[Expr(value=Call(func=Name(id='execute', ctx=Load()), args=[Name(id='func', ctx=Load()), Name(id='args', ctx=Load()), Name(id='msg', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='dry_run', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='spawn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cmd')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Name(id='spawn', ctx=Load()), args=[Name(id='cmd', ctx=Load())], keywords=[keyword(arg='dry_run', value=Attribute(value=Name(id='self', ctx=Load()), attr='dry_run', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='move_file', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='src'), arg(arg='dst')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='move_file', ctx=Load()), args=[Name(id='src', ctx=Load()), Name(id='dst', ctx=Load())], keywords=[keyword(arg='dry_run', value=Attribute(value=Name(id='self', ctx=Load()), attr='dry_run', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='mkpath', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='mode')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=511)]), body=[Expr(value=Call(func=Name(id='mkpath', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='mode', ctx=Load())], keywords=[keyword(arg='dry_run', value=Attribute(value=Name(id='self', ctx=Load()), attr='dry_run', ctx=Load()))]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='_default_compilers', ctx=Store())], value=Tuple(elts=[Tuple(elts=[Constant(value='cygwin.*'), Constant(value='unix')], ctx=Load()), Tuple(elts=[Constant(value='posix'), Constant(value='unix')], ctx=Load()), Tuple(elts=[Constant(value='nt'), Constant(value='msvc')], ctx=Load())], ctx=Load())), FunctionDef(name='get_default_compiler', args=arguments(posonlyargs=[], args=[arg(arg='osname'), arg(arg='platform')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Determine the default compiler to use for the given platform.\n\n    osname should be one of the standard Python OS names (i.e. the\n    ones returned by os.name) and platform the common value\n    returned by sys.platform for the platform in question.\n\n    The default values are os.name and sys.platform in case the\n    parameters are not given.\n    ')), If(test=Compare(left=Name(id='osname', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='osname', ctx=Store())], value=Attribute(value=Name(id='os', ctx=Load()), attr='name', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='platform', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='platform', ctx=Store())], value=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()))], orelse=[]), For(target=Tuple(elts=[Name(id='pattern', ctx=Store()), Name(id='compiler', ctx=Store())], ctx=Store()), iter=Name(id='_default_compilers', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='platform', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='osname', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Return(value=Name(id='compiler', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value='unix'))], decorator_list=[]), Assign(targets=[Name(id='compiler_class', ctx=Store())], value=Dict(keys=[Constant(value='unix'), Constant(value='msvc'), Constant(value='cygwin'), Constant(value='mingw32'), Constant(value='bcpp')], values=[Tuple(elts=[Constant(value='unixccompiler'), Constant(value='UnixCCompiler'), Constant(value='standard UNIX-style compiler')], ctx=Load()), Tuple(elts=[Constant(value='_msvccompiler'), Constant(value='MSVCCompiler'), Constant(value='Microsoft Visual C++')], ctx=Load()), Tuple(elts=[Constant(value='cygwinccompiler'), Constant(value='CygwinCCompiler'), Constant(value='Cygwin port of GNU C Compiler for Win32')], ctx=Load()), Tuple(elts=[Constant(value='cygwinccompiler'), Constant(value='Mingw32CCompiler'), Constant(value='Mingw32 port of GNU C Compiler for Win32')], ctx=Load()), Tuple(elts=[Constant(value='bcppcompiler'), Constant(value='BCPPCompiler'), Constant(value='Borland C++ Compiler')], ctx=Load())])), FunctionDef(name='show_compilers', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Print list of available compilers (used by the "--help-compiler"\n    options to "build", "build_ext", "build_clib").\n    ')), ImportFrom(module='distutils.fancy_getopt', names=[alias(name='FancyGetopt')], level=0), Assign(targets=[Name(id='compilers', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='compiler', ctx=Store()), iter=Call(func=Attribute(value=Name(id='compiler_class', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='compilers', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[BinOp(left=Constant(value='compiler='), op=Add(), right=Name(id='compiler', ctx=Load())), Constant(value=None), Subscript(value=Subscript(value=Name(id='compiler_class', ctx=Load()), slice=Name(id='compiler', ctx=Load()), ctx=Load()), slice=Constant(value=2), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='compilers', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='pretty_printer', ctx=Store())], value=Call(func=Name(id='FancyGetopt', ctx=Load()), args=[Name(id='compilers', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pretty_printer', ctx=Load()), attr='print_help', ctx=Load()), args=[Constant(value='List of available compilers:')], keywords=[]))], decorator_list=[]), FunctionDef(name='new_compiler', args=arguments(posonlyargs=[], args=[arg(arg='plat'), arg(arg='compiler'), arg(arg='verbose'), arg(arg='dry_run'), arg(arg='force')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=0), Constant(value=0), Constant(value=0)]), body=[Expr(value=Constant(value='Generate an instance of some CCompiler subclass for the supplied\n    platform/compiler combination.  \'plat\' defaults to \'os.name\'\n    (eg. \'posix\', \'nt\'), and \'compiler\' defaults to the default compiler\n    for that platform.  Currently only \'posix\' and \'nt\' are supported, and\n    the default compilers are "traditional Unix interface" (UnixCCompiler\n    class) and Visual C++ (MSVCCompiler class).  Note that it\'s perfectly\n    possible to ask for a Unix compiler object under Windows, and a\n    Microsoft compiler object under Unix -- if you supply a value for\n    \'compiler\', \'plat\' is ignored.\n    ')), If(test=Compare(left=Name(id='plat', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='plat', ctx=Store())], value=Attribute(value=Name(id='os', ctx=Load()), attr='name', ctx=Load()))], orelse=[]), Try(body=[If(test=Compare(left=Name(id='compiler', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='compiler', ctx=Store())], value=Call(func=Name(id='get_default_compiler', ctx=Load()), args=[Name(id='plat', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='module_name', ctx=Store()), Name(id='class_name', ctx=Store()), Name(id='long_description', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='compiler_class', ctx=Load()), slice=Name(id='compiler', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=BinOp(left=Constant(value="don't know how to compile C/C++ code on platform '%s'"), op=Mod(), right=Name(id='plat', ctx=Load()))), If(test=Compare(left=Name(id='compiler', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=BinOp(left=Name(id='msg', ctx=Load()), op=Add(), right=BinOp(left=Constant(value=" with '%s' compiler"), op=Mod(), right=Name(id='compiler', ctx=Load()))))], orelse=[]), Raise(exc=Call(func=Name(id='DistutilsPlatformError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[]), Try(body=[Assign(targets=[Name(id='module_name', ctx=Store())], value=BinOp(left=Constant(value='distutils.'), op=Add(), right=Name(id='module_name', ctx=Load()))), Expr(value=Call(func=Name(id='__import__', ctx=Load()), args=[Name(id='module_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='module_name', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='klass', ctx=Store())], value=Subscript(value=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[]), slice=Name(id='class_name', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='DistutilsModuleError', ctx=Load()), args=[BinOp(left=Constant(value="can't compile C/C++ code: unable to load module '%s'"), op=Mod(), right=Name(id='module_name', ctx=Load()))], keywords=[]))]), ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='DistutilsModuleError', ctx=Load()), args=[BinOp(left=Constant(value="can't compile C/C++ code: unable to find class '%s' in module '%s'"), op=Mod(), right=Tuple(elts=[Name(id='class_name', ctx=Load()), Name(id='module_name', ctx=Load())], ctx=Load()))], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Call(func=Name(id='klass', ctx=Load()), args=[Constant(value=None), Name(id='dry_run', ctx=Load()), Name(id='force', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='gen_preprocess_options', args=arguments(posonlyargs=[], args=[arg(arg='macros'), arg(arg='include_dirs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Generate C pre-processor options (-D, -U, -I) as used by at least\n    two types of compilers: the typical Unix compiler and Visual C++.\n    'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)\n    means undefine (-U) macro 'name', and (name,value) means define (-D)\n    macro 'name' to 'value'.  'include_dirs' is just a list of directory\n    names to be added to the header file search path (-I).  Returns a list\n    of command-line options suitable for either Unix compilers or Visual\n    C++.\n    ")), Assign(targets=[Name(id='pp_opts', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='macro', ctx=Store()), iter=Name(id='macros', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='macro', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), Compare(left=Constant(value=1), ops=[LtE(), LtE()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='macro', ctx=Load())], keywords=[]), Constant(value=2)])])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Constant(value="bad macro definition '%s': each element of 'macros' list must be a 1- or 2-tuple"), op=Mod(), right=Name(id='macro', ctx=Load()))], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='macro', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pp_opts', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='-U%s'), op=Mod(), right=Subscript(value=Name(id='macro', ctx=Load()), slice=Constant(value=0), ctx=Load()))], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='macro', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), body=[If(test=Compare(left=Subscript(value=Name(id='macro', ctx=Load()), slice=Constant(value=1), ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pp_opts', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='-D%s'), op=Mod(), right=Subscript(value=Name(id='macro', ctx=Load()), slice=Constant(value=0), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='pp_opts', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='-D%s=%s'), op=Mod(), right=Name(id='macro', ctx=Load()))], keywords=[]))])], orelse=[])])], orelse=[]), For(target=Name(id='dir', ctx=Store()), iter=Name(id='include_dirs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='pp_opts', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='-I%s'), op=Mod(), right=Name(id='dir', ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Name(id='pp_opts', ctx=Load()))], decorator_list=[]), FunctionDef(name='gen_lib_options', args=arguments(posonlyargs=[], args=[arg(arg='compiler'), arg(arg='library_dirs'), arg(arg='runtime_library_dirs'), arg(arg='libraries')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Generate linker options for searching library directories and\n    linking with specific libraries.  'libraries' and 'library_dirs' are,\n    respectively, lists of library names (not filenames!) and search\n    directories.  Returns a list of command-line options suitable for use\n    with some compiler (depending on the two format strings passed in).\n    ")), Assign(targets=[Name(id='lib_opts', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='dir', ctx=Store()), iter=Name(id='library_dirs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lib_opts', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='compiler', ctx=Load()), attr='library_dir_option', ctx=Load()), args=[Name(id='dir', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), For(target=Name(id='dir', ctx=Store()), iter=Name(id='runtime_library_dirs', ctx=Load()), body=[Assign(targets=[Name(id='opt', ctx=Store())], value=Call(func=Attribute(value=Name(id='compiler', ctx=Load()), attr='runtime_library_dir_option', ctx=Load()), args=[Name(id='dir', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='opt', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='lib_opts', ctx=Store())], value=BinOp(left=Name(id='lib_opts', ctx=Load()), op=Add(), right=Name(id='opt', ctx=Load())))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='lib_opts', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='opt', ctx=Load())], keywords=[]))])], orelse=[]), For(target=Name(id='lib', ctx=Store()), iter=Name(id='libraries', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='lib_dir', ctx=Store()), Name(id='lib_name', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='lib', ctx=Load())], keywords=[])), If(test=Name(id='lib_dir', ctx=Load()), body=[Assign(targets=[Name(id='lib_file', ctx=Store())], value=Call(func=Attribute(value=Name(id='compiler', ctx=Load()), attr='find_library_file', ctx=Load()), args=[List(elts=[Name(id='lib_dir', ctx=Load())], ctx=Load()), Name(id='lib_name', ctx=Load())], keywords=[])), If(test=Name(id='lib_file', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lib_opts', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='lib_file', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='compiler', ctx=Load()), attr='warn', ctx=Load()), args=[BinOp(left=Constant(value="no library file corresponding to '%s' found (skipping)"), op=Mod(), right=Name(id='lib', ctx=Load()))], keywords=[]))])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='lib_opts', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='compiler', ctx=Load()), attr='library_option', ctx=Load()), args=[Name(id='lib', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[]), Return(value=Name(id='lib_opts', ctx=Load()))], decorator_list=[])], type_ignores=[])