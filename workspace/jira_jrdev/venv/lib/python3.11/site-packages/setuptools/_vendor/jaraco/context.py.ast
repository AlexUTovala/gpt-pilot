Module(body=[Import(names=[alias(name='os')]), Import(names=[alias(name='subprocess')]), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='tempfile')]), Import(names=[alias(name='shutil')]), Import(names=[alias(name='operator')]), Import(names=[alias(name='warnings')]), FunctionDef(name='pushd', args=arguments(posonlyargs=[], args=[arg(arg='dir')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    >>> tmp_path = getfixture('tmp_path')\n    >>> with pushd(tmp_path):\n    ...     assert os.getcwd() == os.fspath(tmp_path)\n    >>> assert os.getcwd() != os.fspath(tmp_path)\n    ")), Assign(targets=[Name(id='orig', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='chdir', ctx=Load()), args=[Name(id='dir', ctx=Load())], keywords=[])), Try(body=[Expr(value=Yield(value=Name(id='dir', ctx=Load())))], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='chdir', ctx=Load()), args=[Name(id='orig', ctx=Load())], keywords=[]))])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='tarball_context', args=arguments(posonlyargs=[], args=[arg(arg='url'), arg(arg='target_dir'), arg(arg='runner'), arg(arg='pushd')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Name(id='pushd', ctx=Load())]), body=[Expr(value=Constant(value='\n    Get a tarball, extract it, change to that directory, yield, then\n    clean up.\n    `runner` is the function to invoke commands.\n    `pushd` is a context manager for changing the directory.\n    ')), If(test=Compare(left=Name(id='target_dir', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='target_dir', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='.tar.gz'), Constant(value='')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='.tgz'), Constant(value='')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='runner', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='runner', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Attribute(value=Name(id='subprocess', ctx=Load()), attr='check_call', ctx=Load())], keywords=[keyword(arg='shell', value=Constant(value=True))]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='runner parameter is deprecated'), Name(id='DeprecationWarning', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Name(id='runner', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='mkdir {target_dir}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='vars', ctx=Load()), args=[], keywords=[]))])], keywords=[])), Try(body=[Assign(targets=[Name(id='getter', ctx=Store())], value=Constant(value='wget {url} -O -')), Assign(targets=[Name(id='extract', ctx=Store())], value=Constant(value='tar x{compression} --strip-components=1 -C {target_dir}')), Assign(targets=[Name(id='cmd', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' | '), attr='join', ctx=Load()), args=[Tuple(elts=[Name(id='getter', ctx=Load()), Name(id='extract', ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='runner', ctx=Load()), args=[Call(func=Attribute(value=Name(id='cmd', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='compression', value=Call(func=Name(id='infer_compression', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), keyword(value=Call(func=Name(id='vars', ctx=Load()), args=[], keywords=[]))])], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='pushd', ctx=Load()), args=[Name(id='target_dir', ctx=Load())], keywords=[]))], body=[Expr(value=Yield(value=Name(id='target_dir', ctx=Load())))])], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Name(id='runner', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='rm -Rf {target_dir}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='vars', ctx=Load()), args=[], keywords=[]))])], keywords=[]))])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='infer_compression', args=arguments(posonlyargs=[], args=[arg(arg='url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Given a URL or filename, infer the compression code for tar.\n\n    >>> infer_compression('http://foo/bar.tar.gz')\n    'z'\n    >>> infer_compression('http://foo/bar.tgz')\n    'z'\n    >>> infer_compression('file.bz')\n    'j'\n    >>> infer_compression('file.xz')\n    'J'\n    ")), Assign(targets=[Name(id='compression_indicator', ctx=Store())], value=Subscript(value=Name(id='url', ctx=Load()), slice=Slice(lower=UnaryOp(op=USub(), operand=Constant(value=2))), ctx=Load())), Assign(targets=[Name(id='mapping', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[], keywords=[keyword(arg='gz', value=Constant(value='z')), keyword(arg='bz', value=Constant(value='j')), keyword(arg='xz', value=Constant(value='J'))])), Return(value=Call(func=Attribute(value=Name(id='mapping', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='compression_indicator', ctx=Load()), Constant(value='z')], keywords=[]))], decorator_list=[]), FunctionDef(name='temp_dir', args=arguments(posonlyargs=[], args=[arg(arg='remover')], kwonlyargs=[], kw_defaults=[], defaults=[Attribute(value=Name(id='shutil', ctx=Load()), attr='rmtree', ctx=Load())]), body=[Expr(value=Constant(value="\n    Create a temporary directory context. Pass a custom remover\n    to override the removal behavior.\n\n    >>> import pathlib\n    >>> with temp_dir() as the_dir:\n    ...     assert os.path.isdir(the_dir)\n    ...     _ = pathlib.Path(the_dir).joinpath('somefile').write_text('contents')\n    >>> assert not os.path.exists(the_dir)\n    ")), Assign(targets=[Name(id='temp_dir', ctx=Store())], value=Call(func=Attribute(value=Name(id='tempfile', ctx=Load()), attr='mkdtemp', ctx=Load()), args=[], keywords=[])), Try(body=[Expr(value=Yield(value=Name(id='temp_dir', ctx=Load())))], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Name(id='remover', ctx=Load()), args=[Name(id='temp_dir', ctx=Load())], keywords=[]))])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='repo_context', args=arguments(posonlyargs=[], args=[arg(arg='url'), arg(arg='branch'), arg(arg='quiet'), arg(arg='dest_ctx')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=True), Name(id='temp_dir', ctx=Load())]), body=[Expr(value=Constant(value='\n    Check out the repo indicated by url.\n\n    If dest_ctx is supplied, it should be a context manager\n    to yield the target directory for the check out.\n    ')), Assign(targets=[Name(id='exe', ctx=Store())], value=IfExp(test=Compare(left=Constant(value='git'), ops=[In()], comparators=[Name(id='url', ctx=Load())]), body=Constant(value='git'), orelse=Constant(value='hg'))), With(items=[withitem(context_expr=Call(func=Name(id='dest_ctx', ctx=Load()), args=[], keywords=[]), optional_vars=Name(id='repo_dir', ctx=Store()))], body=[Assign(targets=[Name(id='cmd', ctx=Store())], value=List(elts=[Name(id='exe', ctx=Load()), Constant(value='clone'), Name(id='url', ctx=Load()), Name(id='repo_dir', ctx=Load())], ctx=Load())), If(test=Name(id='branch', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='cmd', ctx=Load()), attr='extend', ctx=Load()), args=[List(elts=[Constant(value='--branch'), Name(id='branch', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='devnull', ctx=Store())], value=Call(func=Name(id='open', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='devnull', ctx=Load()), Constant(value='w')], keywords=[])), Assign(targets=[Name(id='stdout', ctx=Store())], value=IfExp(test=Name(id='quiet', ctx=Load()), body=Name(id='devnull', ctx=Load()), orelse=Constant(value=None))), Expr(value=Call(func=Attribute(value=Name(id='subprocess', ctx=Load()), attr='check_call', ctx=Load()), args=[Name(id='cmd', ctx=Load())], keywords=[keyword(arg='stdout', value=Name(id='stdout', ctx=Load()))])), Expr(value=Yield(value=Name(id='repo_dir', ctx=Load())))])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='null', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A null context suitable to stand in for a meaningful context.\n\n    >>> with null() as value:\n    ...     assert value is None\n    ')), Expr(value=Yield())], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), ClassDef(name='ExceptionTrap', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    A context manager that will catch certain exceptions and provide an\n    indication they occurred.\n\n    >>> with ExceptionTrap() as trap:\n    ...     raise Exception()\n    >>> bool(trap)\n    True\n\n    >>> with ExceptionTrap() as trap:\n    ...     pass\n    >>> bool(trap)\n    False\n\n    >>> with ExceptionTrap(ValueError) as trap:\n    ...     raise ValueError("1 + 1 is not 3")\n    >>> bool(trap)\n    True\n    >>> trap.value\n    ValueError(\'1 + 1 is not 3\')\n    >>> trap.tb\n    <traceback object at ...>\n\n    >>> with ExceptionTrap(ValueError) as trap:\n    ...     raise Exception()\n    Traceback (most recent call last):\n    ...\n    Exception\n\n    >>> bool(trap)\n    False\n    ')), Assign(targets=[Name(id='exc_info', ctx=Store())], value=Tuple(elts=[Constant(value=None), Constant(value=None), Constant(value=None)], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exceptions')], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[Name(id='Exception', ctx=Load())], ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exceptions', ctx=Store())], value=Name(id='exceptions', ctx=Load()))], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='type', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exc_info', ctx=Load()), slice=Constant(value=0), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='value', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exc_info', ctx=Load()), slice=Constant(value=1), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='tb', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exc_info', ctx=Load()), slice=Constant(value=2), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='exc_info'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='type', ctx=Store())], value=Subscript(value=Name(id='exc_info', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='matches', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='type', ctx=Load()), Call(func=Name(id='issubclass', ctx=Load()), args=[Name(id='type', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='exceptions', ctx=Load())], keywords=[])])), If(test=Name(id='matches', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exc_info', ctx=Store())], value=Name(id='exc_info', ctx=Load()))], orelse=[]), Return(value=Name(id='matches', ctx=Load()))], decorator_list=[]), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='bool', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='raises', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='func')], kwonlyargs=[arg(arg='_test')], kw_defaults=[Name(id='bool', ctx=Load())], defaults=[]), body=[Expr(value=Constant(value="\n        Wrap func and replace the result with the truth\n        value of the trap (True if an exception occurred).\n\n        First, give the decorator an alias to support Python 3.8\n        Syntax.\n\n        >>> raises = ExceptionTrap(ValueError).raises\n\n        Now decorate a function that always fails.\n\n        >>> @raises\n        ... def fail():\n        ...     raise ValueError('failed')\n        >>> fail()\n        True\n        ")), FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='ExceptionTrap', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='exceptions', ctx=Load())], keywords=[]), optional_vars=Name(id='trap', ctx=Store()))], body=[Expr(value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))]), Return(value=Call(func=Name(id='_test', ctx=Load()), args=[Name(id='trap', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])]), Return(value=Name(id='wrapper', ctx=Load()))], decorator_list=[]), FunctionDef(name='passes', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Wrap func and replace the result with the truth\n        value of the trap (True if no exception).\n\n        First, give the decorator an alias to support Python 3.8\n        Syntax.\n\n        >>> passes = ExceptionTrap(ValueError).passes\n\n        Now decorate a function that always fails.\n\n        >>> @passes\n        ... def fail():\n        ...     raise ValueError('failed')\n\n        >>> fail()\n        False\n        ")), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='raises', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[keyword(arg='_test', value=Attribute(value=Name(id='operator', ctx=Load()), attr='not_', ctx=Load()))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='suppress', bases=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='suppress', ctx=Load()), Attribute(value=Name(id='contextlib', ctx=Load()), attr='ContextDecorator', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    A version of contextlib.suppress with decorator support.\n\n    >>> @suppress(KeyError)\n    ... def key_error():\n    ...     {}['']\n    >>> key_error()\n    "))], decorator_list=[]), ClassDef(name='on_interrupt', bases=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='ContextDecorator', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Replace a KeyboardInterrupt with SystemExit(1)\n\n    >>> def do_interrupt():\n    ...     raise KeyboardInterrupt()\n    >>> on_interrupt('error')(do_interrupt)()\n    Traceback (most recent call last):\n    ...\n    SystemExit: 1\n    >>> on_interrupt('error', code=255)(do_interrupt)()\n    Traceback (most recent call last):\n    ...\n    SystemExit: 255\n    >>> on_interrupt('suppress')(do_interrupt)()\n    >>> with __import__('pytest').raises(KeyboardInterrupt):\n    ...     on_interrupt('ignore')(do_interrupt)()\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='action'), arg(arg='code')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='error'), Constant(value=1)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='action', ctx=Store())], value=Name(id='action', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='code', ctx=Store())], value=Name(id='code', ctx=Load()))], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exctype'), arg(arg='excinst'), arg(arg='exctb')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='exctype', ctx=Load()), ops=[IsNot()], comparators=[Name(id='KeyboardInterrupt', ctx=Load())]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='ignore')])]), body=[Return()], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='error')]), body=[Raise(exc=Call(func=Name(id='SystemExit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='code', ctx=Load())], keywords=[]), cause=Name(id='excinst', ctx=Load()))], orelse=[])]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='suppress')]))], decorator_list=[])], decorator_list=[])], type_ignores=[])