Module(body=[Import(names=[alias(name='re')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='textwrap')]), Import(names=[alias(name='functools')]), Try(body=[ImportFrom(module='importlib.resources', names=[alias(name='files')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[ImportFrom(module='pkg_resources.extern.importlib_resources', names=[alias(name='files')], level=0)])], orelse=[], finalbody=[]), ImportFrom(module='pkg_resources.extern.jaraco.functools', names=[alias(name='compose'), alias(name='method_cache')], level=0), ImportFrom(module='pkg_resources.extern.jaraco.context', names=[alias(name='ExceptionTrap')], level=0), FunctionDef(name='substitution', args=arguments(posonlyargs=[], args=[arg(arg='old'), arg(arg='new')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return a function that will perform a substitution on a string\n    ')), Return(value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='replace', ctx=Load()), args=[Name(id='old', ctx=Load()), Name(id='new', ctx=Load())], keywords=[])))], decorator_list=[]), FunctionDef(name='multi_substitution', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='substitutions'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Take a sequence of pairs specifying substitutions, and create\n    a function that performs those substitutions.\n\n    >>> multi_substitution(('foo', 'bar'), ('bar', 'baz'))('foo')\n    'baz'\n    ")), Assign(targets=[Name(id='substitutions', ctx=Store())], value=Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='starmap', ctx=Load()), args=[Name(id='substitution', ctx=Load()), Name(id='substitutions', ctx=Load())], keywords=[])), Assign(targets=[Name(id='substitutions', ctx=Store())], value=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='substitutions', ctx=Load())], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='compose', ctx=Load()), args=[Starred(value=Name(id='substitutions', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='FoldedCase', bases=[Name(id='str', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A case insensitive string class; behaves just like str\n    except compares equal when the only variation is case.\n\n    >>> s = FoldedCase(\'hello world\')\n\n    >>> s == \'Hello World\'\n    True\n\n    >>> \'Hello World\' == s\n    True\n\n    >>> s != \'Hello World\'\n    False\n\n    >>> s.index(\'O\')\n    4\n\n    >>> s.split(\'O\')\n    [\'hell\', \' w\', \'rld\']\n\n    >>> sorted(map(FoldedCase, [\'GAMMA\', \'alpha\', \'Beta\']))\n    [\'alpha\', \'Beta\', \'GAMMA\']\n\n    Sequence membership is straightforward.\n\n    >>> "Hello World" in [s]\n    True\n    >>> s in ["Hello World"]\n    True\n\n    You may test for set inclusion, but candidate and elements\n    must both be folded.\n\n    >>> FoldedCase("Hello World") in {s}\n    True\n    >>> s in {FoldedCase("Hello World")}\n    True\n\n    String inclusion works as long as the FoldedCase object\n    is on the right.\n\n    >>> "hello" in FoldedCase("Hello World")\n    True\n\n    But not if the FoldedCase object is on the left:\n\n    >>> FoldedCase(\'hello\') in \'Hello World\'\n    False\n\n    In that case, use ``in_``:\n\n    >>> FoldedCase(\'hello\').in_(\'Hello World\')\n    True\n\n    >>> FoldedCase(\'hello\') > FoldedCase(\'Hello\')\n    False\n    ')), FunctionDef(name='__lt__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Lt()], comparators=[Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])]))], decorator_list=[]), FunctionDef(name='__gt__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])]))], decorator_list=[]), FunctionDef(name='__ne__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[]), attr='__contains__', ctx=Load()), args=[Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='in_', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Does self appear in other?')), Return(value=Compare(left=Name(id='self', ctx=Load()), ops=[In()], comparators=[Call(func=Name(id='FoldedCase', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])]))], decorator_list=[]), FunctionDef(name='lower', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='method_cache', ctx=Load())]), FunctionDef(name='index', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='sub')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='index', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sub', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='split', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='splitter'), arg(arg='maxsplit')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=' '), Constant(value=0)]), body=[Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='splitter', ctx=Load())], keywords=[]), Attribute(value=Name(id='re', ctx=Load()), attr='I', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pattern', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='maxsplit', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='_unicode_trap', ctx=Store())], value=Call(func=Name(id='ExceptionTrap', ctx=Load()), args=[Name(id='UnicodeDecodeError', ctx=Load())], keywords=[])), FunctionDef(name='is_decodable', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Return True if the supplied value is decodable (using the default\n    encoding).\n\n    >>> is_decodable(b'\\xff')\n    False\n    >>> is_decodable(b'\\x32')\n    True\n    ")), Expr(value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='decode', ctx=Load()), args=[], keywords=[]))], decorator_list=[Attribute(value=Name(id='_unicode_trap', ctx=Load()), attr='passes', ctx=Load())]), FunctionDef(name='is_binary', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Return True if the value appears to be binary (that is, it's a byte\n    string and isn't decodable).\n\n    >>> is_binary(b'\\xff')\n    True\n    >>> is_binary('\\xff')\n    False\n    ")), Return(value=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='bytes', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='is_decodable', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))]))], decorator_list=[]), FunctionDef(name='trim', args=arguments(posonlyargs=[], args=[arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Trim something like a docstring to remove the whitespace that\n    is common due to indentation and formatting.\n\n    >>> trim("\\n\\tfoo = bar\\n\\t\\tbar = baz\\n")\n    \'foo = bar\\n\\tbar = baz\'\n    ')), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='textwrap', ctx=Load()), attr='dedent', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='wrap', args=arguments(posonlyargs=[], args=[arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Wrap lines of text, retaining existing newlines as\n    paragraph markers.\n\n    >>> print(wrap(lorem_ipsum))\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n    eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad\n    minim veniam, quis nostrud exercitation ullamco laboris nisi ut\n    aliquip ex ea commodo consequat. Duis aute irure dolor in\n    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\n    pariatur. Excepteur sint occaecat cupidatat non proident, sunt in\n    culpa qui officia deserunt mollit anim id est laborum.\n    <BLANKLINE>\n    Curabitur pretium tincidunt lacus. Nulla gravida orci a odio. Nullam\n    varius, turpis et commodo pharetra, est eros bibendum elit, nec luctus\n    magna felis sollicitudin mauris. Integer in mauris eu nibh euismod\n    gravida. Duis ac tellus et risus vulputate vehicula. Donec lobortis\n    risus a elit. Etiam tempor. Ut ullamcorper, ligula eu tempor congue,\n    eros est euismod turpis, id tincidunt sapien risus a quam. Maecenas\n    fermentum consequat mi. Donec fermentum. Pellentesque malesuada nulla\n    a mi. Duis sapien sem, aliquet nec, commodo eget, consequat quis,\n    neque. Aliquam faucibus, elit ut dictum aliquet, felis nisl adipiscing\n    sapien, sed malesuada diam lacus eget erat. Cras mollis scelerisque\n    nunc. Nullam arcu. Aliquam consequat. Curabitur augue lorem, dapibus\n    quis, laoreet et, pretium ac, nisi. Aenean magna nisl, mollis quis,\n    molestie eu, feugiat in, orci. In hac habitasse platea dictumst.\n    ')), Assign(targets=[Name(id='paragraphs', ctx=Store())], value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='wrapped', ctx=Store())], value=GeneratorExp(elt=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='textwrap', ctx=Load()), attr='wrap', ctx=Load()), args=[Name(id='para', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='para', ctx=Store()), iter=Name(id='paragraphs', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Attribute(value=Constant(value='\n\n'), attr='join', ctx=Load()), args=[Name(id='wrapped', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='unwrap', args=arguments(posonlyargs=[], args=[arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Given a multi-line string, return an unwrapped version.\n\n    >>> wrapped = wrap(lorem_ipsum)\n    >>> wrapped.count('\\n')\n    20\n    >>> unwrapped = unwrap(wrapped)\n    >>> unwrapped.count('\\n')\n    1\n    >>> print(unwrapped)\n    Lorem ipsum dolor sit amet, consectetur adipiscing ...\n    Curabitur pretium tincidunt lacus. Nulla gravida orci ...\n\n    ")), Assign(targets=[Name(id='paragraphs', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\\n\\n+'), Name(id='s', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cleaned', ctx=Store())], value=GeneratorExp(elt=Call(func=Attribute(value=Name(id='para', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='\n'), Constant(value=' ')], keywords=[]), generators=[comprehension(target=Name(id='para', ctx=Store()), iter=Name(id='paragraphs', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='cleaned', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='Splitter', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="object that will split a string with the given arguments for each call\n\n    >>> s = Splitter(',')\n    >>> s('hello, world, this is your, master calling')\n    ['hello', ' world', ' this is your', ' master calling']\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Store())], value=Name(id='args', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='split', ctx=Load()), args=[Starred(value=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='indent', args=arguments(posonlyargs=[], args=[arg(arg='string'), arg(arg='prefix')], kwonlyargs=[], kw_defaults=[], defaults=[BinOp(left=Constant(value=' '), op=Mult(), right=Constant(value=4))]), body=[Expr(value=Constant(value="\n    >>> indent('foo')\n    '    foo'\n    ")), Return(value=BinOp(left=Name(id='prefix', ctx=Load()), op=Add(), right=Name(id='string', ctx=Load())))], decorator_list=[]), ClassDef(name='WordSet', bases=[Name(id='tuple', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Given an identifier, return the words that identifier represents,\n    whether in camel case, underscore-separated, etc.\n\n    >>> WordSet.parse("camelCase")\n    (\'camel\', \'Case\')\n\n    >>> WordSet.parse("under_sep")\n    (\'under\', \'sep\')\n\n    Acronyms should be retained\n\n    >>> WordSet.parse("firstSNL")\n    (\'first\', \'SNL\')\n\n    >>> WordSet.parse("you_and_I")\n    (\'you\', \'and\', \'I\')\n\n    >>> WordSet.parse("A simple test")\n    (\'A\', \'simple\', \'test\')\n\n    Multiple caps should not interfere with the first cap of another word.\n\n    >>> WordSet.parse("myABCClass")\n    (\'my\', \'ABC\', \'Class\')\n\n    The result is a WordSet, so you can get the form you need.\n\n    >>> WordSet.parse("myABCClass").underscore_separated()\n    \'my_ABC_Class\'\n\n    >>> WordSet.parse(\'a-command\').camel_case()\n    \'ACommand\'\n\n    >>> WordSet.parse(\'someIdentifier\').lowered().space_separated()\n    \'some identifier\'\n\n    Slices of the result should return another WordSet.\n\n    >>> WordSet.parse(\'taken-out-of-context\')[1:].underscore_separated()\n    \'out_of_context\'\n\n    >>> WordSet.from_class_name(WordSet()).lowered().space_separated()\n    \'word set\'\n\n    >>> example = WordSet.parse(\'figured it out\')\n    >>> example.headless_camel_case()\n    \'figuredItOut\'\n    >>> example.dash_separated()\n    \'figured-it-out\'\n\n    ')), Assign(targets=[Name(id='_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='([A-Z]?[a-z]+)|([A-Z]+(?![a-z]))')], keywords=[])), FunctionDef(name='capitalized', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='WordSet', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='word', ctx=Load()), attr='capitalize', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='word', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='lowered', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='WordSet', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='word', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='word', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='camel_case', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='capitalized', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='headless_camel_case', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='words', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Name(id='first', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='words', ctx=Load())], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='new_words', ctx=Store())], value=Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), args=[Tuple(elts=[Name(id='first', ctx=Load())], ctx=Load()), Call(func=Attribute(value=Call(func=Name(id='WordSet', ctx=Load()), args=[Name(id='words', ctx=Load())], keywords=[]), attr='camel_case', ctx=Load()), args=[], keywords=[])], keywords=[])), Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='new_words', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='underscore_separated', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='_'), attr='join', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='dash_separated', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='-'), attr='join', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='space_separated', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='trim_right', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Remove the item from the end of the set.\n\n        >>> WordSet.parse('foo bar').trim_right('foo')\n        ('foo', 'bar')\n        >>> WordSet.parse('foo bar').trim_right('bar')\n        ('foo',)\n        >>> WordSet.parse('').trim_right('bar')\n        ()\n        ")), Return(value=IfExp(test=BoolOp(op=And(), values=[Name(id='self', ctx=Load()), Compare(left=Subscript(value=Name(id='self', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), ops=[Eq()], comparators=[Name(id='item', ctx=Load())])]), body=Subscript(value=Name(id='self', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), orelse=Name(id='self', ctx=Load())))], decorator_list=[]), FunctionDef(name='trim_left', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Remove the item from the beginning of the set.\n\n        >>> WordSet.parse('foo bar').trim_left('foo')\n        ('bar',)\n        >>> WordSet.parse('foo bar').trim_left('bar')\n        ('foo', 'bar')\n        >>> WordSet.parse('').trim_left('bar')\n        ()\n        ")), Return(value=IfExp(test=BoolOp(op=And(), values=[Name(id='self', ctx=Load()), Compare(left=Subscript(value=Name(id='self', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Name(id='item', ctx=Load())])]), body=Subscript(value=Name(id='self', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), orelse=Name(id='self', ctx=Load())))], decorator_list=[]), FunctionDef(name='trim', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        >>> WordSet.parse('foo bar').trim('foo')\n        ('bar',)\n        ")), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='trim_left', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), attr='trim_right', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='WordSet', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__getitem__', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='item', ctx=Load()), Name(id='slice', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='WordSet', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='parse', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='identifier')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='matches', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='_pattern', ctx=Load()), attr='finditer', ctx=Load()), args=[Name(id='identifier', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='WordSet', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=0)], keywords=[]), generators=[comprehension(target=Name(id='match', ctx=Store()), iter=Name(id='matches', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='from_class_name', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='subject')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='parse', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='subject', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())])], decorator_list=[]), Assign(targets=[Name(id='words', ctx=Store())], value=Attribute(value=Name(id='WordSet', ctx=Load()), attr='parse', ctx=Load())), FunctionDef(name='simple_html_strip', args=arguments(posonlyargs=[], args=[arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Remove HTML from the string `s`.\n\n    >>> str(simple_html_strip(''))\n    ''\n\n    >>> print(simple_html_strip('A <bold>stormy</bold> day in paradise'))\n    A stormy day in paradise\n\n    >>> print(simple_html_strip('Somebody <!-- do not --> tell the truth.'))\n    Somebody  tell the truth.\n\n    >>> print(simple_html_strip('What about<br/>\\nmultiple lines?'))\n    What about\n    multiple lines?\n    ")), Assign(targets=[Name(id='html_stripper', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='(<!--.*?-->)|(<[^>]*>)|([^<]+)'), Attribute(value=Name(id='re', ctx=Load()), attr='DOTALL', ctx=Load())], keywords=[])), Assign(targets=[Name(id='texts', ctx=Store())], value=GeneratorExp(elt=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=3)], keywords=[]), Constant(value='')]), generators=[comprehension(target=Name(id='match', ctx=Store()), iter=Call(func=Attribute(value=Name(id='html_stripper', ctx=Load()), attr='finditer', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), ifs=[], is_async=0)])), Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='texts', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='SeparatedValues', bases=[Name(id='str', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    A string separated by a separator. Overrides __iter__ for getting\n    the values.\n\n    >>> list(SeparatedValues('a,b,c'))\n    ['a', 'b', 'c']\n\n    Whitespace is stripped and empty values are discarded.\n\n    >>> list(SeparatedValues(' a,   b   , c,  '))\n    ['a', 'b', 'c']\n    ")), Assign(targets=[Name(id='separator', ctx=Store())], value=Constant(value=',')), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='split', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='separator', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='filter', ctx=Load()), args=[Constant(value=None), GeneratorExp(elt=Call(func=Attribute(value=Name(id='part', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='part', ctx=Store()), iter=Name(id='parts', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Stripper', bases=[], keywords=[], body=[Expr(value=Constant(value="\n    Given a series of lines, find the common prefix and strip it from them.\n\n    >>> lines = [\n    ...     'abcdefg\\n',\n    ...     'abc\\n',\n    ...     'abcde\\n',\n    ... ]\n    >>> res = Stripper.strip_prefix(lines)\n    >>> res.prefix\n    'abc'\n    >>> list(res.lines)\n    ['defg\\n', '\\n', 'de\\n']\n\n    If no prefix is common, nothing should be stripped.\n\n    >>> lines = [\n    ...     'abcd\\n',\n    ...     '1234\\n',\n    ... ]\n    >>> res = Stripper.strip_prefix(lines)\n    >>> res.prefix = ''\n    >>> list(res.lines)\n    ['abcd\\n', '1234\\n']\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prefix'), arg(arg='lines')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='prefix', ctx=Store())], value=Name(id='prefix', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='lines', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='strip_prefix', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='lines')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='prefix_lines', ctx=Store()), Name(id='lines', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='tee', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prefix', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='reduce', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='common_prefix', ctx=Load()), Name(id='prefix_lines', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='prefix', ctx=Load()), Name(id='lines', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='line')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='prefix', ctx=Load())), body=[Return(value=Name(id='line', ctx=Load()))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='null', ctx=Store()), Name(id='prefix', ctx=Store()), Name(id='rest', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='partition', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='prefix', ctx=Load())], keywords=[])), Return(value=Name(id='rest', ctx=Load()))], decorator_list=[]), FunctionDef(name='common_prefix', args=arguments(posonlyargs=[], args=[arg(arg='s1'), arg(arg='s2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the common prefix of two lines.\n        ')), Assign(targets=[Name(id='index', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='s1', ctx=Load())], keywords=[]), Call(func=Name(id='len', ctx=Load()), args=[Name(id='s2', ctx=Load())], keywords=[])], keywords=[])), While(test=Compare(left=Subscript(value=Name(id='s1', ctx=Load()), slice=Slice(upper=Name(id='index', ctx=Load())), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Name(id='s2', ctx=Load()), slice=Slice(upper=Name(id='index', ctx=Load())), ctx=Load())]), body=[AugAssign(target=Name(id='index', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[]), Return(value=Subscript(value=Name(id='s1', ctx=Load()), slice=Slice(upper=Name(id='index', ctx=Load())), ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())])], decorator_list=[]), FunctionDef(name='remove_prefix', args=arguments(posonlyargs=[], args=[arg(arg='text'), arg(arg='prefix')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Remove the prefix from the text if it exists.\n\n    >>> remove_prefix('underwhelming performance', 'underwhelming ')\n    'performance'\n\n    >>> remove_prefix('something special', 'sample')\n    'something special'\n    ")), Assign(targets=[Tuple(elts=[Name(id='null', ctx=Store()), Name(id='prefix', ctx=Store()), Name(id='rest', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='rpartition', ctx=Load()), args=[Name(id='prefix', ctx=Load())], keywords=[])), Return(value=Name(id='rest', ctx=Load()))], decorator_list=[]), FunctionDef(name='remove_suffix', args=arguments(posonlyargs=[], args=[arg(arg='text'), arg(arg='suffix')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Remove the suffix from the text if it exists.\n\n    >>> remove_suffix('name.git', '.git')\n    'name'\n\n    >>> remove_suffix('something special', 'sample')\n    'something special'\n    ")), Assign(targets=[Tuple(elts=[Name(id='rest', ctx=Store()), Name(id='suffix', ctx=Store()), Name(id='null', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='partition', ctx=Load()), args=[Name(id='suffix', ctx=Load())], keywords=[])), Return(value=Name(id='rest', ctx=Load()))], decorator_list=[]), FunctionDef(name='normalize_newlines', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Replace alternate newlines with the canonical newline.\n\n    >>> normalize_newlines('Lorem Ipsum\\u2029')\n    'Lorem Ipsum\\n'\n    >>> normalize_newlines('Lorem Ipsum\\r\\n')\n    'Lorem Ipsum\\n'\n    >>> normalize_newlines('Lorem Ipsum\\x85')\n    'Lorem Ipsum\\n'\n    ")), Assign(targets=[Name(id='newlines', ctx=Store())], value=List(elts=[Constant(value='\r\n'), Constant(value='\r'), Constant(value='\n'), Constant(value='\x85'), Constant(value='\u2028'), Constant(value='\u2029')], ctx=Load())), Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[Name(id='newlines', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Constant(value='\n'), Name(id='text', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_nonblank', args=arguments(posonlyargs=[], args=[arg(arg='str')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Name(id='str', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='str', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='#')], keywords=[]))]))], decorator_list=[]), FunctionDef(name='yield_lines', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Yield valid lines of a string or iterable.\n\n    >>> list(yield_lines(''))\n    []\n    >>> list(yield_lines(['foo', 'bar']))\n    ['foo', 'bar']\n    >>> list(yield_lines('foo\\nbar'))\n    ['foo', 'bar']\n    >>> list(yield_lines('\\nfoo\\n#bar\\nbaz #comment'))\n    ['foo', 'baz #comment']\n    >>> list(yield_lines(['foo\\nbar', 'baz', 'bing\\n\\n\\n']))\n    ['foo', 'bar', 'baz', 'bing']\n    ")), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='yield_lines', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Attribute(value=Name(id='functools', ctx=Load()), attr='singledispatch', ctx=Load())]), FunctionDef(name='_', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='filter', ctx=Load()), args=[Name(id='_nonblank', ctx=Load()), Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='str', ctx=Load()), attr='strip', ctx=Load()), Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[Call(func=Attribute(value=Name(id='yield_lines', ctx=Load()), attr='register', ctx=Load()), args=[Name(id='str', ctx=Load())], keywords=[])]), FunctionDef(name='drop_comment', args=arguments(posonlyargs=[], args=[arg(arg='line')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Drop comments.\n\n    >>> drop_comment('foo # bar')\n    'foo'\n\n    A hash without a space may be in a URL.\n\n    >>> drop_comment('http://example.com/foo#bar')\n    'http://example.com/foo#bar'\n    ")), Return(value=Subscript(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value=' #')], keywords=[]), slice=Constant(value=0), ctx=Load()))], decorator_list=[]), FunctionDef(name='join_continuation', args=arguments(posonlyargs=[], args=[arg(arg='lines')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Join lines continued by a trailing backslash.\n\n    >>> list(join_continuation(['foo \\\\', 'bar', 'baz']))\n    ['foobar', 'baz']\n    >>> list(join_continuation(['foo \\\\', 'bar', 'baz']))\n    ['foobar', 'baz']\n    >>> list(join_continuation(['foo \\\\', 'bar \\\\', 'baz']))\n    ['foobarbaz']\n\n    Not sure why, but...\n    The character preceeding the backslash is also elided.\n\n    >>> list(join_continuation(['goo\\\\', 'dly']))\n    ['godly']\n\n    A terrible idea, but...\n    If no line is available to continue, suppress the lines.\n\n    >>> list(join_continuation(['foo', 'bar\\\\', 'baz\\\\']))\n    ['foo']\n    ")), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])), For(target=Name(id='item', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[While(test=Call(func=Attribute(value=Name(id='item', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='\\')], keywords=[]), body=[Try(body=[Assign(targets=[Name(id='item', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Subscript(value=Name(id='item', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=2))), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id='next', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return()])], orelse=[], finalbody=[])], orelse=[]), Expr(value=Yield(value=Name(id='item', ctx=Load())))], orelse=[])], decorator_list=[])], type_ignores=[])