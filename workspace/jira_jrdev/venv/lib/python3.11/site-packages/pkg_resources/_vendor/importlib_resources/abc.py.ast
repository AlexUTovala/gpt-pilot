Module(body=[Import(names=[alias(name='abc')]), Import(names=[alias(name='io')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='pathlib')]), ImportFrom(module='typing', names=[alias(name='Any'), alias(name='BinaryIO'), alias(name='Iterable'), alias(name='Iterator'), alias(name='NoReturn'), alias(name='Text'), alias(name='Optional')], level=0), ImportFrom(module='_compat', names=[alias(name='runtime_checkable'), alias(name='Protocol'), alias(name='StrPath')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='ResourceReader'), Constant(value='Traversable'), Constant(value='TraversableResources')], ctx=Load())), ClassDef(name='ResourceReader', bases=[], keywords=[keyword(arg='metaclass', value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()))], body=[Expr(value=Constant(value='Abstract base class for loaders to provide resource reading support.')), FunctionDef(name='open_resource', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resource', annotation=Name(id='Text', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return an opened, file-like object for binary reading.\n\n        The 'resource' argument is expected to represent only a file name.\n        If the resource cannot be found, FileNotFoundError is raised.\n        ")), Raise(exc=Name(id='FileNotFoundError', ctx=Load()))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='BinaryIO', ctx=Load())), FunctionDef(name='resource_path', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resource', annotation=Name(id='Text', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the file system path to the specified resource.\n\n        The 'resource' argument is expected to represent only a file name.\n        If the resource does not exist on the file system, raise\n        FileNotFoundError.\n        ")), Raise(exc=Name(id='FileNotFoundError', ctx=Load()))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='Text', ctx=Load())), FunctionDef(name='is_resource', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path', annotation=Name(id='Text', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return True if the named 'path' is a resource.\n\n        Files are resources, directories are not.\n        ")), Raise(exc=Name(id='FileNotFoundError', ctx=Load()))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='contents', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return an iterable of entries in `package`.')), Raise(exc=Name(id='FileNotFoundError', ctx=Load()))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='TraversalError', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Pass()], decorator_list=[]), ClassDef(name='Traversable', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    An object with a subset of pathlib.Path methods suitable for\n    traversing directories and opening files.\n\n    Any exceptions that occur when accessing the backing resource\n    may propagate unaltered.\n    ')), FunctionDef(name='iterdir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Yield Traversable objects in self\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Constant(value='Traversable'), ctx=Load())), FunctionDef(name='read_bytes', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read contents of self as bytes\n        ')), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='open', ctx=Load()), args=[Constant(value='rb')], keywords=[]), optional_vars=Name(id='strm', ctx=Store()))], body=[Return(value=Call(func=Attribute(value=Name(id='strm', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])], decorator_list=[], returns=Name(id='bytes', ctx=Load())), FunctionDef(name='read_text', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='encoding', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Read contents of self as text\n        ')), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='open', ctx=Load()), args=[], keywords=[keyword(arg='encoding', value=Name(id='encoding', ctx=Load()))]), optional_vars=Name(id='strm', ctx=Store()))], body=[Return(value=Call(func=Attribute(value=Name(id='strm', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='is_dir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return True if self is a directory\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='is_file', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return True if self is a file\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='joinpath', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='descendants', annotation=Name(id='StrPath', ctx=Load())), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return Traversable resolved with any descendants applied.\n\n        Each descendant should be a path segment relative to self\n        and each may contain multiple levels separated by\n        ``posixpath.sep`` (``/``).\n        ')), If(test=UnaryOp(op=Not(), operand=Name(id='descendants', ctx=Load())), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='names', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='path', ctx=Load()), attr='parts', ctx=Load()), generators=[comprehension(target=Name(id='path', ctx=Store()), iter=Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='pathlib', ctx=Load()), attr='PurePosixPath', ctx=Load()), Name(id='descendants', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='target', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='names', ctx=Load())], keywords=[])), Assign(targets=[Name(id='matches', ctx=Store())], value=GeneratorExp(elt=Name(id='traversable', ctx=Load()), generators=[comprehension(target=Name(id='traversable', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iterdir', ctx=Load()), args=[], keywords=[]), ifs=[Compare(left=Attribute(value=Name(id='traversable', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Name(id='target', ctx=Load())])], is_async=0)])), Try(body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='matches', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TraversalError', ctx=Load()), args=[Constant(value='Target not found during traversal.'), Name(id='target', ctx=Load()), Call(func=Name(id='list', ctx=Load()), args=[Name(id='names', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='joinpath', ctx=Load()), args=[Starred(value=Name(id='names', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='Traversable')), FunctionDef(name='__truediv__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='child', annotation=Name(id='StrPath', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return Traversable child in self\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='joinpath', ctx=Load()), args=[Name(id='child', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='Traversable')), FunctionDef(name='open', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value='r')]), body=[Expr(value=Constant(value="\n        mode may be 'r' or 'rb' to open as text or binary. Return a handle\n        suitable for reading (same as pathlib.Path.open).\n\n        When opening as text, accepts encoding parameters such as those\n        accepted by io.TextIOWrapper.\n        "))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())]), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        The base name of this object without any parent references.\n        '))], decorator_list=[Name(id='property', ctx=Load()), Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='str', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())]), ClassDef(name='TraversableResources', bases=[Name(id='ResourceReader', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    The required interface for providing traversable\n    resources.\n    ')), FunctionDef(name='files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a Traversable object for the loaded package.'))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Constant(value='Traversable')), FunctionDef(name='open_resource', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resource', annotation=Name(id='StrPath', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='files', ctx=Load()), args=[], keywords=[]), attr='joinpath', ctx=Load()), args=[Name(id='resource', ctx=Load())], keywords=[]), attr='open', ctx=Load()), args=[Constant(value='rb')], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='io', ctx=Load()), attr='BufferedReader', ctx=Load())), FunctionDef(name='resource_path', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resource', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='FileNotFoundError', ctx=Load()), args=[Name(id='resource', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='NoReturn', ctx=Load())), FunctionDef(name='is_resource', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path', annotation=Name(id='StrPath', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='files', ctx=Load()), args=[], keywords=[]), attr='joinpath', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), attr='is_file', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='contents', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=GeneratorExp(elt=Attribute(value=Name(id='item', ctx=Load()), attr='name', ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='files', ctx=Load()), args=[], keywords=[]), attr='iterdir', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])