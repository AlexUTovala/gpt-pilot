Module(body=[Import(names=[alias(name='functools')]), Import(names=[alias(name='time')]), Import(names=[alias(name='inspect')]), Import(names=[alias(name='collections')]), Import(names=[alias(name='types')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='warnings')]), Import(names=[alias(name='pkg_resources.extern.more_itertools')]), ImportFrom(module='typing', names=[alias(name='Callable'), alias(name='TypeVar')], level=0), Assign(targets=[Name(id='CallableT', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='CallableT')], keywords=[keyword(arg='bound', value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))])), FunctionDef(name='compose', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='funcs'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Compose any number of unary functions into a single unary function.\n\n    >>> import textwrap\n    >>> expected = str.strip(textwrap.dedent(compose.__doc__))\n    >>> strip_and_dedent = compose(str.strip, textwrap.dedent)\n    >>> strip_and_dedent(compose.__doc__) == expected\n    True\n\n    Compose also allows the innermost function to take arbitrary arguments.\n\n    >>> round_three = lambda x: round(x, ndigits=3)\n    >>> f = compose(round_three, int.__truediv__)\n    >>> [f(3*x, x+1) for x in range(1,10)]\n    [1.5, 2.0, 2.25, 2.4, 2.5, 2.571, 2.625, 2.667, 2.7]\n    ')), FunctionDef(name='compose_two', args=arguments(posonlyargs=[], args=[arg(arg='f1'), arg(arg='f2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Lambda(args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=Call(func=Name(id='f1', ctx=Load()), args=[Call(func=Name(id='f2', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[])))], decorator_list=[]), Return(value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='reduce', ctx=Load()), args=[Name(id='compose_two', ctx=Load()), Name(id='funcs', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='method_caller', args=arguments(posonlyargs=[], args=[arg(arg='method_name')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value="\n    Return a function that will call a named method on the\n    target object with optional positional and keyword\n    arguments.\n\n    >>> lower = method_caller('lower')\n    >>> lower('MyString')\n    'mystring'\n    ")), FunctionDef(name='call_method', args=arguments(posonlyargs=[], args=[arg(arg='target')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='method_name', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), Return(value=Name(id='call_method', ctx=Load()))], decorator_list=[]), FunctionDef(name='once', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Decorate func so it's only ever called the first time.\n\n    This decorator can ensure that an expensive or non-idempotent function\n    will not be expensive on subsequent calls and is idempotent.\n\n    >>> add_three = once(lambda a: a+3)\n    >>> add_three(3)\n    6\n    >>> add_three(9)\n    6\n    >>> add_three('12')\n    6\n\n    To reset the stored value, simply clear the property ``saved_result``.\n\n    >>> del add_three.saved_result\n    >>> add_three(9)\n    12\n    >>> add_three(8)\n    12\n\n    Or invoke 'reset()' on it.\n\n    >>> add_three.reset()\n    >>> add_three(-3)\n    0\n    >>> add_three(0)\n    0\n    ")), FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='wrapper', ctx=Load()), Constant(value='saved_result')], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='wrapper', ctx=Load()), attr='saved_result', ctx=Store())], value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[]), Return(value=Attribute(value=Name(id='wrapper', ctx=Load()), attr='saved_result', ctx=Load()))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])]), Assign(targets=[Attribute(value=Name(id='wrapper', ctx=Load()), attr='reset', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='wrapper', ctx=Load())], keywords=[]), attr='__delitem__', ctx=Load()), args=[Constant(value='saved_result')], keywords=[]))), Return(value=Name(id='wrapper', ctx=Load()))], decorator_list=[]), FunctionDef(name='method_cache', args=arguments(posonlyargs=[], args=[arg(arg='method', annotation=Name(id='CallableT', ctx=Load())), arg(arg='cache_wrapper', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='CallableT', ctx=Load())], ctx=Load()), Name(id='CallableT', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='lru_cache', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Constant(value="\n    Wrap lru_cache to support storing the cache data in the object instances.\n\n    Abstracts the common paradigm where the method explicitly saves an\n    underscore-prefixed protected property on first call and returns that\n    subsequently.\n\n    >>> class MyClass:\n    ...     calls = 0\n    ...\n    ...     @method_cache\n    ...     def method(self, value):\n    ...         self.calls += 1\n    ...         return value\n\n    >>> a = MyClass()\n    >>> a.method(3)\n    3\n    >>> for x in range(75):\n    ...     res = a.method(x)\n    >>> a.calls\n    75\n\n    Note that the apparent behavior will be exactly like that of lru_cache\n    except that the cache is stored on each instance, so values in one\n    instance will not flush values from another, and when an instance is\n    deleted, so are the cached values for that instance.\n\n    >>> b = MyClass()\n    >>> for x in range(35):\n    ...     res = b.method(x)\n    >>> b.calls\n    35\n    >>> a.method(0)\n    0\n    >>> a.calls\n    75\n\n    Note that if method had been decorated with ``functools.lru_cache()``,\n    a.calls would have been 76 (due to the cached value of 0 having been\n    flushed by the 'b' instance).\n\n    Clear the cache with ``.cache_clear()``\n\n    >>> a.method.cache_clear()\n\n    Same for a method that hasn't yet been called.\n\n    >>> c = MyClass()\n    >>> c.method.cache_clear()\n\n    Another cache wrapper may be supplied:\n\n    >>> cache = functools.lru_cache(maxsize=2)\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\n    >>> a = MyClass()\n    >>> a.method2()\n    3\n\n    Caution - do not subsequently wrap the method with another decorator, such\n    as ``@property``, which changes the semantics of the function.\n\n    See also\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\n    for another implementation and additional justification.\n    ")), FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=Name(id='object', ctx=Load()))], vararg=arg(arg='args', annotation=Name(id='object', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='object', ctx=Load())), defaults=[]), body=[AnnAssign(target=Name(id='bound_method', ctx=Store()), annotation=Name(id='CallableT', ctx=Load()), value=Call(func=Attribute(value=Name(id='types', ctx=Load()), attr='MethodType', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), simple=1), Assign(targets=[Name(id='cached_method', ctx=Store())], value=Call(func=Name(id='cache_wrapper', ctx=Load()), args=[Name(id='bound_method', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Attribute(value=Name(id='method', ctx=Load()), attr='__name__', ctx=Load()), Name(id='cached_method', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='cached_method', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Name(id='object', ctx=Load())), Assign(targets=[Attribute(value=Name(id='wrapper', ctx=Load()), attr='cache_clear', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=None))), Return(value=BoolOp(op=Or(), values=[Call(func=Name(id='_special_method_cache', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='cache_wrapper', ctx=Load())], keywords=[]), Name(id='wrapper', ctx=Load())]))], decorator_list=[], returns=Name(id='CallableT', ctx=Load())), FunctionDef(name='_special_method_cache', args=arguments(posonlyargs=[], args=[arg(arg='method'), arg(arg='cache_wrapper')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Because Python treats special methods differently, it's not\n    possible to use instance attributes to implement the cached\n    methods.\n\n    Instead, install the wrapper method under a different name\n    and return a simple proxy to that wrapper.\n\n    https://github.com/jaraco/jaraco.functools/issues/5\n    ")), Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='method', ctx=Load()), attr='__name__', ctx=Load())), Assign(targets=[Name(id='special_names', ctx=Store())], value=Tuple(elts=[Constant(value='__getattr__'), Constant(value='__getitem__')], ctx=Load())), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='special_names', ctx=Load())]), body=[Return()], orelse=[]), Assign(targets=[Name(id='wrapper_name', ctx=Store())], value=BinOp(left=Constant(value='__cached'), op=Add(), right=Name(id='name', ctx=Load()))), FunctionDef(name='proxy', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Compare(left=Name(id='wrapper_name', ctx=Load()), ops=[NotIn()], comparators=[Call(func=Name(id='vars', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='types', ctx=Load()), attr='MethodType', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cache', ctx=Store())], value=Call(func=Name(id='cache_wrapper', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='wrapper_name', ctx=Load()), Name(id='cache', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='cache', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='wrapper_name', ctx=Load())], keywords=[]))]), Return(value=Call(func=Name(id='cache', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), Return(value=Name(id='proxy', ctx=Load()))], decorator_list=[]), FunctionDef(name='apply', args=arguments(posonlyargs=[], args=[arg(arg='transform')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Decorate a function with a transform function that is\n    invoked on results returned from the decorated function.\n\n    >>> @apply(reversed)\n    ... def get_numbers(start):\n    ...     "doc for get_numbers"\n    ...     return range(start, start+3)\n    >>> list(get_numbers(4))\n    [6, 5, 4]\n    >>> get_numbers.__doc__\n    \'doc for get_numbers\'\n    ')), FunctionDef(name='wrap', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), args=[Call(func=Name(id='compose', ctx=Load()), args=[Name(id='transform', ctx=Load()), Name(id='func', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), Return(value=Name(id='wrap', ctx=Load()))], decorator_list=[]), FunctionDef(name='result_invoke', args=arguments(posonlyargs=[], args=[arg(arg='action')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Decorate a function with an action function that is\n    invoked on the results returned from the decorated\n    function (for its side-effect), then return the original\n    result.\n\n    >>> @result_invoke(print)\n    ... def add_two(a, b):\n    ...     return a + b\n    >>> x = add_two(2, 3)\n    5\n    >>> x\n    5\n    ')), FunctionDef(name='wrap', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Expr(value=Call(func=Name(id='action', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])]), Return(value=Name(id='wrapper', ctx=Load()))], decorator_list=[]), Return(value=Name(id='wrap', ctx=Load()))], decorator_list=[]), FunctionDef(name='invoke', args=arguments(posonlyargs=[], args=[arg(arg='f')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='\n    Call a function for its side effect after initialization.\n\n    The benefit of using the decorator instead of simply invoking a function\n    after defining it is that it makes explicit the author\'s intent for the\n    function to be called immediately. Whereas if one simply calls the\n    function immediately, it\'s less obvious if that was intentional or\n    incidental. It also avoids repeating the name - the two actions, defining\n    the function and calling it immediately are modeled separately, but linked\n    by the decorator construct.\n\n    The benefit of having a function construct (opposed to just invoking some\n    behavior inline) is to serve as a scope in which the behavior occurs. It\n    avoids polluting the global namespace with local variables, provides an\n    anchor on which to attach documentation (docstring), keeps the behavior\n    logically separated (instead of conceptually separated or not separated at\n    all), and provides potential to re-use the behavior for testing or other\n    purposes.\n\n    This function is named as a pithy way to communicate, "call this function\n    primarily for its side effect", or "while defining this function, also\n    take it aside and call it". It exists because there\'s no Python construct\n    for "define and call" (nor should there be, as decorators serve this need\n    just fine). The behavior happens immediately and synchronously.\n\n    >>> @invoke\n    ... def func(): print("called")\n    called\n    >>> func()\n    called\n\n    Use functools.partial to pass parameters to the initial call\n\n    >>> @functools.partial(invoke, name=\'bingo\')\n    ... def func(name): print("called with", name)\n    called with bingo\n    ')), Expr(value=Call(func=Name(id='f', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Return(value=Name(id='f', ctx=Load()))], decorator_list=[]), FunctionDef(name='call_aside', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='\n    Deprecated name for invoke.\n    ')), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='call_aside is deprecated, use invoke'), Name(id='DeprecationWarning', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='invoke', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), ClassDef(name='Throttler', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Rate-limit a function (or other callable)\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='func'), arg(arg='max_rate')], kwonlyargs=[], kw_defaults=[], defaults=[Call(func=Name(id='float', ctx=Load()), args=[Constant(value='Inf')], keywords=[])]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='func', ctx=Load()), Name(id='Throttler', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Attribute(value=Name(id='func', ctx=Load()), attr='func', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='func', ctx=Store())], value=Name(id='func', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='max_rate', ctx=Store())], value=Name(id='max_rate', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='reset', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='reset', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='last_called', ctx=Store())], value=Constant(value=0))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_wait', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='func', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_wait', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='ensure at least 1/max_rate seconds from last call')), Assign(targets=[Name(id='elapsed', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='last_called', ctx=Load()))), Assign(targets=[Name(id='must_wait', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value=1), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='max_rate', ctx=Load())), op=Sub(), right=Name(id='elapsed', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='sleep', ctx=Load()), args=[Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), Name(id='must_wait', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='last_called', ctx=Store())], value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='__get__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj'), arg(arg='type')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='first_invoke', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_wait', ctx=Load()), Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='func', ctx=Load()), Name(id='obj', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='first_invoke', args=arguments(posonlyargs=[], args=[arg(arg='func1'), arg(arg='func2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return a function that when invoked will invoke func1 without\n    any parameters (for its side-effect) and then invoke func2\n    with whatever parameters were passed, returning its result.\n    ')), FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Name(id='func1', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='func2', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), Return(value=Name(id='wrapper', ctx=Load()))], decorator_list=[]), FunctionDef(name='retry_call', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='cleanup'), arg(arg='retries'), arg(arg='trap')], kwonlyargs=[], kw_defaults=[], defaults=[Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=None)), Constant(value=0), Tuple(elts=[], ctx=Load())]), body=[Expr(value=Constant(value="\n    Given a callable func, trap the indicated exceptions\n    for up to 'retries' times, invoking cleanup on the\n    exception. On the final attempt, allow any exceptions\n    to propagate.\n    ")), Assign(targets=[Name(id='attempts', ctx=Store())], value=IfExp(test=Compare(left=Name(id='retries', ctx=Load()), ops=[Eq()], comparators=[Call(func=Name(id='float', ctx=Load()), args=[Constant(value='inf')], keywords=[])]), body=Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[], keywords=[]), orelse=Call(func=Name(id='range', ctx=Load()), args=[Name(id='retries', ctx=Load())], keywords=[]))), For(target=Name(id='attempt', ctx=Store()), iter=Name(id='attempts', ctx=Load()), body=[Try(body=[Return(value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='trap', ctx=Load()), body=[Expr(value=Call(func=Name(id='cleanup', ctx=Load()), args=[], keywords=[]))])], orelse=[], finalbody=[])], orelse=[]), Return(value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='retry', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='r_args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='r_kwargs'), defaults=[]), body=[Expr(value=Constant(value='\n    Decorator wrapper for retry_call. Accepts arguments to retry_call\n    except func and then returns a decorator for the decorated function.\n\n    Ex:\n\n    >>> @retry(retries=3)\n    ... def my_func(a, b):\n    ...     "this is my funk"\n    ...     print(a, b)\n    >>> my_func.__doc__\n    \'this is my funk\'\n    ')), FunctionDef(name='decorate', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='f_args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='f_kwargs'), defaults=[]), body=[Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Name(id='func', ctx=Load()), Starred(value=Name(id='f_args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='f_kwargs', ctx=Load()))])), Return(value=Call(func=Name(id='retry_call', ctx=Load()), args=[Name(id='bound', ctx=Load()), Starred(value=Name(id='r_args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='r_kwargs', ctx=Load()))]))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])]), Return(value=Name(id='wrapper', ctx=Load()))], decorator_list=[]), Return(value=Name(id='decorate', ctx=Load()))], decorator_list=[]), FunctionDef(name='print_yielded', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Convert a generator into a function that prints all yielded elements\n\n    >>> @print_yielded\n    ... def x():\n    ...     yield 3; yield None\n    >>> x()\n    3\n    None\n    ')), Assign(targets=[Name(id='print_all', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Name(id='map', ctx=Load()), Name(id='print', ctx=Load())], keywords=[])), Assign(targets=[Name(id='print_results', ctx=Store())], value=Call(func=Name(id='compose', ctx=Load()), args=[Attribute(value=Name(id='more_itertools', ctx=Load()), attr='consume', ctx=Load()), Name(id='print_all', ctx=Load()), Name(id='func', ctx=Load())], keywords=[])), Return(value=Call(func=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), args=[Name(id='print_results', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='pass_none', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Wrap func so it's not called if its first param is None\n\n    >>> print_text = pass_none(print)\n    >>> print_text('text')\n    text\n    >>> print_text(None)\n    ")), FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[arg(arg='param')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Compare(left=Name(id='param', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='func', ctx=Load()), args=[Name(id='param', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[])], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])]), Return(value=Name(id='wrapper', ctx=Load()))], decorator_list=[]), FunctionDef(name='assign_params', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='namespace')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Assign parameters from namespace where func solicits.\n\n    >>> def func(x, y=3):\n    ...     print(x, y)\n    >>> assigned = assign_params(func, dict(x=2, z=4))\n    >>> assigned()\n    2 3\n\n    The usual errors are raised if a function doesn't receive\n    its required parameters:\n\n    >>> assigned = assign_params(func, dict(y=3, z=4))\n    >>> assigned()\n    Traceback (most recent call last):\n    TypeError: func() ...argument...\n\n    It even works on methods:\n\n    >>> class Handler:\n    ...     def meth(self, arg):\n    ...         print(arg)\n    >>> assign_params(Handler().meth, dict(arg='crystal', foo='clear'))()\n    crystal\n    ")), Assign(targets=[Name(id='sig', ctx=Store())], value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='signature', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])), Assign(targets=[Name(id='params', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='sig', ctx=Load()), attr='parameters', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='call_ns', ctx=Store())], value=DictComp(key=Name(id='k', ctx=Load()), value=Subscript(value=Name(id='namespace', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Name(id='params', ctx=Load()), ifs=[Compare(left=Name(id='k', ctx=Load()), ops=[In()], comparators=[Name(id='namespace', ctx=Load())])], is_async=0)])), Return(value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[keyword(value=Name(id='call_ns', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='save_method_args', args=arguments(posonlyargs=[], args=[arg(arg='method')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Wrap a method such that when it is called, the args and kwargs are\n    saved on the method.\n\n    >>> class MyClass:\n    ...     @save_method_args\n    ...     def method(self, a, b):\n    ...         print(a, b)\n    >>> my_ob = MyClass()\n    >>> my_ob.method(1, 2)\n    1 2\n    >>> my_ob._saved_method.args\n    (1, 2)\n    >>> my_ob._saved_method.kwargs\n    {}\n    >>> my_ob.method(a=3, b='foo')\n    3 foo\n    >>> my_ob._saved_method.args\n    ()\n    >>> my_ob._saved_method.kwargs == dict(a=3, b='foo')\n    True\n\n    The arguments are stored on the instance, allowing for\n    different instance to save different args.\n\n    >>> your_ob = MyClass()\n    >>> your_ob.method({str('x'): 3}, b=[4])\n    {'x': 3} [4]\n    >>> your_ob._saved_method.args\n    ({'x': 3},)\n    >>> my_ob._saved_method.args\n    ()\n    ")), Assign(targets=[Name(id='args_and_kwargs', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='namedtuple', ctx=Load()), args=[Constant(value='args_and_kwargs'), Constant(value='args kwargs')], keywords=[])), FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Assign(targets=[Name(id='attr_name', ctx=Store())], value=BinOp(left=Constant(value='_saved_'), op=Add(), right=Attribute(value=Name(id='method', ctx=Load()), attr='__name__', ctx=Load()))), Assign(targets=[Name(id='attr', ctx=Store())], value=Call(func=Name(id='args_and_kwargs', ctx=Load()), args=[Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='attr_name', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='method', ctx=Load()), args=[Name(id='self', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='method', ctx=Load())], keywords=[])]), Return(value=Name(id='wrapper', ctx=Load()))], decorator_list=[]), FunctionDef(name='except_', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='exceptions'), kwonlyargs=[arg(arg='replace'), arg(arg='use')], kw_defaults=[Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value="\n    Replace the indicated exceptions, if raised, with the indicated\n    literal replacement or evaluated expression (if present).\n\n    >>> safe_int = except_(ValueError)(int)\n    >>> safe_int('five')\n    >>> safe_int('5')\n    5\n\n    Specify a literal replacement with ``replace``.\n\n    >>> safe_int_r = except_(ValueError, replace=0)(int)\n    >>> safe_int_r('five')\n    0\n\n    Provide an expression to ``use`` to pass through particular parameters.\n\n    >>> safe_int_pt = except_(ValueError, use='args[0]')(int)\n    >>> safe_int_pt('five')\n    'five'\n\n    ")), FunctionDef(name='decorate', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Try(body=[Return(value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='exceptions', ctx=Load()), body=[Try(body=[Return(value=Call(func=Name(id='eval', ctx=Load()), args=[Name(id='use', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Return(value=Name(id='replace', ctx=Load()))])], orelse=[], finalbody=[])])], orelse=[], finalbody=[])], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])]), Return(value=Name(id='wrapper', ctx=Load()))], decorator_list=[]), Return(value=Name(id='decorate', ctx=Load()))], decorator_list=[])], type_ignores=[])