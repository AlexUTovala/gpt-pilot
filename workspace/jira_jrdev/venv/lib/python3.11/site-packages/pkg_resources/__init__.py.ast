Module(body=[Expr(value=Constant(value='\nPackage resource API\n--------------------\n\nA resource is a logical file contained within a package, or a logical\nsubdirectory thereof.  The package resource API expects resource names\nto have their path parts separated with ``/``, *not* whatever the local\npath separator is.  Do not use os.path operations to manipulate resource\nnames being passed into the API.\n\nThe package resource API is designed to work with normal filesystem packages,\n.egg files, and unpacked .egg files.  It can also work in a limited way with\n.zip files and with custom PEP 302 loaders that support the ``get_data()``\nmethod.\n\nThis module is deprecated. Users are directed to :mod:`importlib.resources`,\n:mod:`importlib.metadata` and :pypi:`packaging` instead.\n')), Import(names=[alias(name='sys')]), Import(names=[alias(name='os')]), Import(names=[alias(name='io')]), Import(names=[alias(name='time')]), Import(names=[alias(name='re')]), Import(names=[alias(name='types')]), Import(names=[alias(name='zipfile')]), Import(names=[alias(name='zipimport')]), Import(names=[alias(name='warnings')]), Import(names=[alias(name='stat')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='pkgutil')]), Import(names=[alias(name='operator')]), Import(names=[alias(name='platform')]), Import(names=[alias(name='collections')]), Import(names=[alias(name='plistlib')]), Import(names=[alias(name='email.parser')]), Import(names=[alias(name='errno')]), Import(names=[alias(name='tempfile')]), Import(names=[alias(name='textwrap')]), Import(names=[alias(name='inspect')]), Import(names=[alias(name='ntpath')]), Import(names=[alias(name='posixpath')]), Import(names=[alias(name='importlib')]), ImportFrom(module='pkgutil', names=[alias(name='get_importer')], level=0), Try(body=[Import(names=[alias(name='_imp')])], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Import(names=[alias(name='imp', asname='_imp')])])], orelse=[], finalbody=[]), Try(body=[Expr(value=Name(id='FileExistsError', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='NameError', ctx=Load()), body=[Assign(targets=[Name(id='FileExistsError', ctx=Store())], value=Name(id='OSError', ctx=Load()))])], orelse=[], finalbody=[]), ImportFrom(module='os', names=[alias(name='utime')], level=0), Try(body=[ImportFrom(module='os', names=[alias(name='mkdir'), alias(name='rename'), alias(name='unlink')], level=0), Assign(targets=[Name(id='WRITE_SUPPORT', ctx=Store())], value=Constant(value=True))], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='WRITE_SUPPORT', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[]), ImportFrom(module='os', names=[alias(name='open', asname='os_open')], level=0), ImportFrom(module='os.path', names=[alias(name='isdir'), alias(name='split')], level=0), Try(body=[Import(names=[alias(name='importlib.machinery', asname='importlib_machinery')]), Expr(value=Attribute(value=Name(id='importlib_machinery', ctx=Load()), attr='__name__', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='importlib_machinery', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), ImportFrom(module='pkg_resources.extern.jaraco.text', names=[alias(name='yield_lines'), alias(name='drop_comment'), alias(name='join_continuation')], level=0), ImportFrom(module='pkg_resources.extern', names=[alias(name='platformdirs')], level=0), ImportFrom(module='pkg_resources.extern', names=[alias(name='packaging')], level=0), Expr(value=Call(func=Name(id='__import__', ctx=Load()), args=[Constant(value='pkg_resources.extern.packaging.version')], keywords=[])), Expr(value=Call(func=Name(id='__import__', ctx=Load()), args=[Constant(value='pkg_resources.extern.packaging.specifiers')], keywords=[])), Expr(value=Call(func=Name(id='__import__', ctx=Load()), args=[Constant(value='pkg_resources.extern.packaging.requirements')], keywords=[])), Expr(value=Call(func=Name(id='__import__', ctx=Load()), args=[Constant(value='pkg_resources.extern.packaging.markers')], keywords=[])), Expr(value=Call(func=Name(id='__import__', ctx=Load()), args=[Constant(value='pkg_resources.extern.packaging.utils')], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[Lt()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=5)], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='Python 3.5 or later is required')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='require', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='working_set', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='add_activation_listener', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='resources_stream', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='cleanup_resources', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='resource_dir', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='resource_stream', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='set_extraction_path', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='resource_isdir', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='resource_string', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='iter_entry_points', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='resource_listdir', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='resource_filename', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='resource_exists', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='_distribution_finders', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='_namespace_handlers', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='_namespace_packages', ctx=Store())], value=Constant(value=None)), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Assign(targets=[Name(id='_PEP440_FALLBACK', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^v?(?P<safe>(?:[0-9]+!)?[0-9]+(?:\\.[0-9]+)*)'), Attribute(value=Name(id='re', ctx=Load()), attr='I', ctx=Load())], keywords=[])), ClassDef(name='PEP440Warning', bases=[Name(id='RuntimeWarning', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Used when there is an issue with a version or specifier not complying with\n    PEP 440.\n    '))], decorator_list=[]), Assign(targets=[Name(id='parse_version', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='version', ctx=Load()), attr='Version', ctx=Load())), Assign(targets=[Name(id='_state_vars', ctx=Store())], value=Dict(keys=[], values=[])), FunctionDef(name='_declare_state', args=arguments(posonlyargs=[], args=[arg(arg='vartype')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[]), attr='update', ctx=Load()), args=[Name(id='kw', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='_state_vars', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Name(id='dict', ctx=Load()), attr='fromkeys', ctx=Load()), args=[Name(id='kw', ctx=Load()), Name(id='vartype', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='__getstate__', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='g', ctx=Store())], value=Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='_state_vars', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='state', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Store())], value=Call(func=Subscript(value=Name(id='g', ctx=Load()), slice=BinOp(left=Constant(value='_sget_'), op=Add(), right=Name(id='v', ctx=Load())), ctx=Load()), args=[Subscript(value=Name(id='g', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[]), FunctionDef(name='__setstate__', args=arguments(posonlyargs=[], args=[arg(arg='state')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='g', ctx=Store())], value=Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='state', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Subscript(value=Name(id='g', ctx=Load()), slice=BinOp(left=Constant(value='_sset_'), op=Add(), right=Subscript(value=Name(id='_state_vars', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Load())), ctx=Load()), args=[Name(id='k', ctx=Load()), Subscript(value=Name(id='g', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Load()), Name(id='v', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[]), FunctionDef(name='_sget_dict', args=arguments(posonlyargs=[], args=[arg(arg='val')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='val', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_sset_dict', args=arguments(posonlyargs=[], args=[arg(arg='key'), arg(arg='ob'), arg(arg='state')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='ob', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ob', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_sget_object', args=arguments(posonlyargs=[], args=[arg(arg='val')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='val', ctx=Load()), attr='__getstate__', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_sset_object', args=arguments(posonlyargs=[], args=[arg(arg='key'), arg(arg='ob'), arg(arg='state')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='ob', ctx=Load()), attr='__setstate__', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='_sget_none', ctx=Store()), Name(id='_sset_none', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=None))), FunctionDef(name='get_supported_platform', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return this platform's maximum compatible version.\n\n    distutils.util.get_platform() normally reports the minimum version\n    of macOS that would be required to *use* extensions produced by\n    distutils.  But what we want when checking compatibility is to know the\n    version of macOS that we are *running*.  To allow usage of packages that\n    explicitly require a newer version of macOS, we must also know the\n    current version of the OS.\n\n    If this condition occurs for any other platform with a version in its\n    platform strings, this function should be extended accordingly.\n    ")), Assign(targets=[Name(id='plat', ctx=Store())], value=Call(func=Name(id='get_build_platform', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='m', ctx=Store())], value=Call(func=Attribute(value=Name(id='macosVersionString', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='plat', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='m', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()), ops=[Eq()], comparators=[Constant(value='darwin')])]), body=[Try(body=[Assign(targets=[Name(id='plat', ctx=Store())], value=BinOp(left=Constant(value='macosx-%s-%s'), op=Mod(), right=Tuple(elts=[Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Subscript(value=Call(func=Name(id='_macos_vers', ctx=Load()), args=[], keywords=[]), slice=Slice(upper=Constant(value=2)), ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='m', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=3)], keywords=[])], ctx=Load())))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Return(value=Name(id='plat', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='require'), Constant(value='run_script'), Constant(value='get_provider'), Constant(value='get_distribution'), Constant(value='load_entry_point'), Constant(value='get_entry_map'), Constant(value='get_entry_info'), Constant(value='iter_entry_points'), Constant(value='resource_string'), Constant(value='resource_stream'), Constant(value='resource_filename'), Constant(value='resource_listdir'), Constant(value='resource_exists'), Constant(value='resource_isdir'), Constant(value='declare_namespace'), Constant(value='working_set'), Constant(value='add_activation_listener'), Constant(value='find_distributions'), Constant(value='set_extraction_path'), Constant(value='cleanup_resources'), Constant(value='get_default_cache'), Constant(value='Environment'), Constant(value='WorkingSet'), Constant(value='ResourceManager'), Constant(value='Distribution'), Constant(value='Requirement'), Constant(value='EntryPoint'), Constant(value='ResolutionError'), Constant(value='VersionConflict'), Constant(value='DistributionNotFound'), Constant(value='UnknownExtra'), Constant(value='ExtractionError'), Constant(value='PEP440Warning'), Constant(value='parse_requirements'), Constant(value='parse_version'), Constant(value='safe_name'), Constant(value='safe_version'), Constant(value='get_platform'), Constant(value='compatible_platforms'), Constant(value='yield_lines'), Constant(value='split_sections'), Constant(value='safe_extra'), Constant(value='to_filename'), Constant(value='invalid_marker'), Constant(value='evaluate_marker'), Constant(value='ensure_directory'), Constant(value='normalize_path'), Constant(value='EGG_DIST'), Constant(value='BINARY_DIST'), Constant(value='SOURCE_DIST'), Constant(value='CHECKOUT_DIST'), Constant(value='DEVELOP_DIST'), Constant(value='IMetadataProvider'), Constant(value='IResourceProvider'), Constant(value='FileMetadata'), Constant(value='PathMetadata'), Constant(value='EggMetadata'), Constant(value='EmptyProvider'), Constant(value='empty_provider'), Constant(value='NullProvider'), Constant(value='EggProvider'), Constant(value='DefaultProvider'), Constant(value='ZipProvider'), Constant(value='register_finder'), Constant(value='register_namespace_handler'), Constant(value='register_loader_type'), Constant(value='fixup_namespace_packages'), Constant(value='get_importer'), Constant(value='PkgResourcesDeprecationWarning'), Constant(value='run_main'), Constant(value='AvailableDistributions')], ctx=Load())), ClassDef(name='ResolutionError', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Abstract base for dependency resolution errors')), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), op=Add(), right=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load())], keywords=[])))], decorator_list=[])], decorator_list=[]), ClassDef(name='VersionConflict', bases=[Name(id='ResolutionError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    An already-installed version conflicts with the requested version.\n\n    Should be initialized with the installed Distribution and the requested\n    Requirement.\n    ')), Assign(targets=[Name(id='_template', ctx=Store())], value=Constant(value='{self.dist} is installed but {self.req} is required')), FunctionDef(name='dist', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load()), slice=Constant(value=0), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='req', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load()), slice=Constant(value=1), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='report', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_template', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))]))], decorator_list=[]), FunctionDef(name='with_context', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='required_by')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        If required_by is non-empty, return a version of self that is a\n        ContextualVersionConflict.\n        ')), If(test=UnaryOp(op=Not(), operand=Name(id='required_by', ctx=Load())), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='args', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load()), op=Add(), right=Tuple(elts=[Name(id='required_by', ctx=Load())], ctx=Load()))), Return(value=Call(func=Name(id='ContextualVersionConflict', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='ContextualVersionConflict', bases=[Name(id='VersionConflict', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A VersionConflict that accepts a third parameter, the set of the\n    requirements that required the installed Distribution.\n    ')), Assign(targets=[Name(id='_template', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='VersionConflict', ctx=Load()), attr='_template', ctx=Load()), op=Add(), right=Constant(value=' by {self.required_by}'))), FunctionDef(name='required_by', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load()), slice=Constant(value=2), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())])], decorator_list=[]), ClassDef(name='DistributionNotFound', bases=[Name(id='ResolutionError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A requested distribution was not found')), Assign(targets=[Name(id='_template', ctx=Store())], value=Constant(value="The '{self.req}' distribution was not found and is required by {self.requirers_str}")), FunctionDef(name='req', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load()), slice=Constant(value=0), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='requirers', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load()), slice=Constant(value=1), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='requirers_str', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='requirers', ctx=Load())), body=[Return(value=Constant(value='the application'))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='requirers', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='report', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_template', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))]))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='report', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='UnknownExtra', bases=[Name(id='ResolutionError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Distribution doesn\'t have an "extra feature" of the given name'))], decorator_list=[]), Assign(targets=[Name(id='_provider_factories', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='PY_MAJOR', ctx=Store())], value=Call(func=Attribute(value=Constant(value='{}.{}'), attr='format', ctx=Load()), args=[Starred(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ctx=Load())], keywords=[])), Assign(targets=[Name(id='EGG_DIST', ctx=Store())], value=Constant(value=3)), Assign(targets=[Name(id='BINARY_DIST', ctx=Store())], value=Constant(value=2)), Assign(targets=[Name(id='SOURCE_DIST', ctx=Store())], value=Constant(value=1)), Assign(targets=[Name(id='CHECKOUT_DIST', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='DEVELOP_DIST', ctx=Store())], value=UnaryOp(op=USub(), operand=Constant(value=1))), FunctionDef(name='register_loader_type', args=arguments(posonlyargs=[], args=[arg(arg='loader_type'), arg(arg='provider_factory')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Register `provider_factory` to make providers for `loader_type`\n\n    `loader_type` is the type or class of a PEP 302 ``module.__loader__``,\n    and `provider_factory` is a function that, passed a *module* object,\n    returns an ``IResourceProvider`` for that module.\n    ')), Assign(targets=[Subscript(value=Name(id='_provider_factories', ctx=Load()), slice=Name(id='loader_type', ctx=Load()), ctx=Store())], value=Name(id='provider_factory', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_provider', args=arguments(posonlyargs=[], args=[arg(arg='moduleOrReq')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return an IResourceProvider for the named module or requirement')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='moduleOrReq', ctx=Load()), Name(id='Requirement', ctx=Load())], keywords=[]), body=[Return(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='working_set', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='moduleOrReq', ctx=Load())], keywords=[]), Subscript(value=Call(func=Name(id='require', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='moduleOrReq', ctx=Load())], keywords=[])], keywords=[]), slice=Constant(value=0), ctx=Load())]))], orelse=[]), Try(body=[Assign(targets=[Name(id='module', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='moduleOrReq', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Expr(value=Call(func=Name(id='__import__', ctx=Load()), args=[Name(id='moduleOrReq', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='moduleOrReq', ctx=Load()), ctx=Load()))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='loader', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='module', ctx=Load()), Constant(value='__loader__'), Constant(value=None)], keywords=[])), Return(value=Call(func=Call(func=Name(id='_find_adapter', ctx=Load()), args=[Name(id='_provider_factories', ctx=Load()), Name(id='loader', ctx=Load())], keywords=[]), args=[Name(id='module', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_macos_vers', args=arguments(posonlyargs=[], args=[arg(arg='_cache')], kwonlyargs=[], kw_defaults=[], defaults=[List(elts=[], ctx=Load())]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='_cache', ctx=Load())), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='platform', ctx=Load()), attr='mac_ver', ctx=Load()), args=[], keywords=[]), slice=Constant(value=0), ctx=Load())), If(test=Compare(left=Name(id='version', ctx=Load()), ops=[Eq()], comparators=[Constant(value='')]), body=[Assign(targets=[Name(id='plist', ctx=Store())], value=Constant(value='/System/Library/CoreServices/SystemVersion.plist')), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='plist', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='plistlib', ctx=Load()), Constant(value='readPlist')], keywords=[]), body=[Assign(targets=[Name(id='plist_content', ctx=Store())], value=Call(func=Attribute(value=Name(id='plistlib', ctx=Load()), attr='readPlist', ctx=Load()), args=[Name(id='plist', ctx=Load())], keywords=[])), If(test=Compare(left=Constant(value='ProductVersion'), ops=[In()], comparators=[Name(id='plist_content', ctx=Load())]), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Subscript(value=Name(id='plist_content', ctx=Load()), slice=Constant(value='ProductVersion'), ctx=Load()))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='_cache', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='version', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])], keywords=[]))], orelse=[]), Return(value=Subscript(value=Name(id='_cache', ctx=Load()), slice=Constant(value=0), ctx=Load()))], decorator_list=[]), FunctionDef(name='_macos_arch', args=arguments(posonlyargs=[], args=[arg(arg='machine')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Dict(keys=[Constant(value='PowerPC'), Constant(value='Power_Macintosh')], values=[Constant(value='ppc'), Constant(value='ppc')]), attr='get', ctx=Load()), args=[Name(id='machine', ctx=Load()), Name(id='machine', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_build_platform', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return this platform's string for platform-specific distributions\n\n    XXX Currently this is the same as ``distutils.util.get_platform()``, but it\n    needs some hacks for Linux and macOS.\n    ")), ImportFrom(module='sysconfig', names=[alias(name='get_platform')], level=0), Assign(targets=[Name(id='plat', ctx=Store())], value=Call(func=Name(id='get_platform', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()), ops=[Eq()], comparators=[Constant(value='darwin')]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='plat', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='macosx-')], keywords=[]))]), body=[Try(body=[Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Name(id='_macos_vers', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='machine', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='uname', ctx=Load()), args=[], keywords=[]), slice=Constant(value=4), ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=' '), Constant(value='_')], keywords=[])), Return(value=BinOp(left=Constant(value='macosx-%d.%d-%s'), op=Mod(), right=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Subscript(value=Name(id='version', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), Call(func=Name(id='int', ctx=Load()), args=[Subscript(value=Name(id='version', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[]), Call(func=Name(id='_macos_arch', ctx=Load()), args=[Name(id='machine', ctx=Load())], keywords=[])], ctx=Load())))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Return(value=Name(id='plat', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='macosVersionString', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='macosx-(\\d+)\\.(\\d+)-(.*)')], keywords=[])), Assign(targets=[Name(id='darwinVersionString', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='darwin-(\\d+)\\.(\\d+)\\.(\\d+)-(.*)')], keywords=[])), Assign(targets=[Name(id='get_platform', ctx=Store())], value=Name(id='get_build_platform', ctx=Load())), FunctionDef(name='compatible_platforms', args=arguments(posonlyargs=[], args=[arg(arg='provided'), arg(arg='required')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Can code for the `provided` platform run on the `required` platform?\n\n    Returns true if either platform is ``None``, or the platforms are equal.\n\n    XXX Needs compatibility checks for Linux and other unixy OSes.\n    ')), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='provided', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='required', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='provided', ctx=Load()), ops=[Eq()], comparators=[Name(id='required', ctx=Load())])]), body=[Return(value=Constant(value=True))], orelse=[]), Assign(targets=[Name(id='reqMac', ctx=Store())], value=Call(func=Attribute(value=Name(id='macosVersionString', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='required', ctx=Load())], keywords=[])), If(test=Name(id='reqMac', ctx=Load()), body=[Assign(targets=[Name(id='provMac', ctx=Store())], value=Call(func=Attribute(value=Name(id='macosVersionString', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='provided', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='provMac', ctx=Load())), body=[Assign(targets=[Name(id='provDarwin', ctx=Store())], value=Call(func=Attribute(value=Name(id='darwinVersionString', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='provided', ctx=Load())], keywords=[])), If(test=Name(id='provDarwin', ctx=Load()), body=[Assign(targets=[Name(id='dversion', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='provDarwin', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[])], keywords=[])), Assign(targets=[Name(id='macosversion', ctx=Store())], value=BinOp(left=Constant(value='%s.%s'), op=Mod(), right=Tuple(elts=[Call(func=Attribute(value=Name(id='reqMac', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), Call(func=Attribute(value=Name(id='reqMac', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=2)], keywords=[])], ctx=Load()))), If(test=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Compare(left=Name(id='dversion', ctx=Load()), ops=[Eq()], comparators=[Constant(value=7)]), Compare(left=Name(id='macosversion', ctx=Load()), ops=[GtE()], comparators=[Constant(value='10.3')])]), BoolOp(op=And(), values=[Compare(left=Name(id='dversion', ctx=Load()), ops=[Eq()], comparators=[Constant(value=8)]), Compare(left=Name(id='macosversion', ctx=Load()), ops=[GtE()], comparators=[Constant(value='10.4')])])]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Constant(value=False))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Call(func=Attribute(value=Name(id='provMac', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), ops=[NotEq()], comparators=[Call(func=Attribute(value=Name(id='reqMac', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[])]), Compare(left=Call(func=Attribute(value=Name(id='provMac', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=3)], keywords=[]), ops=[NotEq()], comparators=[Call(func=Attribute(value=Name(id='reqMac', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=3)], keywords=[])])]), body=[Return(value=Constant(value=False))], orelse=[]), If(test=Compare(left=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='provMac', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=2)], keywords=[])], keywords=[]), ops=[Gt()], comparators=[Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reqMac', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=2)], keywords=[])], keywords=[])]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Constant(value=True))], orelse=[]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='run_script', args=arguments(posonlyargs=[], args=[arg(arg='dist_spec'), arg(arg='script_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Locate distribution `dist_spec` and run its `script_name` script')), Assign(targets=[Name(id='ns', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load())), Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__name__'), ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='ns', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__name__'), ctx=Store())], value=Name(id='name', ctx=Load())), Expr(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='require', ctx=Load()), args=[Name(id='dist_spec', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='run_script', ctx=Load()), args=[Name(id='script_name', ctx=Load()), Name(id='ns', ctx=Load())], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='run_main', ctx=Store())], value=Name(id='run_script', ctx=Load())), FunctionDef(name='get_distribution', args=arguments(posonlyargs=[], args=[arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a current distribution object for a Requirement or string')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Name(id='Requirement', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='Requirement', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Name(id='get_provider', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='Distribution', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Expected string, Requirement, or Distribution'), Name(id='dist', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='dist', ctx=Load()))], decorator_list=[]), FunctionDef(name='load_entry_point', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='group'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return `name` entry point of `group` for `dist` or raise ImportError')), Return(value=Call(func=Attribute(value=Call(func=Name(id='get_distribution', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]), attr='load_entry_point', ctx=Load()), args=[Name(id='group', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_entry_map', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='group')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return the entry point map for `group`, or the full entry map')), Return(value=Call(func=Attribute(value=Call(func=Name(id='get_distribution', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]), attr='get_entry_map', ctx=Load()), args=[Name(id='group', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_entry_info', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='group'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the EntryPoint object for `group`+`name`, or ``None``')), Return(value=Call(func=Attribute(value=Call(func=Name(id='get_distribution', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]), attr='get_entry_info', ctx=Load()), args=[Name(id='group', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='IMetadataProvider', bases=[], keywords=[], body=[FunctionDef(name='has_metadata', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Does the package's distribution contain the named metadata?"))], decorator_list=[]), FunctionDef(name='get_metadata', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The named metadata resource as a string'))], decorator_list=[]), FunctionDef(name='get_metadata_lines', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Yield named metadata resource as list of non-blank non-comment lines\n\n        Leading and trailing whitespace is stripped from each line, and lines\n        with ``#`` as the first non-blank character are omitted.'))], decorator_list=[]), FunctionDef(name='metadata_isdir', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Is the named metadata a directory?  (like ``os.path.isdir()``)'))], decorator_list=[]), FunctionDef(name='metadata_listdir', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='List of metadata names in the directory (like ``os.listdir()``)'))], decorator_list=[]), FunctionDef(name='run_script', args=arguments(posonlyargs=[], args=[arg(arg='script_name'), arg(arg='namespace')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Execute the named script in the supplied namespace dictionary'))], decorator_list=[])], decorator_list=[]), ClassDef(name='IResourceProvider', bases=[Name(id='IMetadataProvider', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='An object that provides access to package resources')), FunctionDef(name='get_resource_filename', args=arguments(posonlyargs=[], args=[arg(arg='manager'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a true filesystem path for `resource_name`\n\n        `manager` must be an ``IResourceManager``'))], decorator_list=[]), FunctionDef(name='get_resource_stream', args=arguments(posonlyargs=[], args=[arg(arg='manager'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a readable file-like object for `resource_name`\n\n        `manager` must be an ``IResourceManager``'))], decorator_list=[]), FunctionDef(name='get_resource_string', args=arguments(posonlyargs=[], args=[arg(arg='manager'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a string containing the contents of `resource_name`\n\n        `manager` must be an ``IResourceManager``'))], decorator_list=[]), FunctionDef(name='has_resource', args=arguments(posonlyargs=[], args=[arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Does the package contain the named resource?'))], decorator_list=[]), FunctionDef(name='resource_isdir', args=arguments(posonlyargs=[], args=[arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Is the named resource a directory?  (like ``os.path.isdir()``)'))], decorator_list=[]), FunctionDef(name='resource_listdir', args=arguments(posonlyargs=[], args=[arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='List of resource names in the directory (like ``os.listdir()``)'))], decorator_list=[])], decorator_list=[]), ClassDef(name='WorkingSet', bases=[], keywords=[], body=[Expr(value=Constant(value='A collection of active distributions on sys.path (or a similar list)')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='entries')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Create working set from list of path entries (default=sys.path)')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='entries', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='entry_keys', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='by_key', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='normalized_to_canonical_keys', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callbacks', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Name(id='entries', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='entries', ctx=Store())], value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()))], orelse=[]), For(target=Name(id='entry', ctx=Store()), iter=Name(id='entries', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add_entry', ctx=Load()), args=[Name(id='entry', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_build_master', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Prepare the master working set.\n        ')), Assign(targets=[Name(id='ws', ctx=Store())], value=Call(func=Name(id='cls', ctx=Load()), args=[], keywords=[])), Try(body=[ImportFrom(module='__main__', names=[alias(name='__requires__')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Return(value=Name(id='ws', ctx=Load()))])], orelse=[], finalbody=[]), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='ws', ctx=Load()), attr='require', ctx=Load()), args=[Name(id='__requires__', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='VersionConflict', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_build_from_requirements', ctx=Load()), args=[Name(id='__requires__', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Name(id='ws', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_build_from_requirements', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='req_spec')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Build a working set from a requirement spec. Rewrites sys.path.\n        ')), Assign(targets=[Name(id='ws', ctx=Store())], value=Call(func=Name(id='cls', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[])), Assign(targets=[Name(id='reqs', ctx=Store())], value=Call(func=Name(id='parse_requirements', ctx=Load()), args=[Name(id='req_spec', ctx=Load())], keywords=[])), Assign(targets=[Name(id='dists', ctx=Store())], value=Call(func=Attribute(value=Name(id='ws', ctx=Load()), attr='resolve', ctx=Load()), args=[Name(id='reqs', ctx=Load()), Call(func=Name(id='Environment', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Name(id='dist', ctx=Store()), iter=Name(id='dists', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='ws', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='entry', ctx=Store()), iter=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), body=[If(test=Compare(left=Name(id='entry', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='ws', ctx=Load()), attr='entries', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='ws', ctx=Load()), attr='add_entry', ctx=Load()), args=[Name(id='entry', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), slice=Slice(), ctx=Store())], value=Attribute(value=Name(id='ws', ctx=Load()), attr='entries', ctx=Load())), Return(value=Name(id='ws', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='add_entry', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='entry')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add a path item to ``.entries``, finding any distributions on it\n\n        ``find_distributions(entry, True)`` is used to find distributions\n        corresponding to the path entry, and they are added.  `entry` is\n        always appended to ``.entries``, even if it is already present.\n        (This is because ``sys.path`` can contain the same value more than\n        once, and the ``.entries`` of the ``sys.path`` WorkingSet should always\n        equal ``sys.path``.)\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='entry_keys', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='entry', ctx=Load()), List(elts=[], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='entries', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='entry', ctx=Load())], keywords=[])), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Name(id='find_distributions', ctx=Load()), args=[Name(id='entry', ctx=Load()), Constant(value=True)], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='entry', ctx=Load()), Constant(value=False)], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='True if `dist` is the active distribution for its project')), Return(value=Compare(left=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='by_key', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Name(id='dist', ctx=Load())]))], decorator_list=[]), FunctionDef(name='find', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find a distribution matching requirement `req`\n\n        If there is an active distribution for the requested project, this\n        returns it as long as it meets the version requirement specified by\n        `req`.  But, if there is an active distribution for the project and it\n        does *not* meet the `req` requirement, ``VersionConflict`` is raised.\n        If there is no active distribution for the requested project, ``None``\n        is returned.\n        ')), Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='by_key', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='req', ctx=Load()), attr='key', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='canonical_key', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='normalized_to_canonical_keys', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='req', ctx=Load()), attr='key', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='canonical_key', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='req', ctx=Load()), attr='key', ctx=Store())], value=Name(id='canonical_key', ctx=Load())), Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='by_key', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='canonical_key', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='dist', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='dist', ctx=Load()), ops=[NotIn()], comparators=[Name(id='req', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='VersionConflict', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='req', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='dist', ctx=Load()))], decorator_list=[]), FunctionDef(name='iter_entry_points', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='group'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Yield entry point objects from `group` matching `name`\n\n        If `name` is None, yields all entry points in `group` from all\n        distributions in the working set, otherwise only ones matching\n        both `group` and `name` are yielded (in distribution order).\n        ')), Return(value=GeneratorExp(elt=Name(id='entry', ctx=Load()), generators=[comprehension(target=Name(id='dist', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[], is_async=0), comprehension(target=Name(id='entry', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='get_entry_map', ctx=Load()), args=[Name(id='group', ctx=Load())], keywords=[]), attr='values', ctx=Load()), args=[], keywords=[]), ifs=[BoolOp(op=Or(), values=[Compare(left=Name(id='name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='entry', ctx=Load()), attr='name', ctx=Load())])])], is_async=0)]))], decorator_list=[]), FunctionDef(name='run_script', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requires'), arg(arg='script_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Locate distribution for `requires` and run `script_name` script')), Assign(targets=[Name(id='ns', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load())), Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__name__'), ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='ns', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__name__'), ctx=Store())], value=Name(id='name', ctx=Load())), Expr(value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='require', ctx=Load()), args=[Name(id='requires', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='run_script', ctx=Load()), args=[Name(id='script_name', ctx=Load()), Name(id='ns', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield distributions for non-duplicate projects in the working set\n\n        The yield order is the order in which the items' path entries were\n        added to the working set.\n        ")), Assign(targets=[Name(id='seen', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='item', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='entries', ctx=Load()), body=[If(test=Compare(left=Name(id='item', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='entry_keys', ctx=Load())]), body=[Continue()], orelse=[]), For(target=Name(id='key', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='entry_keys', ctx=Load()), slice=Name(id='item', ctx=Load()), ctx=Load()), body=[If(test=Compare(left=Name(id='key', ctx=Load()), ops=[NotIn()], comparators=[Name(id='seen', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='seen', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Constant(value=1)), Expr(value=Yield(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='by_key', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='add', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist'), arg(arg='entry'), arg(arg='insert'), arg(arg='replace')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=True), Constant(value=False)]), body=[Expr(value=Constant(value="Add `dist` to working set, associated with `entry`\n\n        If `entry` is unspecified, it defaults to the ``.location`` of `dist`.\n        On exit from this routine, `entry` is added to the end of the working\n        set's ``.entries`` (if it wasn't already present).\n\n        `dist` is only added to the working set if it's for a project that\n        doesn't already have a distribution in the set, unless `replace=True`.\n        If it's added, any callbacks registered with the ``subscribe()`` method\n        will be called.\n        ")), If(test=Name(id='insert', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='insert_on', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='entries', ctx=Load()), Name(id='entry', ctx=Load())], keywords=[keyword(arg='replace', value=Name(id='replace', ctx=Load()))]))], orelse=[]), If(test=Compare(left=Name(id='entry', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='entry', ctx=Store())], value=Attribute(value=Name(id='dist', ctx=Load()), attr='location', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='keys', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='entry_keys', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='entry', ctx=Load()), List(elts=[], ctx=Load())], keywords=[])), Assign(targets=[Name(id='keys2', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='entry_keys', ctx=Load()), attr='setdefault', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='location', ctx=Load()), List(elts=[], ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='replace', ctx=Load())), Compare(left=Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='by_key', ctx=Load())])]), body=[Return()], orelse=[]), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='by_key', ctx=Load()), slice=Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load()), ctx=Store())], value=Name(id='dist', ctx=Load())), Assign(targets=[Name(id='normalized_name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='utils', ctx=Load()), attr='canonicalize_name', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='normalized_to_canonical_keys', ctx=Load()), slice=Name(id='normalized_name', ctx=Load()), ctx=Store())], value=Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load()), ops=[NotIn()], comparators=[Name(id='keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='keys', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load()), ops=[NotIn()], comparators=[Name(id='keys2', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='keys2', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_added_new', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='resolve', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requirements'), arg(arg='env'), arg(arg='installer'), arg(arg='replace_conflicting'), arg(arg='extras')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='List all distributions needed to (recursively) meet `requirements`\n\n        `requirements` must be a sequence of ``Requirement`` objects.  `env`,\n        if supplied, should be an ``Environment`` instance.  If\n        not supplied, it defaults to all distributions available within any\n        entry or distribution in the working set.  `installer`, if supplied,\n        will be invoked with each requirement that cannot be met by an\n        already-installed distribution; it should return a ``Distribution`` or\n        ``None``.\n\n        Unless `replace_conflicting=True`, raises a VersionConflict exception\n        if\n        any requirements are found on the path that have the correct name but\n        the wrong version.  Otherwise, if an `installer` is supplied it will be\n        invoked to obtain the correct version of the requirement and activate\n        it.\n\n        `extras` is a list of the extras to be used with these requirements.\n        This is important because extra requirements may look like `my_req;\n        extra = "my_extra"`, which would otherwise be interpreted as a purely\n        optional requirement.  Instead, we want to be able to assert that these\n        requirements are truly required.\n        ')), Assign(targets=[Name(id='requirements', ctx=Store())], value=Subscript(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='requirements', ctx=Load())], keywords=[]), slice=Slice(step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())), Assign(targets=[Name(id='processed', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='best', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='to_activate', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='req_extras', ctx=Store())], value=Call(func=Name(id='_ReqExtras', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='required_by', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='defaultdict', ctx=Load()), args=[Name(id='set', ctx=Load())], keywords=[])), While(test=Name(id='requirements', ctx=Load()), body=[Assign(targets=[Name(id='req', ctx=Store())], value=Call(func=Attribute(value=Name(id='requirements', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value=0)], keywords=[])), If(test=Compare(left=Name(id='req', ctx=Load()), ops=[In()], comparators=[Name(id='processed', ctx=Load())]), body=[Continue()], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='req_extras', ctx=Load()), attr='markers_pass', ctx=Load()), args=[Name(id='req', ctx=Load()), Name(id='extras', ctx=Load())], keywords=[])), body=[Continue()], orelse=[]), Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_resolve_dist', ctx=Load()), args=[Name(id='req', ctx=Load()), Name(id='best', ctx=Load()), Name(id='replace_conflicting', ctx=Load()), Name(id='env', ctx=Load()), Name(id='installer', ctx=Load()), Name(id='required_by', ctx=Load()), Name(id='to_activate', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_requirements', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='requires', ctx=Load()), args=[Attribute(value=Name(id='req', ctx=Load()), attr='extras', ctx=Load())], keywords=[]), slice=Slice(step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='requirements', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='new_requirements', ctx=Load())], keywords=[])), For(target=Name(id='new_requirement', ctx=Store()), iter=Name(id='new_requirements', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='required_by', ctx=Load()), slice=Name(id='new_requirement', ctx=Load()), ctx=Load()), attr='add', ctx=Load()), args=[Attribute(value=Name(id='req', ctx=Load()), attr='project_name', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='req_extras', ctx=Load()), slice=Name(id='new_requirement', ctx=Load()), ctx=Store())], value=Attribute(value=Name(id='req', ctx=Load()), attr='extras', ctx=Load()))], orelse=[]), Assign(targets=[Subscript(value=Name(id='processed', ctx=Load()), slice=Name(id='req', ctx=Load()), ctx=Store())], value=Constant(value=True))], orelse=[]), Return(value=Name(id='to_activate', ctx=Load()))], decorator_list=[]), FunctionDef(name='_resolve_dist', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req'), arg(arg='best'), arg(arg='replace_conflicting'), arg(arg='env'), arg(arg='installer'), arg(arg='required_by'), arg(arg='to_activate')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Name(id='best', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='req', ctx=Load()), attr='key', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='by_key', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='req', ctx=Load()), attr='key', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='dist', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), BoolOp(op=And(), values=[Compare(left=Name(id='dist', ctx=Load()), ops=[NotIn()], comparators=[Name(id='req', ctx=Load())]), Name(id='replace_conflicting', ctx=Load())])]), body=[Assign(targets=[Name(id='ws', ctx=Store())], value=Name(id='self', ctx=Load())), If(test=Compare(left=Name(id='env', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='env', ctx=Store())], value=Call(func=Name(id='Environment', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='entries', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='env', ctx=Store())], value=Call(func=Name(id='Environment', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[])), Assign(targets=[Name(id='ws', ctx=Store())], value=Call(func=Name(id='WorkingSet', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Name(id='dist', ctx=Store()), Subscript(value=Name(id='best', ctx=Load()), slice=Attribute(value=Name(id='req', ctx=Load()), attr='key', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='env', ctx=Load()), attr='best_match', ctx=Load()), args=[Name(id='req', ctx=Load()), Name(id='ws', ctx=Load()), Name(id='installer', ctx=Load())], keywords=[keyword(arg='replace_conflicting', value=Name(id='replace_conflicting', ctx=Load()))])), If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='requirers', ctx=Store())], value=Call(func=Attribute(value=Name(id='required_by', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='req', ctx=Load()), Constant(value=None)], keywords=[])), Raise(exc=Call(func=Name(id='DistributionNotFound', ctx=Load()), args=[Name(id='req', ctx=Load()), Name(id='requirers', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='to_activate', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[NotIn()], comparators=[Name(id='req', ctx=Load())]), body=[Assign(targets=[Name(id='dependent_req', ctx=Store())], value=Subscript(value=Name(id='required_by', ctx=Load()), slice=Name(id='req', ctx=Load()), ctx=Load())), Raise(exc=Call(func=Attribute(value=Call(func=Name(id='VersionConflict', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='req', ctx=Load())], keywords=[]), attr='with_context', ctx=Load()), args=[Name(id='dependent_req', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='dist', ctx=Load()))], decorator_list=[]), FunctionDef(name='find_plugins', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin_env'), arg(arg='full_env'), arg(arg='installer'), arg(arg='fallback')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=True)]), body=[Expr(value=Constant(value='Find all activatable distributions in `plugin_env`\n\n        Example usage::\n\n            distributions, errors = working_set.find_plugins(\n                Environment(plugin_dirlist)\n            )\n            # add plugins+libs to sys.path\n            map(working_set.add, distributions)\n            # display errors\n            print(\'Could not load\', errors)\n\n        The `plugin_env` should be an ``Environment`` instance that contains\n        only distributions that are in the project\'s "plugin directory" or\n        directories. The `full_env`, if supplied, should be an ``Environment``\n        contains all currently-available distributions.  If `full_env` is not\n        supplied, one is created automatically from the ``WorkingSet`` this\n        method is called on, which will typically mean that every directory on\n        ``sys.path`` will be scanned for distributions.\n\n        `installer` is a standard installer callback as used by the\n        ``resolve()`` method. The `fallback` flag indicates whether we should\n        attempt to resolve older versions of a plugin if the newest version\n        cannot be resolved.\n\n        This method returns a 2-tuple: (`distributions`, `error_info`), where\n        `distributions` is a list of the distributions found in `plugin_env`\n        that were loadable, along with any other distributions that are needed\n        to resolve their dependencies.  `error_info` is a dictionary mapping\n        unloadable plugin distributions to an exception instance describing the\n        error that occurred. Usually this will be a ``DistributionNotFound`` or\n        ``VersionConflict`` instance.\n        ')), Assign(targets=[Name(id='plugin_projects', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='plugin_env', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='plugin_projects', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='error_info', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='distributions', ctx=Store())], value=Dict(keys=[], values=[])), If(test=Compare(left=Name(id='full_env', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='env', ctx=Store())], value=Call(func=Name(id='Environment', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='entries', ctx=Load())], keywords=[])), AugAssign(target=Name(id='env', ctx=Store()), op=Add(), value=Name(id='plugin_env', ctx=Load()))], orelse=[Assign(targets=[Name(id='env', ctx=Store())], value=BinOp(left=Name(id='full_env', ctx=Load()), op=Add(), right=Name(id='plugin_env', ctx=Load())))]), Assign(targets=[Name(id='shadow_set', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='shadow_set', ctx=Load()), attr='add', ctx=Load()), Name(id='self', ctx=Load())], keywords=[])], keywords=[])), For(target=Name(id='project_name', ctx=Store()), iter=Name(id='plugin_projects', ctx=Load()), body=[For(target=Name(id='dist', ctx=Store()), iter=Subscript(value=Name(id='plugin_env', ctx=Load()), slice=Name(id='project_name', ctx=Load()), ctx=Load()), body=[Assign(targets=[Name(id='req', ctx=Store())], value=List(elts=[Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='as_requirement', ctx=Load()), args=[], keywords=[])], ctx=Load())), Try(body=[Assign(targets=[Name(id='resolvees', ctx=Store())], value=Call(func=Attribute(value=Name(id='shadow_set', ctx=Load()), attr='resolve', ctx=Load()), args=[Name(id='req', ctx=Load()), Name(id='env', ctx=Load()), Name(id='installer', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ResolutionError', ctx=Load()), name='v', body=[Assign(targets=[Subscript(value=Name(id='error_info', ctx=Load()), slice=Name(id='dist', ctx=Load()), ctx=Store())], value=Name(id='v', ctx=Load())), If(test=Name(id='fallback', ctx=Load()), body=[Continue()], orelse=[Break()])])], orelse=[Expr(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='shadow_set', ctx=Load()), attr='add', ctx=Load()), Name(id='resolvees', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='distributions', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Name(id='dict', ctx=Load()), attr='fromkeys', ctx=Load()), args=[Name(id='resolvees', ctx=Load())], keywords=[])], keywords=[])), Break()], finalbody=[])], orelse=[])], orelse=[]), Assign(targets=[Name(id='distributions', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='distributions', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='distributions', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[])), Return(value=Tuple(elts=[Name(id='distributions', ctx=Load()), Name(id='error_info', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='require', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='requirements'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Ensure that distributions matching `requirements` are activated\n\n        `requirements` must be a string or a (possibly-nested) sequence\n        thereof, specifying the distributions and versions required.  The\n        return value is a sequence of the distributions that needed to be\n        activated to fulfill the requirements; all relevant distributions are\n        included, even if they were already activated in this working set.\n        ')), Assign(targets=[Name(id='needed', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='resolve', ctx=Load()), args=[Call(func=Name(id='parse_requirements', ctx=Load()), args=[Name(id='requirements', ctx=Load())], keywords=[])], keywords=[])), For(target=Name(id='dist', ctx=Store()), iter=Name(id='needed', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='needed', ctx=Load()))], decorator_list=[]), FunctionDef(name='subscribe', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='callback'), arg(arg='existing')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Invoke `callback` for all distributions\n\n        If `existing=True` (default),\n        call on all existing ones, as well.\n        ')), If(test=Compare(left=Name(id='callback', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='callbacks', ctx=Load())]), body=[Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='callbacks', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='callback', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='existing', ctx=Load())), body=[Return()], orelse=[]), For(target=Name(id='dist', ctx=Store()), iter=Name(id='self', ctx=Load()), body=[Expr(value=Call(func=Name(id='callback', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_added_new', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='callback', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='callbacks', ctx=Load()), body=[Expr(value=Call(func=Name(id='callback', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__getstate__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='entries', ctx=Load()), slice=Slice(), ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='entry_keys', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='by_key', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='normalized_to_canonical_keys', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='callbacks', ctx=Load()), slice=Slice(), ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__setstate__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='e_k_b_n_c')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='entries', ctx=Store()), Name(id='keys', ctx=Store()), Name(id='by_key', ctx=Store()), Name(id='normalized_to_canonical_keys', ctx=Store()), Name(id='callbacks', ctx=Store())], ctx=Store())], value=Name(id='e_k_b_n_c', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='entries', ctx=Store())], value=Subscript(value=Name(id='entries', ctx=Load()), slice=Slice(), ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='entry_keys', ctx=Store())], value=Call(func=Attribute(value=Name(id='keys', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='by_key', ctx=Store())], value=Call(func=Attribute(value=Name(id='by_key', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='normalized_to_canonical_keys', ctx=Store())], value=Call(func=Attribute(value=Name(id='normalized_to_canonical_keys', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callbacks', ctx=Store())], value=Subscript(value=Name(id='callbacks', ctx=Load()), slice=Slice(), ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='_ReqExtras', bases=[Name(id='dict', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Map each requirement to the extras that demanded it.\n    ')), FunctionDef(name='markers_pass', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req'), arg(arg='extras')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Evaluate markers for req against each extra that\n        demanded it.\n\n        Return False if the req has a marker and fails\n        evaluation. Otherwise, return True.\n        ')), Assign(targets=[Name(id='extra_evals', ctx=Store())], value=GeneratorExp(elt=Call(func=Attribute(value=Attribute(value=Name(id='req', ctx=Load()), attr='marker', ctx=Load()), attr='evaluate', ctx=Load()), args=[Dict(keys=[Constant(value='extra')], values=[Name(id='extra', ctx=Load())])], keywords=[]), generators=[comprehension(target=Name(id='extra', ctx=Store()), iter=BinOp(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='req', ctx=Load()), Tuple(elts=[], ctx=Load())], keywords=[]), op=Add(), right=BoolOp(op=Or(), values=[Name(id='extras', ctx=Load()), Tuple(elts=[Constant(value=None)], ctx=Load())])), ifs=[], is_async=0)])), Return(value=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='req', ctx=Load()), attr='marker', ctx=Load())), Call(func=Name(id='any', ctx=Load()), args=[Name(id='extra_evals', ctx=Load())], keywords=[])]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Environment', bases=[], keywords=[], body=[Expr(value=Constant(value='Searchable snapshot of distributions on a search path')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='search_path'), arg(arg='platform'), arg(arg='python')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Call(func=Name(id='get_supported_platform', ctx=Load()), args=[], keywords=[]), Name(id='PY_MAJOR', ctx=Load())]), body=[Expr(value=Constant(value="Snapshot distributions available on a search path\n\n        Any distributions found on `search_path` are added to the environment.\n        `search_path` should be a sequence of ``sys.path`` items.  If not\n        supplied, ``sys.path`` is used.\n\n        `platform` is an optional string specifying the name of the platform\n        that platform-specific distributions must be compatible with.  If\n        unspecified, it defaults to the current platform.  `python` is an\n        optional string naming the desired version of Python (e.g. ``'3.6'``);\n        it defaults to the current version.\n\n        You may explicitly set `platform` (and/or `python`) to ``None`` if you\n        wish to map *all* distributions, not just those compatible with the\n        running platform or Python version.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_distmap', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='platform', ctx=Store())], value=Name(id='platform', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='python', ctx=Store())], value=Name(id='python', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='scan', ctx=Load()), args=[Name(id='search_path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='can_add', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Is distribution `dist` acceptable for this environment?\n\n        The distribution must match the platform and python version\n        requirements specified when this environment was created, or False\n        is returned.\n        ')), Assign(targets=[Name(id='py_compat', ctx=Store())], value=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='python', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='dist', ctx=Load()), attr='py_version', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='dist', ctx=Load()), attr='py_version', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='python', ctx=Load())])])), Return(value=BoolOp(op=And(), values=[Name(id='py_compat', ctx=Load()), Call(func=Name(id='compatible_platforms', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='platform', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='platform', ctx=Load())], keywords=[])]))], decorator_list=[]), FunctionDef(name='remove', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove `dist` from the environment')), Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_distmap', ctx=Load()), slice=Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load()), ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='scan', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='search_path')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Scan `search_path` for distributions usable in this environment\n\n        Any distributions found are added to the environment.\n        `search_path` should be a sequence of ``sys.path`` items.  If not\n        supplied, ``sys.path`` is used.  Only distributions conforming to\n        the platform/python version defined at initialization are added.\n        ')), If(test=Compare(left=Name(id='search_path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='search_path', ctx=Store())], value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()))], orelse=[]), For(target=Name(id='item', ctx=Store()), iter=Name(id='search_path', ctx=Load()), body=[For(target=Name(id='dist', ctx=Store()), iter=Call(func=Name(id='find_distributions', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return a newest-to-oldest list of distributions for `project_name`\n\n        Uses case-insensitive `project_name` comparison, assuming all the\n        project's distributions use their project's name converted to all\n        lowercase as their key.\n\n        ")), Assign(targets=[Name(id='distribution_key', ctx=Store())], value=Call(func=Attribute(value=Name(id='project_name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_distmap', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='distribution_key', ctx=Load()), List(elts=[], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='add', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add `dist` if we ``can_add()`` it and it has not already been added')), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='can_add', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='has_version', ctx=Load()), args=[], keywords=[])]), body=[Assign(targets=[Name(id='dists', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_distmap', ctx=Load()), attr='setdefault', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load()), List(elts=[], ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[NotIn()], comparators=[Name(id='dists', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='dists', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='dists', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='attrgetter', ctx=Load()), args=[Constant(value='hashcmp')], keywords=[])), keyword(arg='reverse', value=Constant(value=True))]))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='best_match', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req'), arg(arg='working_set'), arg(arg='installer'), arg(arg='replace_conflicting')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Find distribution best matching `req` and usable on `working_set`\n\n        This calls the ``find(req)`` method of the `working_set` to see if a\n        suitable distribution is already active.  (This may raise\n        ``VersionConflict`` if an unsuitable version of the project is already\n        active in the specified `working_set`.)  If a suitable distribution\n        isn't active, this method returns the newest distribution in the\n        environment that meets the ``Requirement`` in `req`.  If no suitable\n        distribution is found, and `installer` is supplied, then the result of\n        calling the environment's ``obtain(req, installer)`` method will be\n        returned.\n        ")), Try(body=[Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Name(id='working_set', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='VersionConflict', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Name(id='replace_conflicting', ctx=Load())), body=[Raise()], orelse=[]), Assign(targets=[Name(id='dist', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='dist', ctx=Load()))], orelse=[]), For(target=Name(id='dist', ctx=Store()), iter=Subscript(value=Name(id='self', ctx=Load()), slice=Attribute(value=Name(id='req', ctx=Load()), attr='key', ctx=Load()), ctx=Load()), body=[If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[In()], comparators=[Name(id='req', ctx=Load())]), body=[Return(value=Name(id='dist', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='obtain', ctx=Load()), args=[Name(id='req', ctx=Load()), Name(id='installer', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='obtain', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requirement'), arg(arg='installer')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Obtain a distribution matching `requirement` (e.g. via download)\n\n        Obtain a distro that matches requirement (e.g. via download).  In the\n        base ``Environment`` class, this routine just returns\n        ``installer(requirement)``, unless `installer` is None, in which case\n        None is returned instead.  This method is a hook that allows subclasses\n        to attempt other ways of obtaining a distribution before falling back\n        to the `installer` argument.')), If(test=Compare(left=Name(id='installer', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='installer', ctx=Load()), args=[Name(id='requirement', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Yield the unique project names of the available distributions')), For(target=Name(id='key', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_distmap', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), body=[If(test=Subscript(value=Name(id='self', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), body=[Expr(value=Yield(value=Name(id='key', ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='__iadd__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='In-place addition of a distribution or environment')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Distribution', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Environment', ctx=Load())], keywords=[]), body=[For(target=Name(id='project', ctx=Store()), iter=Name(id='other', ctx=Load()), body=[For(target=Name(id='dist', ctx=Store()), iter=Subscript(value=Name(id='other', ctx=Load()), slice=Name(id='project', ctx=Load()), ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Constant(value="Can't add %r to environment"), op=Mod(), right=Tuple(elts=[Name(id='other', ctx=Load())], ctx=Load()))], keywords=[]))])]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__add__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add an environment or distribution to an environment')), Assign(targets=[Name(id='new', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[keyword(arg='platform', value=Constant(value=None)), keyword(arg='python', value=Constant(value=None))])), For(target=Name(id='env', ctx=Store()), iter=Tuple(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load()), body=[AugAssign(target=Name(id='new', ctx=Store()), op=Add(), value=Name(id='env', ctx=Load()))], orelse=[]), Return(value=Name(id='new', ctx=Load()))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='AvailableDistributions', ctx=Store())], value=Name(id='Environment', ctx=Load())), ClassDef(name='ExtractionError', bases=[Name(id='RuntimeError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='An error occurred extracting a resource\n\n    The following attributes are available from instances of this exception:\n\n    manager\n        The resource manager that raised this exception\n\n    cache_path\n        The base directory for resource extraction\n\n    original_error\n        The exception instance that caused extraction to fail\n    '))], decorator_list=[]), ClassDef(name='ResourceManager', bases=[], keywords=[], body=[Expr(value=Constant(value='Manage resource extraction and packages')), Assign(targets=[Name(id='extraction_path', ctx=Store())], value=Constant(value=None)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='cached_files', ctx=Store())], value=Dict(keys=[], values=[]))], decorator_list=[]), FunctionDef(name='resource_exists', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='package_or_requirement'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Does the named resource exist?')), Return(value=Call(func=Attribute(value=Call(func=Name(id='get_provider', ctx=Load()), args=[Name(id='package_or_requirement', ctx=Load())], keywords=[]), attr='has_resource', ctx=Load()), args=[Name(id='resource_name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='resource_isdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='package_or_requirement'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Is the named resource an existing directory?')), Return(value=Call(func=Attribute(value=Call(func=Name(id='get_provider', ctx=Load()), args=[Name(id='package_or_requirement', ctx=Load())], keywords=[]), attr='resource_isdir', ctx=Load()), args=[Name(id='resource_name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='resource_filename', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='package_or_requirement'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a true filesystem path for specified resource')), Return(value=Call(func=Attribute(value=Call(func=Name(id='get_provider', ctx=Load()), args=[Name(id='package_or_requirement', ctx=Load())], keywords=[]), attr='get_resource_filename', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='resource_stream', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='package_or_requirement'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a readable file-like object for specified resource')), Return(value=Call(func=Attribute(value=Call(func=Name(id='get_provider', ctx=Load()), args=[Name(id='package_or_requirement', ctx=Load())], keywords=[]), attr='get_resource_stream', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='resource_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='package_or_requirement'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return specified resource as a string')), Return(value=Call(func=Attribute(value=Call(func=Name(id='get_provider', ctx=Load()), args=[Name(id='package_or_requirement', ctx=Load())], keywords=[]), attr='get_resource_string', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='resource_listdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='package_or_requirement'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='List the contents of the named resource directory')), Return(value=Call(func=Attribute(value=Call(func=Name(id='get_provider', ctx=Load()), args=[Name(id='package_or_requirement', ctx=Load())], keywords=[]), attr='resource_listdir', ctx=Load()), args=[Name(id='resource_name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='extraction_error', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Give an error message for problems extracting file(s)')), Assign(targets=[Name(id='old_exc', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='exc_info', ctx=Load()), args=[], keywords=[]), slice=Constant(value=1), ctx=Load())), Assign(targets=[Name(id='cache_path', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='extraction_path', ctx=Load()), Call(func=Name(id='get_default_cache', ctx=Load()), args=[], keywords=[])])), Assign(targets=[Name(id='tmpl', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='textwrap', ctx=Load()), attr='dedent', ctx=Load()), args=[Constant(value="\n            Can't extract file(s) to egg cache\n\n            The following error occurred while trying to extract file(s)\n            to the Python egg cache:\n\n              {old_exc}\n\n            The Python egg cache directory is currently set to:\n\n              {cache_path}\n\n            Perhaps your account does not have write access to this directory?\n            You can change the cache directory by setting the PYTHON_EGG_CACHE\n            environment variable to point to an accessible directory.\n            ")], keywords=[]), attr='lstrip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='err', ctx=Store())], value=Call(func=Name(id='ExtractionError', ctx=Load()), args=[Call(func=Attribute(value=Name(id='tmpl', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])], keywords=[])), Assign(targets=[Attribute(value=Name(id='err', ctx=Load()), attr='manager', ctx=Store())], value=Name(id='self', ctx=Load())), Assign(targets=[Attribute(value=Name(id='err', ctx=Load()), attr='cache_path', ctx=Store())], value=Name(id='cache_path', ctx=Load())), Assign(targets=[Attribute(value=Name(id='err', ctx=Load()), attr='original_error', ctx=Store())], value=Name(id='old_exc', ctx=Load())), Raise(exc=Name(id='err', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_cache_path', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='archive_name'), arg(arg='names')], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[], ctx=Load())]), body=[Expr(value=Constant(value='Return absolute location in cache for `archive_name` and `names`\n\n        The parent directory of the resulting path will be created if it does\n        not already exist.  `archive_name` should be the base filename of the\n        enclosing egg (which may not be the name of the enclosing zipfile!),\n        including its ".egg" extension.  `names`, if provided, should be a\n        sequence of path name parts "under" the egg\'s extraction location.\n\n        This method should only be called by resource providers that need to\n        obtain an extraction location, and only for names they intend to\n        extract, as it tracks the generated names for possible cleanup later.\n        ')), Assign(targets=[Name(id='extract_path', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='extraction_path', ctx=Load()), Call(func=Name(id='get_default_cache', ctx=Load()), args=[], keywords=[])])), Assign(targets=[Name(id='target_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='extract_path', ctx=Load()), BinOp(left=Name(id='archive_name', ctx=Load()), op=Add(), right=Constant(value='-tmp')), Starred(value=Name(id='names', ctx=Load()), ctx=Load())], keywords=[])), Try(body=[Expr(value=Call(func=Name(id='_bypass_ensure_directory', ctx=Load()), args=[Name(id='target_path', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='extraction_error', ctx=Load()), args=[], keywords=[]))])], orelse=[], finalbody=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_warn_unsafe_extraction_path', ctx=Load()), args=[Name(id='extract_path', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='cached_files', ctx=Load()), slice=Name(id='target_path', ctx=Load()), ctx=Store())], value=Constant(value=1)), Return(value=Name(id='target_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='_warn_unsafe_extraction_path', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        If the default extraction path is overridden and set to an insecure\n        location, such as /tmp, it opens up an opportunity for an attacker to\n        replace an extracted file with an unauthorized payload. Warn the user\n        if a known insecure location is used.\n\n        See Distribute #375 for more details.\n        ')), If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='os', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='nt')]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='startswith', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Constant(value='windir'), ctx=Load())], keywords=[]))]), body=[Return()], orelse=[]), Assign(targets=[Name(id='mode', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='stat', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), attr='st_mode', ctx=Load())), If(test=BoolOp(op=Or(), values=[BinOp(left=Name(id='mode', ctx=Load()), op=BitAnd(), right=Attribute(value=Name(id='stat', ctx=Load()), attr='S_IWOTH', ctx=Load())), BinOp(left=Name(id='mode', ctx=Load()), op=BitAnd(), right=Attribute(value=Name(id='stat', ctx=Load()), attr='S_IWGRP', ctx=Load()))]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Constant(value='Extraction path is writable by group/others and vulnerable to attack when used with get_resource_filename ({path}). Consider a more secure location (set with .set_extraction_path or the PYTHON_EGG_CACHE environment variable).'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='msg', ctx=Load()), Name(id='UserWarning', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='postprocess', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tempname'), arg(arg='filename')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Perform any platform-specific postprocessing of `tempname`\n\n        This is where Mac header rewrites should be done; other platforms don't\n        have anything special they should do.\n\n        Resource providers should call this method ONLY after successfully\n        extracting a compressed resource.  They must NOT call it on resources\n        that are already in the filesystem.\n\n        `tempname` is the current (temporary) name of the file, and `filename`\n        is the name it will be renamed to by the caller after this routine\n        returns.\n        ")), If(test=Compare(left=Attribute(value=Name(id='os', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='posix')]), body=[Assign(targets=[Name(id='mode', ctx=Store())], value=BinOp(left=BinOp(left=Attribute(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='stat', ctx=Load()), args=[Name(id='tempname', ctx=Load())], keywords=[]), attr='st_mode', ctx=Load()), op=BitOr(), right=Constant(value=365)), op=BitAnd(), right=Constant(value=4095))), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='chmod', ctx=Load()), args=[Name(id='tempname', ctx=Load()), Name(id='mode', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='set_extraction_path', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Set the base path where resources will be extracted to, if needed.\n\n        If you do not call this routine before any extractions take place, the\n        path defaults to the return value of ``get_default_cache()``.  (Which\n        is based on the ``PYTHON_EGG_CACHE`` environment variable, with various\n        platform-specific fallbacks.  See that routine's documentation for more\n        details.)\n\n        Resources are extracted to subdirectories of this path based upon\n        information given by the ``IResourceProvider``.  You may set this to a\n        temporary directory, but then you must call ``cleanup_resources()`` to\n        delete the extracted files when done.  There is no guarantee that\n        ``cleanup_resources()`` will be able to remove all extracted files.\n\n        (Note: you may not change the extraction path for a given resource\n        manager once resources have been extracted, unless you first call\n        ``cleanup_resources()``.)\n        ")), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='cached_files', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Can't change extraction path, files already extracted")], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='extraction_path', ctx=Store())], value=Name(id='path', ctx=Load()))], decorator_list=[]), FunctionDef(name='cleanup_resources', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='force')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n        Delete all extracted resource files and directories, returning a list\n        of the file and directory names that could not be successfully removed.\n        This function does not have any concurrency protection, so it should\n        generally only be called when the extraction path is a temporary\n        directory exclusive to a single process.  This method is not\n        automatically called; you must call it explicitly or register it as an\n        ``atexit`` function if you wish to ensure cleanup of a temporary\n        directory used for extractions.\n        '))], decorator_list=[])], decorator_list=[]), FunctionDef(name='get_default_cache', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return the ``PYTHON_EGG_CACHE`` environment variable\n    or a platform-relevant user cache dir for an app\n    named "Python-Eggs".\n    ')), Return(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='PYTHON_EGG_CACHE')], keywords=[]), Call(func=Attribute(value=Name(id='platformdirs', ctx=Load()), attr='user_cache_dir', ctx=Load()), args=[], keywords=[keyword(arg='appname', value=Constant(value='Python-Eggs'))])]))], decorator_list=[]), FunctionDef(name='safe_name', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Convert an arbitrary string to a standard distribution name\n\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    ")), Return(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='[^A-Za-z0-9.]+'), Constant(value='-'), Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='safe_version', args=arguments(posonlyargs=[], args=[arg(arg='version')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Convert an arbitrary string to a standard version string\n    ')), Try(body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='version', ctx=Load()), attr='Version', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='version', ctx=Load()), attr='InvalidVersion', ctx=Load()), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Attribute(value=Name(id='version', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=' '), Constant(value='.')], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='[^A-Za-z0-9.]+'), Constant(value='-'), Name(id='version', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='_forgiving_version', args=arguments(posonlyargs=[], args=[arg(arg='version')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Fallback when ``safe_version`` is not safe enough\n    >>> parse_version(_forgiving_version('0.23ubuntu1'))\n    <Version('0.23.dev0+sanitized.ubuntu1')>\n    >>> parse_version(_forgiving_version('0.23-'))\n    <Version('0.23.dev0+sanitized')>\n    >>> parse_version(_forgiving_version('0.-_'))\n    <Version('0.dev0+sanitized')>\n    >>> parse_version(_forgiving_version('42.+?1'))\n    <Version('42.dev0+sanitized.1')>\n    >>> parse_version(_forgiving_version('hello world'))\n    <Version('0.dev0+sanitized.hello.world')>\n    ")), Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Attribute(value=Name(id='version', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=' '), Constant(value='.')], keywords=[])), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='_PEP440_FALLBACK', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Assign(targets=[Name(id='safe', ctx=Store())], value=Subscript(value=Name(id='match', ctx=Load()), slice=Constant(value='safe'), ctx=Load())), Assign(targets=[Name(id='rest', ctx=Store())], value=Subscript(value=Name(id='version', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='safe', ctx=Load())], keywords=[])), ctx=Load()))], orelse=[Assign(targets=[Name(id='safe', ctx=Store())], value=Constant(value='0')), Assign(targets=[Name(id='rest', ctx=Store())], value=Name(id='version', ctx=Load()))]), Assign(targets=[Name(id='local', ctx=Store())], value=Call(func=Attribute(value=JoinedStr(values=[Constant(value='sanitized.'), FormattedValue(value=Call(func=Name(id='_safe_segment', ctx=Load()), args=[Name(id='rest', ctx=Load())], keywords=[]), conversion=-1)]), attr='strip', ctx=Load()), args=[Constant(value='.')], keywords=[])), Return(value=JoinedStr(values=[FormattedValue(value=Name(id='safe', ctx=Load()), conversion=-1), Constant(value='.dev0+'), FormattedValue(value=Name(id='local', ctx=Load()), conversion=-1)]))], decorator_list=[]), FunctionDef(name='_safe_segment', args=arguments(posonlyargs=[], args=[arg(arg='segment')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Convert an arbitrary string into a safe segment')), Assign(targets=[Name(id='segment', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='[^A-Za-z0-9.]+'), Constant(value='-'), Name(id='segment', ctx=Load())], keywords=[])), Assign(targets=[Name(id='segment', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='-[^A-Za-z0-9]+'), Constant(value='-'), Name(id='segment', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='\\.[^A-Za-z0-9]+'), Constant(value='.'), Name(id='segment', ctx=Load())], keywords=[]), attr='strip', ctx=Load()), args=[Constant(value='.-')], keywords=[]))], decorator_list=[]), FunctionDef(name='safe_extra', args=arguments(posonlyargs=[], args=[arg(arg='extra')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Convert an arbitrary string to a standard 'extra' name\n\n    Any runs of non-alphanumeric characters are replaced with a single '_',\n    and the result is always lowercased.\n    ")), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='[^A-Za-z0-9.-]+'), Constant(value='_'), Name(id='extra', ctx=Load())], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='to_filename', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Convert a project or version name to its filename-escaped form\n\n    Any '-' characters are currently replaced with '_'.\n    ")), Return(value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='_')], keywords=[]))], decorator_list=[]), FunctionDef(name='invalid_marker', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Validate text as a PEP 508 environment marker; return an exception\n    if invalid or False otherwise.\n    ')), Try(body=[Expr(value=Call(func=Name(id='evaluate_marker', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='SyntaxError', ctx=Load()), name='e', body=[Assign(targets=[Attribute(value=Name(id='e', ctx=Load()), attr='filename', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='e', ctx=Load()), attr='lineno', ctx=Store())], value=Constant(value=None)), Return(value=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='evaluate_marker', args=arguments(posonlyargs=[], args=[arg(arg='text'), arg(arg='extra')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n    Evaluate a PEP 508 environment marker.\n    Return a boolean indicating the marker result in this environment.\n    Raise SyntaxError if marker is invalid.\n\n    This implementation uses the 'pyparsing' module.\n    ")), Try(body=[Assign(targets=[Name(id='marker', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='markers', ctx=Load()), attr='Marker', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='marker', ctx=Load()), attr='evaluate', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='markers', ctx=Load()), attr='InvalidMarker', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='SyntaxError', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), ClassDef(name='NullProvider', bases=[], keywords=[], body=[Expr(value=Constant(value='Try to implement resources and metadata for arbitrary PEP 302 loaders')), Assign(targets=[Name(id='egg_name', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='egg_info', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='loader', ctx=Store())], value=Constant(value=None)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='module')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='module', ctx=Load()), Constant(value='__loader__'), Constant(value=None)], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='module', ctx=Load()), Constant(value='__file__'), Constant(value='')], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='get_resource_filename', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='manager'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_resource_stream', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='manager'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='io', ctx=Load()), attr='BytesIO', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_resource_string', ctx=Load()), args=[Name(id='manager', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='get_resource_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='manager'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='has_resource', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_has', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_get_metadata_path', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='has_metadata', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Load())), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_metadata_path', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_has', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_metadata', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Load())), body=[Return(value=Constant(value=''))], orelse=[]), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_metadata_path', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Try(body=[Return(value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[]))], handlers=[ExceptHandler(type=Name(id='UnicodeDecodeError', ctx=Load()), name='exc', body=[AugAssign(target=Attribute(value=Name(id='exc', ctx=Load()), attr='reason', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Constant(value=' in {} file at path: {}'), attr='format', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='path', ctx=Load())], keywords=[])), Raise()])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='get_metadata_lines', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='yield_lines', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_metadata', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='resource_isdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_isdir', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='metadata_isdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_isdir', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])], keywords=[])]))], decorator_list=[]), FunctionDef(name='resource_listdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_listdir', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='metadata_listdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_listdir', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=List(elts=[], ctx=Load()))], decorator_list=[]), FunctionDef(name='run_script', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='script_name'), arg(arg='namespace')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='script', ctx=Store())], value=BinOp(left=Constant(value='scripts/'), op=Add(), right=Name(id='script_name', ctx=Load()))), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='has_metadata', ctx=Load()), args=[Name(id='script', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ResolutionError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Script {script!r} not found in metadata at {self.egg_info!r}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='script_text', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_metadata', ctx=Load()), args=[Name(id='script', ctx=Load())], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='\r\n'), Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='script_text', ctx=Store())], value=Call(func=Attribute(value=Name(id='script_text', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='\r'), Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='script_filename', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Load()), Name(id='script', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='namespace', ctx=Load()), slice=Constant(value='__file__'), ctx=Store())], value=Name(id='script_filename', ctx=Load())), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='script_filename', ctx=Load())], keywords=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='script_filename', ctx=Load())], keywords=[]), optional_vars=Name(id='fid', ctx=Store()))], body=[Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Attribute(value=Name(id='fid', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='code', ctx=Store())], value=Call(func=Name(id='compile', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='script_filename', ctx=Load()), Constant(value='exec')], keywords=[])), Expr(value=Call(func=Name(id='exec', ctx=Load()), args=[Name(id='code', ctx=Load()), Name(id='namespace', ctx=Load()), Name(id='namespace', ctx=Load())], keywords=[]))], orelse=[ImportFrom(module='linecache', names=[alias(name='cache')], level=0), Assign(targets=[Subscript(value=Name(id='cache', ctx=Load()), slice=Name(id='script_filename', ctx=Load()), ctx=Store())], value=Tuple(elts=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='script_text', ctx=Load())], keywords=[]), Constant(value=0), Call(func=Attribute(value=Name(id='script_text', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[]), Name(id='script_filename', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='script_code', ctx=Store())], value=Call(func=Name(id='compile', ctx=Load()), args=[Name(id='script_text', ctx=Load()), Name(id='script_filename', ctx=Load()), Constant(value='exec')], keywords=[])), Expr(value=Call(func=Name(id='exec', ctx=Load()), args=[Name(id='script_code', ctx=Load()), Name(id='namespace', ctx=Load()), Name(id='namespace', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='_has', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value="Can't perform this operation for unregistered loader type")], keywords=[]))], decorator_list=[]), FunctionDef(name='_isdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value="Can't perform this operation for unregistered loader type")], keywords=[]))], decorator_list=[]), FunctionDef(name='_listdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value="Can't perform this operation for unregistered loader type")], keywords=[]))], decorator_list=[]), FunctionDef(name='_fn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='base'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_resource_path', ctx=Load()), args=[Name(id='resource_name', ctx=Load())], keywords=[])), If(test=Name(id='resource_name', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='base', ctx=Load()), Starred(value=Call(func=Attribute(value=Name(id='resource_name', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='/')], keywords=[]), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='base', ctx=Load()))], decorator_list=[]), FunctionDef(name='_validate_resource_path', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Validate the resource paths according to the docs.\n        https://setuptools.pypa.io/en/latest/pkg_resources.html#basic-resource-access\n\n        >>> warned = getfixture('recwarn')\n        >>> warnings.simplefilter('always')\n        >>> vrp = NullProvider._validate_resource_path\n        >>> vrp('foo/bar.txt')\n        >>> bool(warned)\n        False\n        >>> vrp('../foo/bar.txt')\n        >>> bool(warned)\n        True\n        >>> warned.clear()\n        >>> vrp('/foo/bar.txt')\n        >>> bool(warned)\n        True\n        >>> vrp('foo/../../bar.txt')\n        >>> bool(warned)\n        True\n        >>> warned.clear()\n        >>> vrp('foo/f../bar.txt')\n        >>> bool(warned)\n        False\n\n        Windows path separators are straight-up disallowed.\n        >>> vrp(r'\\foo/bar.txt')\n        Traceback (most recent call last):\n        ...\n        ValueError: Use of .. or absolute path in a resource path is not allowed.\n\n        >>> vrp(r'C:\\foo/bar.txt')\n        Traceback (most recent call last):\n        ...\n        ValueError: Use of .. or absolute path in a resource path is not allowed.\n\n        Blank values are allowed\n\n        >>> vrp('')\n        >>> bool(warned)\n        False\n\n        Non-string values are not.\n\n        >>> vrp(None)\n        Traceback (most recent call last):\n        ...\n        AttributeError: ...\n        ")), Assign(targets=[Name(id='invalid', ctx=Store())], value=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='pardir', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='split', ctx=Load()), args=[Attribute(value=Name(id='posixpath', ctx=Load()), attr='sep', ctx=Load())], keywords=[])]), Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='isabs', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='ntpath', ctx=Load()), attr='isabs', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])])), If(test=UnaryOp(op=Not(), operand=Name(id='invalid', ctx=Load())), body=[Return()], orelse=[]), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Use of .. or absolute path in a resource path is not allowed.')), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='ntpath', ctx=Load()), attr='isabs', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='isabs', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='issue_warning', ctx=Load()), args=[BinOp(left=Subscript(value=Name(id='msg', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), op=Add(), right=Constant(value=' and will raise exceptions in a future release.')), Name(id='DeprecationWarning', ctx=Load())], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_get', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), Constant(value='get_data')], keywords=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), attr='get_data', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], orelse=[]), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value="Can't perform this operation for loaders without 'get_data()'")], keywords=[]))], decorator_list=[])], decorator_list=[]), Expr(value=Call(func=Name(id='register_loader_type', ctx=Load()), args=[Name(id='object', ctx=Load()), Name(id='NullProvider', ctx=Load())], keywords=[])), FunctionDef(name='_parents', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    yield all parents of path including path\n    ')), Assign(targets=[Name(id='last', ctx=Store())], value=Constant(value=None)), While(test=Compare(left=Name(id='path', ctx=Load()), ops=[NotEq()], comparators=[Name(id='last', ctx=Load())]), body=[Expr(value=Yield(value=Name(id='path', ctx=Load()))), Assign(targets=[Name(id='last', ctx=Store())], value=Name(id='path', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='path', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), ClassDef(name='EggProvider', bases=[Name(id='NullProvider', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Provider based on a virtual filesystem')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='module')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_setup_prefix', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_setup_prefix', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='eggs', ctx=Store())], value=Call(func=Name(id='filter', ctx=Load()), args=[Name(id='_is_egg_path', ctx=Load()), Call(func=Name(id='_parents', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='egg', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='eggs', ctx=Load()), Constant(value=None)], keywords=[])), Expr(value=BoolOp(op=And(), values=[Name(id='egg', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_set_egg', ctx=Load()), args=[Name(id='egg', ctx=Load())], keywords=[])]))], decorator_list=[]), FunctionDef(name='_set_egg', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='EGG-INFO')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_root', ctx=Store())], value=Name(id='path', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='DefaultProvider', bases=[Name(id='EggProvider', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Provides access to package resources in the filesystem')), FunctionDef(name='_has', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_isdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_listdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_resource_stream', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='manager'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='open', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[]), Constant(value='rb')], keywords=[]))], decorator_list=[]), FunctionDef(name='_get', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='stream', ctx=Store()))], body=[Return(value=Call(func=Attribute(value=Name(id='stream', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='_register', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='loader_names', ctx=Store())], value=Tuple(elts=[Constant(value='SourceFileLoader'), Constant(value='SourcelessFileLoader')], ctx=Load())), For(target=Name(id='name', ctx=Store()), iter=Name(id='loader_names', ctx=Load()), body=[Assign(targets=[Name(id='loader_cls', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='importlib_machinery', ctx=Load()), Name(id='name', ctx=Load()), Call(func=Name(id='type', ctx=Load()), args=[Constant(value=None)], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='register_loader_type', ctx=Load()), args=[Name(id='loader_cls', ctx=Load()), Name(id='cls', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[Name(id='classmethod', ctx=Load())])], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='DefaultProvider', ctx=Load()), attr='_register', ctx=Load()), args=[], keywords=[])), ClassDef(name='EmptyProvider', bases=[Name(id='NullProvider', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Provider that returns nothing for all requests')), Assign(targets=[Name(id='module_path', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='_isdir', ctx=Store()), Name(id='_has', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=False))), FunctionDef(name='_get', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=''))], decorator_list=[]), FunctionDef(name='_listdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=List(elts=[], ctx=Load()))], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='empty_provider', ctx=Store())], value=Call(func=Name(id='EmptyProvider', ctx=Load()), args=[], keywords=[])), ClassDef(name='ZipManifests', bases=[Name(id='dict', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    zip manifest builder\n    ')), FunctionDef(name='build', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Build a dictionary similar to the zipimport directory\n        caches, except instead of tuples, store ZipInfo objects.\n\n        Use a platform-specific path separator (os.sep) for the path keys\n        for compatibility with pypy on Windows.\n        ')), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), optional_vars=Name(id='zfile', ctx=Store()))], body=[Assign(targets=[Name(id='items', ctx=Store())], value=GeneratorExp(elt=Tuple(elts=[Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='/'), Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='zfile', ctx=Load()), attr='getinfo', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])], ctx=Load()), generators=[comprehension(target=Name(id='name', ctx=Store()), iter=Call(func=Attribute(value=Name(id='zfile', ctx=Load()), attr='namelist', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Return(value=Call(func=Name(id='dict', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]))])], decorator_list=[Name(id='classmethod', ctx=Load())]), Assign(targets=[Name(id='load', ctx=Store())], value=Name(id='build', ctx=Load()))], decorator_list=[]), ClassDef(name='MemoizedZipManifests', bases=[Name(id='ZipManifests', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Memoized zipfile manifests.\n    ')), Assign(targets=[Name(id='manifest_mod', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='namedtuple', ctx=Load()), args=[Constant(value='manifest_mod'), Constant(value='manifest mtime')], keywords=[])), FunctionDef(name='load', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Load a manifest at path or return a suitable manifest already loaded.\n        ')), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='mtime', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='stat', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), attr='st_mtime', ctx=Load())), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='path', ctx=Load()), ops=[NotIn()], comparators=[Name(id='self', ctx=Load())]), Compare(left=Attribute(value=Subscript(value=Name(id='self', ctx=Load()), slice=Name(id='path', ctx=Load()), ctx=Load()), attr='mtime', ctx=Load()), ops=[NotEq()], comparators=[Name(id='mtime', ctx=Load())])]), body=[Assign(targets=[Name(id='manifest', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='self', ctx=Load()), slice=Name(id='path', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='manifest_mod', ctx=Load()), args=[Name(id='manifest', ctx=Load()), Name(id='mtime', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Attribute(value=Subscript(value=Name(id='self', ctx=Load()), slice=Name(id='path', ctx=Load()), ctx=Load()), attr='manifest', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='ZipProvider', bases=[Name(id='EggProvider', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Resource support for zips and eggs')), Assign(targets=[Name(id='eagers', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='_zip_manifests', ctx=Store())], value=Call(func=Name(id='MemoizedZipManifests', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='module')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='zip_pre', ctx=Store())], value=BinOp(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), attr='archive', ctx=Load()), op=Add(), right=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())))], decorator_list=[]), FunctionDef(name='_zipinfo_name', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fspath')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='fspath', ctx=Store())], value=Call(func=Attribute(value=Name(id='fspath', ctx=Load()), attr='rstrip', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='fspath', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), attr='archive', ctx=Load())]), body=[Return(value=Constant(value=''))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='fspath', ctx=Load()), attr='startswith', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='zip_pre', ctx=Load())], keywords=[]), body=[Return(value=Subscript(value=Name(id='fspath', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='zip_pre', ctx=Load())], keywords=[])), ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[BinOp(left=Constant(value='%s is not a subpath of %s'), op=Mod(), right=Tuple(elts=[Name(id='fspath', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='zip_pre', ctx=Load())], ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='_parts', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='zip_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='fspath', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='zip_pre', ctx=Load()), op=Add(), right=Name(id='zip_path', ctx=Load()))), If(test=Call(func=Attribute(value=Name(id='fspath', ctx=Load()), attr='startswith', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='egg_root', ctx=Load()), op=Add(), right=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()))], keywords=[]), body=[Return(value=Call(func=Attribute(value=Subscript(value=Name(id='fspath', ctx=Load()), slice=Slice(lower=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_root', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))), ctx=Load()), attr='split', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())], keywords=[]))], orelse=[]), Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[BinOp(left=Constant(value='%s is not a subpath of %s'), op=Mod(), right=Tuple(elts=[Name(id='fspath', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='egg_root', ctx=Load())], ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='zipinfo', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_zip_manifests', ctx=Load()), attr='load', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), attr='archive', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='get_resource_filename', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='manager'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='egg_name', ctx=Load())), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value='resource_filename() only supported for .egg, not .zip')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='zip_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_resource_to_zip', ctx=Load()), args=[Name(id='resource_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eagers', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eager_resources', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Constant(value='/'), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parts', ctx=Load()), args=[Name(id='zip_path', ctx=Load())], keywords=[])], keywords=[]), ops=[In()], comparators=[Name(id='eagers', ctx=Load())]), body=[For(target=Name(id='name', ctx=Store()), iter=Name(id='eagers', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_extract_resource', ctx=Load()), args=[Name(id='manager', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_eager_to_zip', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_extract_resource', ctx=Load()), args=[Name(id='manager', ctx=Load()), Name(id='zip_path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_get_date_and_size', args=arguments(posonlyargs=[], args=[arg(arg='zip_stat')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='size', ctx=Store())], value=Attribute(value=Name(id='zip_stat', ctx=Load()), attr='file_size', ctx=Load())), Assign(targets=[Name(id='date_time', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='zip_stat', ctx=Load()), attr='date_time', ctx=Load()), op=Add(), right=Tuple(elts=[Constant(value=0), Constant(value=0), UnaryOp(op=USub(), operand=Constant(value=1))], ctx=Load()))), Assign(targets=[Name(id='timestamp', ctx=Store())], value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='mktime', ctx=Load()), args=[Name(id='date_time', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='timestamp', ctx=Load()), Name(id='size', ctx=Load())], ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_extract_resource', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='manager'), arg(arg='zip_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='zip_path', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Load()), args=[], keywords=[])]), body=[For(target=Name(id='name', ctx=Store()), iter=Subscript(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Load()), args=[], keywords=[]), slice=Name(id='zip_path', ctx=Load()), ctx=Load()), body=[Assign(targets=[Name(id='last', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_extract_resource', ctx=Load()), args=[Name(id='manager', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='zip_path', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='last', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='timestamp', ctx=Store()), Name(id='size', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_date_and_size', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='zipinfo', ctx=Load()), slice=Name(id='zip_path', ctx=Load()), ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='WRITE_SUPPORT', ctx=Load())), body=[Raise(exc=Call(func=Name(id='IOError', ctx=Load()), args=[Constant(value='"os.rename" and "os.unlink" are not supported on this platform')], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Name(id='real_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='manager', ctx=Load()), attr='get_cache_path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_name', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parts', ctx=Load()), args=[Name(id='zip_path', ctx=Load())], keywords=[])], keywords=[])), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_is_current', ctx=Load()), args=[Name(id='real_path', ctx=Load()), Name(id='zip_path', ctx=Load())], keywords=[]), body=[Return(value=Name(id='real_path', ctx=Load()))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='outf', ctx=Store()), Name(id='tmpnam', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_mkstemp', ctx=Load()), args=[Constant(value='.$extract')], keywords=[keyword(arg='dir', value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='real_path', ctx=Load())], keywords=[]))])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='outf', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), attr='get_data', ctx=Load()), args=[Name(id='zip_path', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='close', ctx=Load()), args=[Name(id='outf', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='utime', ctx=Load()), args=[Name(id='tmpnam', ctx=Load()), Tuple(elts=[Name(id='timestamp', ctx=Load()), Name(id='timestamp', ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='manager', ctx=Load()), attr='postprocess', ctx=Load()), args=[Name(id='tmpnam', ctx=Load()), Name(id='real_path', ctx=Load())], keywords=[])), Try(body=[Expr(value=Call(func=Name(id='rename', ctx=Load()), args=[Name(id='tmpnam', ctx=Load()), Name(id='real_path', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='os', ctx=Load()), attr='error', ctx=Load()), body=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='real_path', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_is_current', ctx=Load()), args=[Name(id='real_path', ctx=Load()), Name(id='zip_path', ctx=Load())], keywords=[]), body=[Return(value=Name(id='real_path', ctx=Load()))], orelse=[If(test=Compare(left=Attribute(value=Name(id='os', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='nt')]), body=[Expr(value=Call(func=Name(id='unlink', ctx=Load()), args=[Name(id='real_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='rename', ctx=Load()), args=[Name(id='tmpnam', ctx=Load()), Name(id='real_path', ctx=Load())], keywords=[])), Return(value=Name(id='real_path', ctx=Load()))], orelse=[])])], orelse=[]), Raise()])], orelse=[], finalbody=[])], handlers=[ExceptHandler(type=Attribute(value=Name(id='os', ctx=Load()), attr='error', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='manager', ctx=Load()), attr='extraction_error', ctx=Load()), args=[], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Name(id='real_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='_is_current', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='file_path'), arg(arg='zip_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return True if the file_path is current for this zip_path\n        ')), Assign(targets=[Tuple(elts=[Name(id='timestamp', ctx=Store()), Name(id='size', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_date_and_size', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='zipinfo', ctx=Load()), slice=Name(id='zip_path', ctx=Load()), ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='stat', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='stat', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='stat', ctx=Load()), attr='st_size', ctx=Load()), ops=[NotEq()], comparators=[Name(id='size', ctx=Load())]), Compare(left=Attribute(value=Name(id='stat', ctx=Load()), attr='st_mtime', ctx=Load()), ops=[NotEq()], comparators=[Name(id='timestamp', ctx=Load())])]), body=[Return(value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='zip_contents', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), attr='get_data', ctx=Load()), args=[Name(id='zip_path', ctx=Load())], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='file_contents', ctx=Store())], value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Return(value=Compare(left=Name(id='zip_contents', ctx=Load()), ops=[Eq()], comparators=[Name(id='file_contents', ctx=Load())]))], decorator_list=[]), FunctionDef(name='_get_eager_resources', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='eagers', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='eagers', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='name', ctx=Store()), iter=Tuple(elts=[Constant(value='native_libs.txt'), Constant(value='eager_resources.txt')], ctx=Load()), body=[If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='has_metadata', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='eagers', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_metadata_lines', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='eagers', ctx=Store())], value=Name(id='eagers', ctx=Load()))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='eagers', ctx=Load()))], decorator_list=[]), FunctionDef(name='_index', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_dirindex', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Assign(targets=[Name(id='ind', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='path', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='zipinfo', ctx=Load()), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='split', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())], keywords=[])), While(test=Name(id='parts', ctx=Load()), body=[Assign(targets=[Name(id='parent', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), attr='join', ctx=Load()), args=[Subscript(value=Name(id='parts', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='parent', ctx=Load()), ops=[In()], comparators=[Name(id='ind', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='ind', ctx=Load()), slice=Name(id='parent', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='parts', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], keywords=[])), Break()], orelse=[Assign(targets=[Subscript(value=Name(id='ind', ctx=Load()), slice=Name(id='parent', ctx=Load()), ctx=Store())], value=List(elts=[Call(func=Attribute(value=Name(id='parts', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[])], ctx=Load()))])], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_dirindex', ctx=Store())], value=Name(id='ind', ctx=Load())), Return(value=Name(id='ind', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='_has', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fspath')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='zip_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_zipinfo_name', ctx=Load()), args=[Name(id='fspath', ctx=Load())], keywords=[])), Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='zip_path', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='zipinfo', ctx=Load())]), Compare(left=Name(id='zip_path', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Load()), args=[], keywords=[])])]))], decorator_list=[]), FunctionDef(name='_isdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fspath')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_zipinfo_name', ctx=Load()), args=[Name(id='fspath', ctx=Load())], keywords=[]), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Load()), args=[], keywords=[])]))], decorator_list=[]), FunctionDef(name='_listdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fspath')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Load()), args=[], keywords=[]), attr='get', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_zipinfo_name', ctx=Load()), args=[Name(id='fspath', ctx=Load())], keywords=[]), Tuple(elts=[], ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_eager_to_zip', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_zipinfo_name', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_root', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_resource_to_zip', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resource_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_zipinfo_name', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Load()), Name(id='resource_name', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[])], decorator_list=[]), Expr(value=Call(func=Name(id='register_loader_type', ctx=Load()), args=[Attribute(value=Name(id='zipimport', ctx=Load()), attr='zipimporter', ctx=Load()), Name(id='ZipProvider', ctx=Load())], keywords=[])), ClassDef(name='FileMetadata', bases=[Name(id='EmptyProvider', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Metadata handler for standalone PKG-INFO files\n\n    Usage::\n\n        metadata = FileMetadata("/path/to/PKG-INFO")\n\n    This provider rejects all data and metadata requests except for PKG-INFO,\n    which is treated as existing, and will be the contents of the file at\n    the provided location.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Store())], value=Name(id='path', ctx=Load()))], decorator_list=[]), FunctionDef(name='_get_metadata_path', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()))], decorator_list=[]), FunctionDef(name='has_metadata', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='PKG-INFO')]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[])]))], decorator_list=[]), FunctionDef(name='get_metadata', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='PKG-INFO')]), body=[Raise(exc=Call(func=Name(id='KeyError', ctx=Load()), args=[Constant(value='No metadata except PKG-INFO is available')], keywords=[]))], orelse=[]), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='io', ctx=Load()), attr='open', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[keyword(arg='encoding', value=Constant(value='utf-8')), keyword(arg='errors', value=Constant(value='replace'))]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_warn_on_replacement', ctx=Load()), args=[Name(id='metadata', ctx=Load())], keywords=[])), Return(value=Name(id='metadata', ctx=Load()))], decorator_list=[]), FunctionDef(name='_warn_on_replacement', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='metadata')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='replacement_char', ctx=Store())], value=Constant(value='�')), If(test=Compare(left=Name(id='replacement_char', ctx=Load()), ops=[In()], comparators=[Name(id='metadata', ctx=Load())]), body=[Assign(targets=[Name(id='tmpl', ctx=Store())], value=Constant(value='{self.path} could not be properly decoded in UTF-8')), Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Name(id='tmpl', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='get_metadata_lines', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='yield_lines', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_metadata', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='PathMetadata', bases=[Name(id='DefaultProvider', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Metadata provider for egg directories\n\n    Usage::\n\n        # Development eggs:\n\n        egg_info = "/path/to/PackageName.egg-info"\n        base_dir = os.path.dirname(egg_info)\n        metadata = PathMetadata(base_dir, egg_info)\n        dist_name = os.path.splitext(os.path.basename(egg_info))[0]\n        dist = Distribution(basedir, project_name=dist_name, metadata=metadata)\n\n        # Unpacked egg directories:\n\n        egg_path = "/path/to/PackageName-ver-pyver-etc.egg"\n        metadata = PathMetadata(egg_path, os.path.join(egg_path,\'EGG-INFO\'))\n        dist = Distribution.from_filename(egg_path, metadata=metadata)\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path'), arg(arg='egg_info')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Store())], value=Name(id='path', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_info', ctx=Store())], value=Name(id='egg_info', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='EggMetadata', bases=[Name(id='ZipProvider', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Metadata provider for .egg files')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='importer')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a metadata provider from a zipimporter')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='zip_pre', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='importer', ctx=Load()), attr='archive', ctx=Load()), op=Add(), right=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Store())], value=Name(id='importer', ctx=Load())), If(test=Attribute(value=Name(id='importer', ctx=Load()), attr='prefix', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='importer', ctx=Load()), attr='archive', ctx=Load()), Attribute(value=Name(id='importer', ctx=Load()), attr='prefix', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='module_path', ctx=Store())], value=Attribute(value=Name(id='importer', ctx=Load()), attr='archive', ctx=Load()))]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_setup_prefix', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], decorator_list=[]), Expr(value=Call(func=Name(id='_declare_state', ctx=Load()), args=[Constant(value='dict')], keywords=[keyword(arg='_distribution_finders', value=Dict(keys=[], values=[]))])), FunctionDef(name='register_finder', args=arguments(posonlyargs=[], args=[arg(arg='importer_type'), arg(arg='distribution_finder')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Register `distribution_finder` to find distributions in sys.path items\n\n    `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item\n    handler), and `distribution_finder` is a callable that, passed a path\n    item and the importer instance, yields ``Distribution`` instances found on\n    that path item.  See ``pkg_resources.find_on_path`` for an example.')), Assign(targets=[Subscript(value=Name(id='_distribution_finders', ctx=Load()), slice=Name(id='importer_type', ctx=Load()), ctx=Store())], value=Name(id='distribution_finder', ctx=Load()))], decorator_list=[]), FunctionDef(name='find_distributions', args=arguments(posonlyargs=[], args=[arg(arg='path_item'), arg(arg='only')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Yield distributions accessible via `path_item`')), Assign(targets=[Name(id='importer', ctx=Store())], value=Call(func=Name(id='get_importer', ctx=Load()), args=[Name(id='path_item', ctx=Load())], keywords=[])), Assign(targets=[Name(id='finder', ctx=Store())], value=Call(func=Name(id='_find_adapter', ctx=Load()), args=[Name(id='_distribution_finders', ctx=Load()), Name(id='importer', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='finder', ctx=Load()), args=[Name(id='importer', ctx=Load()), Name(id='path_item', ctx=Load()), Name(id='only', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='find_eggs_in_zip', args=arguments(posonlyargs=[], args=[arg(arg='importer'), arg(arg='path_item'), arg(arg='only')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Find eggs in zip files; possibly multiple nested eggs.\n    ')), If(test=Call(func=Attribute(value=Attribute(value=Name(id='importer', ctx=Load()), attr='archive', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.whl')], keywords=[]), body=[Return()], orelse=[]), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='EggMetadata', ctx=Load()), args=[Name(id='importer', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='has_metadata', ctx=Load()), args=[Constant(value='PKG-INFO')], keywords=[]), body=[Expr(value=Yield(value=Call(func=Attribute(value=Name(id='Distribution', ctx=Load()), attr='from_filename', ctx=Load()), args=[Name(id='path_item', ctx=Load())], keywords=[keyword(arg='metadata', value=Name(id='metadata', ctx=Load()))])))], orelse=[]), If(test=Name(id='only', ctx=Load()), body=[Return()], orelse=[]), For(target=Name(id='subitem', ctx=Store()), iter=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='resource_listdir', ctx=Load()), args=[Constant(value='')], keywords=[]), body=[If(test=Call(func=Name(id='_is_egg_path', ctx=Load()), args=[Name(id='subitem', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='subpath', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path_item', ctx=Load()), Name(id='subitem', ctx=Load())], keywords=[])), Assign(targets=[Name(id='dists', ctx=Store())], value=Call(func=Name(id='find_eggs_in_zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='zipimport', ctx=Load()), attr='zipimporter', ctx=Load()), args=[Name(id='subpath', ctx=Load())], keywords=[]), Name(id='subpath', ctx=Load())], keywords=[])), For(target=Name(id='dist', ctx=Store()), iter=Name(id='dists', ctx=Load()), body=[Expr(value=Yield(value=Name(id='dist', ctx=Load())))], orelse=[])], orelse=[If(test=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='subitem', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='endswith', ctx=Load()), args=[Tuple(elts=[Constant(value='.dist-info'), Constant(value='.egg-info')], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='subpath', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path_item', ctx=Load()), Name(id='subitem', ctx=Load())], keywords=[])), Assign(targets=[Name(id='submeta', ctx=Store())], value=Call(func=Name(id='EggMetadata', ctx=Load()), args=[Call(func=Attribute(value=Name(id='zipimport', ctx=Load()), attr='zipimporter', ctx=Load()), args=[Name(id='subpath', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='submeta', ctx=Load()), attr='egg_info', ctx=Store())], value=Name(id='subpath', ctx=Load())), Expr(value=Yield(value=Call(func=Attribute(value=Name(id='Distribution', ctx=Load()), attr='from_location', ctx=Load()), args=[Name(id='path_item', ctx=Load()), Name(id='subitem', ctx=Load()), Name(id='submeta', ctx=Load())], keywords=[])))], orelse=[])])], orelse=[])], decorator_list=[]), Expr(value=Call(func=Name(id='register_finder', ctx=Load()), args=[Attribute(value=Name(id='zipimport', ctx=Load()), attr='zipimporter', ctx=Load()), Name(id='find_eggs_in_zip', ctx=Load())], keywords=[])), FunctionDef(name='find_nothing', args=arguments(posonlyargs=[], args=[arg(arg='importer'), arg(arg='path_item'), arg(arg='only')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Return(value=Tuple(elts=[], ctx=Load()))], decorator_list=[]), Expr(value=Call(func=Name(id='register_finder', ctx=Load()), args=[Name(id='object', ctx=Load()), Name(id='find_nothing', ctx=Load())], keywords=[])), FunctionDef(name='find_on_path', args=arguments(posonlyargs=[], args=[arg(arg='importer'), arg(arg='path_item'), arg(arg='only')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Yield distributions accessible on a sys.path directory')), Assign(targets=[Name(id='path_item', ctx=Store())], value=Call(func=Name(id='_normalize_cached', ctx=Load()), args=[Name(id='path_item', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='_is_unpacked_egg', ctx=Load()), args=[Name(id='path_item', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Call(func=Attribute(value=Name(id='Distribution', ctx=Load()), attr='from_filename', ctx=Load()), args=[Name(id='path_item', ctx=Load())], keywords=[keyword(arg='metadata', value=Call(func=Name(id='PathMetadata', ctx=Load()), args=[Name(id='path_item', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path_item', ctx=Load()), Constant(value='EGG-INFO')], keywords=[])], keywords=[]))]))), Return()], orelse=[]), Assign(targets=[Name(id='entries', ctx=Store())], value=GeneratorExp(elt=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path_item', ctx=Load()), Name(id='child', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='child', ctx=Store()), iter=Call(func=Name(id='safe_listdir', ctx=Load()), args=[Name(id='path_item', ctx=Load())], keywords=[]), ifs=[], is_async=0)])), For(target=Name(id='entry', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='entries', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='fullpath', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path_item', ctx=Load()), Name(id='entry', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factory', ctx=Store())], value=Call(func=Name(id='dist_factory', ctx=Load()), args=[Name(id='path_item', ctx=Load()), Name(id='entry', ctx=Load()), Name(id='only', ctx=Load())], keywords=[])), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Name(id='factory', ctx=Load()), args=[Name(id='fullpath', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='dist', ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='dist_factory', args=arguments(posonlyargs=[], args=[arg(arg='path_item'), arg(arg='entry'), arg(arg='only')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a dist_factory for the given entry.')), Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='entry', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='is_egg_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='lower', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.egg-info')], keywords=[])), Assign(targets=[Name(id='is_dist_info', ctx=Store())], value=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='lower', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.dist-info')], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path_item', ctx=Load()), Name(id='entry', ctx=Load())], keywords=[])], keywords=[])])), Assign(targets=[Name(id='is_meta', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='is_egg_info', ctx=Load()), Name(id='is_dist_info', ctx=Load())])), Return(value=IfExp(test=Name(id='is_meta', ctx=Load()), body=Name(id='distributions_from_metadata', ctx=Load()), orelse=IfExp(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='only', ctx=Load())), Call(func=Name(id='_is_egg_path', ctx=Load()), args=[Name(id='entry', ctx=Load())], keywords=[])]), body=Name(id='find_distributions', ctx=Load()), orelse=IfExp(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='only', ctx=Load())), Call(func=Attribute(value=Name(id='lower', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.egg-link')], keywords=[])]), body=Name(id='resolve_egg_link', ctx=Load()), orelse=Call(func=Name(id='NoDists', ctx=Load()), args=[], keywords=[])))))], decorator_list=[]), ClassDef(name='NoDists', bases=[], keywords=[], body=[Expr(value=Constant(value="\n    >>> bool(NoDists())\n    False\n\n    >>> list(NoDists()('anything'))\n    []\n    ")), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fullpath')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Tuple(elts=[], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='safe_listdir', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Attempt to list contents of path, but suppress some exceptions.\n    ')), Try(body=[Return(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='PermissionError', ctx=Load()), Name(id='NotADirectoryError', ctx=Load())], ctx=Load()), body=[Pass()]), ExceptHandler(type=Name(id='OSError', ctx=Load()), name='e', body=[If(test=Compare(left=Attribute(value=Name(id='e', ctx=Load()), attr='errno', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Attribute(value=Name(id='errno', ctx=Load()), attr='ENOTDIR', ctx=Load()), Attribute(value=Name(id='errno', ctx=Load()), attr='EACCES', ctx=Load()), Attribute(value=Name(id='errno', ctx=Load()), attr='ENOENT', ctx=Load())], ctx=Load())]), body=[Raise()], orelse=[])])], orelse=[], finalbody=[]), Return(value=Tuple(elts=[], ctx=Load()))], decorator_list=[]), FunctionDef(name='distributions_from_metadata', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='root', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[]), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return()], orelse=[]), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='PathMetadata', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='FileMetadata', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='entry', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Expr(value=Yield(value=Call(func=Attribute(value=Name(id='Distribution', ctx=Load()), attr='from_location', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='entry', ctx=Load()), Name(id='metadata', ctx=Load())], keywords=[keyword(arg='precedence', value=Name(id='DEVELOP_DIST', ctx=Load()))])))], decorator_list=[]), FunctionDef(name='non_empty_lines', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Yield non-empty lines from file at path\n    ')), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[For(target=Name(id='line', ctx=Store()), iter=Name(id='f', ctx=Load()), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Name(id='line', ctx=Load()), body=[Expr(value=Yield(value=Name(id='line', ctx=Load())))], orelse=[])], orelse=[])])], decorator_list=[]), FunctionDef(name='resolve_egg_link', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Given a path to an .egg-link, resolve distributions\n    present in the referenced path.\n    ')), Assign(targets=[Name(id='referenced_paths', ctx=Store())], value=Call(func=Name(id='non_empty_lines', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='resolved_paths', ctx=Store())], value=GeneratorExp(elt=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), Name(id='ref', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='ref', ctx=Store()), iter=Name(id='referenced_paths', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='dist_groups', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='find_distributions', ctx=Load()), Name(id='resolved_paths', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='dist_groups', ctx=Load()), Tuple(elts=[], ctx=Load())], keywords=[]))], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='pkgutil', ctx=Load()), Constant(value='ImpImporter')], keywords=[]), body=[Expr(value=Call(func=Name(id='register_finder', ctx=Load()), args=[Attribute(value=Name(id='pkgutil', ctx=Load()), attr='ImpImporter', ctx=Load()), Name(id='find_on_path', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='register_finder', ctx=Load()), args=[Attribute(value=Name(id='importlib_machinery', ctx=Load()), attr='FileFinder', ctx=Load()), Name(id='find_on_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_declare_state', ctx=Load()), args=[Constant(value='dict')], keywords=[keyword(arg='_namespace_handlers', value=Dict(keys=[], values=[]))])), Expr(value=Call(func=Name(id='_declare_state', ctx=Load()), args=[Constant(value='dict')], keywords=[keyword(arg='_namespace_packages', value=Dict(keys=[], values=[]))])), FunctionDef(name='register_namespace_handler', args=arguments(posonlyargs=[], args=[arg(arg='importer_type'), arg(arg='namespace_handler')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Register `namespace_handler` to declare namespace packages\n\n    `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item\n    handler), and `namespace_handler` is a callable like this::\n\n        def namespace_handler(importer, path_entry, moduleName, module):\n            # return a path_entry to use for child packages\n\n    Namespace handlers are only called if the importer object has already\n    agreed that it can handle the relevant path item, and they should only\n    return a subpath if the module __path__ does not already contain an\n    equivalent subpath.  For an example namespace handler, see\n    ``pkg_resources.file_ns_handler``.\n    ')), Assign(targets=[Subscript(value=Name(id='_namespace_handlers', ctx=Load()), slice=Name(id='importer_type', ctx=Load()), ctx=Store())], value=Name(id='namespace_handler', ctx=Load()))], decorator_list=[]), FunctionDef(name='_handle_ns', args=arguments(posonlyargs=[], args=[arg(arg='packageName'), arg(arg='path_item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Ensure that named package includes a subpath of path_item (if needed)')), Assign(targets=[Name(id='importer', ctx=Store())], value=Call(func=Name(id='get_importer', ctx=Load()), args=[Name(id='path_item', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='importer', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Try(body=[Assign(targets=[Name(id='spec', ctx=Store())], value=Call(func=Attribute(value=Name(id='importer', ctx=Load()), attr='find_spec', ctx=Load()), args=[Name(id='packageName', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='catch_warnings', ctx=Load()), args=[], keywords=[]))], body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='simplefilter', ctx=Load()), args=[Constant(value='ignore')], keywords=[])), Assign(targets=[Name(id='loader', ctx=Store())], value=Call(func=Attribute(value=Name(id='importer', ctx=Load()), attr='find_module', ctx=Load()), args=[Name(id='packageName', ctx=Load())], keywords=[]))])])], orelse=[Assign(targets=[Name(id='loader', ctx=Store())], value=IfExp(test=Name(id='spec', ctx=Load()), body=Attribute(value=Name(id='spec', ctx=Load()), attr='loader', ctx=Load()), orelse=Constant(value=None)))], finalbody=[]), If(test=Compare(left=Name(id='loader', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='packageName', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='module', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='module', ctx=Store()), Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='packageName', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='types', ctx=Load()), attr='ModuleType', ctx=Load()), args=[Name(id='packageName', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='module', ctx=Load()), attr='__path__', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Call(func=Name(id='_set_parent_ns', ctx=Load()), args=[Name(id='packageName', ctx=Load())], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='module', ctx=Load()), Constant(value='__path__')], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Not a package:'), Name(id='packageName', ctx=Load())], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='handler', ctx=Store())], value=Call(func=Name(id='_find_adapter', ctx=Load()), args=[Name(id='_namespace_handlers', ctx=Load()), Name(id='importer', ctx=Load())], keywords=[])), Assign(targets=[Name(id='subpath', ctx=Store())], value=Call(func=Name(id='handler', ctx=Load()), args=[Name(id='importer', ctx=Load()), Name(id='path_item', ctx=Load()), Name(id='packageName', ctx=Load()), Name(id='module', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='subpath', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Attribute(value=Name(id='module', ctx=Load()), attr='__path__', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='subpath', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='importlib', ctx=Load()), attr='import_module', ctx=Load()), args=[Name(id='packageName', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_rebuild_mod_path', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='packageName', ctx=Load()), Name(id='module', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='subpath', ctx=Load()))], decorator_list=[]), FunctionDef(name='_rebuild_mod_path', args=arguments(posonlyargs=[], args=[arg(arg='orig_path'), arg(arg='package_name'), arg(arg='module')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Rebuild module.__path__ ensuring that all entries are ordered\n    corresponding to their sys.path order\n    ')), Assign(targets=[Name(id='sys_path', ctx=Store())], value=ListComp(elt=Call(func=Name(id='_normalize_cached', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), ifs=[], is_async=0)])), FunctionDef(name='safe_sys_path_index', args=arguments(posonlyargs=[], args=[arg(arg='entry')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Workaround for #520 and #513.\n        ')), Try(body=[Return(value=Call(func=Attribute(value=Name(id='sys_path', ctx=Load()), attr='index', ctx=Load()), args=[Name(id='entry', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=Call(func=Name(id='float', ctx=Load()), args=[Constant(value='inf')], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='position_in_sys_path', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the ordinal of the path based on its position in sys.path\n        ')), Assign(targets=[Name(id='path_parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='split', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module_parts', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='package_name', ctx=Load()), attr='count', ctx=Load()), args=[Constant(value='.')], keywords=[]), op=Add(), right=Constant(value=1))), Assign(targets=[Name(id='parts', ctx=Store())], value=Subscript(value=Name(id='path_parts', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Name(id='module_parts', ctx=Load()))), ctx=Load())), Return(value=Call(func=Name(id='safe_sys_path_index', ctx=Load()), args=[Call(func=Name(id='_normalize_cached', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='new_path', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='orig_path', ctx=Load())], keywords=[keyword(arg='key', value=Name(id='position_in_sys_path', ctx=Load()))])), Assign(targets=[Name(id='new_path', ctx=Store())], value=ListComp(elt=Call(func=Name(id='_normalize_cached', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='new_path', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='module', ctx=Load()), attr='__path__', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='module', ctx=Load()), attr='__path__', ctx=Load()), slice=Slice(), ctx=Store())], value=Name(id='new_path', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='module', ctx=Load()), attr='__path__', ctx=Store())], value=Name(id='new_path', ctx=Load()))])], decorator_list=[]), FunctionDef(name='declare_namespace', args=arguments(posonlyargs=[], args=[arg(arg='packageName')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Declare that package 'packageName' is a namespace package")), Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='Deprecated call to `pkg_resources.declare_namespace('), FormattedValue(value=Name(id='packageName', ctx=Load()), conversion=114), Constant(value=')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages')])), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='msg', ctx=Load()), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Expr(value=Call(func=Attribute(value=Name(id='_imp', ctx=Load()), attr='acquire_lock', ctx=Load()), args=[], keywords=[])), Try(body=[If(test=Compare(left=Name(id='packageName', ctx=Load()), ops=[In()], comparators=[Name(id='_namespace_packages', ctx=Load())]), body=[Return()], orelse=[]), Assign(targets=[Name(id='path', ctx=Store())], value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='parent', ctx=Store()), Name(id='_', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='packageName', ctx=Load()), attr='rpartition', ctx=Load()), args=[Constant(value='.')], keywords=[])), If(test=Name(id='parent', ctx=Load()), body=[Expr(value=Call(func=Name(id='declare_namespace', ctx=Load()), args=[Name(id='parent', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='parent', ctx=Load()), ops=[NotIn()], comparators=[Name(id='_namespace_packages', ctx=Load())]), body=[Expr(value=Call(func=Name(id='__import__', ctx=Load()), args=[Name(id='parent', ctx=Load())], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Name(id='path', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='parent', ctx=Load()), ctx=Load()), attr='__path__', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Not a package:'), Name(id='parent', ctx=Load())], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='_namespace_packages', ctx=Load()), attr='setdefault', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='parent', ctx=Load()), Constant(value=None)]), List(elts=[], ctx=Load())], keywords=[]), attr='append', ctx=Load()), args=[Name(id='packageName', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='_namespace_packages', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='packageName', ctx=Load()), List(elts=[], ctx=Load())], keywords=[])), For(target=Name(id='path_item', ctx=Store()), iter=Name(id='path', ctx=Load()), body=[Expr(value=Call(func=Name(id='_handle_ns', ctx=Load()), args=[Name(id='packageName', ctx=Load()), Name(id='path_item', ctx=Load())], keywords=[]))], orelse=[])], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='_imp', ctx=Load()), attr='release_lock', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='fixup_namespace_packages', args=arguments(posonlyargs=[], args=[arg(arg='path_item'), arg(arg='parent')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Ensure that previously-declared namespace packages include path_item')), Expr(value=Call(func=Attribute(value=Name(id='_imp', ctx=Load()), attr='acquire_lock', ctx=Load()), args=[], keywords=[])), Try(body=[For(target=Name(id='package', ctx=Store()), iter=Call(func=Attribute(value=Name(id='_namespace_packages', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='parent', ctx=Load()), Tuple(elts=[], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='subpath', ctx=Store())], value=Call(func=Name(id='_handle_ns', ctx=Load()), args=[Name(id='package', ctx=Load()), Name(id='path_item', ctx=Load())], keywords=[])), If(test=Name(id='subpath', ctx=Load()), body=[Expr(value=Call(func=Name(id='fixup_namespace_packages', ctx=Load()), args=[Name(id='subpath', ctx=Load()), Name(id='package', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='_imp', ctx=Load()), attr='release_lock', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='file_ns_handler', args=arguments(posonlyargs=[], args=[arg(arg='importer'), arg(arg='path_item'), arg(arg='packageName'), arg(arg='module')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute an ns-package subpath for a filesystem or zipfile importer')), Assign(targets=[Name(id='subpath', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path_item', ctx=Load()), Subscript(value=Call(func=Attribute(value=Name(id='packageName', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='normalized', ctx=Store())], value=Call(func=Name(id='_normalize_cached', ctx=Load()), args=[Name(id='subpath', ctx=Load())], keywords=[])), For(target=Name(id='item', ctx=Store()), iter=Attribute(value=Name(id='module', ctx=Load()), attr='__path__', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='_normalize_cached', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Name(id='normalized', ctx=Load())]), body=[Break()], orelse=[])], orelse=[Return(value=Name(id='subpath', ctx=Load()))])], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='pkgutil', ctx=Load()), Constant(value='ImpImporter')], keywords=[]), body=[Expr(value=Call(func=Name(id='register_namespace_handler', ctx=Load()), args=[Attribute(value=Name(id='pkgutil', ctx=Load()), attr='ImpImporter', ctx=Load()), Name(id='file_ns_handler', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='register_namespace_handler', ctx=Load()), args=[Attribute(value=Name(id='zipimport', ctx=Load()), attr='zipimporter', ctx=Load()), Name(id='file_ns_handler', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='register_namespace_handler', ctx=Load()), args=[Attribute(value=Name(id='importlib_machinery', ctx=Load()), attr='FileFinder', ctx=Load()), Name(id='file_ns_handler', ctx=Load())], keywords=[])), FunctionDef(name='null_ns_handler', args=arguments(posonlyargs=[], args=[arg(arg='importer'), arg(arg='path_item'), arg(arg='packageName'), arg(arg='module')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=None))], decorator_list=[]), Expr(value=Call(func=Name(id='register_namespace_handler', ctx=Load()), args=[Name(id='object', ctx=Load()), Name(id='null_ns_handler', ctx=Load())], keywords=[])), FunctionDef(name='normalize_path', args=arguments(posonlyargs=[], args=[arg(arg='filename')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Normalize a file/dir name for comparison purposes')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normcase', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='realpath', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[Call(func=Name(id='_cygwin_patch', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[])], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_cygwin_patch', args=arguments(posonlyargs=[], args=[arg(arg='filename')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Contrary to POSIX 2008, on Cygwin, getcwd (3) contains\n    symlink components. Using\n    os.path.abspath() works around this limitation. A fix in os.getcwd()\n    would probably better, in Cygwin even more so, except\n    that this seems to be by design...\n    ')), Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()), ops=[Eq()], comparators=[Constant(value='cygwin')]), body=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), orelse=Name(id='filename', ctx=Load())))], decorator_list=[]), FunctionDef(name='_normalize_cached', args=arguments(posonlyargs=[], args=[arg(arg='filename'), arg(arg='_cache')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[])]), body=[Try(body=[Return(value=Subscript(value=Name(id='_cache', ctx=Load()), slice=Name(id='filename', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='_cache', ctx=Load()), slice=Name(id='filename', ctx=Load()), ctx=Store()), Name(id='result', ctx=Store())], value=Call(func=Name(id='normalize_path', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[])), Return(value=Name(id='result', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='_is_egg_path', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Determine if given path appears to be an egg.\n    ')), Return(value=BoolOp(op=Or(), values=[Call(func=Name(id='_is_zip_egg', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), Call(func=Name(id='_is_unpacked_egg', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])]))], decorator_list=[]), FunctionDef(name='_is_zip_egg', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='endswith', ctx=Load()), args=[Constant(value='.egg')], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='zipfile', ctx=Load()), attr='is_zipfile', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])]))], decorator_list=[]), FunctionDef(name='_is_unpacked_egg', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Determine if given path appears to be an unpacked egg.\n    ')), Return(value=BoolOp(op=And(), values=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='endswith', ctx=Load()), args=[Constant(value='.egg')], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='EGG-INFO'), Constant(value='PKG-INFO')], keywords=[])], keywords=[])]))], decorator_list=[]), FunctionDef(name='_set_parent_ns', args=arguments(posonlyargs=[], args=[arg(arg='packageName')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='packageName', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='parts', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[])), If(test=Name(id='parts', ctx=Load()), body=[Assign(targets=[Name(id='parent', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='parent', ctx=Load()), ctx=Load()), Name(id='name', ctx=Load()), Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='packageName', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='MODULE', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\\w+(\\.\\w+)*$')], keywords=[]), attr='match', ctx=Load())), Assign(targets=[Name(id='EGG_NAME', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\n    (?P<name>[^-]+) (\n        -(?P<ver>[^-]+) (\n            -py(?P<pyver>[^-]+) (\n                -(?P<plat>.+)\n            )?\n        )?\n    )?\n    '), BinOp(left=Attribute(value=Name(id='re', ctx=Load()), attr='VERBOSE', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load()))], keywords=[]), attr='match', ctx=Load())), ClassDef(name='EntryPoint', bases=[], keywords=[], body=[Expr(value=Constant(value='Object representing an advertised importable object')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='module_name'), arg(arg='attrs'), arg(arg='extras'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[], ctx=Load()), Tuple(elts=[], ctx=Load()), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='MODULE', ctx=Load()), args=[Name(id='module_name', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Invalid module name'), Name(id='module_name', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='module_name', ctx=Store())], value=Name(id='module_name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='attrs', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='attrs', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='extras', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Store())], value=Name(id='dist', ctx=Load()))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='s', ctx=Store())], value=BinOp(left=Constant(value='%s = %s'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='module_name', ctx=Load())], ctx=Load()))), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='attrs', ctx=Load()), body=[AugAssign(target=Name(id='s', ctx=Store()), op=Add(), value=BinOp(left=Constant(value=':'), op=Add(), right=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='attrs', ctx=Load())], keywords=[])))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Load()), body=[AugAssign(target=Name(id='s', ctx=Store()), op=Add(), value=BinOp(left=Constant(value=' [%s]'), op=Mod(), right=Call(func=Attribute(value=Constant(value=','), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Load())], keywords=[])))], orelse=[]), Return(value=Name(id='s', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='EntryPoint.parse(%r)'), op=Mod(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])))], decorator_list=[]), FunctionDef(name='load', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='require')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n        Require packages for this EntryPoint, then resolve it.\n        ')), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='require', ctx=Load())), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='Parameters to load are deprecated.  Call .resolve and .require separately.'), Name(id='PkgResourcesDeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))], orelse=[]), If(test=Name(id='require', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='require', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='resolve', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='resolve', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Resolve the entry point from its module and attrs.\n        ')), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Name(id='__import__', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='module_name', ctx=Load())], keywords=[keyword(arg='fromlist', value=List(elts=[Constant(value='__name__')], ctx=Load())), keyword(arg='level', value=Constant(value=0))])), Try(body=[Return(value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='reduce', ctx=Load()), args=[Name(id='getattr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='attrs', ctx=Load()), Name(id='module', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='exc', body=[Raise(exc=Call(func=Name(id='ImportError', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='exc', ctx=Load())], keywords=[])], keywords=[]), cause=Name(id='exc', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='require', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='env'), arg(arg='installer')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Load()), UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='UnknownExtra', ctx=Load()), args=[Constant(value="Can't require() without a distribution"), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='reqs', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='requires', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Load())], keywords=[])), Assign(targets=[Name(id='items', ctx=Store())], value=Call(func=Attribute(value=Name(id='working_set', ctx=Load()), attr='resolve', ctx=Load()), args=[Name(id='reqs', ctx=Load()), Name(id='env', ctx=Load()), Name(id='installer', ctx=Load())], keywords=[keyword(arg='extras', value=Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Load()))])), Expr(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='working_set', ctx=Load()), attr='add', ctx=Load()), Name(id='items', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\\s*(?P<name>.+?)\\s*=\\s*(?P<module>[\\w.]+)\\s*(:\\s*(?P<attr>[\\w.]+))?\\s*(?P<extras>\\[.*\\])?\\s*$')], keywords=[])), FunctionDef(name='parse', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='src'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Parse a single entry point from string `src`\n\n        Entry point syntax follows the form::\n\n            name = some.module:some.attr [extra1, extra2]\n\n        The entry name and module name are required, but the ``:attrs`` and\n        ``[extras]`` parts are optional\n        ')), Assign(targets=[Name(id='m', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='pattern', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='src', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='m', ctx=Load())), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value="EntryPoint must be in 'name=module:attrs [extras]' format")), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Name(id='msg', ctx=Load()), Name(id='src', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Name(id='m', ctx=Load()), attr='groupdict', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='extras', ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_parse_extras', ctx=Load()), args=[Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value='extras'), ctx=Load())], keywords=[])), Assign(targets=[Name(id='attrs', ctx=Store())], value=IfExp(test=Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value='attr'), ctx=Load()), body=Call(func=Attribute(value=Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value='attr'), ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]), orelse=Tuple(elts=[], ctx=Load()))), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value='name'), ctx=Load()), Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value='module'), ctx=Load()), Name(id='attrs', ctx=Load()), Name(id='extras', ctx=Load()), Name(id='dist', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_parse_extras', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='extras_spec')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='extras_spec', ctx=Load())), body=[Return(value=Tuple(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='req', ctx=Store())], value=Call(func=Attribute(value=Name(id='Requirement', ctx=Load()), attr='parse', ctx=Load()), args=[BinOp(left=Constant(value='x'), op=Add(), right=Name(id='extras_spec', ctx=Load()))], keywords=[])), If(test=Attribute(value=Name(id='req', ctx=Load()), attr='specs', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='req', ctx=Load()), attr='extras', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='parse_group', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='group'), arg(arg='lines'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Parse an entry point group')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='MODULE', ctx=Load()), args=[Name(id='group', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Invalid group name'), Name(id='group', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='this', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='line', ctx=Store()), iter=Call(func=Name(id='yield_lines', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='ep', ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='dist', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), ops=[In()], comparators=[Name(id='this', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Duplicate entry point'), Name(id='group', ctx=Load()), Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='this', ctx=Load()), slice=Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Name(id='ep', ctx=Load()))], orelse=[]), Return(value=Name(id='this', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='parse_map', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='data'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Parse a map of entry point groups')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Name(id='split_sections', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='maps', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='group', ctx=Store()), Name(id='lines', ctx=Store())], ctx=Store()), iter=Name(id='data', ctx=Load()), body=[If(test=Compare(left=Name(id='group', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='lines', ctx=Load())), body=[Continue()], orelse=[]), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Entry points must be listed in groups')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='group', ctx=Store())], value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='group', ctx=Load()), ops=[In()], comparators=[Name(id='maps', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Duplicate group name'), Name(id='group', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='maps', ctx=Load()), slice=Name(id='group', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='parse_group', ctx=Load()), args=[Name(id='group', ctx=Load()), Name(id='lines', ctx=Load()), Name(id='dist', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='maps', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())])], decorator_list=[]), FunctionDef(name='_version_from_file', args=arguments(posonlyargs=[], args=[arg(arg='lines')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Given an iterable of lines from a Metadata file, return\n    the value of the Version field, if present, or None otherwise.\n    ')), FunctionDef(name='is_version_line', args=arguments(posonlyargs=[], args=[arg(arg='line')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Constant(value='version:')], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='version_lines', ctx=Store())], value=Call(func=Name(id='filter', ctx=Load()), args=[Name(id='is_version_line', ctx=Load()), Name(id='lines', ctx=Load())], keywords=[])), Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Name(id='version_lines', ctx=Load())], keywords=[]), Constant(value='')], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='_', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value=':')], keywords=[])), Return(value=BoolOp(op=Or(), values=[Call(func=Name(id='safe_version', ctx=Load()), args=[Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], keywords=[]), Constant(value=None)]))], decorator_list=[]), ClassDef(name='Distribution', bases=[], keywords=[], body=[Expr(value=Constant(value='Wrap an actual or potential sys.path entry w/metadata')), Assign(targets=[Name(id='PKG_INFO', ctx=Store())], value=Constant(value='PKG-INFO')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location'), arg(arg='metadata'), arg(arg='project_name'), arg(arg='version'), arg(arg='py_version'), arg(arg='platform'), arg(arg='precedence')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Name(id='PY_MAJOR', ctx=Load()), Constant(value=None), Name(id='EGG_DIST', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Store())], value=Call(func=Name(id='safe_name', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='project_name', ctx=Load()), Constant(value='Unknown')])], keywords=[])), If(test=Compare(left=Name(id='version', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_version', ctx=Store())], value=Call(func=Name(id='safe_version', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='py_version', ctx=Store())], value=Name(id='py_version', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='platform', ctx=Store())], value=Name(id='platform', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Store())], value=Name(id='location', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='precedence', ctx=Store())], value=Name(id='precedence', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_provider', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='metadata', ctx=Load()), Name(id='empty_provider', ctx=Load())]))], decorator_list=[]), FunctionDef(name='from_location', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='location'), arg(arg='basename'), arg(arg='metadata')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[Constant(value=None)]), body=[Assign(targets=[Tuple(elts=[Name(id='project_name', ctx=Store()), Name(id='version', ctx=Store()), Name(id='py_version', ctx=Store()), Name(id='platform', ctx=Store())], ctx=Store())], value=BinOp(left=List(elts=[Constant(value=None)], ctx=Load()), op=Mult(), right=Constant(value=4))), Assign(targets=[Tuple(elts=[Name(id='basename', ctx=Store()), Name(id='ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='basename', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='ext', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[Name(id='_distributionImpl', ctx=Load())]), body=[Assign(targets=[Name(id='cls', ctx=Store())], value=Subscript(value=Name(id='_distributionImpl', ctx=Load()), slice=Call(func=Attribute(value=Name(id='ext', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ctx=Load())), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Name(id='EGG_NAME', ctx=Load()), args=[Name(id='basename', ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='project_name', ctx=Store()), Name(id='version', ctx=Store()), Name(id='py_version', ctx=Store()), Name(id='platform', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='name'), Constant(value='ver'), Constant(value='pyver'), Constant(value='plat')], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='location', ctx=Load()), Name(id='metadata', ctx=Load())], keywords=[keyword(arg='project_name', value=Name(id='project_name', ctx=Load())), keyword(arg='version', value=Name(id='version', ctx=Load())), keyword(arg='py_version', value=Name(id='py_version', ctx=Load())), keyword(arg='platform', value=Name(id='platform', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))]), attr='_reload_version', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_reload_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='hashcmp', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_forgiving_parsed_version', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='precedence', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='key', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load()), BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='py_version', ctx=Load()), Constant(value='')]), BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='platform', ctx=Load()), Constant(value='')])], ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='hashcmp', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__lt__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='hashcmp', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='hashcmp', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__le__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='hashcmp', ctx=Load()), ops=[LtE()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='hashcmp', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__gt__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='hashcmp', ctx=Load()), ops=[Gt()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='hashcmp', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__ge__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='hashcmp', ctx=Load()), ops=[GtE()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='hashcmp', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='hashcmp', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='hashcmp', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__ne__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=UnaryOp(op=Not(), operand=Compare(left=Name(id='self', ctx=Load()), ops=[Eq()], comparators=[Name(id='other', ctx=Load())])))], decorator_list=[]), FunctionDef(name='key', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_key', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_key', ctx=Store()), Name(id='key', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='key', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='parsed_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='_parsed_version')], keywords=[])), body=[Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_version', ctx=Store())], value=Call(func=Name(id='parse_version', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='version', ctx=Load()), attr='InvalidVersion', ctx=Load()), name='ex', body=[Assign(targets=[Name(id='info', ctx=Store())], value=JoinedStr(values=[Constant(value='(package: '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), conversion=-1), Constant(value=')')])), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ex', ctx=Load()), Constant(value='add_note')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='ex', ctx=Load()), attr='add_note', ctx=Load()), args=[Name(id='info', ctx=Load())], keywords=[])), Raise()], orelse=[]), Raise(exc=Call(func=Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='version', ctx=Load()), attr='InvalidVersion', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='ex', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' '), FormattedValue(value=Name(id='info', ctx=Load()), conversion=-1)])], keywords=[]), cause=Constant(value=None))])], orelse=[], finalbody=[])], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_version', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_forgiving_parsed_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='parsed_version', ctx=Load()))], handlers=[ExceptHandler(type=Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='version', ctx=Load()), attr='InvalidVersion', ctx=Load()), name='ex', body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_version', ctx=Store())], value=Call(func=Name(id='parse_version', ctx=Load()), args=[Call(func=Name(id='_forgiving_version', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='notes', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ex', ctx=Load()), Constant(value='__notes__'), List(elts=[], ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='!!\n\n\n            *************************************************************************\n            '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='ex', ctx=Load())], keywords=[]), conversion=-1), Constant(value='\n'), FormattedValue(value=Name(id='notes', ctx=Load()), conversion=-1), Constant(value='\n\n            This is a long overdue deprecation.\n            For the time being, `pkg_resources` will use `'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_version', ctx=Load()), conversion=-1), Constant(value='`\n            as a replacement to avoid breaking existing environments,\n            but no future compatibility is guaranteed.\n\n            If you maintain package '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), conversion=-1), Constant(value=' you should implement\n            the relevant changes to adequate the project to PEP 440 immediately.\n            *************************************************************************\n            \n\n!!\n            ')])), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='msg', ctx=Load()), Name(id='DeprecationWarning', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_version', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_version', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='e', body=[Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_version', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='version', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_metadata_path_for_display', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='PKG_INFO', ctx=Load())], keywords=[])), Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Constant(value="Missing 'Version:' header and/or {} file at path: {}"), attr='format', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='PKG_INFO', ctx=Load()), Name(id='path', ctx=Load())], keywords=[])), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Name(id='msg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), cause=Name(id='e', ctx=Load()))], orelse=[]), Return(value=Name(id='version', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_dep_map', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        A map of extra to its list of (direct) requirements\n        for this distribution, including the null extra.\n        ')), Try(body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dep_map', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__dep_map', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_filter_extras', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_build_dep_map', ctx=Load()), args=[], keywords=[])], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dep_map', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_filter_extras', args=arguments(posonlyargs=[], args=[arg(arg='dm')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Given a mapping of extras to dependencies, strip off\n        environment markers and filter out any dependencies\n        not matching the markers.\n        ')), For(target=Name(id='extra', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='filter', ctx=Load()), args=[Constant(value=None), Name(id='dm', ctx=Load())], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='new_extra', ctx=Store())], value=Name(id='extra', ctx=Load())), Assign(targets=[Name(id='reqs', ctx=Store())], value=Call(func=Attribute(value=Name(id='dm', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='extra', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='new_extra', ctx=Store()), Name(id='_', ctx=Store()), Name(id='marker', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='extra', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value=':')], keywords=[])), Assign(targets=[Name(id='fails_marker', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='marker', ctx=Load()), BoolOp(op=Or(), values=[Call(func=Name(id='invalid_marker', ctx=Load()), args=[Name(id='marker', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='evaluate_marker', ctx=Load()), args=[Name(id='marker', ctx=Load())], keywords=[]))])])), If(test=Name(id='fails_marker', ctx=Load()), body=[Assign(targets=[Name(id='reqs', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='new_extra', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Name(id='safe_extra', ctx=Load()), args=[Name(id='new_extra', ctx=Load())], keywords=[]), Constant(value=None)])), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='dm', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='new_extra', ctx=Load()), List(elts=[], ctx=Load())], keywords=[]), attr='extend', ctx=Load()), args=[Name(id='reqs', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='dm', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_build_dep_map', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='dm', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='name', ctx=Store()), iter=Tuple(elts=[Constant(value='requires.txt'), Constant(value='depends.txt')], ctx=Load()), body=[For(target=Tuple(elts=[Name(id='extra', ctx=Store()), Name(id='reqs', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='split_sections', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_metadata', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='dm', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='extra', ctx=Load()), List(elts=[], ctx=Load())], keywords=[]), attr='extend', ctx=Load()), args=[Call(func=Name(id='parse_requirements', ctx=Load()), args=[Name(id='reqs', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='dm', ctx=Load()))], decorator_list=[]), FunctionDef(name='requires', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='extras')], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[], ctx=Load())]), body=[Expr(value=Constant(value='List of Requirements needed for this distro if `extras` are used')), Assign(targets=[Name(id='dm', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_dep_map', ctx=Load())), Assign(targets=[Name(id='deps', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='deps', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='dm', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value=None), Tuple(elts=[], ctx=Load())], keywords=[])], keywords=[])), For(target=Name(id='ext', ctx=Store()), iter=Name(id='extras', ctx=Load()), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='deps', ctx=Load()), attr='extend', ctx=Load()), args=[Subscript(value=Name(id='dm', ctx=Load()), slice=Call(func=Name(id='safe_extra', ctx=Load()), args=[Name(id='ext', ctx=Load())], keywords=[]), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='UnknownExtra', ctx=Load()), args=[BinOp(left=Constant(value='%s has no such extra feature %r'), op=Mod(), right=Tuple(elts=[Name(id='self', ctx=Load()), Name(id='ext', ctx=Load())], ctx=Load()))], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[]), Return(value=Name(id='deps', ctx=Load()))], decorator_list=[]), FunctionDef(name='_get_metadata_path_for_display', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the path to the given metadata file, if available.\n        ')), Try(body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_provider', ctx=Load()), attr='_get_metadata_path', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Return(value=Constant(value='[could not detect]'))])], orelse=[], finalbody=[]), Return(value=Name(id='path', ctx=Load()))], decorator_list=[]), FunctionDef(name='_get_metadata', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='has_metadata', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), body=[For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_metadata_lines', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='line', ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='_get_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_metadata', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='PKG_INFO', ctx=Load())], keywords=[])), Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Name(id='_version_from_file', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])), Return(value=Name(id='version', ctx=Load()))], decorator_list=[]), FunctionDef(name='activate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path'), arg(arg='replace')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Ensure distribution is importable on `path` (default=sys.path)')), If(test=Compare(left=Name(id='path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='insert_on', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[keyword(arg='replace', value=Name(id='replace', ctx=Load()))])), If(test=Compare(left=Name(id='path', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load())]), body=[Expr(value=Call(func=Name(id='fixup_namespace_packages', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load())], keywords=[])), For(target=Name(id='pkg', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_metadata', ctx=Load()), args=[Constant(value='namespace_packages.txt')], keywords=[]), body=[If(test=Compare(left=Name(id='pkg', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load())]), body=[Expr(value=Call(func=Name(id='declare_namespace', ctx=Load()), args=[Name(id='pkg', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='egg_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return what this distribution's standard .egg filename should be")), Assign(targets=[Name(id='filename', ctx=Store())], value=BinOp(left=Constant(value='%s-%s-py%s'), op=Mod(), right=Tuple(elts=[Call(func=Name(id='to_filename', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load())], keywords=[]), Call(func=Name(id='to_filename', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load())], keywords=[]), BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='py_version', ctx=Load()), Name(id='PY_MAJOR', ctx=Load())])], ctx=Load()))), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='platform', ctx=Load()), body=[AugAssign(target=Name(id='filename', ctx=Store()), op=Add(), value=BinOp(left=Constant(value='-'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='platform', ctx=Load())))], orelse=[]), Return(value=Name(id='filename', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load()), body=[Return(value=BinOp(left=Constant(value='%s (%s)'), op=Mod(), right=Tuple(elts=[Name(id='self', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load())], ctx=Load())))], orelse=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='version'), Constant(value=None)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='version', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='version', ctx=Load()), Constant(value='[unknown version]')])), Return(value=BinOp(left=Constant(value='%s %s'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), Name(id='version', ctx=Load())], ctx=Load())))], decorator_list=[]), FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='attr')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Delegate all unrecognized public attributes to .metadata provider')), If(test=Call(func=Attribute(value=Name(id='attr', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_')], keywords=[]), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_provider', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__dir__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='list', ctx=Load()), args=[BinOp(left=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='Distribution', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__dir__', ctx=Load()), args=[], keywords=[])], keywords=[]), op=BitOr(), right=Call(func=Name(id='set', ctx=Load()), args=[GeneratorExp(elt=Name(id='attr', ctx=Load()), generators=[comprehension(target=Name(id='attr', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_provider', ctx=Load()), attr='__dir__', ctx=Load()), args=[], keywords=[]), ifs=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='attr', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_')], keywords=[]))], is_async=0)])], keywords=[]))], keywords=[]))], decorator_list=[]), FunctionDef(name='from_filename', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='filename'), arg(arg='metadata')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[Constant(value=None)]), body=[Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='from_location', ctx=Load()), args=[Call(func=Name(id='_normalize_cached', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), Name(id='metadata', ctx=Load())], keywords=[keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='as_requirement', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a ``Requirement`` that matches this distribution exactly')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='parsed_version', ctx=Load()), Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='version', ctx=Load()), attr='Version', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='spec', ctx=Store())], value=BinOp(left=Constant(value='%s==%s'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='parsed_version', ctx=Load())], ctx=Load())))], orelse=[Assign(targets=[Name(id='spec', ctx=Store())], value=BinOp(left=Constant(value='%s===%s'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='parsed_version', ctx=Load())], ctx=Load())))]), Return(value=Call(func=Attribute(value=Name(id='Requirement', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='spec', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='load_entry_point', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='group'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the `name` entry point of `group` or raise ImportError')), Assign(targets=[Name(id='ep', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_entry_info', ctx=Load()), args=[Name(id='group', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='ep', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ImportError', ctx=Load()), args=[BinOp(left=Constant(value='Entry point %r not found'), op=Mod(), right=Tuple(elts=[Tuple(elts=[Name(id='group', ctx=Load()), Name(id='name', ctx=Load())], ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='ep', ctx=Load()), attr='load', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='get_entry_map', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='group')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return the entry point map for `group`, or the full entry map')), Try(body=[Assign(targets=[Name(id='ep_map', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ep_map', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Assign(targets=[Name(id='ep_map', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='_ep_map', ctx=Store())], value=Call(func=Attribute(value=Name(id='EntryPoint', ctx=Load()), attr='parse_map', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_metadata', ctx=Load()), args=[Constant(value='entry_points.txt')], keywords=[]), Name(id='self', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='group', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Attribute(value=Name(id='ep_map', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='group', ctx=Load()), Dict(keys=[], values=[])], keywords=[]))], orelse=[]), Return(value=Name(id='ep_map', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_entry_info', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='group'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the EntryPoint object for `group`+`name`, or ``None``')), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_entry_map', ctx=Load()), args=[Name(id='group', ctx=Load())], keywords=[]), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='insert_on', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path'), arg(arg='loc'), arg(arg='replace')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Ensure self.location is on path\n\n        If replace=False (default):\n            - If location is already in path anywhere, do nothing.\n            - Else:\n              - If it's an egg and its parent directory is on path,\n                insert just ahead of the parent.\n              - Else: add to the end of path.\n        If replace=True:\n            - If location is already on path anywhere (not eggs)\n              or higher priority than its parent (eggs)\n              do nothing.\n            - Else:\n              - If it's an egg and its parent directory is on path,\n                insert just ahead of the parent,\n                removing any lower-priority entries.\n              - Else: add it to the front of path.\n        ")), Assign(targets=[Name(id='loc', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load())])), If(test=UnaryOp(op=Not(), operand=Name(id='loc', ctx=Load())), body=[Return()], orelse=[]), Assign(targets=[Name(id='nloc', ctx=Store())], value=Call(func=Name(id='_normalize_cached', ctx=Load()), args=[Name(id='loc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bdir', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='nloc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='npath', ctx=Store())], value=ListComp(elt=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Name(id='p', ctx=Load()), Call(func=Name(id='_normalize_cached', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])]), Name(id='p', ctx=Load())]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='path', ctx=Load()), ifs=[], is_async=0)])), For(target=Tuple(elts=[Name(id='p', ctx=Store()), Name(id='item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='npath', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='item', ctx=Load()), ops=[Eq()], comparators=[Name(id='nloc', ctx=Load())]), body=[If(test=Name(id='replace', ctx=Load()), body=[Break()], orelse=[Return()])], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='item', ctx=Load()), ops=[Eq()], comparators=[Name(id='bdir', ctx=Load())]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='precedence', ctx=Load()), ops=[Eq()], comparators=[Name(id='EGG_DIST', ctx=Load())])]), body=[If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='replace', ctx=Load())), Compare(left=Name(id='nloc', ctx=Load()), ops=[In()], comparators=[Subscript(value=Name(id='npath', ctx=Load()), slice=Slice(lower=Name(id='p', ctx=Load())), ctx=Load())])]), body=[Return()], orelse=[]), If(test=Compare(left=Name(id='path', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='check_version_conflict', ctx=Load()), args=[], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='insert', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='npath', ctx=Load()), attr='insert', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='nloc', ctx=Load())], keywords=[])), Break()], orelse=[])])], orelse=[If(test=Compare(left=Name(id='path', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='check_version_conflict', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Name(id='replace', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Name(id='loc', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='loc', ctx=Load())], keywords=[]))]), Return()]), While(test=Constant(value=True), body=[Try(body=[Assign(targets=[Name(id='np', ctx=Store())], value=Call(func=Attribute(value=Name(id='npath', ctx=Load()), attr='index', ctx=Load()), args=[Name(id='nloc', ctx=Load()), BinOp(left=Name(id='p', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Break()])], orelse=[Delete(targets=[Subscript(value=Name(id='npath', ctx=Load()), slice=Name(id='np', ctx=Load()), ctx=Del()), Subscript(value=Name(id='path', ctx=Load()), slice=Name(id='np', ctx=Load()), ctx=Del())]), Assign(targets=[Name(id='p', ctx=Store())], value=Name(id='np', ctx=Load()))], finalbody=[])], orelse=[]), Return()], decorator_list=[]), FunctionDef(name='check_version_conflict', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='key', ctx=Load()), ops=[Eq()], comparators=[Constant(value='setuptools')]), body=[Return()], orelse=[]), Assign(targets=[Name(id='nsp', ctx=Store())], value=Call(func=Attribute(value=Name(id='dict', ctx=Load()), attr='fromkeys', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_metadata', ctx=Load()), args=[Constant(value='namespace_packages.txt')], keywords=[])], keywords=[])), Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Name(id='normalize_path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load())], keywords=[])), For(target=Name(id='modname', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_metadata', ctx=Load()), args=[Constant(value='top_level.txt')], keywords=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='modname', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load())]), Compare(left=Name(id='modname', ctx=Load()), ops=[In()], comparators=[Name(id='nsp', ctx=Load())]), Compare(left=Name(id='modname', ctx=Load()), ops=[In()], comparators=[Name(id='_namespace_packages', ctx=Load())])]), body=[Continue()], orelse=[]), If(test=Compare(left=Name(id='modname', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='pkg_resources'), Constant(value='setuptools'), Constant(value='site')], ctx=Load())]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='fn', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='modname', ctx=Load()), ctx=Load()), Constant(value='__file__'), Constant(value=None)], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='fn', ctx=Load()), BoolOp(op=Or(), values=[Call(func=Attribute(value=Call(func=Name(id='normalize_path', ctx=Load()), args=[Name(id='fn', ctx=Load())], keywords=[]), attr='startswith', ctx=Load()), args=[Name(id='loc', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='fn', ctx=Load()), attr='startswith', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load())], keywords=[])])]), body=[Continue()], orelse=[]), Expr(value=Call(func=Name(id='issue_warning', ctx=Load()), args=[BinOp(left=Constant(value='Module %s was already imported from %s, but %s is being added to sys.path'), op=Mod(), right=Tuple(elts=[Name(id='modname', ctx=Load()), Name(id='fn', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='has_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Expr(value=Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Expr(value=Call(func=Name(id='issue_warning', ctx=Load()), args=[BinOp(left=Constant(value='Unbuilt egg for '), op=Add(), right=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], keywords=[])), Return(value=Constant(value=False))]), ExceptHandler(type=Name(id='SystemError', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='clone', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Expr(value=Constant(value='Copy this distribution, substituting in any changed keyword args')), Assign(targets=[Name(id='names', ctx=Store())], value=Constant(value='project_name version py_version platform location precedence')), For(target=Name(id='attr', ctx=Store()), iter=Call(func=Attribute(value=Name(id='names', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='kw', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='attr', ctx=Load()), Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='attr', ctx=Load()), Constant(value=None)], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='kw', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='metadata'), Attribute(value=Name(id='self', ctx=Load()), attr='_provider', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), args=[], keywords=[keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='extras', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=ListComp(elt=Name(id='dep', ctx=Load()), generators=[comprehension(target=Name(id='dep', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_dep_map', ctx=Load()), ifs=[Name(id='dep', ctx=Load())], is_async=0)]))], decorator_list=[Name(id='property', ctx=Load())])], decorator_list=[]), ClassDef(name='EggInfoDistribution', bases=[Name(id='Distribution', ctx=Load())], keywords=[], body=[FunctionDef(name='_reload_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Packages installed by distutils (e.g. numpy or scipy),\n        which uses an old safe_version, and so\n        their version numbers can get mangled when\n        converted to filenames (e.g., 1.11.0.dev0+2329eae to\n        1.11.0.dev0_2329eae). These distributions will not be\n        parsed properly\n        downstream by Distribution and safe_version, so\n        take an extra step and try to get the version number from\n        the metadata file itself instead of the filename.\n        ')), Assign(targets=[Name(id='md_version', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_version', ctx=Load()), args=[], keywords=[])), If(test=Name(id='md_version', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_version', ctx=Store())], value=Name(id='md_version', ctx=Load()))], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='DistInfoDistribution', bases=[Name(id='Distribution', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Wrap an actual or potential sys.path entry\n    w/metadata, .dist-info style.\n    ')), Assign(targets=[Name(id='PKG_INFO', ctx=Store())], value=Constant(value='METADATA')), Assign(targets=[Name(id='EQEQ', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='([\\(,])\\s*(\\d.*?)\\s*([,\\)])')], keywords=[])), FunctionDef(name='_parsed_pkg_info', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parse and cache metadata')), Try(body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_pkg_info', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_metadata', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='PKG_INFO', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_pkg_info', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='email', ctx=Load()), attr='parser', ctx=Load()), attr='Parser', ctx=Load()), args=[], keywords=[]), attr='parsestr', ctx=Load()), args=[Name(id='metadata', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_pkg_info', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_dep_map', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dep_map', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__dep_map', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_dependencies', ctx=Load()), args=[], keywords=[])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dep_map', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_compute_dependencies', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Recompute this distribution's dependencies.")), Assign(targets=[Name(id='dm', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='__dep_map', ctx=Store())], value=Dict(keys=[Constant(value=None)], values=[List(elts=[], ctx=Load())])), Assign(targets=[Name(id='reqs', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='req', ctx=Store()), iter=BoolOp(op=Or(), values=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_pkg_info', ctx=Load()), attr='get_all', ctx=Load()), args=[Constant(value='Requires-Dist')], keywords=[]), List(elts=[], ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='reqs', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Name(id='parse_requirements', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), FunctionDef(name='reqs_for_extra', args=arguments(posonlyargs=[], args=[arg(arg='extra')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='req', ctx=Store()), iter=Name(id='reqs', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='req', ctx=Load()), attr='marker', ctx=Load())), Call(func=Attribute(value=Attribute(value=Name(id='req', ctx=Load()), attr='marker', ctx=Load()), attr='evaluate', ctx=Load()), args=[Dict(keys=[Constant(value='extra')], values=[Name(id='extra', ctx=Load())])], keywords=[])]), body=[Expr(value=Yield(value=Name(id='req', ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='common', ctx=Store())], value=Call(func=Attribute(value=Name(id='types', ctx=Load()), attr='MappingProxyType', ctx=Load()), args=[Call(func=Attribute(value=Name(id='dict', ctx=Load()), attr='fromkeys', ctx=Load()), args=[Call(func=Name(id='reqs_for_extra', ctx=Load()), args=[Constant(value=None)], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='dm', ctx=Load()), slice=Constant(value=None), ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='common', ctx=Load())], keywords=[])), For(target=Name(id='extra', ctx=Store()), iter=BoolOp(op=Or(), values=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_pkg_info', ctx=Load()), attr='get_all', ctx=Load()), args=[Constant(value='Provides-Extra')], keywords=[]), List(elts=[], ctx=Load())]), body=[Assign(targets=[Name(id='s_extra', ctx=Store())], value=Call(func=Name(id='safe_extra', ctx=Load()), args=[Call(func=Attribute(value=Name(id='extra', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Subscript(value=Name(id='dm', ctx=Load()), slice=Name(id='s_extra', ctx=Load()), ctx=Store())], value=ListComp(elt=Name(id='r', ctx=Load()), generators=[comprehension(target=Name(id='r', ctx=Store()), iter=Call(func=Name(id='reqs_for_extra', ctx=Load()), args=[Name(id='extra', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='r', ctx=Load()), ops=[NotIn()], comparators=[Name(id='common', ctx=Load())])], is_async=0)]))], orelse=[]), Return(value=Name(id='dm', ctx=Load()))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='_distributionImpl', ctx=Store())], value=Dict(keys=[Constant(value='.egg'), Constant(value='.egg-info'), Constant(value='.dist-info')], values=[Name(id='Distribution', ctx=Load()), Name(id='EggInfoDistribution', ctx=Load()), Name(id='DistInfoDistribution', ctx=Load())])), FunctionDef(name='issue_warning', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Assign(targets=[Name(id='level', ctx=Store())], value=Constant(value=1)), Assign(targets=[Name(id='g', ctx=Store())], value=Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[])), Try(body=[While(test=Compare(left=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Name(id='level', ctx=Load())], keywords=[]), attr='f_globals', ctx=Load()), ops=[Is()], comparators=[Name(id='g', ctx=Load())]), body=[AugAssign(target=Name(id='level', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(arg='stacklevel', value=BinOp(left=Name(id='level', ctx=Load()), op=Add(), right=Constant(value=1))), keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='parse_requirements', args=arguments(posonlyargs=[], args=[arg(arg='strs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Yield ``Requirement`` objects for each specification in `strs`.\n\n    `strs` must be a string, or a (possibly-nested) iterable thereof.\n    ')), Return(value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='Requirement', ctx=Load()), Call(func=Name(id='join_continuation', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='drop_comment', ctx=Load()), Call(func=Name(id='yield_lines', ctx=Load()), args=[Name(id='strs', ctx=Load())], keywords=[])], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[]), ClassDef(name='RequirementParseError', bases=[Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='requirements', ctx=Load()), attr='InvalidRequirement', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Compatibility wrapper for InvalidRequirement'))], decorator_list=[]), ClassDef(name='Requirement', bases=[Attribute(value=Attribute(value=Name(id='packaging', ctx=Load()), attr='requirements', ctx=Load()), attr='Requirement', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requirement_string')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='Requirement', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='requirement_string', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='unsafe_name', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())), Assign(targets=[Name(id='project_name', ctx=Store())], value=Call(func=Name(id='safe_name', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='key', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='project_name', ctx=Load()), Call(func=Attribute(value=Name(id='project_name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='specs', ctx=Store())], value=ListComp(elt=Tuple(elts=[Attribute(value=Name(id='spec', ctx=Load()), attr='operator', ctx=Load()), Attribute(value=Name(id='spec', ctx=Load()), attr='version', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='spec', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='specifier', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='safe_extra', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='hashCmp', ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='key', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='url', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='specifier', ctx=Load()), Call(func=Name(id='frozenset', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Load())], keywords=[]), IfExp(test=Attribute(value=Name(id='self', ctx=Load()), attr='marker', ctx=Load()), body=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='marker', ctx=Load())], keywords=[]), orelse=Constant(value=None))], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__hash', ctx=Store())], value=Call(func=Name(id='hash', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='hashCmp', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Requirement', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='hashCmp', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='hashCmp', ctx=Load())])]))], decorator_list=[]), FunctionDef(name='__ne__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=UnaryOp(op=Not(), operand=Compare(left=Name(id='self', ctx=Load()), ops=[Eq()], comparators=[Name(id='other', ctx=Load())])))], decorator_list=[]), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='item', ctx=Load()), Name(id='Distribution', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Attribute(value=Name(id='item', ctx=Load()), attr='key', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='key', ctx=Load())]), body=[Return(value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='item', ctx=Store())], value=Attribute(value=Name(id='item', ctx=Load()), attr='version', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='specifier', ctx=Load()), attr='contains', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[keyword(arg='prereleases', value=Constant(value=True))]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__hash', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='Requirement.parse(%r)'), op=Mod(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])))], decorator_list=[]), FunctionDef(name='parse', args=arguments(posonlyargs=[], args=[arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='req', ctx=Store())], ctx=Store())], value=Call(func=Name(id='parse_requirements', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[])), Return(value=Name(id='req', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())])], decorator_list=[]), FunctionDef(name='_always_object', args=arguments(posonlyargs=[], args=[arg(arg='classes')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Ensure object appears in the mro even\n    for old-style classes.\n    ')), If(test=Compare(left=Name(id='object', ctx=Load()), ops=[NotIn()], comparators=[Name(id='classes', ctx=Load())]), body=[Return(value=BinOp(left=Name(id='classes', ctx=Load()), op=Add(), right=Tuple(elts=[Name(id='object', ctx=Load())], ctx=Load())))], orelse=[]), Return(value=Name(id='classes', ctx=Load()))], decorator_list=[]), FunctionDef(name='_find_adapter', args=arguments(posonlyargs=[], args=[arg(arg='registry'), arg(arg='ob')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return an adapter factory for `ob` from `registry`')), Assign(targets=[Name(id='types', ctx=Store())], value=Call(func=Name(id='_always_object', ctx=Load()), args=[Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='getmro', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ob', ctx=Load()), Constant(value='__class__'), Call(func=Name(id='type', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])], keywords=[])], keywords=[])], keywords=[])), For(target=Name(id='t', ctx=Store()), iter=Name(id='types', ctx=Load()), body=[If(test=Compare(left=Name(id='t', ctx=Load()), ops=[In()], comparators=[Name(id='registry', ctx=Load())]), body=[Return(value=Subscript(value=Name(id='registry', ctx=Load()), slice=Name(id='t', ctx=Load()), ctx=Load()))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='ensure_directory', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Ensure that the parent directory of `path` exists')), Assign(targets=[Name(id='dirname', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='makedirs', ctx=Load()), args=[Name(id='dirname', ctx=Load())], keywords=[keyword(arg='exist_ok', value=Constant(value=True))]))], decorator_list=[]), FunctionDef(name='_bypass_ensure_directory', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Sandbox-bypassing version of ensure_directory()')), If(test=UnaryOp(op=Not(), operand=Name(id='WRITE_SUPPORT', ctx=Load())), body=[Raise(exc=Call(func=Name(id='IOError', ctx=Load()), args=[Constant(value='"os.mkdir" not supported on this platform.')], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='dirname', ctx=Store()), Name(id='filename', ctx=Store())], ctx=Store())], value=Call(func=Name(id='split', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='dirname', ctx=Load()), Name(id='filename', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Name(id='isdir', ctx=Load()), args=[Name(id='dirname', ctx=Load())], keywords=[]))]), body=[Expr(value=Call(func=Name(id='_bypass_ensure_directory', ctx=Load()), args=[Name(id='dirname', ctx=Load())], keywords=[])), Try(body=[Expr(value=Call(func=Name(id='mkdir', ctx=Load()), args=[Name(id='dirname', ctx=Load()), Constant(value=493)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='FileExistsError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='split_sections', args=arguments(posonlyargs=[], args=[arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Split a string or iterable thereof into (section, content) pairs\n\n    Each ``section`` is a stripped version of the section header ("[section]")\n    and each ``content`` is a list of stripped lines excluding blank lines and\n    comment-only lines.  If there are any such lines before the first section\n    header, they\'re returned in a first ``section`` of ``None``.\n    ')), Assign(targets=[Name(id='section', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='content', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Call(func=Name(id='yield_lines', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='[')], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value=']')], keywords=[]), body=[If(test=BoolOp(op=Or(), values=[Name(id='section', ctx=Load()), Name(id='content', ctx=Load())]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='section', ctx=Load()), Name(id='content', ctx=Load())], ctx=Load())))], orelse=[]), Assign(targets=[Name(id='section', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=Constant(value=1), upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='content', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Invalid section heading'), Name(id='line', ctx=Load())], keywords=[]))])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]))])], orelse=[]), Expr(value=Yield(value=Tuple(elts=[Name(id='section', ctx=Load()), Name(id='content', ctx=Load())], ctx=Load())))], decorator_list=[]), FunctionDef(name='_mkstemp', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Assign(targets=[Name(id='old_open', ctx=Store())], value=Attribute(value=Name(id='os', ctx=Load()), attr='open', ctx=Load())), Try(body=[Assign(targets=[Attribute(value=Name(id='os', ctx=Load()), attr='open', ctx=Store())], value=Name(id='os_open', ctx=Load())), Return(value=Call(func=Attribute(value=Name(id='tempfile', ctx=Load()), attr='mkstemp', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kw', ctx=Load()))]))], handlers=[], orelse=[], finalbody=[Assign(targets=[Attribute(value=Name(id='os', ctx=Load()), attr='open', ctx=Store())], value=Name(id='old_open', ctx=Load()))])], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='filterwarnings', ctx=Load()), args=[Constant(value='ignore')], keywords=[keyword(arg='category', value=Name(id='PEP440Warning', ctx=Load())), keyword(arg='append', value=Constant(value=True))])), FunctionDef(name='_call_aside', args=arguments(posonlyargs=[], args=[arg(arg='f')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Name(id='f', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Return(value=Name(id='f', ctx=Load()))], decorator_list=[]), FunctionDef(name='_initialize', args=arguments(posonlyargs=[], args=[arg(arg='g')], kwonlyargs=[], kw_defaults=[], defaults=[Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Constant(value='Set up global resource manager (deliberately not state-saved)')), Assign(targets=[Name(id='manager', ctx=Store())], value=Call(func=Name(id='ResourceManager', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='g', ctx=Load()), slice=Constant(value='_manager'), ctx=Store())], value=Name(id='manager', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='g', ctx=Load()), attr='update', ctx=Load()), args=[GeneratorExp(elt=Tuple(elts=[Name(id='name', ctx=Load()), Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='manager', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])], ctx=Load()), generators=[comprehension(target=Name(id='name', ctx=Store()), iter=Call(func=Name(id='dir', ctx=Load()), args=[Name(id='manager', ctx=Load())], keywords=[]), ifs=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_')], keywords=[]))], is_async=0)])], keywords=[]))], decorator_list=[Name(id='_call_aside', ctx=Load())]), ClassDef(name='PkgResourcesDeprecationWarning', bases=[Name(id='Warning', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Base class for warning about deprecations in ``pkg_resources``\n\n    This class is not derived from ``DeprecationWarning``, and as such is\n    visible by default.\n    '))], decorator_list=[]), FunctionDef(name='_initialize_master_working_set', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Prepare the master working set and make the ``require()``\n    API available.\n\n    This function has explicit effects on the global state\n    of pkg_resources. It is intended to be invoked once at\n    the initialization of this module.\n\n    Invocation by other packages is unsupported and done\n    at their own risk.\n    ')), Assign(targets=[Name(id='working_set', ctx=Store())], value=Call(func=Attribute(value=Name(id='WorkingSet', ctx=Load()), attr='_build_master', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='_declare_state', ctx=Load()), args=[Constant(value='object')], keywords=[keyword(arg='working_set', value=Name(id='working_set', ctx=Load()))])), Assign(targets=[Name(id='require', ctx=Store())], value=Attribute(value=Name(id='working_set', ctx=Load()), attr='require', ctx=Load())), Assign(targets=[Name(id='iter_entry_points', ctx=Store())], value=Attribute(value=Name(id='working_set', ctx=Load()), attr='iter_entry_points', ctx=Load())), Assign(targets=[Name(id='add_activation_listener', ctx=Store())], value=Attribute(value=Name(id='working_set', ctx=Load()), attr='subscribe', ctx=Load())), Assign(targets=[Name(id='run_script', ctx=Store())], value=Attribute(value=Name(id='working_set', ctx=Load()), attr='run_script', ctx=Load())), Assign(targets=[Name(id='run_main', ctx=Store())], value=Name(id='run_script', ctx=Load())), Expr(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='activate', ctx=Load()), args=[], keywords=[keyword(arg='replace', value=Constant(value=False))]), generators=[comprehension(target=Name(id='dist', ctx=Store()), iter=Name(id='working_set', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Expr(value=Call(func=Name(id='add_activation_listener', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='activate', ctx=Load()), args=[], keywords=[keyword(arg='replace', value=Constant(value=True))]))], keywords=[keyword(arg='existing', value=Constant(value=False))])), Assign(targets=[Attribute(value=Name(id='working_set', ctx=Load()), attr='entries', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='working_set', ctx=Load()), attr='add_entry', ctx=Load()), Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[]), attr='update', ctx=Load()), args=[Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[Name(id='_call_aside', ctx=Load())])], type_ignores=[])