Module(body=[Import(names=[alias(name='csv')]), Import(names=[alias(name='email.message')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='json')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='pathlib')]), Import(names=[alias(name='re')]), Import(names=[alias(name='zipfile')]), ImportFrom(module='typing', names=[alias(name='IO'), alias(name='TYPE_CHECKING'), alias(name='Any'), alias(name='Collection'), alias(name='Container'), alias(name='Dict'), alias(name='Iterable'), alias(name='Iterator'), alias(name='List'), alias(name='NamedTuple'), alias(name='Optional'), alias(name='Tuple'), alias(name='Union')], level=0), ImportFrom(module='pip._vendor.packaging.requirements', names=[alias(name='Requirement')], level=0), ImportFrom(module='pip._vendor.packaging.specifiers', names=[alias(name='InvalidSpecifier'), alias(name='SpecifierSet')], level=0), ImportFrom(module='pip._vendor.packaging.utils', names=[alias(name='NormalizedName'), alias(name='canonicalize_name')], level=0), ImportFrom(module='pip._vendor.packaging.version', names=[alias(name='LegacyVersion'), alias(name='Version')], level=0), ImportFrom(module='pip._internal.exceptions', names=[alias(name='NoneMetadataError')], level=0), ImportFrom(module='pip._internal.locations', names=[alias(name='site_packages'), alias(name='user_site')], level=0), ImportFrom(module='pip._internal.models.direct_url', names=[alias(name='DIRECT_URL_METADATA_NAME'), alias(name='DirectUrl'), alias(name='DirectUrlValidationError')], level=0), ImportFrom(module='pip._internal.utils.compat', names=[alias(name='stdlib_pkgs')], level=0), ImportFrom(module='pip._internal.utils.egg_link', names=[alias(name='egg_link_path_from_sys_path')], level=0), ImportFrom(module='pip._internal.utils.misc', names=[alias(name='is_local'), alias(name='normalize_path')], level=0), ImportFrom(module='pip._internal.utils.urls', names=[alias(name='url_to_path')], level=0), ImportFrom(module='_json', names=[alias(name='msg_to_json')], level=1), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='typing', names=[alias(name='Protocol')], level=0)], orelse=[Assign(targets=[Name(id='Protocol', ctx=Store())], value=Name(id='object', ctx=Load()))]), Assign(targets=[Name(id='DistributionVersion', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='LegacyVersion', ctx=Load()), Name(id='Version', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='InfoPath', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='pathlib', ctx=Load()), attr='PurePath', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='BaseEntryPoint', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='value', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='group', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))], decorator_list=[]), FunctionDef(name='_convert_installed_files_path', args=arguments(posonlyargs=[], args=[arg(arg='entry', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), arg(arg='info', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Convert a legacy installed-files.txt path into modern RECORD path.\n\n    The legacy format stores paths relative to the info directory, while the\n    modern format stores paths relative to the package root, e.g. the\n    site-packages directory.\n\n    :param entry: Path parts of the installed-files.txt entry.\n    :param info: Path parts of the egg-info directory relative to package root.\n    :returns: The converted entry.\n\n    For best compatibility with symlinks, this does not use ``abspath()`` or\n    ``Path.resolve()``, but tries to work with path parts:\n\n    1. While ``entry`` starts with ``..``, remove the equal amounts of parts\n       from ``info``; if ``info`` is empty, start appending ``..`` instead.\n    2. Join the two directly.\n    ')), While(test=BoolOp(op=And(), values=[Name(id='entry', ctx=Load()), Compare(left=Subscript(value=Name(id='entry', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Constant(value='..')])]), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='info', ctx=Load())), Compare(left=Subscript(value=Name(id='info', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), ops=[Eq()], comparators=[Constant(value='..')])]), body=[AugAssign(target=Name(id='info', ctx=Store()), op=Add(), value=Tuple(elts=[Constant(value='..')], ctx=Load()))], orelse=[Assign(targets=[Name(id='info', ctx=Store())], value=Subscript(value=Name(id='info', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))]), Assign(targets=[Name(id='entry', ctx=Store())], value=Subscript(value=Name(id='entry', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Starred(value=Name(id='info', ctx=Load()), ctx=Load()), Starred(value=Name(id='entry', ctx=Load()), ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), ClassDef(name='RequiresEntry', bases=[Name(id='NamedTuple', ctx=Load())], keywords=[], body=[AnnAssign(target=Name(id='requirement', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='extra', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='marker', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='BaseDistribution', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[FunctionDef(name='from_directory', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='directory', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Load the distribution from a metadata directory.\n\n        :param directory: Path to a metadata directory, e.g. ``.dist-info``.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='BaseDistribution')), FunctionDef(name='from_metadata_file_contents', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='metadata_contents', annotation=Name(id='bytes', ctx=Load())), arg(arg='filename', annotation=Name(id='str', ctx=Load())), arg(arg='project_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Load the distribution from the contents of a METADATA file.\n\n        This is used to implement PEP 658 by generating a "shallow" dist object that can\n        be used for resolution without downloading or building the actual dist yet.\n\n        :param metadata_contents: The contents of a METADATA file.\n        :param filename: File name for the dist with this metadata.\n        :param project_name: Name of the project this dist represents.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='BaseDistribution')), FunctionDef(name='from_wheel', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='wheel', annotation=Constant(value='Wheel')), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Load the distribution from a given wheel.\n\n        :param wheel: A concrete wheel definition.\n        :param name: File name of the wheel.\n\n        :raises InvalidWheel: Whenever loading of the wheel causes a\n            :py:exc:`zipfile.BadZipFile` exception to be thrown.\n        :raises UnsupportedWheel: If the wheel is a valid zip, but malformed\n            internally.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='BaseDistribution')), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='raw_name', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load()), conversion=-1), Constant(value=' ('), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load()), conversion=-1), Constant(value=')')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='raw_name', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load()), conversion=-1)]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='location', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Where the distribution is loaded from.\n\n        A string value is not necessarily a filesystem path, since distributions\n        can be loaded from other sources, e.g. arbitrary zip archives. ``None``\n        means the distribution is created in-memory.\n\n        Do not canonicalize this value with e.g. ``pathlib.Path.resolve()``. If\n        this is a symbolic link, we want to preserve the relative path between\n        it and files in the distribution.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='editable_project_location', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The project location for editable distributions.\n\n        This is the directory where pyproject.toml or setup.py is located.\n        None if the distribution is not installed in editable mode.\n        ')), Assign(targets=[Name(id='direct_url', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='direct_url', ctx=Load())), If(test=Name(id='direct_url', ctx=Load()), body=[If(test=Call(func=Attribute(value=Name(id='direct_url', ctx=Load()), attr='is_local_editable', ctx=Load()), args=[], keywords=[]), body=[Return(value=Call(func=Name(id='url_to_path', ctx=Load()), args=[Attribute(value=Name(id='direct_url', ctx=Load()), attr='url', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='egg_link_path', ctx=Store())], value=Call(func=Name(id='egg_link_path_from_sys_path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='raw_name', ctx=Load())], keywords=[])), If(test=Name(id='egg_link_path', ctx=Load()), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load()))], orelse=[])]), Return(value=Constant(value=None))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='installed_location', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The distribution\'s "installed" location.\n\n        This should generally be a ``site-packages`` directory. This is\n        usually ``dist.location``, except for legacy develop-installed packages,\n        where ``dist.location`` is the source code location, and this is where\n        the ``.egg-link`` file is.\n\n        The returned location is normalized (in particular, with symlinks removed).\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='info_location', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Location of the .[egg|dist]-info directory or file.\n\n        Similarly to ``location``, a string value is not necessarily a\n        filesystem path. ``None`` means the distribution is created in-memory.\n\n        For a modern .dist-info installation on disk, this should be something\n        like ``{location}/{raw_name}-{version}.dist-info``.\n\n        Do not canonicalize this value with e.g. ``pathlib.Path.resolve()``. If\n        this is a symbolic link, we want to preserve the relative path between\n        it and other files in the distribution.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='installed_by_distutils', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether this distribution is installed with legacy distutils format.\n\n        A distribution installed with "raw" distutils not patched by setuptools\n        uses one single file at ``info_location`` to store metadata. We need to\n        treat this specially on uninstallation.\n        ')), Assign(targets=[Name(id='info_location', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='info_location', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='info_location', ctx=Load())), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Name(id='info_location', ctx=Load())], keywords=[]), attr='is_file', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='installed_as_egg', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether this distribution is installed as an egg.\n\n        This usually indicates the distribution was installed by (older versions\n        of) easy_install.\n        ')), Assign(targets=[Name(id='location', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='location', ctx=Load())), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='location', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.egg')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='installed_with_setuptools_egg_info', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether this distribution is installed with the ``.egg-info`` format.\n\n        This usually indicates the distribution was installed with setuptools\n        with an old pip version or with ``single-version-externally-managed``.\n\n        Note that this ensure the metadata store is a directory. distutils can\n        also installs an ``.egg-info``, but as a file, not a directory. This\n        property is *False* for that case. Also see ``installed_by_distutils``.\n        ')), Assign(targets=[Name(id='info_location', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='info_location', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='info_location', ctx=Load())), body=[Return(value=Constant(value=False))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='info_location', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.egg-info')], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Name(id='info_location', ctx=Load())], keywords=[]), attr='is_dir', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='installed_with_dist_info', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether this distribution is installed with the "modern format".\n\n        This indicates a "modern" installation, e.g. storing metadata in the\n        ``.dist-info`` directory. This applies to installations made by\n        setuptools (but through pip, not directly), or anything using the\n        standardized build backend interface (PEP 517).\n        ')), Assign(targets=[Name(id='info_location', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='info_location', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='info_location', ctx=Load())), body=[Return(value=Constant(value=False))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='info_location', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.dist-info')], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Name(id='info_location', ctx=Load())], keywords=[]), attr='is_dir', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='canonical_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='NormalizedName', ctx=Load())), FunctionDef(name='version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='DistributionVersion', ctx=Load())), FunctionDef(name='setuptools_filename', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Convert a project name to its setuptools-compatible filename.\n\n        This is a copy of ``pkg_resources.to_filename()`` for compatibility.\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='raw_name', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='_')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='direct_url', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Obtain a DirectUrl from this distribution.\n\n        Returns None if the distribution has no `direct_url.json` metadata,\n        or if `direct_url.json` is invalid.\n        ')), Try(body=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Name(id='DIRECT_URL_METADATA_NAME', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Return(value=Constant(value=None))])], orelse=[], finalbody=[]), Try(body=[Return(value=Call(func=Attribute(value=Name(id='DirectUrl', ctx=Load()), attr='from_json', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='UnicodeDecodeError', ctx=Load()), Attribute(value=Name(id='json', ctx=Load()), attr='JSONDecodeError', ctx=Load()), Name(id='DirectUrlValidationError', ctx=Load())], ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Error parsing %s for %s: %s'), Name(id='DIRECT_URL_METADATA_NAME', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='canonical_name', ctx=Load()), Name(id='e', ctx=Load())], keywords=[])), Return(value=Constant(value=None))])], orelse=[], finalbody=[])], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='DirectUrl', ctx=Load()), ctx=Load())), FunctionDef(name='installer', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='installer_text', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='INSTALLER')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='OSError', ctx=Load()), Name(id='ValueError', ctx=Load()), Name(id='NoneMetadataError', ctx=Load())], ctx=Load()), body=[Return(value=Constant(value=''))])], orelse=[], finalbody=[]), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='installer_text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='cleaned_line', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Name(id='cleaned_line', ctx=Load()), body=[Return(value=Name(id='cleaned_line', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=''))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='requested', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_file', ctx=Load()), args=[Constant(value='REQUESTED')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='editable', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='bool', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='editable_project_location', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='local', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="If distribution is installed in the current virtual environment.\n\n        Always True if we're not in a virtualenv.\n        ")), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='installed_location', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Name(id='is_local', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='installed_location', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='in_usersite', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='installed_location', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='user_site', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='installed_location', ctx=Load()), attr='startswith', ctx=Load()), args=[Call(func=Name(id='normalize_path', ctx=Load()), args=[Name(id='user_site', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='in_site_packages', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='installed_location', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='site_packages', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='installed_location', ctx=Load()), attr='startswith', ctx=Load()), args=[Call(func=Name(id='normalize_path', ctx=Load()), args=[Name(id='site_packages', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='is_file', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path', annotation=Name(id='InfoPath', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check whether an entry in the info directory is a file.')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='iter_distutils_script_names', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Find distutils 'scripts' entries metadata.\n\n        If 'scripts' is supplied in ``setup.py``, distutils records those in the\n        installed distribution's ``scripts`` directory, a file for each script.\n        ")), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='read_text', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path', annotation=Name(id='InfoPath', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Read a file in the info directory.\n\n        :raise FileNotFoundError: If ``path`` does not exist in the directory.\n        :raise NoneMetadataError: If ``path`` exists in the info directory, but\n            cannot be read.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='iter_entry_points', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='BaseEntryPoint', ctx=Load()), ctx=Load())), FunctionDef(name='_metadata_impl', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Attribute(value=Attribute(value=Name(id='email', ctx=Load()), attr='message', ctx=Load()), attr='Message', ctx=Load())), FunctionDef(name='_metadata_cached', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_metadata_impl', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_egg_info_requires', ctx=Load()), args=[Name(id='metadata', ctx=Load())], keywords=[])), Return(value=Name(id='metadata', ctx=Load()))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='lru_cache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=1))])], returns=Attribute(value=Attribute(value=Name(id='email', ctx=Load()), attr='message', ctx=Load()), attr='Message', ctx=Load())), FunctionDef(name='metadata', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Metadata of distribution parsed from e.g. METADATA or PKG-INFO.\n\n        This should return an empty message if the metadata file is unavailable.\n\n        :raises NoneMetadataError: If the metadata file is available, but does\n            not contain valid metadata.\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_metadata_cached', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Attribute(value=Name(id='email', ctx=Load()), attr='message', ctx=Load()), attr='Message', ctx=Load())), FunctionDef(name='metadata_dict', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='PEP 566 compliant JSON-serializable representation of METADATA or PKG-INFO.\n\n        This should return an empty dict if the metadata file is unavailable.\n\n        :raises NoneMetadataError: If the metadata file is available, but does\n            not contain valid metadata.\n        ')), Return(value=Call(func=Name(id='msg_to_json', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='metadata_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Value of "Metadata-Version:" in distribution metadata, if available.')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='Metadata-Version')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='raw_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Value of "Name:" in distribution metadata.')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='Name'), Attribute(value=Name(id='self', ctx=Load()), attr='canonical_name', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='requires_python', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Value of "Requires-Python:" in distribution metadata.\n\n        If the key does not exist or contains an invalid value, an empty\n        SpecifierSet should be returned.\n        ')), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='Requires-Python')], keywords=[])), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='SpecifierSet', ctx=Load()), args=[], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Name(id='spec', ctx=Store())], value=Call(func=Name(id='SpecifierSet', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='InvalidSpecifier', ctx=Load()), name='e', body=[Assign(targets=[Name(id='message', ctx=Store())], value=Constant(value='Package %r has an invalid Requires-Python: %s')), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Name(id='message', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='raw_name', ctx=Load()), Name(id='e', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='SpecifierSet', ctx=Load()), args=[], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Name(id='spec', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='SpecifierSet', ctx=Load())), FunctionDef(name='iter_dependencies', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='extras', annotation=Subscript(value=Name(id='Collection', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[], ctx=Load())]), body=[Expr(value=Constant(value='Dependencies of this distribution.\n\n        For modern .dist-info distributions, this is the collection of\n        "Requires-Dist:" entries in distribution metadata.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Requirement', ctx=Load()), ctx=Load())), FunctionDef(name='iter_provided_extras', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Extras provided by this distribution.\n\n        For modern .dist-info distributions, this is the collection of\n        "Provides-Extra:" entries in distribution metadata.\n\n        The return value of this function is not particularly useful other than\n        display purposes due to backward compatibility issues and the extra\n        names being poorly normalized prior to PEP 685. If you want to perform\n        logic operations on extras, use :func:`is_extra_provided` instead.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='is_extra_provided', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='extra', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check whether an extra is provided by this distribution.\n\n        This is needed mostly for compatibility issues with pkg_resources not\n        following the extra normalization rules defined in PEP 685.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_iter_declared_entries_from_record', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='RECORD')], keywords=[]))], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Return(value=Constant(value=None))])], orelse=[], finalbody=[]), Return(value=GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Subscript(value=Name(id='row', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='row', ctx=Store()), iter=Call(func=Attribute(value=Name(id='csv', ctx=Load()), attr='reader', ctx=Load()), args=[Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='_iter_declared_entries_from_legacy', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='installed-files.txt')], keywords=[]))], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Return(value=Constant(value=None))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='paths', ctx=Store())], value=GeneratorExp(elt=Name(id='p', ctx=Load()), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[keyword(arg='keepends', value=Constant(value=False))]), ifs=[Name(id='p', ctx=Load())], is_async=0)])), Assign(targets=[Name(id='root', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load())), Assign(targets=[Name(id='info', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='info_location', ctx=Load())), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='root', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='info', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Return(value=Name(id='paths', ctx=Load()))], orelse=[]), Try(body=[Assign(targets=[Name(id='info_rel', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Name(id='info', ctx=Load())], keywords=[]), attr='relative_to', ctx=Load()), args=[Name(id='root', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=Name(id='paths', ctx=Load()))])], orelse=[], finalbody=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='info_rel', ctx=Load()), attr='parts', ctx=Load())), body=[Return(value=Name(id='paths', ctx=Load()))], orelse=[]), Return(value=GeneratorExp(elt=Call(func=Name(id='_convert_installed_files_path', ctx=Load()), args=[Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[]), attr='parts', ctx=Load()), Attribute(value=Name(id='info_rel', ctx=Load()), attr='parts', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='paths', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='iter_declared_entries', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterate through file entries declared in this distribution.\n\n        For modern .dist-info distributions, this is the files listed in the\n        ``RECORD`` metadata file. For legacy setuptools distributions, this\n        comes from ``installed-files.txt``, with entries normalized to be\n        compatible with the format used by ``RECORD``.\n\n        :return: An iterator for listed entries, or None if the distribution\n            contains neither ``RECORD`` nor ``installed-files.txt``.\n        ')), Return(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_iter_declared_entries_from_record', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_iter_declared_entries_from_legacy', ctx=Load()), args=[], keywords=[])]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='_iter_requires_txt_entries', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parse a ``requires.txt`` in an egg-info directory.\n\n        This is an INI-ish format where an egg-info stores dependencies. A\n        section name describes extra other environment markers, while each entry\n        is an arbitrary string (not a key-value pair) representing a dependency\n        as a requirement string (no markers).\n\n        There is a construct in ``importlib.metadata`` called ``Sectioned`` that\n        does mostly the same, but the format is currently considered private.\n        ')), Try(body=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='requires.txt')], keywords=[]))], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Return()])], orelse=[], finalbody=[]), Assign(targets=[Name(id='extra', ctx=Store()), Name(id='marker', ctx=Store())], value=Constant(value='')), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='line', ctx=Load())), Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='#')], keywords=[])]), body=[Continue()], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='[')], keywords=[]), Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value=']')], keywords=[])]), body=[Assign(targets=[Tuple(elts=[Name(id='extra', ctx=Store()), Name(id='_', ctx=Store()), Name(id='marker', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[Constant(value='[]')], keywords=[]), attr='partition', ctx=Load()), args=[Constant(value=':')], keywords=[])), Continue()], orelse=[]), Expr(value=Yield(value=Call(func=Name(id='RequiresEntry', ctx=Load()), args=[], keywords=[keyword(arg='requirement', value=Name(id='line', ctx=Load())), keyword(arg='extra', value=Name(id='extra', ctx=Load())), keyword(arg='marker', value=Name(id='marker', ctx=Load()))])))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='RequiresEntry', ctx=Load()), ctx=Load())), FunctionDef(name='_iter_egg_info_extras', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get extras from the egg-info directory.')), Assign(targets=[Name(id='known_extras', ctx=Store())], value=Set(elts=[Constant(value='')])), For(target=Name(id='entry', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_iter_requires_txt_entries', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='extra', ctx=Store())], value=Call(func=Name(id='canonicalize_name', ctx=Load()), args=[Attribute(value=Name(id='entry', ctx=Load()), attr='extra', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='extra', ctx=Load()), ops=[In()], comparators=[Name(id='known_extras', ctx=Load())]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='known_extras', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='extra', ctx=Load())], keywords=[])), Expr(value=Yield(value=Name(id='extra', ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_iter_egg_info_dependencies', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get distribution dependencies from the egg-info directory.\n\n        To ease parsing, this converts a legacy dependency entry into a PEP 508\n        requirement string. Like ``_iter_requires_txt_entries()``, there is code\n        in ``importlib.metadata`` that does mostly the same, but not do exactly\n        what we need.\n\n        Namely, ``importlib.metadata`` does not normalize the extra name before\n        putting it into the requirement string, which causes marker comparison\n        to fail because the dist-info format do normalize. This is consistent in\n        all currently available PEP 517 backends, although not standardized.\n        ')), For(target=Name(id='entry', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_iter_requires_txt_entries', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='extra', ctx=Store())], value=Call(func=Name(id='canonicalize_name', ctx=Load()), args=[Attribute(value=Name(id='entry', ctx=Load()), attr='extra', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='extra', ctx=Load()), Attribute(value=Name(id='entry', ctx=Load()), attr='marker', ctx=Load())]), body=[Assign(targets=[Name(id='marker', ctx=Store())], value=JoinedStr(values=[Constant(value='('), FormattedValue(value=Attribute(value=Name(id='entry', ctx=Load()), attr='marker', ctx=Load()), conversion=-1), Constant(value=') and extra == "'), FormattedValue(value=Name(id='extra', ctx=Load()), conversion=-1), Constant(value='"')]))], orelse=[If(test=Name(id='extra', ctx=Load()), body=[Assign(targets=[Name(id='marker', ctx=Store())], value=JoinedStr(values=[Constant(value='extra == "'), FormattedValue(value=Name(id='extra', ctx=Load()), conversion=-1), Constant(value='"')]))], orelse=[If(test=Attribute(value=Name(id='entry', ctx=Load()), attr='marker', ctx=Load()), body=[Assign(targets=[Name(id='marker', ctx=Store())], value=Attribute(value=Name(id='entry', ctx=Load()), attr='marker', ctx=Load()))], orelse=[Assign(targets=[Name(id='marker', ctx=Store())], value=Constant(value=''))])])]), If(test=Name(id='marker', ctx=Load()), body=[Expr(value=Yield(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='entry', ctx=Load()), attr='requirement', ctx=Load()), conversion=-1), Constant(value=' ; '), FormattedValue(value=Name(id='marker', ctx=Load()), conversion=-1)])))], orelse=[Expr(value=Yield(value=Attribute(value=Name(id='entry', ctx=Load()), attr='requirement', ctx=Load())))])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_add_egg_info_requires', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='metadata', annotation=Attribute(value=Attribute(value=Name(id='email', ctx=Load()), attr='message', ctx=Load()), attr='Message', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add egg-info requires.txt information to the metadata.')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='get_all', ctx=Load()), args=[Constant(value='Requires-Dist')], keywords=[])), body=[For(target=Name(id='dep', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_iter_egg_info_dependencies', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='metadata', ctx=Load()), slice=Constant(value='Requires-Dist'), ctx=Store())], value=Name(id='dep', ctx=Load()))], orelse=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='get_all', ctx=Load()), args=[Constant(value='Provides-Extra')], keywords=[])), body=[For(target=Name(id='extra', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_iter_egg_info_extras', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='metadata', ctx=Load()), slice=Constant(value='Provides-Extra'), ctx=Store())], value=Name(id='extra', ctx=Load()))], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='BaseEnvironment', bases=[], keywords=[], body=[Expr(value=Constant(value='An environment containing distributions to introspect.')), FunctionDef(name='default', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='BaseEnvironment')), FunctionDef(name='from_paths', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='paths', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='BaseEnvironment')), FunctionDef(name='get_distribution', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Given a requirement name, return the installed distributions.\n\n        The name may not be normalized. The implementation must canonicalize\n        it for lookup.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='BaseDistribution'), ctx=Load())), FunctionDef(name='_iter_distributions', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterate through installed distributions.\n\n        This function should be implemented by subclass, but never called\n        directly. Use the public ``iter_distribution()`` instead, which\n        implements additional logic to make sure the distributions are valid.\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Constant(value='BaseDistribution'), ctx=Load())), FunctionDef(name='iter_all_distributions', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterate through all installed distributions without any filtering.')), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_iter_distributions', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='project_name_valid', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Constant(value='^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$'), Attribute(value=Name(id='dist', ctx=Load()), attr='canonical_name', ctx=Load())], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load()))])), If(test=UnaryOp(op=Not(), operand=Name(id='project_name_valid', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Ignoring invalid distribution %s (%s)'), Attribute(value=Name(id='dist', ctx=Load()), attr='canonical_name', ctx=Load()), Attribute(value=Name(id='dist', ctx=Load()), attr='location', ctx=Load())], keywords=[])), Continue()], orelse=[]), Expr(value=Yield(value=Name(id='dist', ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='BaseDistribution', ctx=Load()), ctx=Load())), FunctionDef(name='iter_installed_distributions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='local_only', annotation=Name(id='bool', ctx=Load())), arg(arg='skip', annotation=Subscript(value=Name(id='Container', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='include_editables', annotation=Name(id='bool', ctx=Load())), arg(arg='editables_only', annotation=Name(id='bool', ctx=Load())), arg(arg='user_only', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Name(id='stdlib_pkgs', ctx=Load()), Constant(value=True), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value="Return a list of installed distributions.\n\n        This is based on ``iter_all_distributions()`` with additional filtering\n        options. Note that ``iter_installed_distributions()`` without arguments\n        is *not* equal to ``iter_all_distributions()``, since some of the\n        configurations exclude packages by default.\n\n        :param local_only: If True (default), only return installations\n        local to the current virtualenv, if in a virtualenv.\n        :param skip: An iterable of canonicalized project names to ignore;\n            defaults to ``stdlib_pkgs``.\n        :param include_editables: If False, don't report editables.\n        :param editables_only: If True, only report editables.\n        :param user_only: If True, only report installations in the user\n        site directory.\n        ")), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iter_all_distributions', ctx=Load()), args=[], keywords=[])), If(test=Name(id='local_only', ctx=Load()), body=[Assign(targets=[Name(id='it', ctx=Store())], value=GeneratorExp(elt=Name(id='d', ctx=Load()), generators=[comprehension(target=Name(id='d', ctx=Store()), iter=Name(id='it', ctx=Load()), ifs=[Attribute(value=Name(id='d', ctx=Load()), attr='local', ctx=Load())], is_async=0)]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='include_editables', ctx=Load())), body=[Assign(targets=[Name(id='it', ctx=Store())], value=GeneratorExp(elt=Name(id='d', ctx=Load()), generators=[comprehension(target=Name(id='d', ctx=Store()), iter=Name(id='it', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='d', ctx=Load()), attr='editable', ctx=Load()))], is_async=0)]))], orelse=[]), If(test=Name(id='editables_only', ctx=Load()), body=[Assign(targets=[Name(id='it', ctx=Store())], value=GeneratorExp(elt=Name(id='d', ctx=Load()), generators=[comprehension(target=Name(id='d', ctx=Store()), iter=Name(id='it', ctx=Load()), ifs=[Attribute(value=Name(id='d', ctx=Load()), attr='editable', ctx=Load())], is_async=0)]))], orelse=[]), If(test=Name(id='user_only', ctx=Load()), body=[Assign(targets=[Name(id='it', ctx=Store())], value=GeneratorExp(elt=Name(id='d', ctx=Load()), generators=[comprehension(target=Name(id='d', ctx=Store()), iter=Name(id='it', ctx=Load()), ifs=[Attribute(value=Name(id='d', ctx=Load()), attr='in_usersite', ctx=Load())], is_async=0)]))], orelse=[]), Return(value=GeneratorExp(elt=Name(id='d', ctx=Load()), generators=[comprehension(target=Name(id='d', ctx=Store()), iter=Name(id='it', ctx=Load()), ifs=[Compare(left=Attribute(value=Name(id='d', ctx=Load()), attr='canonical_name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='skip', ctx=Load())])], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='BaseDistribution', ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='Wheel', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[AnnAssign(target=Name(id='location', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), FunctionDef(name='as_zipfile', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load()))], decorator_list=[]), ClassDef(name='FilesystemWheel', bases=[Name(id='Wheel', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Store())], value=Name(id='location', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='as_zipfile', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load())], keywords=[keyword(arg='allowZip64', value=Constant(value=True))]))], decorator_list=[], returns=Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load()))], decorator_list=[]), ClassDef(name='MemoryWheel', bases=[Name(id='Wheel', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load())), arg(arg='stream', annotation=Subscript(value=Name(id='IO', ctx=Load()), slice=Name(id='bytes', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Store())], value=Name(id='location', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Store())], value=Name(id='stream', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='as_zipfile', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load())], keywords=[keyword(arg='allowZip64', value=Constant(value=True))]))], decorator_list=[], returns=Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load()))], decorator_list=[])], type_ignores=[])