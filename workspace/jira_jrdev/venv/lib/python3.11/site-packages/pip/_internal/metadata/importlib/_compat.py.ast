Module(body=[Import(names=[alias(name='importlib.metadata')]), ImportFrom(module='typing', names=[alias(name='Any'), alias(name='Optional'), alias(name='Protocol'), alias(name='cast')], level=0), ClassDef(name='BadMetadata', bases=[Name(id='ValueError', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist', annotation=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='metadata', ctx=Load()), attr='Distribution', ctx=Load()))], kwonlyargs=[arg(arg='reason', annotation=Name(id='str', ctx=Load()))], kw_defaults=[None], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Store())], value=Name(id='dist', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='reason', ctx=Store())], value=Name(id='reason', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='Bad metadata in '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), conversion=-1), Constant(value=' ('), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='reason', ctx=Load()), conversion=-1), Constant(value=')')]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='BasePath', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A protocol that various path objects conform.\n\n    This exists because importlib.metadata uses both ``pathlib.Path`` and\n    ``zipfile.Path``, and we need a common base for type hints (Union does not\n    work well since ``zipfile.Path`` is too new for our linter setup).\n\n    This does not mean to be exhaustive, but only contains things that present\n    in both classes *that we need*.\n    ')), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='parent', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Constant(value='BasePath'))], decorator_list=[]), FunctionDef(name='get_info_location', args=arguments(posonlyargs=[], args=[arg(arg='d', annotation=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='metadata', ctx=Load()), attr='Distribution', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Find the path to the distribution's metadata directory.\n\n    HACK: This relies on importlib.metadata's private ``_path`` attribute. Not\n    all distributions exist on disk, so importlib.metadata is correct to not\n    expose the attribute as public. But pip's code base is old and not as clean,\n    so we do this to avoid having to rewrite too many things. Hopefully we can\n    eliminate this some day.\n    ")), Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='d', ctx=Load()), Constant(value='_path'), Constant(value=None)], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='BasePath', ctx=Load()), ctx=Load())), FunctionDef(name='get_dist_name', args=arguments(posonlyargs=[], args=[arg(arg='dist', annotation=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='metadata', ctx=Load()), attr='Distribution', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Get the distribution's project name.\n\n    The ``name`` attribute is only available in Python 3.10 or later. We are\n    targeting exactly that, but Mypy does not know this.\n    ")), Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='Any', ctx=Load()), Name(id='dist', ctx=Load())], keywords=[]), attr='name', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='BadMetadata', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[keyword(arg='reason', value=Constant(value="invalid metadata entry 'name'"))]))], orelse=[]), Return(value=Name(id='name', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load()))], type_ignores=[])