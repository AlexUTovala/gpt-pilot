Module(body=[Import(names=[alias(name='contextlib')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='os')]), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Dict'), alias(name='List'), alias(name='Optional'), alias(name='Set'), alias(name='Tuple'), alias(name='cast')], level=0), ImportFrom(module='pip._vendor.packaging.utils', names=[alias(name='canonicalize_name')], level=0), ImportFrom(module='pip._vendor.resolvelib', names=[alias(name='BaseReporter'), alias(name='ResolutionImpossible')], level=0), ImportFrom(module='pip._vendor.resolvelib', names=[alias(name='Resolver', asname='RLResolver')], level=0), ImportFrom(module='pip._vendor.resolvelib.structs', names=[alias(name='DirectedGraph')], level=0), ImportFrom(module='pip._internal.cache', names=[alias(name='WheelCache')], level=0), ImportFrom(module='pip._internal.index.package_finder', names=[alias(name='PackageFinder')], level=0), ImportFrom(module='pip._internal.operations.prepare', names=[alias(name='RequirementPreparer')], level=0), ImportFrom(module='pip._internal.req.constructors', names=[alias(name='install_req_extend_extras')], level=0), ImportFrom(module='pip._internal.req.req_install', names=[alias(name='InstallRequirement')], level=0), ImportFrom(module='pip._internal.req.req_set', names=[alias(name='RequirementSet')], level=0), ImportFrom(module='pip._internal.resolution.base', names=[alias(name='BaseResolver'), alias(name='InstallRequirementProvider')], level=0), ImportFrom(module='pip._internal.resolution.resolvelib.provider', names=[alias(name='PipProvider')], level=0), ImportFrom(module='pip._internal.resolution.resolvelib.reporter', names=[alias(name='PipDebuggingReporter'), alias(name='PipReporter')], level=0), ImportFrom(module='pip._internal.utils.packaging', names=[alias(name='get_requirement')], level=0), ImportFrom(module='base', names=[alias(name='Candidate'), alias(name='Requirement')], level=1), ImportFrom(module='factory', names=[alias(name='Factory')], level=1), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='pip._vendor.resolvelib.resolvers', names=[alias(name='Result', asname='RLResult')], level=0), Assign(targets=[Name(id='Result', ctx=Store())], value=Subscript(value=Name(id='RLResult', ctx=Load()), slice=Tuple(elts=[Name(id='Requirement', ctx=Load()), Name(id='Candidate', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='Resolver', bases=[Name(id='BaseResolver', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='_allowed_strategies', ctx=Store())], value=Set(elts=[Constant(value='eager'), Constant(value='only-if-needed'), Constant(value='to-satisfy-only')])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='preparer', annotation=Name(id='RequirementPreparer', ctx=Load())), arg(arg='finder', annotation=Name(id='PackageFinder', ctx=Load())), arg(arg='wheel_cache', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='WheelCache', ctx=Load()), ctx=Load())), arg(arg='make_install_req', annotation=Name(id='InstallRequirementProvider', ctx=Load())), arg(arg='use_user_site', annotation=Name(id='bool', ctx=Load())), arg(arg='ignore_dependencies', annotation=Name(id='bool', ctx=Load())), arg(arg='ignore_installed', annotation=Name(id='bool', ctx=Load())), arg(arg='ignore_requires_python', annotation=Name(id='bool', ctx=Load())), arg(arg='force_reinstall', annotation=Name(id='bool', ctx=Load())), arg(arg='upgrade_strategy', annotation=Name(id='str', ctx=Load())), arg(arg='py_version_info', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assert(test=Compare(left=Name(id='upgrade_strategy', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_allowed_strategies', ctx=Load())])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='factory', ctx=Store())], value=Call(func=Name(id='Factory', ctx=Load()), args=[], keywords=[keyword(arg='finder', value=Name(id='finder', ctx=Load())), keyword(arg='preparer', value=Name(id='preparer', ctx=Load())), keyword(arg='make_install_req', value=Name(id='make_install_req', ctx=Load())), keyword(arg='wheel_cache', value=Name(id='wheel_cache', ctx=Load())), keyword(arg='use_user_site', value=Name(id='use_user_site', ctx=Load())), keyword(arg='force_reinstall', value=Name(id='force_reinstall', ctx=Load())), keyword(arg='ignore_installed', value=Name(id='ignore_installed', ctx=Load())), keyword(arg='ignore_requires_python', value=Name(id='ignore_requires_python', ctx=Load())), keyword(arg='py_version_info', value=Name(id='py_version_info', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ignore_dependencies', ctx=Store())], value=Name(id='ignore_dependencies', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='upgrade_strategy', ctx=Store())], value=Name(id='upgrade_strategy', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_result', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Result', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[]), FunctionDef(name='resolve', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='root_reqs', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load())), arg(arg='check_supported_wheels', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='collected', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='factory', ctx=Load()), attr='collect_root_requirements', ctx=Load()), args=[Name(id='root_reqs', ctx=Load())], keywords=[])), Assign(targets=[Name(id='provider', ctx=Store())], value=Call(func=Name(id='PipProvider', ctx=Load()), args=[], keywords=[keyword(arg='factory', value=Attribute(value=Name(id='self', ctx=Load()), attr='factory', ctx=Load())), keyword(arg='constraints', value=Attribute(value=Name(id='collected', ctx=Load()), attr='constraints', ctx=Load())), keyword(arg='ignore_dependencies', value=Attribute(value=Name(id='self', ctx=Load()), attr='ignore_dependencies', ctx=Load())), keyword(arg='upgrade_strategy', value=Attribute(value=Name(id='self', ctx=Load()), attr='upgrade_strategy', ctx=Load())), keyword(arg='user_requested', value=Attribute(value=Name(id='collected', ctx=Load()), attr='user_requested', ctx=Load()))])), If(test=Compare(left=Constant(value='PIP_RESOLVER_DEBUG'), ops=[In()], comparators=[Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load())]), body=[AnnAssign(target=Name(id='reporter', ctx=Store()), annotation=Name(id='BaseReporter', ctx=Load()), value=Call(func=Name(id='PipDebuggingReporter', ctx=Load()), args=[], keywords=[]), simple=1)], orelse=[Assign(targets=[Name(id='reporter', ctx=Store())], value=Call(func=Name(id='PipReporter', ctx=Load()), args=[], keywords=[]))]), AnnAssign(target=Name(id='resolver', ctx=Store()), annotation=Subscript(value=Name(id='RLResolver', ctx=Load()), slice=Tuple(elts=[Name(id='Requirement', ctx=Load()), Name(id='Candidate', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='RLResolver', ctx=Load()), args=[Name(id='provider', ctx=Load()), Name(id='reporter', ctx=Load())], keywords=[]), simple=1), Try(body=[Assign(targets=[Name(id='limit_how_complex_resolution_can_be', ctx=Store())], value=Constant(value=200000)), Assign(targets=[Name(id='result', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='resolver', ctx=Load()), attr='resolve', ctx=Load()), args=[Attribute(value=Name(id='collected', ctx=Load()), attr='requirements', ctx=Load())], keywords=[keyword(arg='max_rounds', value=Name(id='limit_how_complex_resolution_can_be', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='ResolutionImpossible', ctx=Load()), name='e', body=[Assign(targets=[Name(id='error', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='factory', ctx=Load()), attr='get_installation_error', ctx=Load()), args=[Call(func=Name(id='cast', ctx=Load()), args=[Constant(value='ResolutionImpossible[Requirement, Candidate]'), Name(id='e', ctx=Load())], keywords=[]), Attribute(value=Name(id='collected', ctx=Load()), attr='constraints', ctx=Load())], keywords=[])), Raise(exc=Name(id='error', ctx=Load()), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='req_set', ctx=Store())], value=Call(func=Name(id='RequirementSet', ctx=Load()), args=[], keywords=[keyword(arg='check_supported_wheels', value=Name(id='check_supported_wheels', ctx=Load()))])), For(target=Name(id='candidate', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='mapping', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='c')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Attribute(value=Name(id='c', ctx=Load()), attr='name', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='c', ctx=Load()), attr='project_name', ctx=Load())])))]), body=[Assign(targets=[Name(id='ireq', ctx=Store())], value=Call(func=Attribute(value=Name(id='candidate', ctx=Load()), attr='get_install_requirement', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='ireq', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Attribute(value=Name(id='candidate', ctx=Load()), attr='name', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='candidate', ctx=Load()), attr='project_name', ctx=Load())]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='suppress', ctx=Load()), args=[Name(id='KeyError', ctx=Load())], keywords=[]))], body=[Assign(targets=[Name(id='req', ctx=Store())], value=Call(func=Attribute(value=Name(id='req_set', ctx=Load()), attr='get_requirement', ctx=Load()), args=[Attribute(value=Name(id='candidate', ctx=Load()), attr='project_name', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='req_set', ctx=Load()), attr='add_named_requirement', ctx=Load()), args=[Call(func=Name(id='install_req_extend_extras', ctx=Load()), args=[Name(id='req', ctx=Load()), Attribute(value=Call(func=Name(id='get_requirement', ctx=Load()), args=[Attribute(value=Name(id='candidate', ctx=Load()), attr='name', ctx=Load())], keywords=[]), attr='extras', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[]), Continue()], orelse=[]), Assign(targets=[Name(id='installed_dist', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='factory', ctx=Load()), attr='get_dist_to_uninstall', ctx=Load()), args=[Name(id='candidate', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='installed_dist', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='ireq', ctx=Load()), attr='should_reinstall', ctx=Store())], value=Constant(value=False))], orelse=[If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='factory', ctx=Load()), attr='force_reinstall', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='ireq', ctx=Load()), attr='should_reinstall', ctx=Store())], value=Constant(value=True))], orelse=[If(test=Compare(left=Attribute(value=Name(id='installed_dist', ctx=Load()), attr='version', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='candidate', ctx=Load()), attr='version', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='ireq', ctx=Load()), attr='should_reinstall', ctx=Store())], value=Constant(value=True))], orelse=[If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='candidate', ctx=Load()), attr='is_editable', ctx=Load()), Attribute(value=Name(id='installed_dist', ctx=Load()), attr='editable', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='ireq', ctx=Load()), attr='should_reinstall', ctx=Store())], value=Constant(value=True))], orelse=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='candidate', ctx=Load()), attr='source_link', ctx=Load()), Attribute(value=Attribute(value=Name(id='candidate', ctx=Load()), attr='source_link', ctx=Load()), attr='is_file', ctx=Load())]), body=[If(test=Attribute(value=Attribute(value=Name(id='candidate', ctx=Load()), attr='source_link', ctx=Load()), attr='is_wheel', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Constant(value='%s is already installed with the same version as the provided wheel. Use --force-reinstall to force an installation of the wheel.'), Attribute(value=Name(id='ireq', ctx=Load()), attr='name', ctx=Load())], keywords=[])), Continue()], orelse=[]), Assign(targets=[Attribute(value=Name(id='ireq', ctx=Load()), attr='should_reinstall', ctx=Store())], value=Constant(value=True))], orelse=[Continue()])])])])]), Assign(targets=[Name(id='link', ctx=Store())], value=Attribute(value=Name(id='candidate', ctx=Load()), attr='source_link', ctx=Load())), If(test=BoolOp(op=And(), values=[Name(id='link', ctx=Load()), Attribute(value=Name(id='link', ctx=Load()), attr='is_yanked', ctx=Load())]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Constant(value='The candidate selected for download or install is a yanked version: {name!r} candidate (version {version} at {link})\nReason for being yanked: {reason}'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='candidate', ctx=Load()), attr='name', ctx=Load())), keyword(arg='version', value=Attribute(value=Name(id='candidate', ctx=Load()), attr='version', ctx=Load())), keyword(arg='link', value=Name(id='link', ctx=Load())), keyword(arg='reason', value=BoolOp(op=Or(), values=[Attribute(value=Name(id='link', ctx=Load()), attr='yanked_reason', ctx=Load()), Constant(value='<none given>')]))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='req_set', ctx=Load()), attr='add_named_requirement', ctx=Load()), args=[Name(id='ireq', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='reqs', ctx=Store())], value=Attribute(value=Name(id='req_set', ctx=Load()), attr='all_requirements', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='factory', ctx=Load()), attr='preparer', ctx=Load()), attr='prepare_linked_requirements_more', ctx=Load()), args=[Name(id='reqs', ctx=Load())], keywords=[])), For(target=Name(id='req', ctx=Store()), iter=Name(id='reqs', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='req', ctx=Load()), attr='prepared', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='req', ctx=Load()), attr='needs_more_preparation', ctx=Store())], value=Constant(value=False))], orelse=[]), Return(value=Name(id='req_set', ctx=Load()))], decorator_list=[], returns=Name(id='RequirementSet', ctx=Load())), FunctionDef(name='get_installation_order', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req_set', annotation=Name(id='RequirementSet', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get order for installation of requirements in RequirementSet.\n\n        The returned list contains a requirement before another that depends on\n        it. This helps ensure that the environment is kept consistent as they\n        get installed one-by-one.\n\n        The current implementation creates a topological ordering of the\n        dependency graph, giving more weight to packages with less\n        or no dependencies, while breaking any cycles in the graph at\n        arbitrary points. We make no guarantees about where the cycle\n        would be broken, other than it *would* be broken.\n        ')), Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_result', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), msg=Constant(value='must call resolve() first')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='req_set', ctx=Load()), attr='requirements', ctx=Load())), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='graph', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_result', ctx=Load()), attr='graph', ctx=Load())), Assign(targets=[Name(id='weights', ctx=Store())], value=Call(func=Name(id='get_topological_weights', ctx=Load()), args=[Name(id='graph', ctx=Load()), Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='req_set', ctx=Load()), attr='requirements', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='sorted_items', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='req_set', ctx=Load()), attr='requirements', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Name(id='_req_set_item_sorter', ctx=Load())], keywords=[keyword(arg='weights', value=Name(id='weights', ctx=Load()))])), keyword(arg='reverse', value=Constant(value=True))])), Return(value=ListComp(elt=Name(id='ireq', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='_', ctx=Store()), Name(id='ireq', ctx=Store())], ctx=Store()), iter=Name(id='sorted_items', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='get_topological_weights', args=arguments(posonlyargs=[], args=[arg(arg='graph', annotation=Constant(value='DirectedGraph[Optional[str]]')), arg(arg='requirement_keys', annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Assign weights to each node based on how "deep" they are.\n\n    This implementation may change at any point in the future without prior\n    notice.\n\n    We first simplify the dependency graph by pruning any leaves and giving them\n    the highest weight: a package without any dependencies should be installed\n    first. This is done again and again in the same way, giving ever less weight\n    to the newly found leaves. The loop stops when no leaves are left: all\n    remaining packages have at least one dependency left in the graph.\n\n    Then we continue with the remaining graph, by taking the length for the\n    longest path to any node from root, ignoring any paths that contain a single\n    node twice (i.e. cycles). This is done through a depth-first search through\n    the graph, while keeping track of the path to the node.\n\n    Cycles in the graph result would result in node being revisited while also\n    being on its own path. In this case, take no action. This helps ensure we\n    don\'t get stuck in a cycle.\n\n    When assigning weight, the longer path (i.e. larger length) is preferred.\n\n    We are only interested in the weights of packages that are in the\n    requirement_keys.\n    ')), AnnAssign(target=Name(id='path', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), AnnAssign(target=Name(id='weights', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), FunctionDef(name='visit', args=arguments(posonlyargs=[], args=[arg(arg='node', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='node', ctx=Load()), ops=[In()], comparators=[Name(id='path', ctx=Load())]), body=[Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), For(target=Name(id='child', ctx=Store()), iter=Call(func=Attribute(value=Name(id='graph', ctx=Load()), attr='iter_children', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='visit', ctx=Load()), args=[Name(id='child', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='node', ctx=Load()), ops=[NotIn()], comparators=[Name(id='requirement_keys', ctx=Load())]), body=[Return()], orelse=[]), Assign(targets=[Name(id='last_known_parent_count', ctx=Store())], value=Call(func=Attribute(value=Name(id='weights', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='node', ctx=Load()), Constant(value=0)], keywords=[])), Assign(targets=[Subscript(value=Name(id='weights', ctx=Load()), slice=Name(id='node', ctx=Load()), ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Name(id='last_known_parent_count', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), While(test=Constant(value=True), body=[Assign(targets=[Name(id='leaves', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='key', ctx=Store()), iter=Name(id='graph', ctx=Load()), body=[If(test=Compare(left=Name(id='key', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Continue()], orelse=[]), For(target=Name(id='_child', ctx=Store()), iter=Call(func=Attribute(value=Name(id='graph', ctx=Load()), attr='iter_children', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]), body=[Break()], orelse=[Expr(value=Call(func=Attribute(value=Name(id='leaves', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]))])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='leaves', ctx=Load())), body=[Break()], orelse=[]), Assign(targets=[Name(id='weight', ctx=Store())], value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='graph', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))), For(target=Name(id='leaf', ctx=Store()), iter=Name(id='leaves', ctx=Load()), body=[If(test=Compare(left=Name(id='leaf', ctx=Load()), ops=[NotIn()], comparators=[Name(id='requirement_keys', ctx=Load())]), body=[Continue()], orelse=[]), Assign(targets=[Subscript(value=Name(id='weights', ctx=Load()), slice=Name(id='leaf', ctx=Load()), ctx=Store())], value=Name(id='weight', ctx=Load()))], orelse=[]), For(target=Name(id='leaf', ctx=Store()), iter=Name(id='leaves', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='graph', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='leaf', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Name(id='visit', ctx=Load()), args=[Constant(value=None)], keywords=[])), Assign(targets=[Name(id='difference', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='weights', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), attr='difference', ctx=Load()), args=[Name(id='requirement_keys', ctx=Load())], keywords=[])), Assert(test=UnaryOp(op=Not(), operand=Name(id='difference', ctx=Load())), msg=Name(id='difference', ctx=Load())), Return(value=Name(id='weights', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_req_set_item_sorter', args=arguments(posonlyargs=[], args=[arg(arg='item', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='InstallRequirement', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='weights', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Key function used to sort install requirements for installation.\n\n    Based on the "weight" mapping calculated in ``get_installation_order()``.\n    The canonical package name is returned as the second member as a tie-\n    breaker to ensure the result is predictable, which is useful in tests.\n    ')), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Name(id='canonicalize_name', ctx=Load()), args=[Subscript(value=Name(id='item', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Subscript(value=Name(id='weights', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()), Name(id='name', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], type_ignores=[])