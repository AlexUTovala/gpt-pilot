Module(body=[Import(names=[alias(name='abc')]), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='pip._internal.index.package_finder', names=[alias(name='PackageFinder')], level=0), ImportFrom(module='pip._internal.metadata.base', names=[alias(name='BaseDistribution')], level=0), ImportFrom(module='pip._internal.req', names=[alias(name='InstallRequirement')], level=0), ClassDef(name='AbstractDistribution', bases=[], keywords=[keyword(arg='metaclass', value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()))], body=[Expr(value=Constant(value="A base class for handling installable artifacts.\n\n    The requirements for anything installable are as follows:\n\n     - we must be able to determine the requirement name\n       (or we can't correctly handle the non-upgrade case).\n\n     - for packages with setup requirements, we must also be able\n       to determine their requirements without installing additional\n       packages (for the same reason as run-time dependencies)\n\n     - we must be able to create a Distribution object exposing the\n       above metadata.\n\n     - if we need to do work in the build tracker, we must be able to generate a unique\n       string to identify the requirement in the build tracker.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req', annotation=Name(id='InstallRequirement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='req', ctx=Store())], value=Name(id='req', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='build_tracker_id', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='A string that uniquely identifies this requirement to the build tracker.\n\n        If None, then this dist has no work to do in the build tracker, and\n        ``.prepare_distribution_metadata()`` will not be called.')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractproperty', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='get_metadata_distribution', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='BaseDistribution', ctx=Load())), FunctionDef(name='prepare_distribution_metadata', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='finder', annotation=Name(id='PackageFinder', ctx=Load())), arg(arg='build_isolation', annotation=Name(id='bool', ctx=Load())), arg(arg='check_build_deps', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[], keywords=[]))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Constant(value=None))], decorator_list=[])], type_ignores=[])