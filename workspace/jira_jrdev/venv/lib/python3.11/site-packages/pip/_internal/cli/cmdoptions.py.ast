Module(body=[Expr(value=Constant(value="\nshared options and groups\n\nThe principle here is to define options once, but *not* instantiate them\nglobally. One reason being that options with action='append' can carry state\nbetween parses. pip parses general options twice internally, and shouldn't\npass on state. To be consistent, all options will follow this design.\n")), Import(names=[alias(name='importlib.util')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='os')]), Import(names=[alias(name='textwrap')]), ImportFrom(module='functools', names=[alias(name='partial')], level=0), ImportFrom(module='optparse', names=[alias(name='SUPPRESS_HELP'), alias(name='Option'), alias(name='OptionGroup'), alias(name='OptionParser'), alias(name='Values')], level=0), ImportFrom(module='textwrap', names=[alias(name='dedent')], level=0), ImportFrom(module='typing', names=[alias(name='Any'), alias(name='Callable'), alias(name='Dict'), alias(name='Optional'), alias(name='Tuple')], level=0), ImportFrom(module='pip._vendor.packaging.utils', names=[alias(name='canonicalize_name')], level=0), ImportFrom(module='pip._internal.cli.parser', names=[alias(name='ConfigOptionParser')], level=0), ImportFrom(module='pip._internal.exceptions', names=[alias(name='CommandError')], level=0), ImportFrom(module='pip._internal.locations', names=[alias(name='USER_CACHE_DIR'), alias(name='get_src_prefix')], level=0), ImportFrom(module='pip._internal.models.format_control', names=[alias(name='FormatControl')], level=0), ImportFrom(module='pip._internal.models.index', names=[alias(name='PyPI')], level=0), ImportFrom(module='pip._internal.models.target_python', names=[alias(name='TargetPython')], level=0), ImportFrom(module='pip._internal.utils.hashes', names=[alias(name='STRONG_HASHES')], level=0), ImportFrom(module='pip._internal.utils.misc', names=[alias(name='strtobool')], level=0), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), FunctionDef(name='raise_option_error', args=arguments(posonlyargs=[], args=[arg(arg='parser', annotation=Name(id='OptionParser', ctx=Load())), arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='msg', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Raise an option parsing error using parser.error().\n\n    Args:\n      parser: an OptionParser instance.\n      option: an Option instance.\n      msg: the error text.\n    ')), Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='option', ctx=Load()), conversion=-1), Constant(value=' error: '), FormattedValue(value=Name(id='msg', ctx=Load()), conversion=-1)])), Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Name(id='textwrap', ctx=Load()), attr='fill', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='msg', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='error', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='make_option_group', args=arguments(posonlyargs=[], args=[arg(arg='group', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='parser', annotation=Name(id='ConfigOptionParser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Return an OptionGroup object\n    group  -- assumed to be dict with 'name' and 'options' keys\n    parser -- an optparse Parser\n    ")), Assign(targets=[Name(id='option_group', ctx=Store())], value=Call(func=Name(id='OptionGroup', ctx=Load()), args=[Name(id='parser', ctx=Load()), Subscript(value=Name(id='group', ctx=Load()), slice=Constant(value='name'), ctx=Load())], keywords=[])), For(target=Name(id='option', ctx=Store()), iter=Subscript(value=Name(id='group', ctx=Load()), slice=Constant(value='options'), ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='option_group', ctx=Load()), attr='add_option', ctx=Load()), args=[Call(func=Name(id='option', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='option_group', ctx=Load()))], decorator_list=[], returns=Name(id='OptionGroup', ctx=Load())), FunctionDef(name='check_dist_restriction', args=arguments(posonlyargs=[], args=[arg(arg='options', annotation=Name(id='Values', ctx=Load())), arg(arg='check_target', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Function for determining if custom platform options are allowed.\n\n    :param options: The OptionParser options.\n    :param check_target: Whether or not to check if --target is being used.\n    ')), Assign(targets=[Name(id='dist_restriction_set', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[List(elts=[Attribute(value=Name(id='options', ctx=Load()), attr='python_version', ctx=Load()), Attribute(value=Name(id='options', ctx=Load()), attr='platforms', ctx=Load()), Attribute(value=Name(id='options', ctx=Load()), attr='abis', ctx=Load()), Attribute(value=Name(id='options', ctx=Load()), attr='implementation', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='binary_only', ctx=Store())], value=Call(func=Name(id='FormatControl', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), Set(elts=[Constant(value=':all:')])], keywords=[])), Assign(targets=[Name(id='sdist_dependencies_allowed', ctx=Store())], value=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='options', ctx=Load()), attr='format_control', ctx=Load()), ops=[NotEq()], comparators=[Name(id='binary_only', ctx=Load())]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='options', ctx=Load()), attr='ignore_dependencies', ctx=Load()))])), If(test=BoolOp(op=And(), values=[Name(id='dist_restriction_set', ctx=Load()), Name(id='sdist_dependencies_allowed', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='CommandError', ctx=Load()), args=[Constant(value='When restricting platform and interpreter constraints using --python-version, --platform, --abi, or --implementation, either --no-deps must be set, or --only-binary=:all: must be set and --no-binary must not be set (or must be set to :none:).')], keywords=[]))], orelse=[]), If(test=Name(id='check_target', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='options', ctx=Load()), attr='dry_run', ctx=Load())), Name(id='dist_restriction_set', ctx=Load()), UnaryOp(op=Not(), operand=Attribute(value=Name(id='options', ctx=Load()), attr='target_dir', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='CommandError', ctx=Load()), args=[Constant(value="Can not use any platform or abi specific options unless installing via '--target' or using '--dry-run'")], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_path_option_check', args=arguments(posonlyargs=[], args=[arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='opt', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='expanduser', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_package_name_option_check', args=arguments(posonlyargs=[], args=[arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='opt', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='canonicalize_name', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), ClassDef(name='PipOption', bases=[Name(id='Option', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='TYPES', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='Option', ctx=Load()), attr='TYPES', ctx=Load()), op=Add(), right=Tuple(elts=[Constant(value='path'), Constant(value='package_name')], ctx=Load()))), Assign(targets=[Name(id='TYPE_CHECKER', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='Option', ctx=Load()), attr='TYPE_CHECKER', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='TYPE_CHECKER', ctx=Load()), slice=Constant(value='package_name'), ctx=Store())], value=Name(id='_package_name_option_check', ctx=Load())), Assign(targets=[Subscript(value=Name(id='TYPE_CHECKER', ctx=Load()), slice=Constant(value='path'), ctx=Store())], value=Name(id='_path_option_check', ctx=Load()))], decorator_list=[]), AnnAssign(target=Name(id='help_', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='-h'), Constant(value='--help')], keywords=[keyword(arg='dest', value=Constant(value='help')), keyword(arg='action', value=Constant(value='help')), keyword(arg='help', value=Constant(value='Show help.'))]), simple=1), AnnAssign(target=Name(id='debug_mode', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--debug')], keywords=[keyword(arg='dest', value=Constant(value='debug_mode')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Let unhandled exceptions propagate outside the main subroutine, instead of logging them to stderr.'))]), simple=1), AnnAssign(target=Name(id='isolated_mode', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--isolated')], keywords=[keyword(arg='dest', value=Constant(value='isolated_mode')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Run pip in an isolated mode, ignoring environment variables and user configuration.'))]), simple=1), AnnAssign(target=Name(id='require_virtualenv', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--require-virtualenv'), Constant(value='--require-venv')], keywords=[keyword(arg='dest', value=Constant(value='require_venv')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Allow pip to only run in a virtual environment; exit with an error otherwise.'))]), simple=1), AnnAssign(target=Name(id='override_externally_managed', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--break-system-packages')], keywords=[keyword(arg='dest', value=Constant(value='override_externally_managed')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='help', value=Constant(value='Allow pip to modify an EXTERNALLY-MANAGED Python installation'))]), simple=1), AnnAssign(target=Name(id='python', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--python')], keywords=[keyword(arg='dest', value=Constant(value='python')), keyword(arg='help', value=Constant(value='Run pip with the specified Python interpreter.'))]), simple=1), AnnAssign(target=Name(id='verbose', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='-v'), Constant(value='--verbose')], keywords=[keyword(arg='dest', value=Constant(value='verbose')), keyword(arg='action', value=Constant(value='count')), keyword(arg='default', value=Constant(value=0)), keyword(arg='help', value=Constant(value='Give more output. Option is additive, and can be used up to 3 times.'))]), simple=1), AnnAssign(target=Name(id='no_color', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--no-color')], keywords=[keyword(arg='dest', value=Constant(value='no_color')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Suppress colored output.'))]), simple=1), AnnAssign(target=Name(id='version', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='-V'), Constant(value='--version')], keywords=[keyword(arg='dest', value=Constant(value='version')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='help', value=Constant(value='Show version and exit.'))]), simple=1), AnnAssign(target=Name(id='quiet', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='-q'), Constant(value='--quiet')], keywords=[keyword(arg='dest', value=Constant(value='quiet')), keyword(arg='action', value=Constant(value='count')), keyword(arg='default', value=Constant(value=0)), keyword(arg='help', value=Constant(value='Give less output. Option is additive, and can be used up to 3 times (corresponding to WARNING, ERROR, and CRITICAL logging levels).'))]), simple=1), AnnAssign(target=Name(id='progress_bar', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--progress-bar')], keywords=[keyword(arg='dest', value=Constant(value='progress_bar')), keyword(arg='type', value=Constant(value='choice')), keyword(arg='choices', value=List(elts=[Constant(value='on'), Constant(value='off')], ctx=Load())), keyword(arg='default', value=Constant(value='on')), keyword(arg='help', value=Constant(value='Specify whether the progress bar should be used [on, off] (default: on)'))]), simple=1), AnnAssign(target=Name(id='log', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='PipOption', ctx=Load()), Constant(value='--log'), Constant(value='--log-file'), Constant(value='--local-log')], keywords=[keyword(arg='dest', value=Constant(value='log')), keyword(arg='metavar', value=Constant(value='path')), keyword(arg='type', value=Constant(value='path')), keyword(arg='help', value=Constant(value='Path to a verbose appending log.'))]), simple=1), AnnAssign(target=Name(id='no_input', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--no-input')], keywords=[keyword(arg='dest', value=Constant(value='no_input')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Disable prompting for input.'))]), simple=1), AnnAssign(target=Name(id='keyring_provider', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--keyring-provider')], keywords=[keyword(arg='dest', value=Constant(value='keyring_provider')), keyword(arg='choices', value=List(elts=[Constant(value='auto'), Constant(value='disabled'), Constant(value='import'), Constant(value='subprocess')], ctx=Load())), keyword(arg='default', value=Constant(value='auto')), keyword(arg='help', value=Constant(value='Enable the credential lookup via the keyring library if user input is allowed. Specify which mechanism to use [disabled, import, subprocess]. (default: disabled)'))]), simple=1), AnnAssign(target=Name(id='proxy', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--proxy')], keywords=[keyword(arg='dest', value=Constant(value='proxy')), keyword(arg='type', value=Constant(value='str')), keyword(arg='default', value=Constant(value='')), keyword(arg='help', value=Constant(value='Specify a proxy in the form scheme://[user:passwd@]proxy.server:port.'))]), simple=1), AnnAssign(target=Name(id='retries', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--retries')], keywords=[keyword(arg='dest', value=Constant(value='retries')), keyword(arg='type', value=Constant(value='int')), keyword(arg='default', value=Constant(value=5)), keyword(arg='help', value=Constant(value='Maximum number of retries each connection should attempt (default %default times).'))]), simple=1), AnnAssign(target=Name(id='timeout', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--timeout'), Constant(value='--default-timeout')], keywords=[keyword(arg='metavar', value=Constant(value='sec')), keyword(arg='dest', value=Constant(value='timeout')), keyword(arg='type', value=Constant(value='float')), keyword(arg='default', value=Constant(value=15)), keyword(arg='help', value=Constant(value='Set the socket timeout (default %default seconds).'))]), simple=1), FunctionDef(name='exists_action', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Option', ctx=Load()), args=[Constant(value='--exists-action')], keywords=[keyword(arg='dest', value=Constant(value='exists_action')), keyword(arg='type', value=Constant(value='choice')), keyword(arg='choices', value=List(elts=[Constant(value='s'), Constant(value='i'), Constant(value='w'), Constant(value='b'), Constant(value='a')], ctx=Load())), keyword(arg='default', value=List(elts=[], ctx=Load())), keyword(arg='action', value=Constant(value='append')), keyword(arg='metavar', value=Constant(value='action')), keyword(arg='help', value=Constant(value='Default action when a path already exists: (s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort.'))]))], decorator_list=[], returns=Name(id='Option', ctx=Load())), AnnAssign(target=Name(id='cert', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='PipOption', ctx=Load()), Constant(value='--cert')], keywords=[keyword(arg='dest', value=Constant(value='cert')), keyword(arg='type', value=Constant(value='path')), keyword(arg='metavar', value=Constant(value='path')), keyword(arg='help', value=Constant(value="Path to PEM-encoded CA certificate bundle. If provided, overrides the default. See 'SSL Certificate Verification' in pip documentation for more information."))]), simple=1), AnnAssign(target=Name(id='client_cert', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='PipOption', ctx=Load()), Constant(value='--client-cert')], keywords=[keyword(arg='dest', value=Constant(value='client_cert')), keyword(arg='type', value=Constant(value='path')), keyword(arg='default', value=Constant(value=None)), keyword(arg='metavar', value=Constant(value='path')), keyword(arg='help', value=Constant(value='Path to SSL client certificate, a single file containing the private key and the certificate in PEM format.'))]), simple=1), AnnAssign(target=Name(id='index_url', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='-i'), Constant(value='--index-url'), Constant(value='--pypi-url')], keywords=[keyword(arg='dest', value=Constant(value='index_url')), keyword(arg='metavar', value=Constant(value='URL')), keyword(arg='default', value=Attribute(value=Name(id='PyPI', ctx=Load()), attr='simple_url', ctx=Load())), keyword(arg='help', value=Constant(value='Base URL of the Python Package Index (default %default). This should point to a repository compliant with PEP 503 (the simple repository API) or a local directory laid out in the same format.'))]), simple=1), FunctionDef(name='extra_index_url', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Option', ctx=Load()), args=[Constant(value='--extra-index-url')], keywords=[keyword(arg='dest', value=Constant(value='extra_index_urls')), keyword(arg='metavar', value=Constant(value='URL')), keyword(arg='action', value=Constant(value='append')), keyword(arg='default', value=List(elts=[], ctx=Load())), keyword(arg='help', value=Constant(value='Extra URLs of package indexes to use in addition to --index-url. Should follow the same rules as --index-url.'))]))], decorator_list=[], returns=Name(id='Option', ctx=Load())), AnnAssign(target=Name(id='no_index', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--no-index')], keywords=[keyword(arg='dest', value=Constant(value='no_index')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Ignore package index (only looking at --find-links URLs instead).'))]), simple=1), FunctionDef(name='find_links', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Option', ctx=Load()), args=[Constant(value='-f'), Constant(value='--find-links')], keywords=[keyword(arg='dest', value=Constant(value='find_links')), keyword(arg='action', value=Constant(value='append')), keyword(arg='default', value=List(elts=[], ctx=Load())), keyword(arg='metavar', value=Constant(value='url')), keyword(arg='help', value=Constant(value="If a URL or path to an html file, then parse for links to archives such as sdist (.tar.gz) or wheel (.whl) files. If a local path or file:// URL that's a directory, then look for archives in the directory listing. Links to VCS project URLs are not supported."))]))], decorator_list=[], returns=Name(id='Option', ctx=Load())), FunctionDef(name='trusted_host', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Option', ctx=Load()), args=[Constant(value='--trusted-host')], keywords=[keyword(arg='dest', value=Constant(value='trusted_hosts')), keyword(arg='action', value=Constant(value='append')), keyword(arg='metavar', value=Constant(value='HOSTNAME')), keyword(arg='default', value=List(elts=[], ctx=Load())), keyword(arg='help', value=Constant(value='Mark this host or host:port pair as trusted, even though it does not have valid or any HTTPS.'))]))], decorator_list=[], returns=Name(id='Option', ctx=Load())), FunctionDef(name='constraints', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Option', ctx=Load()), args=[Constant(value='-c'), Constant(value='--constraint')], keywords=[keyword(arg='dest', value=Constant(value='constraints')), keyword(arg='action', value=Constant(value='append')), keyword(arg='default', value=List(elts=[], ctx=Load())), keyword(arg='metavar', value=Constant(value='file')), keyword(arg='help', value=Constant(value='Constrain versions using the given constraints file. This option can be used multiple times.'))]))], decorator_list=[], returns=Name(id='Option', ctx=Load())), FunctionDef(name='requirements', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Option', ctx=Load()), args=[Constant(value='-r'), Constant(value='--requirement')], keywords=[keyword(arg='dest', value=Constant(value='requirements')), keyword(arg='action', value=Constant(value='append')), keyword(arg='default', value=List(elts=[], ctx=Load())), keyword(arg='metavar', value=Constant(value='file')), keyword(arg='help', value=Constant(value='Install from the given requirements file. This option can be used multiple times.'))]))], decorator_list=[], returns=Name(id='Option', ctx=Load())), FunctionDef(name='editable', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Option', ctx=Load()), args=[Constant(value='-e'), Constant(value='--editable')], keywords=[keyword(arg='dest', value=Constant(value='editables')), keyword(arg='action', value=Constant(value='append')), keyword(arg='default', value=List(elts=[], ctx=Load())), keyword(arg='metavar', value=Constant(value='path/url')), keyword(arg='help', value=Constant(value='Install a project in editable mode (i.e. setuptools "develop mode") from a local project path or a VCS url.'))]))], decorator_list=[], returns=Name(id='Option', ctx=Load())), FunctionDef(name='_handle_src', args=arguments(posonlyargs=[], args=[arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='opt_str', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='parser', annotation=Name(id='OptionParser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), Attribute(value=Name(id='option', ctx=Load()), attr='dest', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), AnnAssign(target=Name(id='src', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='PipOption', ctx=Load()), Constant(value='--src'), Constant(value='--source'), Constant(value='--source-dir'), Constant(value='--source-directory')], keywords=[keyword(arg='dest', value=Constant(value='src_dir')), keyword(arg='type', value=Constant(value='path')), keyword(arg='metavar', value=Constant(value='dir')), keyword(arg='default', value=Call(func=Name(id='get_src_prefix', ctx=Load()), args=[], keywords=[])), keyword(arg='action', value=Constant(value='callback')), keyword(arg='callback', value=Name(id='_handle_src', ctx=Load())), keyword(arg='help', value=Constant(value='Directory to check out editable projects into. The default in a virtualenv is "<venv path>/src". The default for global installs is "<current dir>/src".'))]), simple=1), FunctionDef(name='_get_format_control', args=arguments(posonlyargs=[], args=[arg(arg='values', annotation=Name(id='Values', ctx=Load())), arg(arg='option', annotation=Name(id='Option', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get a format_control object.')), Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='values', ctx=Load()), Attribute(value=Name(id='option', ctx=Load()), attr='dest', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='_handle_no_binary', args=arguments(posonlyargs=[], args=[arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='opt_str', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='parser', annotation=Name(id='OptionParser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='existing', ctx=Store())], value=Call(func=Name(id='_get_format_control', ctx=Load()), args=[Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), Name(id='option', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='FormatControl', ctx=Load()), attr='handle_mutual_excludes', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='existing', ctx=Load()), attr='no_binary', ctx=Load()), Attribute(value=Name(id='existing', ctx=Load()), attr='only_binary', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_handle_only_binary', args=arguments(posonlyargs=[], args=[arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='opt_str', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='parser', annotation=Name(id='OptionParser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='existing', ctx=Store())], value=Call(func=Name(id='_get_format_control', ctx=Load()), args=[Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), Name(id='option', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='FormatControl', ctx=Load()), attr='handle_mutual_excludes', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='existing', ctx=Load()), attr='only_binary', ctx=Load()), Attribute(value=Name(id='existing', ctx=Load()), attr='no_binary', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='no_binary', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='format_control', ctx=Store())], value=Call(func=Name(id='FormatControl', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='Option', ctx=Load()), args=[Constant(value='--no-binary')], keywords=[keyword(arg='dest', value=Constant(value='format_control')), keyword(arg='action', value=Constant(value='callback')), keyword(arg='callback', value=Name(id='_handle_no_binary', ctx=Load())), keyword(arg='type', value=Constant(value='str')), keyword(arg='default', value=Name(id='format_control', ctx=Load())), keyword(arg='help', value=Constant(value='Do not use binary packages. Can be supplied multiple times, and each time adds to the existing value. Accepts either ":all:" to disable all binary packages, ":none:" to empty the set (notice the colons), or one or more package names with commas between them (no colons). Note that some packages are tricky to compile and may fail to install when this option is used on them.'))]))], decorator_list=[], returns=Name(id='Option', ctx=Load())), FunctionDef(name='only_binary', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='format_control', ctx=Store())], value=Call(func=Name(id='FormatControl', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='Option', ctx=Load()), args=[Constant(value='--only-binary')], keywords=[keyword(arg='dest', value=Constant(value='format_control')), keyword(arg='action', value=Constant(value='callback')), keyword(arg='callback', value=Name(id='_handle_only_binary', ctx=Load())), keyword(arg='type', value=Constant(value='str')), keyword(arg='default', value=Name(id='format_control', ctx=Load())), keyword(arg='help', value=Constant(value='Do not use source packages. Can be supplied multiple times, and each time adds to the existing value. Accepts either ":all:" to disable all source packages, ":none:" to empty the set, or one or more package names with commas between them. Packages without binary distributions will fail to install when this option is used on them.'))]))], decorator_list=[], returns=Name(id='Option', ctx=Load())), AnnAssign(target=Name(id='platforms', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--platform')], keywords=[keyword(arg='dest', value=Constant(value='platforms')), keyword(arg='metavar', value=Constant(value='platform')), keyword(arg='action', value=Constant(value='append')), keyword(arg='default', value=Constant(value=None)), keyword(arg='help', value=Constant(value='Only use wheels compatible with <platform>. Defaults to the platform of the running system. Use this option multiple times to specify multiple platforms supported by the target interpreter.'))]), simple=1), FunctionDef(name='_convert_python_version', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Convert a version string like "3", "37", or "3.7.3" into a tuple of ints.\n\n    :return: A 2-tuple (version_info, error_msg), where `error_msg` is\n        non-None if and only if there was a parsing error.\n    ')), If(test=UnaryOp(op=Not(), operand=Name(id='value', ctx=Load())), body=[Return(value=Tuple(elts=[Constant(value=None), Constant(value=None)], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=3)]), body=[Return(value=Tuple(elts=[Tuple(elts=[], ctx=Load()), Constant(value='at most three version parts are allowed')], ctx=Load()))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Subscript(value=Name(id='parts', ctx=Load()), slice=Constant(value=0), ctx=Load())), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=List(elts=[Subscript(value=Name(id='value', ctx=Load()), slice=Constant(value=0), ctx=Load()), Subscript(value=Name(id='value', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], ctx=Load()))], orelse=[])], orelse=[]), Try(body=[Assign(targets=[Name(id='version_info', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='int', ctx=Load()), args=[Name(id='part', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='part', ctx=Store()), iter=Name(id='parts', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=Tuple(elts=[Tuple(elts=[], ctx=Load()), Constant(value='each version part must be an integer')], ctx=Load()))])], orelse=[], finalbody=[]), Return(value=Tuple(elts=[Name(id='version_info', ctx=Load()), Constant(value=None)], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_handle_python_version', args=arguments(posonlyargs=[], args=[arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='opt_str', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='parser', annotation=Name(id='OptionParser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Handle a provided --python-version value.\n    ')), Assign(targets=[Tuple(elts=[Name(id='version_info', ctx=Store()), Name(id='error_msg', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_convert_python_version', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='error_msg', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Constant(value='invalid --python-version value: {!r}: {}'), attr='format', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='error_msg', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='raise_option_error', ctx=Load()), args=[Name(id='parser', ctx=Load())], keywords=[keyword(arg='option', value=Name(id='option', ctx=Load())), keyword(arg='msg', value=Name(id='msg', ctx=Load()))]))], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), attr='python_version', ctx=Store())], value=Name(id='version_info', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), AnnAssign(target=Name(id='python_version', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--python-version')], keywords=[keyword(arg='dest', value=Constant(value='python_version')), keyword(arg='metavar', value=Constant(value='python_version')), keyword(arg='action', value=Constant(value='callback')), keyword(arg='callback', value=Name(id='_handle_python_version', ctx=Load())), keyword(arg='type', value=Constant(value='str')), keyword(arg='default', value=Constant(value=None)), keyword(arg='help', value=Call(func=Name(id='dedent', ctx=Load()), args=[Constant(value='    The Python interpreter version to use for wheel and "Requires-Python"\n    compatibility checks. Defaults to a version derived from the running\n    interpreter. The version can be specified using up to three dot-separated\n    integers (e.g. "3" for 3.0.0, "3.7" for 3.7.0, or "3.7.3"). A major-minor\n    version can also be given as a string without dots (e.g. "37" for 3.7.0).\n    ')], keywords=[]))]), simple=1), AnnAssign(target=Name(id='implementation', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--implementation')], keywords=[keyword(arg='dest', value=Constant(value='implementation')), keyword(arg='metavar', value=Constant(value='implementation')), keyword(arg='default', value=Constant(value=None)), keyword(arg='help', value=Constant(value="Only use wheels compatible with Python implementation <implementation>, e.g. 'pp', 'jy', 'cp',  or 'ip'. If not specified, then the current interpreter implementation is used.  Use 'py' to force implementation-agnostic wheels."))]), simple=1), AnnAssign(target=Name(id='abis', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--abi')], keywords=[keyword(arg='dest', value=Constant(value='abis')), keyword(arg='metavar', value=Constant(value='abi')), keyword(arg='action', value=Constant(value='append')), keyword(arg='default', value=Constant(value=None)), keyword(arg='help', value=Constant(value="Only use wheels compatible with Python abi <abi>, e.g. 'pypy_41'. If not specified, then the current interpreter abi tag is used. Use this option multiple times to specify multiple abis supported by the target interpreter. Generally you will need to specify --implementation, --platform, and --python-version when using this option."))]), simple=1), FunctionDef(name='add_target_python_options', args=arguments(posonlyargs=[], args=[arg(arg='cmd_opts', annotation=Name(id='OptionGroup', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='cmd_opts', ctx=Load()), attr='add_option', ctx=Load()), args=[Call(func=Name(id='platforms', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cmd_opts', ctx=Load()), attr='add_option', ctx=Load()), args=[Call(func=Name(id='python_version', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cmd_opts', ctx=Load()), attr='add_option', ctx=Load()), args=[Call(func=Name(id='implementation', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cmd_opts', ctx=Load()), attr='add_option', ctx=Load()), args=[Call(func=Name(id='abis', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='make_target_python', args=arguments(posonlyargs=[], args=[arg(arg='options', annotation=Name(id='Values', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='target_python', ctx=Store())], value=Call(func=Name(id='TargetPython', ctx=Load()), args=[], keywords=[keyword(arg='platforms', value=Attribute(value=Name(id='options', ctx=Load()), attr='platforms', ctx=Load())), keyword(arg='py_version_info', value=Attribute(value=Name(id='options', ctx=Load()), attr='python_version', ctx=Load())), keyword(arg='abis', value=Attribute(value=Name(id='options', ctx=Load()), attr='abis', ctx=Load())), keyword(arg='implementation', value=Attribute(value=Name(id='options', ctx=Load()), attr='implementation', ctx=Load()))])), Return(value=Name(id='target_python', ctx=Load()))], decorator_list=[], returns=Name(id='TargetPython', ctx=Load())), FunctionDef(name='prefer_binary', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Option', ctx=Load()), args=[Constant(value='--prefer-binary')], keywords=[keyword(arg='dest', value=Constant(value='prefer_binary')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Prefer binary packages over source packages, even if the source packages are newer.'))]))], decorator_list=[], returns=Name(id='Option', ctx=Load())), AnnAssign(target=Name(id='cache_dir', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='PipOption', ctx=Load()), Constant(value='--cache-dir')], keywords=[keyword(arg='dest', value=Constant(value='cache_dir')), keyword(arg='default', value=Name(id='USER_CACHE_DIR', ctx=Load())), keyword(arg='metavar', value=Constant(value='dir')), keyword(arg='type', value=Constant(value='path')), keyword(arg='help', value=Constant(value='Store the cache data in <dir>.'))]), simple=1), FunctionDef(name='_handle_no_cache_dir', args=arguments(posonlyargs=[], args=[arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='opt', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='parser', annotation=Name(id='OptionParser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Process a value provided for the --no-cache-dir option.\n\n    This is an optparse.Option callback for the --no-cache-dir option.\n    ')), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Try(body=[Expr(value=Call(func=Name(id='strtobool', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='exc', body=[Expr(value=Call(func=Name(id='raise_option_error', ctx=Load()), args=[Name(id='parser', ctx=Load())], keywords=[keyword(arg='option', value=Name(id='option', ctx=Load())), keyword(arg='msg', value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='exc', ctx=Load())], keywords=[]))]))])], orelse=[], finalbody=[])], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), attr='cache_dir', ctx=Store())], value=Constant(value=False))], decorator_list=[], returns=Constant(value=None)), AnnAssign(target=Name(id='no_cache', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--no-cache-dir')], keywords=[keyword(arg='dest', value=Constant(value='cache_dir')), keyword(arg='action', value=Constant(value='callback')), keyword(arg='callback', value=Name(id='_handle_no_cache_dir', ctx=Load())), keyword(arg='help', value=Constant(value='Disable the cache.'))]), simple=1), AnnAssign(target=Name(id='no_deps', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--no-deps'), Constant(value='--no-dependencies')], keywords=[keyword(arg='dest', value=Constant(value='ignore_dependencies')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value="Don't install package dependencies."))]), simple=1), AnnAssign(target=Name(id='ignore_requires_python', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--ignore-requires-python')], keywords=[keyword(arg='dest', value=Constant(value='ignore_requires_python')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='help', value=Constant(value='Ignore the Requires-Python information.'))]), simple=1), AnnAssign(target=Name(id='no_build_isolation', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--no-build-isolation')], keywords=[keyword(arg='dest', value=Constant(value='build_isolation')), keyword(arg='action', value=Constant(value='store_false')), keyword(arg='default', value=Constant(value=True)), keyword(arg='help', value=Constant(value='Disable isolation when building a modern source distribution. Build dependencies specified by PEP 518 must be already installed if this option is used.'))]), simple=1), AnnAssign(target=Name(id='check_build_deps', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--check-build-dependencies')], keywords=[keyword(arg='dest', value=Constant(value='check_build_deps')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Check the build dependencies when PEP517 is used.'))]), simple=1), FunctionDef(name='_handle_no_use_pep517', args=arguments(posonlyargs=[], args=[arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='opt', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='parser', annotation=Name(id='OptionParser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Process a value provided for the --no-use-pep517 option.\n\n    This is an optparse.Option callback for the no_use_pep517 option.\n    ')), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='A value was passed for --no-use-pep517,\n        probably using either the PIP_NO_USE_PEP517 environment variable\n        or the "no-use-pep517" config file option. Use an appropriate value\n        of the PIP_USE_PEP517 environment variable or the "use-pep517"\n        config file option instead.\n        ')), Expr(value=Call(func=Name(id='raise_option_error', ctx=Load()), args=[Name(id='parser', ctx=Load())], keywords=[keyword(arg='option', value=Name(id='option', ctx=Load())), keyword(arg='msg', value=Name(id='msg', ctx=Load()))]))], orelse=[]), Assign(targets=[Name(id='packages', ctx=Store())], value=Tuple(elts=[Constant(value='setuptools'), Constant(value='wheel')], ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='util', ctx=Load()), attr='find_spec', ctx=Load()), args=[Name(id='package', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='package', ctx=Store()), iter=Name(id='packages', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='It is not possible to use --no-use-pep517 without '), FormattedValue(value=Call(func=Attribute(value=Constant(value=' and '), attr='join', ctx=Load()), args=[Name(id='packages', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' installed.')])), Expr(value=Call(func=Name(id='raise_option_error', ctx=Load()), args=[Name(id='parser', ctx=Load())], keywords=[keyword(arg='option', value=Name(id='option', ctx=Load())), keyword(arg='msg', value=Name(id='msg', ctx=Load()))]))], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), attr='use_pep517', ctx=Store())], value=Constant(value=False))], decorator_list=[], returns=Constant(value=None)), AnnAssign(target=Name(id='use_pep517', ctx=Store()), annotation=Name(id='Any', ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--use-pep517')], keywords=[keyword(arg='dest', value=Constant(value='use_pep517')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=None)), keyword(arg='help', value=Constant(value='Use PEP 517 for building source distributions (use --no-use-pep517 to force legacy behaviour).'))]), simple=1), AnnAssign(target=Name(id='no_use_pep517', ctx=Store()), annotation=Name(id='Any', ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--no-use-pep517')], keywords=[keyword(arg='dest', value=Constant(value='use_pep517')), keyword(arg='action', value=Constant(value='callback')), keyword(arg='callback', value=Name(id='_handle_no_use_pep517', ctx=Load())), keyword(arg='default', value=Constant(value=None)), keyword(arg='help', value=Name(id='SUPPRESS_HELP', ctx=Load()))]), simple=1), FunctionDef(name='_handle_config_settings', args=arguments(posonlyargs=[], args=[arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='opt_str', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='parser', annotation=Name(id='OptionParser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='sep', ctx=Store()), Name(id='val', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value='=')], keywords=[])), If(test=Compare(left=Name(id='sep', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='=')]), body=[Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='error', ctx=Load()), args=[JoinedStr(values=[Constant(value='Arguments to '), FormattedValue(value=Name(id='opt_str', ctx=Load()), conversion=-1), Constant(value=' must be of the form KEY=VAL')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='dest', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), Attribute(value=Name(id='option', ctx=Load()), attr='dest', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='dest', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='dest', ctx=Store())], value=Dict(keys=[], values=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), Attribute(value=Name(id='option', ctx=Load()), attr='dest', ctx=Load()), Name(id='dest', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='key', ctx=Load()), ops=[In()], comparators=[Name(id='dest', ctx=Load())]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='dest', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='dest', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Subscript(value=Name(id='dest', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=List(elts=[Subscript(value=Name(id='dest', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), Name(id='val', ctx=Load())], ctx=Load()))])], orelse=[Assign(targets=[Subscript(value=Name(id='dest', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='val', ctx=Load()))])], decorator_list=[], returns=Constant(value=None)), AnnAssign(target=Name(id='config_settings', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='-C'), Constant(value='--config-settings')], keywords=[keyword(arg='dest', value=Constant(value='config_settings')), keyword(arg='type', value=Name(id='str', ctx=Load())), keyword(arg='action', value=Constant(value='callback')), keyword(arg='callback', value=Name(id='_handle_config_settings', ctx=Load())), keyword(arg='metavar', value=Constant(value='settings')), keyword(arg='help', value=Constant(value='Configuration settings to be passed to the PEP 517 build backend. Settings take the form KEY=VALUE. Use multiple --config-settings options to pass multiple keys to the backend.'))]), simple=1), AnnAssign(target=Name(id='build_options', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--build-option')], keywords=[keyword(arg='dest', value=Constant(value='build_options')), keyword(arg='metavar', value=Constant(value='options')), keyword(arg='action', value=Constant(value='append')), keyword(arg='help', value=Constant(value="Extra arguments to be supplied to 'setup.py bdist_wheel'."))]), simple=1), AnnAssign(target=Name(id='global_options', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--global-option')], keywords=[keyword(arg='dest', value=Constant(value='global_options')), keyword(arg='action', value=Constant(value='append')), keyword(arg='metavar', value=Constant(value='options')), keyword(arg='help', value=Constant(value='Extra global options to be supplied to the setup.py call before the install or bdist_wheel command.'))]), simple=1), AnnAssign(target=Name(id='no_clean', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--no-clean')], keywords=[keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value="Don't clean up build directories."))]), simple=1), AnnAssign(target=Name(id='pre', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--pre')], keywords=[keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Include pre-release and development versions. By default, pip only finds stable versions.'))]), simple=1), AnnAssign(target=Name(id='disable_pip_version_check', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--disable-pip-version-check')], keywords=[keyword(arg='dest', value=Constant(value='disable_pip_version_check')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value="Don't periodically check PyPI to determine whether a new version of pip is available for download. Implied with --no-index."))]), simple=1), AnnAssign(target=Name(id='root_user_action', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--root-user-action')], keywords=[keyword(arg='dest', value=Constant(value='root_user_action')), keyword(arg='default', value=Constant(value='warn')), keyword(arg='choices', value=List(elts=[Constant(value='warn'), Constant(value='ignore')], ctx=Load())), keyword(arg='help', value=Constant(value='Action if pip is run as a root user. By default, a warning message is shown.'))]), simple=1), FunctionDef(name='_handle_merge_hash', args=arguments(posonlyargs=[], args=[arg(arg='option', annotation=Name(id='Option', ctx=Load())), arg(arg='opt_str', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='parser', annotation=Name(id='OptionParser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Given a value spelled "algo:digest", append the digest to a list\n    pointed to in a dict by the algo name.')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), attr='hashes', ctx=Load())), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), attr='hashes', ctx=Store())], value=Dict(keys=[], values=[]))], orelse=[]), Try(body=[Assign(targets=[Tuple(elts=[Name(id='algo', ctx=Store()), Name(id='digest', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':'), Constant(value=1)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='error', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Arguments to {} must be a hash name followed by a value, like --hash=sha256:abcde...'), attr='format', ctx=Load()), args=[Name(id='opt_str', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='algo', ctx=Load()), ops=[NotIn()], comparators=[Name(id='STRONG_HASHES', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='error', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Allowed hash algorithms for {} are {}.'), attr='format', ctx=Load()), args=[Name(id='opt_str', ctx=Load()), Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='STRONG_HASHES', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='parser', ctx=Load()), attr='values', ctx=Load()), attr='hashes', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='algo', ctx=Load()), List(elts=[], ctx=Load())], keywords=[]), attr='append', ctx=Load()), args=[Name(id='digest', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), AnnAssign(target=Name(id='hash', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--hash')], keywords=[keyword(arg='dest', value=Constant(value='hashes')), keyword(arg='action', value=Constant(value='callback')), keyword(arg='callback', value=Name(id='_handle_merge_hash', ctx=Load())), keyword(arg='type', value=Constant(value='string')), keyword(arg='help', value=Constant(value="Verify that the package's archive matches this hash before installing. Example: --hash=sha256:abcdef..."))]), simple=1), AnnAssign(target=Name(id='require_hashes', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--require-hashes')], keywords=[keyword(arg='dest', value=Constant(value='require_hashes')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Require a hash to check each requirement against, for repeatable installs. This option is implied when any package in a requirements file has a --hash option.'))]), simple=1), AnnAssign(target=Name(id='list_path', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='PipOption', ctx=Load()), Constant(value='--path')], keywords=[keyword(arg='dest', value=Constant(value='path')), keyword(arg='type', value=Constant(value='path')), keyword(arg='action', value=Constant(value='append')), keyword(arg='help', value=Constant(value='Restrict to the specified installation path for listing packages (can be used multiple times).'))]), simple=1), FunctionDef(name='check_list_path_option', args=arguments(posonlyargs=[], args=[arg(arg='options', annotation=Name(id='Values', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='options', ctx=Load()), attr='path', ctx=Load()), BoolOp(op=Or(), values=[Attribute(value=Name(id='options', ctx=Load()), attr='user', ctx=Load()), Attribute(value=Name(id='options', ctx=Load()), attr='local', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='CommandError', ctx=Load()), args=[Constant(value="Cannot combine '--path' with '--user' or '--local'")], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), AnnAssign(target=Name(id='list_exclude', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='PipOption', ctx=Load()), Constant(value='--exclude')], keywords=[keyword(arg='dest', value=Constant(value='excludes')), keyword(arg='action', value=Constant(value='append')), keyword(arg='metavar', value=Constant(value='package')), keyword(arg='type', value=Constant(value='package_name')), keyword(arg='help', value=Constant(value='Exclude specified package from the output'))]), simple=1), AnnAssign(target=Name(id='no_python_version_warning', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--no-python-version-warning')], keywords=[keyword(arg='dest', value=Constant(value='no_python_version_warning')), keyword(arg='action', value=Constant(value='store_true')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Silence deprecation warnings for upcoming unsupported Pythons.'))]), simple=1), Assign(targets=[Name(id='ALWAYS_ENABLED_FEATURES', ctx=Store())], value=List(elts=[Constant(value='no-binary-enable-wheel-cache')], ctx=Load())), AnnAssign(target=Name(id='use_new_feature', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--use-feature')], keywords=[keyword(arg='dest', value=Constant(value='features_enabled')), keyword(arg='metavar', value=Constant(value='feature')), keyword(arg='action', value=Constant(value='append')), keyword(arg='default', value=List(elts=[], ctx=Load())), keyword(arg='choices', value=BinOp(left=List(elts=[Constant(value='fast-deps'), Constant(value='truststore')], ctx=Load()), op=Add(), right=Name(id='ALWAYS_ENABLED_FEATURES', ctx=Load()))), keyword(arg='help', value=Constant(value='Enable new functionality, that may be backward incompatible.'))]), simple=1), AnnAssign(target=Name(id='use_deprecated_feature', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Option', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='Option', ctx=Load()), Constant(value='--use-deprecated')], keywords=[keyword(arg='dest', value=Constant(value='deprecated_features_enabled')), keyword(arg='metavar', value=Constant(value='feature')), keyword(arg='action', value=Constant(value='append')), keyword(arg='default', value=List(elts=[], ctx=Load())), keyword(arg='choices', value=List(elts=[Constant(value='legacy-resolver')], ctx=Load())), keyword(arg='help', value=Constant(value='Enable deprecated functionality, that will be removed in the future.'))]), simple=1), AnnAssign(target=Name(id='general_group', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[Constant(value='name'), Constant(value='options')], values=[Constant(value='General Options'), List(elts=[Name(id='help_', ctx=Load()), Name(id='debug_mode', ctx=Load()), Name(id='isolated_mode', ctx=Load()), Name(id='require_virtualenv', ctx=Load()), Name(id='python', ctx=Load()), Name(id='verbose', ctx=Load()), Name(id='version', ctx=Load()), Name(id='quiet', ctx=Load()), Name(id='log', ctx=Load()), Name(id='no_input', ctx=Load()), Name(id='keyring_provider', ctx=Load()), Name(id='proxy', ctx=Load()), Name(id='retries', ctx=Load()), Name(id='timeout', ctx=Load()), Name(id='exists_action', ctx=Load()), Name(id='trusted_host', ctx=Load()), Name(id='cert', ctx=Load()), Name(id='client_cert', ctx=Load()), Name(id='cache_dir', ctx=Load()), Name(id='no_cache', ctx=Load()), Name(id='disable_pip_version_check', ctx=Load()), Name(id='no_color', ctx=Load()), Name(id='no_python_version_warning', ctx=Load()), Name(id='use_new_feature', ctx=Load()), Name(id='use_deprecated_feature', ctx=Load())], ctx=Load())]), simple=1), AnnAssign(target=Name(id='index_group', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[Constant(value='name'), Constant(value='options')], values=[Constant(value='Package Index Options'), List(elts=[Name(id='index_url', ctx=Load()), Name(id='extra_index_url', ctx=Load()), Name(id='no_index', ctx=Load()), Name(id='find_links', ctx=Load())], ctx=Load())]), simple=1)], type_ignores=[])