Module(body=[Import(names=[alias(name='functools')]), Import(names=[alias(name='importlib.metadata')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='os')]), Import(names=[alias(name='pathlib')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='zipfile')]), Import(names=[alias(name='zipimport')]), ImportFrom(module='typing', names=[alias(name='Iterator'), alias(name='List'), alias(name='Optional'), alias(name='Sequence'), alias(name='Set'), alias(name='Tuple')], level=0), ImportFrom(module='pip._vendor.packaging.utils', names=[alias(name='NormalizedName'), alias(name='canonicalize_name')], level=0), ImportFrom(module='pip._internal.metadata.base', names=[alias(name='BaseDistribution'), alias(name='BaseEnvironment')], level=0), ImportFrom(module='pip._internal.models.wheel', names=[alias(name='Wheel')], level=0), ImportFrom(module='pip._internal.utils.deprecation', names=[alias(name='deprecated')], level=0), ImportFrom(module='pip._internal.utils.filetypes', names=[alias(name='WHEEL_EXTENSION')], level=0), ImportFrom(module='_compat', names=[alias(name='BadMetadata'), alias(name='BasePath'), alias(name='get_dist_name'), alias(name='get_info_location')], level=1), ImportFrom(module='_dists', names=[alias(name='Distribution')], level=1), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), FunctionDef(name='_looks_like_wheel', args=arguments(posonlyargs=[], args=[arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='location', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='WHEEL_EXTENSION', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='Wheel', ctx=Load()), attr='wheel_file_re', ctx=Load()), attr='match', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[])], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='zipfile', ctx=Load()), attr='is_zipfile', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), ClassDef(name='_DistributionFinder', bases=[], keywords=[], body=[Expr(value=Constant(value="Finder to locate distributions.\n\n    The main purpose of this class is to memoize found distributions' names, so\n    only one distribution is returned for each package name. At lot of pip code\n    assumes this (because it is setuptools's behavior), and not doing the same\n    can potentially cause a distribution in lower precedence path to override a\n    higher precedence one if the caller is not careful.\n\n    Eventually we probably want to make it possible to see lower precedence\n    installations as well. It's useful feature, after all.\n    ")), Assign(targets=[Name(id='FoundResult', ctx=Store())], value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='metadata', ctx=Load()), attr='Distribution', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='BasePath', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_found_names', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='NormalizedName', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_find_impl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find distributions in a location.')), If(test=Call(func=Name(id='_looks_like_wheel', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]), body=[Return()], orelse=[]), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='metadata', ctx=Load()), attr='distributions', ctx=Load()), args=[], keywords=[keyword(arg='path', value=List(elts=[Name(id='location', ctx=Load())], ctx=Load()))]), body=[Assign(targets=[Name(id='info_location', ctx=Store())], value=Call(func=Name(id='get_info_location', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='raw_name', ctx=Store())], value=Call(func=Name(id='get_dist_name', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='BadMetadata', ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Skipping %s due to %s'), Name(id='info_location', ctx=Load()), Attribute(value=Name(id='e', ctx=Load()), attr='reason', ctx=Load())], keywords=[])), Continue()])], orelse=[], finalbody=[]), Assign(targets=[Name(id='normalized_name', ctx=Store())], value=Call(func=Name(id='canonicalize_name', ctx=Load()), args=[Name(id='raw_name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='normalized_name', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_found_names', ctx=Load())]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_found_names', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='normalized_name', ctx=Load())], keywords=[])), Expr(value=Yield(value=Tuple(elts=[Name(id='dist', ctx=Load()), Name(id='info_location', ctx=Load())], ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='FoundResult', ctx=Load()), ctx=Load())), FunctionDef(name='find', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find distributions in a location.\n\n        The path can be either a directory, or a ZIP archive.\n        ')), For(target=Tuple(elts=[Name(id='dist', ctx=Store()), Name(id='info_location', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_impl', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='info_location', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[AnnAssign(target=Name(id='installed_location', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='BasePath', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1)], orelse=[Assign(targets=[Name(id='installed_location', ctx=Store())], value=Attribute(value=Name(id='info_location', ctx=Load()), attr='parent', ctx=Load()))]), Expr(value=Yield(value=Call(func=Name(id='Distribution', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='info_location', ctx=Load()), Name(id='installed_location', ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='BaseDistribution', ctx=Load()), ctx=Load())), FunctionDef(name='find_linked', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Read location in egg-link files and return distributions in there.\n\n        The path should be a directory; otherwise this returns nothing. This\n        follows how setuptools does this for compatibility. The first non-empty\n        line in the egg-link is read as a path (resolved against the egg-link's\n        containing directory if relative). Distributions found at that linked\n        location are returned.\n        ")), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[])), body=[Return()], orelse=[]), For(target=Name(id='child', ctx=Store()), iter=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='iterdir', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Attribute(value=Name(id='child', ctx=Load()), attr='suffix', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='.egg-link')]), body=[Continue()], orelse=[]), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='child', ctx=Load()), attr='open', ctx=Load()), args=[], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='lines', ctx=Store())], value=GeneratorExp(elt=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Name(id='f', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='target_rel', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[GeneratorExp(elt=Name(id='line', ctx=Load()), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), ifs=[Name(id='line', ctx=Load())], is_async=0)]), Constant(value='')], keywords=[]))]), If(test=UnaryOp(op=Not(), operand=Name(id='target_rel', ctx=Load())), body=[Continue()], orelse=[]), Assign(targets=[Name(id='target_location', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Name(id='target_rel', ctx=Load())], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='dist', ctx=Store()), Name(id='info_location', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_impl', ctx=Load()), args=[Name(id='target_location', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Call(func=Name(id='Distribution', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='info_location', ctx=Load()), Name(id='path', ctx=Load())], keywords=[])))], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='BaseDistribution', ctx=Load()), ctx=Load())), FunctionDef(name='_find_eggs_in_dir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='pip._vendor.pkg_resources', names=[alias(name='find_distributions')], level=0), ImportFrom(module='pip._internal.metadata', names=[alias(name='pkg_resources', asname='legacy')], level=0), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='scandir', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]), optional_vars=Name(id='it', ctx=Store()))], body=[For(target=Name(id='entry', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='entry', ctx=Load()), attr='name', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.egg')], keywords=[])), body=[Continue()], orelse=[]), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Name(id='find_distributions', ctx=Load()), args=[Attribute(value=Name(id='entry', ctx=Load()), attr='path', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Call(func=Attribute(value=Name(id='legacy', ctx=Load()), attr='Distribution', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[])))], orelse=[])], orelse=[])])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='BaseDistribution', ctx=Load()), ctx=Load())), FunctionDef(name='_find_eggs_in_zip', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='pip._vendor.pkg_resources', names=[alias(name='find_eggs_in_zip')], level=0), ImportFrom(module='pip._internal.metadata', names=[alias(name='pkg_resources', asname='legacy')], level=0), Try(body=[Assign(targets=[Name(id='importer', ctx=Store())], value=Call(func=Attribute(value=Name(id='zipimport', ctx=Load()), attr='zipimporter', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='zipimport', ctx=Load()), attr='ZipImportError', ctx=Load()), body=[Return()])], orelse=[], finalbody=[]), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Name(id='find_eggs_in_zip', ctx=Load()), args=[Name(id='importer', ctx=Load()), Name(id='location', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Call(func=Attribute(value=Name(id='legacy', ctx=Load()), attr='Distribution', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='BaseDistribution', ctx=Load()), ctx=Load())), FunctionDef(name='find_eggs', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Find eggs in a location.\n\n        This actually uses the old *pkg_resources* backend. We likely want to\n        deprecate this so we can eventually remove the *pkg_resources*\n        dependency entirely. Before that, this should first emit a deprecation\n        warning for some versions when using the fallback since importing\n        *pkg_resources* is slow for those who don't need it.\n        ")), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]), body=[Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_eggs_in_dir', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[])))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='zipfile', ctx=Load()), attr='is_zipfile', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]), body=[Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_eggs_in_zip', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='BaseDistribution', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='_emit_egg_deprecation', args=arguments(posonlyargs=[], args=[arg(arg='location', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Name(id='deprecated', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=JoinedStr(values=[Constant(value='Loading egg at '), FormattedValue(value=Name(id='location', ctx=Load()), conversion=-1), Constant(value=' is deprecated.')])), keyword(arg='replacement', value=Constant(value='to use pip for package installation.')), keyword(arg='gone_in', value=Constant(value='24.3')), keyword(arg='issue', value=Constant(value=12330))]))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='lru_cache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=None))])], returns=Constant(value=None)), ClassDef(name='Environment', bases=[Name(id='BaseEnvironment', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='paths', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_paths', ctx=Store())], value=Name(id='paths', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='default', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='BaseEnvironment', ctx=Load())), FunctionDef(name='from_paths', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='paths', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='paths', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='paths', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='BaseEnvironment', ctx=Load())), FunctionDef(name='_iter_distributions', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='finder', ctx=Store())], value=Call(func=Name(id='_DistributionFinder', ctx=Load()), args=[], keywords=[])), For(target=Name(id='location', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_paths', ctx=Load()), body=[Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]))), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find_eggs', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='_emit_egg_deprecation', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='location', ctx=Load())], keywords=[])), Expr(value=Yield(value=Name(id='dist', ctx=Load())))], orelse=[]), Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find_linked', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='BaseDistribution', ctx=Load()), ctx=Load())), FunctionDef(name='get_distribution', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='matches', ctx=Store())], value=GeneratorExp(elt=Name(id='distribution', ctx=Load()), generators=[comprehension(target=Name(id='distribution', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iter_all_distributions', ctx=Load()), args=[], keywords=[]), ifs=[Compare(left=Attribute(value=Name(id='distribution', ctx=Load()), attr='canonical_name', ctx=Load()), ops=[Eq()], comparators=[Call(func=Name(id='canonicalize_name', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])])], is_async=0)])), Return(value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='matches', ctx=Load()), Constant(value=None)], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='BaseDistribution', ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])