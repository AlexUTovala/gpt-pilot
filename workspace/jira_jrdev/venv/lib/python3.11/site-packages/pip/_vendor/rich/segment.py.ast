Module(body=[ImportFrom(module='enum', names=[alias(name='IntEnum')], level=0), ImportFrom(module='functools', names=[alias(name='lru_cache')], level=0), ImportFrom(module='itertools', names=[alias(name='filterfalse')], level=0), ImportFrom(module='logging', names=[alias(name='getLogger')], level=0), ImportFrom(module='operator', names=[alias(name='attrgetter')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Dict'), alias(name='Iterable'), alias(name='List'), alias(name='NamedTuple'), alias(name='Optional'), alias(name='Sequence'), alias(name='Tuple'), alias(name='Type'), alias(name='Union')], level=0), ImportFrom(module='cells', names=[alias(name='_is_single_cell_widths'), alias(name='cached_cell_len'), alias(name='cell_len'), alias(name='get_character_cell_size'), alias(name='set_cell_size')], level=1), ImportFrom(module='repr', names=[alias(name='Result'), alias(name='rich_repr')], level=1), ImportFrom(module='style', names=[alias(name='Style')], level=1), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='console', names=[alias(name='Console'), alias(name='ConsoleOptions'), alias(name='RenderResult')], level=1)], orelse=[]), Assign(targets=[Name(id='log', ctx=Store())], value=Call(func=Name(id='getLogger', ctx=Load()), args=[Constant(value='rich')], keywords=[])), ClassDef(name='ControlType', bases=[Name(id='IntEnum', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Non-printable control codes which typically translate to ANSI codes.')), Assign(targets=[Name(id='BELL', ctx=Store())], value=Constant(value=1)), Assign(targets=[Name(id='CARRIAGE_RETURN', ctx=Store())], value=Constant(value=2)), Assign(targets=[Name(id='HOME', ctx=Store())], value=Constant(value=3)), Assign(targets=[Name(id='CLEAR', ctx=Store())], value=Constant(value=4)), Assign(targets=[Name(id='SHOW_CURSOR', ctx=Store())], value=Constant(value=5)), Assign(targets=[Name(id='HIDE_CURSOR', ctx=Store())], value=Constant(value=6)), Assign(targets=[Name(id='ENABLE_ALT_SCREEN', ctx=Store())], value=Constant(value=7)), Assign(targets=[Name(id='DISABLE_ALT_SCREEN', ctx=Store())], value=Constant(value=8)), Assign(targets=[Name(id='CURSOR_UP', ctx=Store())], value=Constant(value=9)), Assign(targets=[Name(id='CURSOR_DOWN', ctx=Store())], value=Constant(value=10)), Assign(targets=[Name(id='CURSOR_FORWARD', ctx=Store())], value=Constant(value=11)), Assign(targets=[Name(id='CURSOR_BACKWARD', ctx=Store())], value=Constant(value=12)), Assign(targets=[Name(id='CURSOR_MOVE_TO_COLUMN', ctx=Store())], value=Constant(value=13)), Assign(targets=[Name(id='CURSOR_MOVE_TO', ctx=Store())], value=Constant(value=14)), Assign(targets=[Name(id='ERASE_IN_LINE', ctx=Store())], value=Constant(value=15)), Assign(targets=[Name(id='SET_WINDOW_TITLE', ctx=Store())], value=Constant(value=16))], decorator_list=[]), Assign(targets=[Name(id='ControlCode', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Name(id='ControlType', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='ControlType', ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='ControlType', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='Segment', bases=[Name(id='NamedTuple', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A piece of text with associated style. Segments are produced by the Console render process and\n    are ultimately converted in to strings to be written to the terminal.\n\n    Args:\n        text (str): A piece of text.\n        style (:class:`~rich.style.Style`, optional): An optional style to apply to the text.\n        control (Tuple[ControlCode], optional): Optional sequence of control codes.\n\n    Attributes:\n        cell_length (int): The cell length of this Segment.\n    ')), AnnAssign(target=Name(id='text', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='style', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Style', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), AnnAssign(target=Name(id='control', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='ControlCode', ctx=Load()), ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), FunctionDef(name='cell_length', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The number of terminal cells required to display self.text.\n\n        Returns:\n            int: A number of cells.\n        ')), Assign(targets=[Tuple(elts=[Name(id='text', ctx=Store()), Name(id='_style', ctx=Store()), Name(id='control', ctx=Store())], ctx=Store())], value=Name(id='self', ctx=Load())), Return(value=IfExp(test=Name(id='control', ctx=Load()), body=Constant(value=0), orelse=Call(func=Name(id='cell_len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='__rich_repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Yield(value=Attribute(value=Name(id='self', ctx=Load()), attr='text', ctx=Load()))), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='control', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load())))], orelse=[])], orelse=[Expr(value=Yield(value=Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load()))), Expr(value=Yield(value=Attribute(value=Name(id='self', ctx=Load()), attr='control', ctx=Load())))])], decorator_list=[], returns=Name(id='Result', ctx=Load())), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if the segment contains text.')), Return(value=Call(func=Name(id='bool', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='text', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='is_control', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if the segment contains control codes.')), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='control', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_split_cells', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='segment', annotation=Constant(value='Segment')), arg(arg='cut', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='text', ctx=Store()), Name(id='style', ctx=Store()), Name(id='control', ctx=Store())], ctx=Store())], value=Name(id='segment', ctx=Load())), Assign(targets=[Name(id='_Segment', ctx=Store())], value=Name(id='Segment', ctx=Load())), Assign(targets=[Name(id='cell_length', ctx=Store())], value=Attribute(value=Name(id='segment', ctx=Load()), attr='cell_length', ctx=Load())), If(test=Compare(left=Name(id='cut', ctx=Load()), ops=[GtE()], comparators=[Name(id='cell_length', ctx=Load())]), body=[Return(value=Tuple(elts=[Name(id='segment', ctx=Load()), Call(func=Name(id='_Segment', ctx=Load()), args=[Constant(value=''), Name(id='style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[])], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='cell_size', ctx=Store())], value=Name(id='get_character_cell_size', ctx=Load())), Assign(targets=[Name(id='pos', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='cut', ctx=Load()), op=Div(), right=Name(id='cell_length', ctx=Load())), op=Mult(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1)))], keywords=[])), Assign(targets=[Name(id='before', ctx=Store())], value=Subscript(value=Name(id='text', ctx=Load()), slice=Slice(upper=Name(id='pos', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='cell_pos', ctx=Store())], value=Call(func=Name(id='cell_len', ctx=Load()), args=[Name(id='before', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='cell_pos', ctx=Load()), ops=[Eq()], comparators=[Name(id='cut', ctx=Load())]), body=[Return(value=Tuple(elts=[Call(func=Name(id='_Segment', ctx=Load()), args=[Name(id='before', ctx=Load()), Name(id='style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[]), Call(func=Name(id='_Segment', ctx=Load()), args=[Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Name(id='pos', ctx=Load())), ctx=Load()), Name(id='style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[])], ctx=Load()))], orelse=[]), While(test=Compare(left=Name(id='pos', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='char', ctx=Store())], value=Subscript(value=Name(id='text', ctx=Load()), slice=Name(id='pos', ctx=Load()), ctx=Load())), AugAssign(target=Name(id='pos', ctx=Store()), op=Add(), value=Constant(value=1)), AugAssign(target=Name(id='cell_pos', ctx=Store()), op=Add(), value=Call(func=Name(id='cell_size', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[])), Assign(targets=[Name(id='before', ctx=Store())], value=Subscript(value=Name(id='text', ctx=Load()), slice=Slice(upper=Name(id='pos', ctx=Load())), ctx=Load())), If(test=Compare(left=Name(id='cell_pos', ctx=Load()), ops=[Eq()], comparators=[Name(id='cut', ctx=Load())]), body=[Return(value=Tuple(elts=[Call(func=Name(id='_Segment', ctx=Load()), args=[Name(id='before', ctx=Load()), Name(id='style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[]), Call(func=Name(id='_Segment', ctx=Load()), args=[Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Name(id='pos', ctx=Load())), ctx=Load()), Name(id='style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[])], ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='cell_pos', ctx=Load()), ops=[Gt()], comparators=[Name(id='cut', ctx=Load())]), body=[Return(value=Tuple(elts=[Call(func=Name(id='_Segment', ctx=Load()), args=[BinOp(left=Subscript(value=Name(id='before', ctx=Load()), slice=Slice(upper=BinOp(left=Name(id='pos', ctx=Load()), op=Sub(), right=Constant(value=1))), ctx=Load()), op=Add(), right=Constant(value=' ')), Name(id='style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[]), Call(func=Name(id='_Segment', ctx=Load()), args=[BinOp(left=Constant(value=' '), op=Add(), right=Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Name(id='pos', ctx=Load())), ctx=Load())), Name(id='style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[])], ctx=Load()))], orelse=[])], orelse=[]), Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Constant(value='Will never reach here')], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load()), Call(func=Name(id='lru_cache', ctx=Load()), args=[BinOp(left=Constant(value=1024), op=Mult(), right=Constant(value=16))], keywords=[])], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Constant(value='Segment'), Constant(value='Segment')], ctx=Load()), ctx=Load())), FunctionDef(name='split_cells', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cut', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Split segment in to two segments at the specified column.\n\n        If the cut point falls in the middle of a 2-cell wide character then it is replaced\n        by two spaces, to preserve the display width of the parent segment.\n\n        Returns:\n            Tuple[Segment, Segment]: Two segments.\n        ')), Assign(targets=[Tuple(elts=[Name(id='text', ctx=Store()), Name(id='style', ctx=Store()), Name(id='control', ctx=Store())], ctx=Store())], value=Name(id='self', ctx=Load())), If(test=Call(func=Name(id='_is_single_cell_widths', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='cut', ctx=Load()), ops=[GtE()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])]), body=[Return(value=Tuple(elts=[Name(id='self', ctx=Load()), Call(func=Name(id='Segment', ctx=Load()), args=[Constant(value=''), Name(id='style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[])], ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='Segment', ctx=Load()), args=[Subscript(value=Name(id='text', ctx=Load()), slice=Slice(upper=Name(id='cut', ctx=Load())), ctx=Load()), Name(id='style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[]), Call(func=Name(id='Segment', ctx=Load()), args=[Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Name(id='cut', ctx=Load())), ctx=Load()), Name(id='style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[])], ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_split_cells', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='cut', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Constant(value='Segment'), Constant(value='Segment')], ctx=Load()), ctx=Load())), FunctionDef(name='line', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Make a new line segment.')), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Constant(value='\n')], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='Segment')), FunctionDef(name='apply_style', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='segments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), arg(arg='style', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Style', ctx=Load()), ctx=Load())), arg(arg='post_style', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Style', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Apply style(s) to an iterable of segments.\n\n        Returns an iterable of segments where the style is replaced by ``style + segment.style + post_style``.\n\n        Args:\n            segments (Iterable[Segment]): Segments to process.\n            style (Style, optional): Base style. Defaults to None.\n            post_style (Style, optional): Style to apply on top of segment style. Defaults to None.\n\n        Returns:\n            Iterable[Segments]: A new iterable of segments (possibly the same iterable).\n        ')), Assign(targets=[Name(id='result_segments', ctx=Store())], value=Name(id='segments', ctx=Load())), If(test=Name(id='style', ctx=Load()), body=[Assign(targets=[Name(id='apply', ctx=Store())], value=Attribute(value=Name(id='style', ctx=Load()), attr='__add__', ctx=Load())), Assign(targets=[Name(id='result_segments', ctx=Store())], value=GeneratorExp(elt=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='text', ctx=Load()), IfExp(test=Name(id='control', ctx=Load()), body=Constant(value=None), orelse=Call(func=Name(id='apply', ctx=Load()), args=[Name(id='_style', ctx=Load())], keywords=[])), Name(id='control', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='text', ctx=Store()), Name(id='_style', ctx=Store()), Name(id='control', ctx=Store())], ctx=Store()), iter=Name(id='result_segments', ctx=Load()), ifs=[], is_async=0)]))], orelse=[]), If(test=Name(id='post_style', ctx=Load()), body=[Assign(targets=[Name(id='result_segments', ctx=Store())], value=GeneratorExp(elt=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='text', ctx=Load()), IfExp(test=Name(id='control', ctx=Load()), body=Constant(value=None), orelse=IfExp(test=Name(id='_style', ctx=Load()), body=BinOp(left=Name(id='_style', ctx=Load()), op=Add(), right=Name(id='post_style', ctx=Load())), orelse=Name(id='post_style', ctx=Load()))), Name(id='control', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='text', ctx=Store()), Name(id='_style', ctx=Store()), Name(id='control', ctx=Store())], ctx=Store()), iter=Name(id='result_segments', ctx=Load()), ifs=[], is_async=0)]))], orelse=[]), Return(value=Name(id='result_segments', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), FunctionDef(name='filter_control', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='segments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), arg(arg='is_control', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Filter segments by ``is_control`` attribute.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of Segment instances.\n            is_control (bool, optional): is_control flag to match in search.\n\n        Returns:\n            Iterable[Segment]: And iterable of Segment instances.\n\n        ')), If(test=Name(id='is_control', ctx=Load()), body=[Return(value=Call(func=Name(id='filter', ctx=Load()), args=[Call(func=Name(id='attrgetter', ctx=Load()), args=[Constant(value='control')], keywords=[]), Name(id='segments', ctx=Load())], keywords=[]))], orelse=[Return(value=Call(func=Name(id='filterfalse', ctx=Load()), args=[Call(func=Name(id='attrgetter', ctx=Load()), args=[Constant(value='control')], keywords=[]), Name(id='segments', ctx=Load())], keywords=[]))])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), FunctionDef(name='split_lines', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='segments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Split a sequence of segments in to a list of lines.\n\n        Args:\n            segments (Iterable[Segment]): Segments potentially containing line feeds.\n\n        Yields:\n            Iterable[List[Segment]]: Iterable of segment lists, one per line.\n        ')), AnnAssign(target=Name(id='line', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Segment', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='append', ctx=Store())], value=Attribute(value=Name(id='line', ctx=Load()), attr='append', ctx=Load())), For(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='\n'), ops=[In()], comparators=[Attribute(value=Name(id='segment', ctx=Load()), attr='text', ctx=Load())]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='segment', ctx=Load()), attr='control', ctx=Load()))]), body=[Assign(targets=[Tuple(elts=[Name(id='text', ctx=Store()), Name(id='style', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Name(id='segment', ctx=Load())), While(test=Name(id='text', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='_text', ctx=Store()), Name(id='new_line', ctx=Store()), Name(id='text', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value='\n')], keywords=[])), If(test=Name(id='_text', ctx=Load()), body=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Call(func=Name(id='cls', ctx=Load()), args=[Name(id='_text', ctx=Load()), Name(id='style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=Name(id='new_line', ctx=Load()), body=[Expr(value=Yield(value=Name(id='line', ctx=Load()))), Assign(targets=[Name(id='line', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='append', ctx=Store())], value=Attribute(value=Name(id='line', ctx=Load()), attr='append', ctx=Load()))], orelse=[])], orelse=[])], orelse=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[]))])], orelse=[]), If(test=Name(id='line', ctx=Load()), body=[Expr(value=Yield(value=Name(id='line', ctx=Load())))], orelse=[])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load())), FunctionDef(name='split_and_crop_lines', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='segments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), arg(arg='length', annotation=Name(id='int', ctx=Load())), arg(arg='style', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Style', ctx=Load()), ctx=Load())), arg(arg='pad', annotation=Name(id='bool', ctx=Load())), arg(arg='include_new_lines', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=True), Constant(value=True)]), body=[Expr(value=Constant(value='Split segments in to lines, and crop lines greater than a given length.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of segments, probably\n                generated from console.render.\n            length (int): Desired line length.\n            style (Style, optional): Style to use for any padding.\n            pad (bool): Enable padding of lines that are less than `length`.\n\n        Returns:\n            Iterable[List[Segment]]: An iterable of lines of segments.\n        ')), AnnAssign(target=Name(id='line', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Segment', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='append', ctx=Store())], value=Attribute(value=Name(id='line', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='adjust_line_length', ctx=Store())], value=Attribute(value=Name(id='cls', ctx=Load()), attr='adjust_line_length', ctx=Load())), Assign(targets=[Name(id='new_line_segment', ctx=Store())], value=Call(func=Name(id='cls', ctx=Load()), args=[Constant(value='\n')], keywords=[])), For(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='\n'), ops=[In()], comparators=[Attribute(value=Name(id='segment', ctx=Load()), attr='text', ctx=Load())]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='segment', ctx=Load()), attr='control', ctx=Load()))]), body=[Assign(targets=[Tuple(elts=[Name(id='text', ctx=Store()), Name(id='segment_style', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Name(id='segment', ctx=Load())), While(test=Name(id='text', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='_text', ctx=Store()), Name(id='new_line', ctx=Store()), Name(id='text', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value='\n')], keywords=[])), If(test=Name(id='_text', ctx=Load()), body=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Call(func=Name(id='cls', ctx=Load()), args=[Name(id='_text', ctx=Load()), Name(id='segment_style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=Name(id='new_line', ctx=Load()), body=[Assign(targets=[Name(id='cropped_line', ctx=Store())], value=Call(func=Name(id='adjust_line_length', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='length', ctx=Load())], keywords=[keyword(arg='style', value=Name(id='style', ctx=Load())), keyword(arg='pad', value=Name(id='pad', ctx=Load()))])), If(test=Name(id='include_new_lines', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='cropped_line', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='new_line_segment', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Yield(value=Name(id='cropped_line', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[])], orelse=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[]))])], orelse=[]), If(test=Name(id='line', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Name(id='adjust_line_length', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='length', ctx=Load())], keywords=[keyword(arg='style', value=Name(id='style', ctx=Load())), keyword(arg='pad', value=Name(id='pad', ctx=Load()))])))], orelse=[])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load())), FunctionDef(name='adjust_line_length', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='line', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), arg(arg='length', annotation=Name(id='int', ctx=Load())), arg(arg='style', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Style', ctx=Load()), ctx=Load())), arg(arg='pad', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=True)]), body=[Expr(value=Constant(value='Adjust a line to a given width (cropping or padding as required).\n\n        Args:\n            segments (Iterable[Segment]): A list of segments in a single line.\n            length (int): The desired width of the line.\n            style (Style, optional): The style of padding if used (space on the end). Defaults to None.\n            pad (bool, optional): Pad lines with spaces if they are shorter than `length`. Defaults to True.\n\n        Returns:\n            List[Segment]: A line of segments with the desired length.\n        ')), Assign(targets=[Name(id='line_length', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='segment', ctx=Load()), attr='cell_length', ctx=Load()), generators=[comprehension(target=Name(id='segment', ctx=Store()), iter=Name(id='line', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), AnnAssign(target=Name(id='new_line', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Segment', ctx=Load()), ctx=Load()), simple=1), If(test=Compare(left=Name(id='line_length', ctx=Load()), ops=[Lt()], comparators=[Name(id='length', ctx=Load())]), body=[If(test=Name(id='pad', ctx=Load()), body=[Assign(targets=[Name(id='new_line', ctx=Store())], value=BinOp(left=Name(id='line', ctx=Load()), op=Add(), right=List(elts=[Call(func=Name(id='cls', ctx=Load()), args=[BinOp(left=Constant(value=' '), op=Mult(), right=BinOp(left=Name(id='length', ctx=Load()), op=Sub(), right=Name(id='line_length', ctx=Load()))), Name(id='style', ctx=Load())], keywords=[])], ctx=Load())))], orelse=[Assign(targets=[Name(id='new_line', ctx=Store())], value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(), ctx=Load()))])], orelse=[If(test=Compare(left=Name(id='line_length', ctx=Load()), ops=[Gt()], comparators=[Name(id='length', ctx=Load())]), body=[Assign(targets=[Name(id='new_line', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='append', ctx=Store())], value=Attribute(value=Name(id='new_line', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='line_length', ctx=Store())], value=Constant(value=0)), For(target=Name(id='segment', ctx=Store()), iter=Name(id='line', ctx=Load()), body=[Assign(targets=[Name(id='segment_length', ctx=Store())], value=Attribute(value=Name(id='segment', ctx=Load()), attr='cell_length', ctx=Load())), If(test=BoolOp(op=Or(), values=[Compare(left=BinOp(left=Name(id='line_length', ctx=Load()), op=Add(), right=Name(id='segment_length', ctx=Load())), ops=[Lt()], comparators=[Name(id='length', ctx=Load())]), Attribute(value=Name(id='segment', ctx=Load()), attr='control', ctx=Load())]), body=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[])), AugAssign(target=Name(id='line_length', ctx=Store()), op=Add(), value=Name(id='segment_length', ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='text', ctx=Store()), Name(id='segment_style', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Name(id='segment', ctx=Load())), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Name(id='set_cell_size', ctx=Load()), args=[Name(id='text', ctx=Load()), BinOp(left=Name(id='length', ctx=Load()), op=Sub(), right=Name(id='line_length', ctx=Load()))], keywords=[])), Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Call(func=Name(id='cls', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='segment_style', ctx=Load())], keywords=[])], keywords=[])), Break()])], orelse=[])], orelse=[Assign(targets=[Name(id='new_line', ctx=Store())], value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(), ctx=Load()))])]), Return(value=Name(id='new_line', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), FunctionDef(name='get_line_length', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='line', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Get the length of list of segments.\n\n        Args:\n            line (List[Segment]): A line encoded as a list of Segments (assumes no '\\\\n' characters),\n\n        Returns:\n            int: The length of the line.\n        ")), Assign(targets=[Name(id='_cell_len', ctx=Store())], value=Name(id='cell_len', ctx=Load())), Return(value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_cell_len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='text', ctx=Store()), Name(id='style', ctx=Store()), Name(id='control', ctx=Store())], ctx=Store()), iter=Name(id='line', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Name(id='control', ctx=Load()))], is_async=0)])], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='get_shape', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='lines', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Get the shape (enclosing rectangle) of a list of lines.\n\n        Args:\n            lines (List[List[Segment]]): A list of lines (no '\\\\n' characters).\n\n        Returns:\n            Tuple[int, int]: Width and height in characters.\n        ")), Assign(targets=[Name(id='get_line_length', ctx=Store())], value=Attribute(value=Name(id='cls', ctx=Load()), attr='get_line_length', ctx=Load())), Assign(targets=[Name(id='max_width', ctx=Store())], value=IfExp(test=Name(id='lines', ctx=Load()), body=Call(func=Name(id='max', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='get_line_length', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), orelse=Constant(value=0))), Return(value=Tuple(elts=[Name(id='max_width', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])], ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='set_shape', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='lines', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load())), arg(arg='width', annotation=Name(id='int', ctx=Load())), arg(arg='height', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='style', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Style', ctx=Load()), ctx=Load())), arg(arg='new_lines', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Set the shape of a list of lines (enclosing rectangle).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style, optional): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include "\n". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        ')), Assign(targets=[Name(id='_height', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='height', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])])), Assign(targets=[Name(id='blank', ctx=Store())], value=IfExp(test=Name(id='new_lines', ctx=Load()), body=List(elts=[Call(func=Name(id='cls', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='width', ctx=Load())), op=Add(), right=Constant(value='\n')), Name(id='style', ctx=Load())], keywords=[])], ctx=Load()), orelse=List(elts=[Call(func=Name(id='cls', ctx=Load()), args=[BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='width', ctx=Load())), Name(id='style', ctx=Load())], keywords=[])], ctx=Load()))), Assign(targets=[Name(id='adjust_line_length', ctx=Store())], value=Attribute(value=Name(id='cls', ctx=Load()), attr='adjust_line_length', ctx=Load())), Assign(targets=[Name(id='shaped_lines', ctx=Store())], value=Subscript(value=Name(id='lines', ctx=Load()), slice=Slice(upper=Name(id='_height', ctx=Load())), ctx=Load())), Assign(targets=[Subscript(value=Name(id='shaped_lines', ctx=Load()), slice=Slice(), ctx=Store())], value=ListComp(elt=Call(func=Name(id='adjust_line_length', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='width', ctx=Load())], keywords=[keyword(arg='style', value=Name(id='style', ctx=Load()))]), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), ifs=[], is_async=0)])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='shaped_lines', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Name(id='_height', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='shaped_lines', ctx=Load()), attr='extend', ctx=Load()), args=[BinOp(left=List(elts=[Name(id='blank', ctx=Load())], ctx=Load()), op=Mult(), right=BinOp(left=Name(id='_height', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='shaped_lines', ctx=Load())], keywords=[])))], keywords=[]))], orelse=[]), Return(value=Name(id='shaped_lines', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load())), FunctionDef(name='align_top', args=arguments(posonlyargs=[], args=[arg(arg='cls', annotation=Subscript(value=Name(id='Type', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), arg(arg='lines', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load())), arg(arg='width', annotation=Name(id='int', ctx=Load())), arg(arg='height', annotation=Name(id='int', ctx=Load())), arg(arg='style', annotation=Name(id='Style', ctx=Load())), arg(arg='new_lines', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Aligns lines to top (adds extra lines to bottom as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include "\n". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        ')), Assign(targets=[Name(id='extra_lines', ctx=Store())], value=BinOp(left=Name(id='height', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]))), If(test=UnaryOp(op=Not(), operand=Name(id='extra_lines', ctx=Load())), body=[Return(value=Subscript(value=Name(id='lines', ctx=Load()), slice=Slice(), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='lines', ctx=Store())], value=Subscript(value=Name(id='lines', ctx=Load()), slice=Slice(upper=Name(id='height', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='blank', ctx=Store())], value=IfExp(test=Name(id='new_lines', ctx=Load()), body=Call(func=Name(id='cls', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='width', ctx=Load())), op=Add(), right=Constant(value='\n')), Name(id='style', ctx=Load())], keywords=[]), orelse=Call(func=Name(id='cls', ctx=Load()), args=[BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='width', ctx=Load())), Name(id='style', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='lines', ctx=Store())], value=BinOp(left=Name(id='lines', ctx=Load()), op=Add(), right=BinOp(left=List(elts=[List(elts=[Name(id='blank', ctx=Load())], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='extra_lines', ctx=Load())))), Return(value=Name(id='lines', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load())), FunctionDef(name='align_bottom', args=arguments(posonlyargs=[], args=[arg(arg='cls', annotation=Subscript(value=Name(id='Type', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), arg(arg='lines', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load())), arg(arg='width', annotation=Name(id='int', ctx=Load())), arg(arg='height', annotation=Name(id='int', ctx=Load())), arg(arg='style', annotation=Name(id='Style', ctx=Load())), arg(arg='new_lines', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Aligns render to bottom (adds extra lines above as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added. Defaults to None.\n            new_lines (bool, optional): Padded lines should include "\n". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        ')), Assign(targets=[Name(id='extra_lines', ctx=Store())], value=BinOp(left=Name(id='height', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]))), If(test=UnaryOp(op=Not(), operand=Name(id='extra_lines', ctx=Load())), body=[Return(value=Subscript(value=Name(id='lines', ctx=Load()), slice=Slice(), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='lines', ctx=Store())], value=Subscript(value=Name(id='lines', ctx=Load()), slice=Slice(upper=Name(id='height', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='blank', ctx=Store())], value=IfExp(test=Name(id='new_lines', ctx=Load()), body=Call(func=Name(id='cls', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='width', ctx=Load())), op=Add(), right=Constant(value='\n')), Name(id='style', ctx=Load())], keywords=[]), orelse=Call(func=Name(id='cls', ctx=Load()), args=[BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='width', ctx=Load())), Name(id='style', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='lines', ctx=Store())], value=BinOp(left=BinOp(left=List(elts=[List(elts=[Name(id='blank', ctx=Load())], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='extra_lines', ctx=Load())), op=Add(), right=Name(id='lines', ctx=Load()))), Return(value=Name(id='lines', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load())), FunctionDef(name='align_middle', args=arguments(posonlyargs=[], args=[arg(arg='cls', annotation=Subscript(value=Name(id='Type', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), arg(arg='lines', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load())), arg(arg='width', annotation=Name(id='int', ctx=Load())), arg(arg='height', annotation=Name(id='int', ctx=Load())), arg(arg='style', annotation=Name(id='Style', ctx=Load())), arg(arg='new_lines', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Aligns lines to middle (adds extra lines to above and below as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include "\n". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        ')), Assign(targets=[Name(id='extra_lines', ctx=Store())], value=BinOp(left=Name(id='height', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]))), If(test=UnaryOp(op=Not(), operand=Name(id='extra_lines', ctx=Load())), body=[Return(value=Subscript(value=Name(id='lines', ctx=Load()), slice=Slice(), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='lines', ctx=Store())], value=Subscript(value=Name(id='lines', ctx=Load()), slice=Slice(upper=Name(id='height', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='blank', ctx=Store())], value=IfExp(test=Name(id='new_lines', ctx=Load()), body=Call(func=Name(id='cls', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='width', ctx=Load())), op=Add(), right=Constant(value='\n')), Name(id='style', ctx=Load())], keywords=[]), orelse=Call(func=Name(id='cls', ctx=Load()), args=[BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='width', ctx=Load())), Name(id='style', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='top_lines', ctx=Store())], value=BinOp(left=Name(id='extra_lines', ctx=Load()), op=FloorDiv(), right=Constant(value=2))), Assign(targets=[Name(id='bottom_lines', ctx=Store())], value=BinOp(left=Name(id='extra_lines', ctx=Load()), op=Sub(), right=Name(id='top_lines', ctx=Load()))), Assign(targets=[Name(id='lines', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=List(elts=[List(elts=[Name(id='blank', ctx=Load())], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='top_lines', ctx=Load())), op=Add(), right=Name(id='lines', ctx=Load())), op=Add(), right=BinOp(left=List(elts=[List(elts=[Name(id='blank', ctx=Load())], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='bottom_lines', ctx=Load())))), Return(value=Name(id='lines', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load())), FunctionDef(name='simplify', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='segments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Simplify an iterable of segments by combining contiguous segments with the same style.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of segments.\n\n        Returns:\n            Iterable[Segment]: A possibly smaller iterable of segments that will render the same way.\n        ')), Assign(targets=[Name(id='iter_segments', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='segments', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='last_segment', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iter_segments', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return()])], orelse=[], finalbody=[]), Assign(targets=[Name(id='_Segment', ctx=Store())], value=Name(id='Segment', ctx=Load())), For(target=Name(id='segment', ctx=Store()), iter=Name(id='iter_segments', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='last_segment', ctx=Load()), attr='style', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='segment', ctx=Load()), attr='style', ctx=Load())]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='segment', ctx=Load()), attr='control', ctx=Load()))]), body=[Assign(targets=[Name(id='last_segment', ctx=Store())], value=Call(func=Name(id='_Segment', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='last_segment', ctx=Load()), attr='text', ctx=Load()), op=Add(), right=Attribute(value=Name(id='segment', ctx=Load()), attr='text', ctx=Load())), Attribute(value=Name(id='last_segment', ctx=Load()), attr='style', ctx=Load())], keywords=[]))], orelse=[Expr(value=Yield(value=Name(id='last_segment', ctx=Load()))), Assign(targets=[Name(id='last_segment', ctx=Store())], value=Name(id='segment', ctx=Load()))])], orelse=[]), Expr(value=Yield(value=Name(id='last_segment', ctx=Load())))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), FunctionDef(name='strip_links', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='segments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove all links from an iterable of styles.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with link removed.\n        ')), For(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='segment', ctx=Load()), attr='control', ctx=Load()), Compare(left=Attribute(value=Name(id='segment', ctx=Load()), attr='style', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Expr(value=Yield(value=Name(id='segment', ctx=Load())))], orelse=[Assign(targets=[Tuple(elts=[Name(id='text', ctx=Store()), Name(id='style', ctx=Store()), Name(id='_control', ctx=Store())], ctx=Store())], value=Name(id='segment', ctx=Load())), Expr(value=Yield(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='text', ctx=Load()), IfExp(test=Name(id='style', ctx=Load()), body=Call(func=Attribute(value=Name(id='style', ctx=Load()), attr='update_link', ctx=Load()), args=[Constant(value=None)], keywords=[]), orelse=Constant(value=None))], keywords=[])))])], orelse=[])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), FunctionDef(name='strip_styles', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='segments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove all styles from an iterable of segments.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with styles replace with None\n        ')), For(target=Tuple(elts=[Name(id='text', ctx=Store()), Name(id='_style', ctx=Store()), Name(id='control', ctx=Store())], ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='text', ctx=Load()), Constant(value=None), Name(id='control', ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), FunctionDef(name='remove_color', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='segments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove all color from an iterable of segments.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with colorless style.\n        ')), AnnAssign(target=Name(id='cache', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='Style', ctx=Load()), Name(id='Style', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), For(target=Tuple(elts=[Name(id='text', ctx=Store()), Name(id='style', ctx=Store()), Name(id='control', ctx=Store())], ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[If(test=Name(id='style', ctx=Load()), body=[Assign(targets=[Name(id='colorless_style', ctx=Store())], value=Call(func=Attribute(value=Name(id='cache', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='style', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='colorless_style', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='colorless_style', ctx=Store())], value=Attribute(value=Name(id='style', ctx=Load()), attr='without_color', ctx=Load())), Assign(targets=[Subscript(value=Name(id='cache', ctx=Load()), slice=Name(id='style', ctx=Load()), ctx=Store())], value=Name(id='colorless_style', ctx=Load()))], orelse=[]), Expr(value=Yield(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='colorless_style', ctx=Load()), Name(id='control', ctx=Load())], keywords=[])))], orelse=[Expr(value=Yield(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='text', ctx=Load()), Constant(value=None), Name(id='control', ctx=Load())], keywords=[])))])], orelse=[])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), FunctionDef(name='divide', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='segments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), arg(arg='cuts', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Divides an iterable of segments in to portions.\n\n        Args:\n            cuts (Iterable[int]): Cell positions where to divide.\n\n        Yields:\n            [Iterable[List[Segment]]]: An iterable of Segments in List.\n        ')), AnnAssign(target=Name(id='split_segments', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='add_segment', ctx=Store())], value=Attribute(value=Name(id='split_segments', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='iter_cuts', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='cuts', ctx=Load())], keywords=[])), While(test=Constant(value=True), body=[Assign(targets=[Name(id='cut', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iter_cuts', ctx=Load()), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[])), If(test=Compare(left=Name(id='cut', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='cut', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Break()], orelse=[]), Expr(value=Yield(value=List(elts=[], ctx=Load())))], orelse=[]), Assign(targets=[Name(id='pos', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='segments_clear', ctx=Store())], value=Attribute(value=Name(id='split_segments', ctx=Load()), attr='clear', ctx=Load())), Assign(targets=[Name(id='segments_copy', ctx=Store())], value=Attribute(value=Name(id='split_segments', ctx=Load()), attr='copy', ctx=Load())), Assign(targets=[Name(id='_cell_len', ctx=Store())], value=Name(id='cached_cell_len', ctx=Load())), For(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='text', ctx=Store()), Name(id='_style', ctx=Store()), Name(id='control', ctx=Store())], ctx=Store())], value=Name(id='segment', ctx=Load())), While(test=Name(id='text', ctx=Load()), body=[Assign(targets=[Name(id='end_pos', ctx=Store())], value=IfExp(test=Name(id='control', ctx=Load()), body=Name(id='pos', ctx=Load()), orelse=BinOp(left=Name(id='pos', ctx=Load()), op=Add(), right=Call(func=Name(id='_cell_len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])))), If(test=Compare(left=Name(id='end_pos', ctx=Load()), ops=[Lt()], comparators=[Name(id='cut', ctx=Load())]), body=[Expr(value=Call(func=Name(id='add_segment', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[])), Assign(targets=[Name(id='pos', ctx=Store())], value=Name(id='end_pos', ctx=Load())), Break()], orelse=[]), If(test=Compare(left=Name(id='end_pos', ctx=Load()), ops=[Eq()], comparators=[Name(id='cut', ctx=Load())]), body=[Expr(value=Call(func=Name(id='add_segment', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[])), Expr(value=Yield(value=Call(func=Name(id='segments_copy', ctx=Load()), args=[], keywords=[]))), Expr(value=Call(func=Name(id='segments_clear', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='pos', ctx=Store())], value=Name(id='end_pos', ctx=Load())), Assign(targets=[Name(id='cut', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iter_cuts', ctx=Load()), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[])), If(test=Compare(left=Name(id='cut', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[If(test=Name(id='split_segments', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Name(id='segments_copy', ctx=Load()), args=[], keywords=[])))], orelse=[]), Return()], orelse=[]), Break()], orelse=[Assign(targets=[Tuple(elts=[Name(id='before', ctx=Store()), Name(id='segment', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='split_cells', ctx=Load()), args=[BinOp(left=Name(id='cut', ctx=Load()), op=Sub(), right=Name(id='pos', ctx=Load()))], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='text', ctx=Store()), Name(id='_style', ctx=Store()), Name(id='control', ctx=Store())], ctx=Store())], value=Name(id='segment', ctx=Load())), Expr(value=Call(func=Name(id='add_segment', ctx=Load()), args=[Name(id='before', ctx=Load())], keywords=[])), Expr(value=Yield(value=Call(func=Name(id='segments_copy', ctx=Load()), args=[], keywords=[]))), Expr(value=Call(func=Name(id='segments_clear', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='pos', ctx=Store())], value=Name(id='cut', ctx=Load()))]), Assign(targets=[Name(id='cut', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iter_cuts', ctx=Load()), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[])), If(test=Compare(left=Name(id='cut', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[If(test=Name(id='split_segments', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Name(id='segments_copy', ctx=Load()), args=[], keywords=[])))], orelse=[]), Return()], orelse=[])], orelse=[])], orelse=[]), Expr(value=Yield(value=Call(func=Name(id='segments_copy', ctx=Load()), args=[], keywords=[])))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Segment'), ctx=Load()), ctx=Load()))], decorator_list=[Call(func=Name(id='rich_repr', ctx=Load()), args=[], keywords=[])]), ClassDef(name='Segments', bases=[], keywords=[], body=[Expr(value=Constant(value='A simple renderable to render an iterable of segments. This class may be useful if\n    you want to print segments outside of a __rich_console__ method.\n\n    Args:\n        segments (Iterable[Segment]): An iterable of segments.\n        new_lines (bool, optional): Add new lines between segments. Defaults to False.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='segments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Segment', ctx=Load()), ctx=Load())), arg(arg='new_lines', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='segments', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='segments', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='new_lines', ctx=Store())], value=Name(id='new_lines', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__rich_console__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='console', annotation=Constant(value='Console')), arg(arg='options', annotation=Constant(value='ConsoleOptions'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='new_lines', ctx=Load()), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Attribute(value=Name(id='Segment', ctx=Load()), attr='line', ctx=Load()), args=[], keywords=[])), For(target=Name(id='segment', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='segments', ctx=Load()), body=[Expr(value=Yield(value=Name(id='segment', ctx=Load()))), Expr(value=Yield(value=Name(id='line', ctx=Load())))], orelse=[])], orelse=[Expr(value=YieldFrom(value=Attribute(value=Name(id='self', ctx=Load()), attr='segments', ctx=Load())))])], decorator_list=[], returns=Constant(value='RenderResult'))], decorator_list=[]), ClassDef(name='SegmentLines', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Segment', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='new_lines', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='A simple renderable containing a number of lines of segments. May be used as an intermediate\n        in rendering process.\n\n        Args:\n            lines (Iterable[List[Segment]]): Lists of segments forming lines.\n            new_lines (bool, optional): Insert new lines after each line. Defaults to False.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='new_lines', ctx=Store())], value=Name(id='new_lines', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__rich_console__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='console', annotation=Constant(value='Console')), arg(arg='options', annotation=Constant(value='ConsoleOptions'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='new_lines', ctx=Load()), body=[Assign(targets=[Name(id='new_line', ctx=Store())], value=Call(func=Attribute(value=Name(id='Segment', ctx=Load()), attr='line', ctx=Load()), args=[], keywords=[])), For(target=Name(id='line', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Load()), body=[Expr(value=YieldFrom(value=Name(id='line', ctx=Load()))), Expr(value=Yield(value=Name(id='new_line', ctx=Load())))], orelse=[])], orelse=[For(target=Name(id='line', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Load()), body=[Expr(value=YieldFrom(value=Name(id='line', ctx=Load())))], orelse=[])])], decorator_list=[], returns=Constant(value='RenderResult'))], decorator_list=[]), If(test=Compare(left=Name(id='__name__', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__main__')]), body=[ImportFrom(module='pip._vendor.rich.console', names=[alias(name='Console')], level=0), ImportFrom(module='pip._vendor.rich.syntax', names=[alias(name='Syntax')], level=0), ImportFrom(module='pip._vendor.rich.text', names=[alias(name='Text')], level=0), Assign(targets=[Name(id='code', ctx=Store())], value=Constant(value='from rich.console import Console\nconsole = Console()\ntext = Text.from_markup("Hello, [bold magenta]World[/]!")\nconsole.print(text)')), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='Text', ctx=Load()), attr='from_markup', ctx=Load()), args=[Constant(value='Hello, [bold magenta]World[/]!')], keywords=[])), Assign(targets=[Name(id='console', ctx=Store())], value=Call(func=Name(id='Console', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='rule', ctx=Load()), args=[Constant(value='rich.Segment')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Constant(value='A Segment is the last step in the Rich render process before generating text with ANSI codes.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Constant(value='\nConsider the following code:\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Call(func=Name(id='Syntax', ctx=Load()), args=[Name(id='code', ctx=Load()), Constant(value='python')], keywords=[keyword(arg='line_numbers', value=Constant(value=True))])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Constant(value='When you call [b]print()[/b], Rich [i]renders[/i] the object in to the following:\n')], keywords=[])), Assign(targets=[Name(id='fragments', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='render', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Name(id='fragments', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Constant(value='The Segments are then processed to produce the following output:\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Constant(value='\nYou will only need to know this if you are implementing your own Rich renderables.')], keywords=[]))], orelse=[])], type_ignores=[])