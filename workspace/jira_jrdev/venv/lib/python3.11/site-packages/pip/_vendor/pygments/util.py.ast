Module(body=[Expr(value=Constant(value='\n    pygments.util\n    ~~~~~~~~~~~~~\n\n    Utility functions.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n')), Import(names=[alias(name='re')]), ImportFrom(module='io', names=[alias(name='TextIOWrapper')], level=0), Assign(targets=[Name(id='split_path_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='[/\\\\ ]')], keywords=[])), Assign(targets=[Name(id='doctype_lookup_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\n    <!DOCTYPE\\s+(\n     [a-zA-Z_][a-zA-Z0-9]*\n     (?: \\s+      # optional in HTML5\n     [a-zA-Z_][a-zA-Z0-9]*\\s+\n     "[^"]*")?\n     )\n     [^>]*>\n'), BinOp(left=BinOp(left=Attribute(value=Name(id='re', ctx=Load()), attr='DOTALL', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load())), op=BitOr(), right=Attribute(value=Name(id='re', ctx=Load()), attr='VERBOSE', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='tag_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='<(.+?)(\\s.*?)?>.*?</.+?>'), BinOp(left=BinOp(left=Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='re', ctx=Load()), attr='DOTALL', ctx=Load())), op=BitOr(), right=Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='xml_decl_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\\s*<\\?xml[^>]*\\?>'), Attribute(value=Name(id='re', ctx=Load()), attr='I', ctx=Load())], keywords=[])), ClassDef(name='ClassNotFound', bases=[Name(id='ValueError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Raised if one of the lookup functions didn't find a matching class."))], decorator_list=[]), ClassDef(name='OptionError', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    This exception will be raised by all option processing functions if\n    the type or value of the argument is not correct.\n    '))], decorator_list=[]), FunctionDef(name='get_choice_opt', args=arguments(posonlyargs=[], args=[arg(arg='options'), arg(arg='optname'), arg(arg='allowed'), arg(arg='default'), arg(arg='normcase')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='\n    If the key `optname` from the dictionary is not in the sequence\n    `allowed`, raise an error, otherwise return it.\n    ')), Assign(targets=[Name(id='string', ctx=Store())], value=Call(func=Attribute(value=Name(id='options', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='optname', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), If(test=Name(id='normcase', ctx=Load()), body=[Assign(targets=[Name(id='string', ctx=Store())], value=Call(func=Attribute(value=Name(id='string', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='string', ctx=Load()), ops=[NotIn()], comparators=[Name(id='allowed', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='OptionError', ctx=Load()), args=[BinOp(left=Constant(value='Value for option %s must be one of %s'), op=Mod(), right=Tuple(elts=[Name(id='optname', ctx=Load()), Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='allowed', ctx=Load())], keywords=[])], keywords=[])], ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Name(id='string', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_bool_opt', args=arguments(posonlyargs=[], args=[arg(arg='options'), arg(arg='optname'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Intuitively, this is `options.get(optname, default)`, but restricted to\n    Boolean value. The Booleans can be represented as string, in order to accept\n    Boolean value from the command line arguments. If the key `optname` is\n    present in the dictionary `options` and is not associated with a Boolean,\n    raise an `OptionError`. If it is absent, `default` is returned instead.\n\n    The valid string values for ``True`` are ``1``, ``yes``, ``true`` and\n    ``on``, the ones for ``False`` are ``0``, ``no``, ``false`` and ``off``\n    (matched case-insensitively).\n    ')), Assign(targets=[Name(id='string', ctx=Store())], value=Call(func=Attribute(value=Name(id='options', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='optname', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='bool', ctx=Load())], keywords=[]), body=[Return(value=Name(id='string', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='string', ctx=Load())], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='OptionError', ctx=Load()), args=[BinOp(left=Constant(value='Invalid type %r for option %s; use 1/0, yes/no, true/false, on/off'), op=Mod(), right=Tuple(elts=[Name(id='string', ctx=Load()), Name(id='optname', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Attribute(value=Name(id='string', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[Tuple(elts=[Constant(value='1'), Constant(value='yes'), Constant(value='true'), Constant(value='on')], ctx=Load())]), body=[Return(value=Constant(value=True))], orelse=[If(test=Compare(left=Call(func=Attribute(value=Name(id='string', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[Tuple(elts=[Constant(value='0'), Constant(value='no'), Constant(value='false'), Constant(value='off')], ctx=Load())]), body=[Return(value=Constant(value=False))], orelse=[Raise(exc=Call(func=Name(id='OptionError', ctx=Load()), args=[BinOp(left=Constant(value='Invalid value %r for option %s; use 1/0, yes/no, true/false, on/off'), op=Mod(), right=Tuple(elts=[Name(id='string', ctx=Load()), Name(id='optname', ctx=Load())], ctx=Load()))], keywords=[]))])])])])])], decorator_list=[]), FunctionDef(name='get_int_opt', args=arguments(posonlyargs=[], args=[arg(arg='options'), arg(arg='optname'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='As :func:`get_bool_opt`, but interpret the value as an integer.')), Assign(targets=[Name(id='string', ctx=Store())], value=Call(func=Attribute(value=Name(id='options', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='optname', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Try(body=[Return(value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='string', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='OptionError', ctx=Load()), args=[BinOp(left=Constant(value='Invalid type %r for option %s; you must give an integer value'), op=Mod(), right=Tuple(elts=[Name(id='string', ctx=Load()), Name(id='optname', ctx=Load())], ctx=Load()))], keywords=[]))]), ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='OptionError', ctx=Load()), args=[BinOp(left=Constant(value='Invalid value %r for option %s; you must give an integer value'), op=Mod(), right=Tuple(elts=[Name(id='string', ctx=Load()), Name(id='optname', ctx=Load())], ctx=Load()))], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='get_list_opt', args=arguments(posonlyargs=[], args=[arg(arg='options'), arg(arg='optname'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    If the key `optname` from the dictionary `options` is a string,\n    split it at whitespace and return it. If it is already a list\n    or a tuple, it is returned as a list.\n    ')), Assign(targets=[Name(id='val', ctx=Store())], value=Call(func=Attribute(value=Name(id='options', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='optname', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='val', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='val', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='val', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='OptionError', ctx=Load()), args=[BinOp(left=Constant(value='Invalid type %r for option %s; you must give a list value'), op=Mod(), right=Tuple(elts=[Name(id='val', ctx=Load()), Name(id='optname', ctx=Load())], ctx=Load()))], keywords=[]))])])], decorator_list=[]), FunctionDef(name='docstring_headline', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='obj', ctx=Load()), attr='__doc__', ctx=Load())), body=[Return(value=Constant(value=''))], orelse=[]), Assign(targets=[Name(id='res', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='obj', ctx=Load()), attr='__doc__', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='splitlines', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value=' '), op=Add(), right=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], keywords=[]))], orelse=[Break()])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='res', ctx=Load())], keywords=[]), attr='lstrip', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='make_analysator', args=arguments(posonlyargs=[], args=[arg(arg='f')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a static text analyser function that returns float values.')), FunctionDef(name='text_analyse', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Name(id='f', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Return(value=Constant(value=0.0))])], orelse=[], finalbody=[]), If(test=UnaryOp(op=Not(), operand=Name(id='rv', ctx=Load())), body=[Return(value=Constant(value=0.0))], orelse=[]), Try(body=[Return(value=Call(func=Name(id='min', ctx=Load()), args=[Constant(value=1.0), Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0.0), Call(func=Name(id='float', ctx=Load()), args=[Name(id='rv', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ValueError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), body=[Return(value=Constant(value=0.0))])], orelse=[], finalbody=[])], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='text_analyse', ctx=Load()), attr='__doc__', ctx=Store())], value=Attribute(value=Name(id='f', ctx=Load()), attr='__doc__', ctx=Load())), Return(value=Call(func=Name(id='staticmethod', ctx=Load()), args=[Name(id='text_analyse', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='shebang_matches', args=arguments(posonlyargs=[], args=[arg(arg='text'), arg(arg='regex')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Check if the given regular expression matches the last part of the\n    shebang if one exists.\n\n        >>> from pygments.util import shebang_matches\n        >>> shebang_matches('#!/usr/bin/env python', r'python(2\\.\\d)?')\n        True\n        >>> shebang_matches('#!/usr/bin/python2.4', r'python(2\\.\\d)?')\n        True\n        >>> shebang_matches('#!/usr/bin/python-ruby', r'python(2\\.\\d)?')\n        False\n        >>> shebang_matches('#!/usr/bin/python/ruby', r'python(2\\.\\d)?')\n        False\n        >>> shebang_matches('#!/usr/bin/startsomethingwith python',\n        ...                 r'python(2\\.\\d)?')\n        True\n\n    It also checks for common windows executable file extensions::\n\n        >>> shebang_matches('#!C:\\\\Python2.4\\\\Python.exe', r'python(2\\.\\d)?')\n        True\n\n    Parameters (``'-f'`` or ``'--foo'`` are ignored so ``'perl'`` does\n    the same as ``'perl -e'``)\n\n    Note that this method automatically searches the whole string (eg:\n    the regular expression is wrapped in ``'^$'``)\n    ")), Assign(targets=[Name(id='index', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='\n')], keywords=[])), If(test=Compare(left=Name(id='index', ctx=Load()), ops=[GtE()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='first_line', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='text', ctx=Load()), slice=Slice(upper=Name(id='index', ctx=Load())), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='first_line', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]))]), If(test=Call(func=Attribute(value=Name(id='first_line', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='#!')], keywords=[]), body=[Try(body=[Assign(targets=[Name(id='found', ctx=Store())], value=Subscript(value=ListComp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='split_path_re', ctx=Load()), attr='split', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Name(id='first_line', ctx=Load()), slice=Slice(lower=Constant(value=2)), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], keywords=[]), ifs=[BoolOp(op=And(), values=[Name(id='x', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='-')], keywords=[]))])], is_async=0)]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[BinOp(left=Constant(value='^%s(\\.(exe|cmd|bat|bin))?$'), op=Mod(), right=Name(id='regex', ctx=Load())), Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='regex', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='found', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='doctype_matches', args=arguments(posonlyargs=[], args=[arg(arg='text'), arg(arg='regex')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if the doctype matches a regular expression (if present).\n\n    Note that this method only checks the first part of a DOCTYPE.\n    eg: \'html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"\'\n    ')), Assign(targets=[Name(id='m', ctx=Store())], value=Call(func=Attribute(value=Name(id='doctype_lookup_re', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='m', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='doctype', ctx=Store())], value=Call(func=Attribute(value=Name(id='m', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[])), Return(value=Compare(left=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='regex', ctx=Load()), Attribute(value=Name(id='re', ctx=Load()), attr='I', ctx=Load())], keywords=[]), attr='match', ctx=Load()), args=[Call(func=Attribute(value=Name(id='doctype', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)]))], decorator_list=[]), FunctionDef(name='html_doctype_matches', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if the file looks like it has a html doctype.')), Return(value=Call(func=Name(id='doctype_matches', ctx=Load()), args=[Name(id='text', ctx=Load()), Constant(value='html')], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='_looks_like_xml_cache', ctx=Store())], value=Dict(keys=[], values=[])), FunctionDef(name='looks_like_xml', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if a doctype exists or if we have some tags.')), If(test=Call(func=Attribute(value=Name(id='xml_decl_re', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[]), Assign(targets=[Name(id='key', ctx=Store())], value=Call(func=Name(id='hash', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Try(body=[Return(value=Subscript(value=Name(id='_looks_like_xml_cache', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Assign(targets=[Name(id='m', ctx=Store())], value=Call(func=Attribute(value=Name(id='doctype_lookup_re', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='m', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=True))], orelse=[]), Assign(targets=[Name(id='rv', ctx=Store())], value=Compare(left=Call(func=Attribute(value=Name(id='tag_re', ctx=Load()), attr='search', ctx=Load()), args=[Subscript(value=Name(id='text', ctx=Load()), slice=Slice(upper=Constant(value=1000)), ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Subscript(value=Name(id='_looks_like_xml_cache', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='rv', ctx=Load())), Return(value=Name(id='rv', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='surrogatepair', args=arguments(posonlyargs=[], args=[arg(arg='c')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Given a unicode character code with length greater than 16 bits,\n    return the two 16 bit surrogate pair.\n    ')), Return(value=Tuple(elts=[BinOp(left=Constant(value=55232), op=Add(), right=BinOp(left=Name(id='c', ctx=Load()), op=RShift(), right=Constant(value=10))), BinOp(left=Constant(value=56320), op=Add(), right=BinOp(left=Name(id='c', ctx=Load()), op=BitAnd(), right=Constant(value=1023)))], ctx=Load()))], decorator_list=[]), FunctionDef(name='format_lines', args=arguments(posonlyargs=[], args=[arg(arg='var_name'), arg(arg='seq'), arg(arg='raw'), arg(arg='indent_level')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=0)]), body=[Expr(value=Constant(value='Formats a sequence of strings for output.')), Assign(targets=[Name(id='lines', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='base_indent', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='indent_level', ctx=Load())), op=Mult(), right=Constant(value=4))), Assign(targets=[Name(id='inner_indent', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value=' '), op=Mult(), right=BinOp(left=Name(id='indent_level', ctx=Load()), op=Add(), right=Constant(value=1))), op=Mult(), right=Constant(value=4))), Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='base_indent', ctx=Load()), op=Add(), right=Name(id='var_name', ctx=Load())), op=Add(), right=Constant(value=' = ('))], keywords=[])), If(test=Name(id='raw', ctx=Load()), body=[For(target=Name(id='i', ctx=Store()), iter=Name(id='seq', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='inner_indent', ctx=Load()), op=Add(), right=Name(id='i', ctx=Load())), op=Add(), right=Constant(value=','))], keywords=[]))], orelse=[])], orelse=[For(target=Name(id='i', ctx=Store()), iter=Name(id='seq', ctx=Load()), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Name(id='repr', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value='"'))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Name(id='inner_indent', ctx=Load()), op=Add(), right=Subscript(value=Name(id='r', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=2))), ctx=Load())), op=Add(), right=Subscript(value=Name(id='r', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), op=Add(), right=Constant(value=','))], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='base_indent', ctx=Load()), op=Add(), right=Constant(value=')'))], keywords=[])), Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='duplicates_removed', args=arguments(posonlyargs=[], args=[arg(arg='it'), arg(arg='already_seen')], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[], ctx=Load())]), body=[Expr(value=Constant(value='\n    Returns a list with duplicates removed from the iterable `it`.\n\n    Order is preserved.\n    ')), Assign(targets=[Name(id='lst', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='seen', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[In()], comparators=[Name(id='seen', ctx=Load())]), Compare(left=Name(id='i', ctx=Load()), ops=[In()], comparators=[Name(id='already_seen', ctx=Load())])]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='lst', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='lst', ctx=Load()))], decorator_list=[]), ClassDef(name='Future', bases=[], keywords=[], body=[Expr(value=Constant(value='Generic class to defer some work.\n\n    Handled specially in RegexLexerMeta, to support regex string construction at\n    first use.\n    ')), FunctionDef(name='get', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[])], decorator_list=[]), FunctionDef(name='guess_decode', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Decode *text* with guessed encoding.\n\n    First try UTF-8; this should fail for non-UTF-8 encodings.\n    Then try the preferred locale encoding.\n    Fall back to latin-1, which always works.\n    ')), Try(body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[])), Return(value=Tuple(elts=[Name(id='text', ctx=Load()), Constant(value='utf-8')], ctx=Load()))], handlers=[ExceptHandler(type=Name(id='UnicodeDecodeError', ctx=Load()), body=[Try(body=[Import(names=[alias(name='locale')]), Assign(targets=[Name(id='prefencoding', ctx=Store())], value=Call(func=Attribute(value=Name(id='locale', ctx=Load()), attr='getpreferredencoding', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='decode', ctx=Load()), args=[], keywords=[])), Return(value=Tuple(elts=[Name(id='text', ctx=Load()), Name(id='prefencoding', ctx=Load())], ctx=Load()))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='UnicodeDecodeError', ctx=Load()), Name(id='LookupError', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value='latin1')], keywords=[])), Return(value=Tuple(elts=[Name(id='text', ctx=Load()), Constant(value='latin1')], ctx=Load()))])], orelse=[], finalbody=[])])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='guess_decode_from_terminal', args=arguments(posonlyargs=[], args=[arg(arg='text'), arg(arg='term')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Decode *text* coming from terminal *term*.\n\n    First try the terminal encoding, if given.\n    Then try UTF-8.  Then try the preferred locale encoding.\n    Fall back to latin-1, which always works.\n    ')), If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='term', ctx=Load()), Constant(value='encoding'), Constant(value=None)], keywords=[]), body=[Try(body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='decode', ctx=Load()), args=[Attribute(value=Name(id='term', ctx=Load()), attr='encoding', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='UnicodeDecodeError', ctx=Load()), body=[Pass()])], orelse=[Return(value=Tuple(elts=[Name(id='text', ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='encoding', ctx=Load())], ctx=Load()))], finalbody=[])], orelse=[]), Return(value=Call(func=Name(id='guess_decode', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='terminal_encoding', args=arguments(posonlyargs=[], args=[arg(arg='term')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return our best guess of encoding for the given *term*.')), If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='term', ctx=Load()), Constant(value='encoding'), Constant(value=None)], keywords=[]), body=[Return(value=Attribute(value=Name(id='term', ctx=Load()), attr='encoding', ctx=Load()))], orelse=[]), Import(names=[alias(name='locale')]), Return(value=Call(func=Attribute(value=Name(id='locale', ctx=Load()), attr='getpreferredencoding', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), ClassDef(name='UnclosingTextIOWrapper', bases=[Name(id='TextIOWrapper', ctx=Load())], keywords=[], body=[FunctionDef(name='close', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], decorator_list=[])], type_ignores=[])