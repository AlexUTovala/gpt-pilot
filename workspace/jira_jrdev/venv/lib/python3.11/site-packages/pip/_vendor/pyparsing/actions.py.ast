Module(body=[ImportFrom(module='exceptions', names=[alias(name='ParseException')], level=1), ImportFrom(module='util', names=[alias(name='col'), alias(name='replaced_by_pep8')], level=1), ClassDef(name='OnlyOnce', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Wrapper for parse actions, to ensure they are only called once.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='method_call')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='core', names=[alias(name='_trim_arity')], level=1), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callable', ctx=Store())], value=Call(func=Name(id='_trim_arity', ctx=Load()), args=[Name(id='method_call', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='called', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='called', ctx=Load())), body=[Assign(targets=[Name(id='results', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='callable', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), Name(id='t', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='called', ctx=Store())], value=Constant(value=True)), Return(value=Name(id='results', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), Constant(value='OnlyOnce obj called multiple times w/out reset')], keywords=[]))], decorator_list=[]), FunctionDef(name='reset', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Allow the associated parse action to be called once more.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='called', ctx=Store())], value=Constant(value=False))], decorator_list=[])], decorator_list=[]), FunctionDef(name='match_only_at_col', args=arguments(posonlyargs=[], args=[arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper method for defining parse actions that require matching at\n    a specific column in the input text.\n    ')), FunctionDef(name='verify_col', args=arguments(posonlyargs=[], args=[arg(arg='strg'), arg(arg='locn'), arg(arg='toks')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Call(func=Name(id='col', ctx=Load()), args=[Name(id='locn', ctx=Load()), Name(id='strg', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='n', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='strg', ctx=Load()), Name(id='locn', ctx=Load()), JoinedStr(values=[Constant(value='matched token not at column '), FormattedValue(value=Name(id='n', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], decorator_list=[]), Return(value=Name(id='verify_col', ctx=Load()))], decorator_list=[]), FunctionDef(name='replace_with', args=arguments(posonlyargs=[], args=[arg(arg='repl_str')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper method for common parse actions that simply return\n    a literal value.  Especially useful when used with\n    :class:`transform_string<ParserElement.transform_string>` ().\n\n    Example::\n\n        num = Word(nums).set_parse_action(lambda toks: int(toks[0]))\n        na = one_of("N/A NA").set_parse_action(replace_with(math.nan))\n        term = na | num\n\n        term[1, ...].parse_string("324 234 N/A 234") # -> [324, 234, nan, 234]\n    ')), Return(value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=List(elts=[Name(id='repl_str', ctx=Load())], ctx=Load())))], decorator_list=[]), FunctionDef(name='remove_quotes', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper parse action for removing quotation marks from parsed\n    quoted strings.\n\n    Example::\n\n        # by default, quotation marks are included in parsed results\n        quoted_string.parse_string("\'Now is the Winter of our Discontent\'") # -> ["\'Now is the Winter of our Discontent\'"]\n\n        # use remove_quotes to strip quotation marks from parsed results\n        quoted_string.set_parse_action(remove_quotes)\n        quoted_string.parse_string("\'Now is the Winter of our Discontent\'") # -> ["Now is the Winter of our Discontent"]\n    ')), Return(value=Subscript(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Slice(lower=Constant(value=1), upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], decorator_list=[]), FunctionDef(name='with_attribute', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='attr_dict'), defaults=[]), body=[Expr(value=Constant(value='\n    Helper to create a validating parse action to be used with start\n    tags created with :class:`make_xml_tags` or\n    :class:`make_html_tags`. Use ``with_attribute`` to qualify\n    a starting tag with a required attribute value, to avoid false\n    matches on common tags such as ``<TD>`` or ``<DIV>``.\n\n    Call ``with_attribute`` with a series of attribute names and\n    values. Specify the list of filter attributes names and values as:\n\n    - keyword arguments, as in ``(align="right")``, or\n    - as an explicit dict with ``**`` operator, when an attribute\n      name is also a Python reserved word, as in ``**{"class":"Customer", "align":"right"}``\n    - a list of name-value tuples, as in ``(("ns1:class", "Customer"), ("ns2:align", "right"))``\n\n    For attribute names with a namespace prefix, you must use the second\n    form.  Attribute names are matched insensitive to upper/lower case.\n\n    If just testing for ``class`` (with or without a namespace), use\n    :class:`with_class`.\n\n    To verify that the attribute exists, but without specifying a value,\n    pass ``with_attribute.ANY_VALUE`` as the value.\n\n    Example::\n\n        html = \'\'\'\n            <div>\n            Some text\n            <div type="grid">1 4 0 1 0</div>\n            <div type="graph">1,3 2,3 1,1</div>\n            <div>this has no type</div>\n            </div>\n\n        \'\'\'\n        div,div_end = make_html_tags("div")\n\n        # only match div tag having a type attribute with value "grid"\n        div_grid = div().set_parse_action(with_attribute(type="grid"))\n        grid_expr = div_grid + SkipTo(div | div_end)("body")\n        for grid_header in grid_expr.search_string(html):\n            print(grid_header.body)\n\n        # construct a match with any div tag having a type attribute, regardless of the value\n        div_any_type = div().set_parse_action(with_attribute(type=with_attribute.ANY_VALUE))\n        div_expr = div_any_type + SkipTo(div | div_end)("body")\n        for div_header in div_expr.search_string(html):\n            print(div_header.body)\n\n    prints::\n\n        1 4 0 1 0\n\n        1 4 0 1 0\n        1,3 2,3 1,1\n    ')), If(test=Name(id='args', ctx=Load()), body=[Assign(targets=[Name(id='attrs', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Slice(), ctx=Load()))], orelse=[Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Attribute(value=Name(id='attr_dict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='attrs', ctx=Store())], value=ListComp(elt=Tuple(elts=[Name(id='k', ctx=Load()), Name(id='v', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Name(id='attrs', ctx=Load()), ifs=[], is_async=0)])), FunctionDef(name='pa', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='tokens')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Tuple(elts=[Name(id='attrName', ctx=Store()), Name(id='attrValue', ctx=Store())], ctx=Store()), iter=Name(id='attrs', ctx=Load()), body=[If(test=Compare(left=Name(id='attrName', ctx=Load()), ops=[NotIn()], comparators=[Name(id='tokens', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), BinOp(left=Constant(value='no matching attribute '), op=Add(), right=Name(id='attrName', ctx=Load()))], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='attrValue', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='with_attribute', ctx=Load()), attr='ANY_VALUE', ctx=Load())]), Compare(left=Subscript(value=Name(id='tokens', ctx=Load()), slice=Name(id='attrName', ctx=Load()), ctx=Load()), ops=[NotEq()], comparators=[Name(id='attrValue', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), JoinedStr(values=[Constant(value='attribute '), FormattedValue(value=Name(id='attrName', ctx=Load()), conversion=114), Constant(value=' has value '), FormattedValue(value=Subscript(value=Name(id='tokens', ctx=Load()), slice=Name(id='attrName', ctx=Load()), ctx=Load()), conversion=114), Constant(value=', must be '), FormattedValue(value=Name(id='attrValue', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[]), Return(value=Name(id='pa', ctx=Load()))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='with_attribute', ctx=Load()), attr='ANY_VALUE', ctx=Store())], value=Call(func=Name(id='object', ctx=Load()), args=[], keywords=[])), FunctionDef(name='with_class', args=arguments(posonlyargs=[], args=[arg(arg='classname'), arg(arg='namespace')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='')]), body=[Expr(value=Constant(value='\n    Simplified version of :class:`with_attribute` when\n    matching on a div class - made difficult because ``class`` is\n    a reserved word in Python.\n\n    Example::\n\n        html = \'\'\'\n            <div>\n            Some text\n            <div class="grid">1 4 0 1 0</div>\n            <div class="graph">1,3 2,3 1,1</div>\n            <div>this &lt;div&gt; has no class</div>\n            </div>\n\n        \'\'\'\n        div,div_end = make_html_tags("div")\n        div_grid = div().set_parse_action(with_class("grid"))\n\n        grid_expr = div_grid + SkipTo(div | div_end)("body")\n        for grid_header in grid_expr.search_string(html):\n            print(grid_header.body)\n\n        div_any_type = div().set_parse_action(with_class(withAttribute.ANY_VALUE))\n        div_expr = div_any_type + SkipTo(div | div_end)("body")\n        for div_header in div_expr.search_string(html):\n            print(div_header.body)\n\n    prints::\n\n        1 4 0 1 0\n\n        1 4 0 1 0\n        1,3 2,3 1,1\n    ')), Assign(targets=[Name(id='classattr', ctx=Store())], value=IfExp(test=Name(id='namespace', ctx=Load()), body=JoinedStr(values=[FormattedValue(value=Name(id='namespace', ctx=Load()), conversion=-1), Constant(value=':class')]), orelse=Constant(value='class'))), Return(value=Call(func=Name(id='with_attribute', ctx=Load()), args=[], keywords=[keyword(value=Dict(keys=[Name(id='classattr', ctx=Load())], values=[Name(id='classname', ctx=Load())]))]))], decorator_list=[]), FunctionDef(name='replaceWith', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='replace_with', ctx=Load())], keywords=[])]), FunctionDef(name='removeQuotes', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='remove_quotes', ctx=Load())], keywords=[])]), FunctionDef(name='withAttribute', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='with_attribute', ctx=Load())], keywords=[])]), FunctionDef(name='withClass', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='with_class', ctx=Load())], keywords=[])]), FunctionDef(name='matchOnlyAtCol', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='match_only_at_col', ctx=Load())], keywords=[])])], type_ignores=[])