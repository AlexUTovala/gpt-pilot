Module(body=[Import(names=[alias(name='re')]), ImportFrom(module='functools', names=[alias(name='partial'), alias(name='reduce')], level=0), ImportFrom(module='math', names=[alias(name='gcd')], level=0), ImportFrom(module='operator', names=[alias(name='itemgetter')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Any'), alias(name='Callable'), alias(name='Dict'), alias(name='Iterable'), alias(name='List'), alias(name='NamedTuple'), alias(name='Optional'), alias(name='Tuple'), alias(name='Union')], level=0), ImportFrom(module='_loop', names=[alias(name='loop_last')], level=1), ImportFrom(module='_pick', names=[alias(name='pick_bool')], level=1), ImportFrom(module='_wrap', names=[alias(name='divide_line')], level=1), ImportFrom(module='align', names=[alias(name='AlignMethod')], level=1), ImportFrom(module='cells', names=[alias(name='cell_len'), alias(name='set_cell_size')], level=1), ImportFrom(module='containers', names=[alias(name='Lines')], level=1), ImportFrom(module='control', names=[alias(name='strip_control_codes')], level=1), ImportFrom(module='emoji', names=[alias(name='EmojiVariant')], level=1), ImportFrom(module='jupyter', names=[alias(name='JupyterMixin')], level=1), ImportFrom(module='measure', names=[alias(name='Measurement')], level=1), ImportFrom(module='segment', names=[alias(name='Segment')], level=1), ImportFrom(module='style', names=[alias(name='Style'), alias(name='StyleType')], level=1), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='console', names=[alias(name='Console'), alias(name='ConsoleOptions'), alias(name='JustifyMethod'), alias(name='OverflowMethod')], level=1)], orelse=[]), AnnAssign(target=Name(id='DEFAULT_JUSTIFY', ctx=Store()), annotation=Constant(value='JustifyMethod'), value=Constant(value='default'), simple=1), AnnAssign(target=Name(id='DEFAULT_OVERFLOW', ctx=Store()), annotation=Constant(value='OverflowMethod'), value=Constant(value='fold'), simple=1), Assign(targets=[Name(id='_re_whitespace', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\\s+$')], keywords=[])), Assign(targets=[Name(id='TextType', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='Text')], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='GetStyleCallable', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='StyleType', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='Span', bases=[Name(id='NamedTuple', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A marked up region in some text.')), AnnAssign(target=Name(id='start', ctx=Store()), annotation=Name(id='int', ctx=Load()), simple=1), Expr(value=Constant(value='Span start index.')), AnnAssign(target=Name(id='end', ctx=Store()), annotation=Name(id='int', ctx=Load()), simple=1), Expr(value=Constant(value='Span end index.')), AnnAssign(target=Name(id='style', ctx=Store()), annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Style', ctx=Load())], ctx=Load()), ctx=Load()), simple=1), Expr(value=Constant(value='Style associated with the span.')), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='Span('), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='start', ctx=Load()), conversion=-1), Constant(value=', '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='end', ctx=Load()), conversion=-1), Constant(value=', '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load()), conversion=114), Constant(value=')')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='end', ctx=Load()), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='start', ctx=Load())]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='split', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='offset', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Split a span in to 2 from a given offset.')), If(test=Compare(left=Name(id='offset', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='start', ctx=Load())]), body=[Return(value=Tuple(elts=[Name(id='self', ctx=Load()), Constant(value=None)], ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='offset', ctx=Load()), ops=[GtE()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='end', ctx=Load())]), body=[Return(value=Tuple(elts=[Name(id='self', ctx=Load()), Constant(value=None)], ctx=Load()))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store())], value=Name(id='self', ctx=Load())), Assign(targets=[Name(id='span1', ctx=Store())], value=Call(func=Name(id='Span', ctx=Load()), args=[Name(id='start', ctx=Load()), Call(func=Name(id='min', ctx=Load()), args=[Name(id='end', ctx=Load()), Name(id='offset', ctx=Load())], keywords=[]), Name(id='style', ctx=Load())], keywords=[])), Assign(targets=[Name(id='span2', ctx=Store())], value=Call(func=Name(id='Span', ctx=Load()), args=[Attribute(value=Name(id='span1', ctx=Load()), attr='end', ctx=Load()), Name(id='end', ctx=Load()), Name(id='style', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='span1', ctx=Load()), Name(id='span2', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Constant(value='Span'), Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='Span'), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='move', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='offset', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Move start and end by a given offset.\n\n        Args:\n            offset (int): Number of characters to add to start and end.\n\n        Returns:\n            TextSpan: A new TextSpan with adjusted position.\n        ')), Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store())], value=Name(id='self', ctx=Load())), Return(value=Call(func=Name(id='Span', ctx=Load()), args=[BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Name(id='offset', ctx=Load())), BinOp(left=Name(id='end', ctx=Load()), op=Add(), right=Name(id='offset', ctx=Load())), Name(id='style', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='Span')), FunctionDef(name='right_crop', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='offset', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Crop the span at the given offset.\n\n        Args:\n            offset (int): A value between start and end.\n\n        Returns:\n            Span: A new (possibly smaller) span.\n        ')), Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store())], value=Name(id='self', ctx=Load())), If(test=Compare(left=Name(id='offset', ctx=Load()), ops=[GtE()], comparators=[Name(id='end', ctx=Load())]), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='Span', ctx=Load()), args=[Name(id='start', ctx=Load()), Call(func=Name(id='min', ctx=Load()), args=[Name(id='offset', ctx=Load()), Name(id='end', ctx=Load())], keywords=[]), Name(id='style', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='Span'))], decorator_list=[]), ClassDef(name='Text', bases=[Name(id='JupyterMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Text with color / style.\n\n    Args:\n        text (str, optional): Default unstyled text. Defaults to "".\n        style (Union[str, Style], optional): Base style for text. Defaults to "".\n        justify (str, optional): Justify method: "left", "center", "full", "right". Defaults to None.\n        overflow (str, optional): Overflow method: "crop", "fold", "ellipsis". Defaults to None.\n        no_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None.\n        end (str, optional): Character to end text with. Defaults to "\\\\n".\n        tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to 8.\n        spans (List[Span], optional). A list of predefined style spans. Defaults to None.\n    ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=List(elts=[Constant(value='_text'), Constant(value='style'), Constant(value='justify'), Constant(value='overflow'), Constant(value='no_wrap'), Constant(value='end'), Constant(value='tab_size'), Constant(value='_spans'), Constant(value='_length')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text', annotation=Name(id='str', ctx=Load())), arg(arg='style', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Style', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='justify', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='JustifyMethod'), ctx=Load())), arg(arg='overflow', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='OverflowMethod'), ctx=Load())), arg(arg='no_wrap', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='end', annotation=Name(id='str', ctx=Load())), arg(arg='tab_size', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='spans', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Span', ctx=Load()), ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='\n'), Constant(value=8), Constant(value=None)], defaults=[Constant(value=''), Constant(value='')]), body=[Assign(targets=[Name(id='sanitized_text', ctx=Store())], value=Call(func=Name(id='strip_control_codes', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Store())], value=List(elts=[Name(id='sanitized_text', ctx=Load())], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Store())], value=Name(id='style', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='justify', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='JustifyMethod'), ctx=Load()), value=Name(id='justify', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='overflow', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='OverflowMethod'), ctx=Load()), value=Name(id='overflow', ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='no_wrap', ctx=Store())], value=Name(id='no_wrap', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='end', ctx=Store())], value=Name(id='end', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='tab_size', ctx=Store())], value=Name(id='tab_size', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Span', ctx=Load()), ctx=Load()), value=BoolOp(op=Or(), values=[Name(id='spans', ctx=Load()), List(elts=[], ctx=Load())]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sanitized_text', ctx=Load())], keywords=[]), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__len__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Load()))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='bool', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<text '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), conversion=114), Constant(value=' '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), conversion=114), Constant(value='>')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__add__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Text', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), Return(value=Name(id='result', ctx=Load()))], orelse=[]), Return(value=Name(id='NotImplemented', ctx=Load()))], decorator_list=[], returns=Constant(value='Text')), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Text', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='plain', ctx=Load())]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='_spans', ctx=Load())])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Return(value=Compare(left=Name(id='other', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Text', ctx=Load())], keywords=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='other', ctx=Load()), attr='plain', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())]))], orelse=[])]), Return(value=Constant(value=False))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='slice', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='slice', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='get_text_at', args=arguments(posonlyargs=[], args=[arg(arg='offset', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Name(id='Text', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), slice=Name(id='offset', ctx=Load()), ctx=Load())], keywords=[keyword(arg='spans', value=ListComp(elt=Call(func=Name(id='_Span', ctx=Load()), args=[Constant(value=0), Constant(value=1), Name(id='style', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), ifs=[Compare(left=Name(id='end', ctx=Load()), ops=[Gt(), GtE()], comparators=[Name(id='offset', ctx=Load()), Name(id='start', ctx=Load())])], is_async=0)])), keyword(arg='end', value=Constant(value=''))])), Return(value=Name(id='text', ctx=Load()))], decorator_list=[], returns=Constant(value='Text')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='slice', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='get_text_at', ctx=Load()), args=[Name(id='slice', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='stop', ctx=Store()), Name(id='step', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='slice', ctx=Load()), attr='indices', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='divide', ctx=Load()), args=[List(elts=[Name(id='start', ctx=Load()), Name(id='stop', ctx=Load())], ctx=Load())], keywords=[])), Return(value=Subscript(value=Name(id='lines', ctx=Load()), slice=Constant(value=1), ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='slices with step!=1 are not supported')], keywords=[]))])])], decorator_list=[], returns=Constant(value='Text')), FunctionDef(name='cell_len', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the number of cells required to render this text.')), Return(value=Call(func=Name(id='cell_len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='markup', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get console markup to render this Text.\n\n        Returns:\n            str: A string potentially creating markup tags.\n        ')), ImportFrom(module='markup', names=[alias(name='escape')], level=1), AnnAssign(target=Name(id='output', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='plain', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())), Assign(targets=[Name(id='markup_spans', ctx=Store())], value=List(elts=[Tuple(elts=[Constant(value=0), Constant(value=False), Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load())], ctx=Load()), Starred(value=GeneratorExp(elt=Tuple(elts=[Attribute(value=Name(id='span', ctx=Load()), attr='start', ctx=Load()), Constant(value=False), Attribute(value=Name(id='span', ctx=Load()), attr='style', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='span', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), ifs=[], is_async=0)]), ctx=Load()), Starred(value=GeneratorExp(elt=Tuple(elts=[Attribute(value=Name(id='span', ctx=Load()), attr='end', ctx=Load()), Constant(value=True), Attribute(value=Name(id='span', ctx=Load()), attr='style', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='span', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), ifs=[], is_async=0)]), ctx=Load()), Tuple(elts=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='plain', ctx=Load())], keywords=[]), Constant(value=True), Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load())], ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='markup_spans', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Call(func=Name(id='itemgetter', ctx=Load()), args=[Constant(value=0), Constant(value=1)], keywords=[]))])), Assign(targets=[Name(id='position', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='append', ctx=Store())], value=Attribute(value=Name(id='output', ctx=Load()), attr='append', ctx=Load())), For(target=Tuple(elts=[Name(id='offset', ctx=Store()), Name(id='closing', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store()), iter=Name(id='markup_spans', ctx=Load()), body=[If(test=Compare(left=Name(id='offset', ctx=Load()), ops=[Gt()], comparators=[Name(id='position', ctx=Load())]), body=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Call(func=Name(id='escape', ctx=Load()), args=[Subscript(value=Name(id='plain', ctx=Load()), slice=Slice(lower=Name(id='position', ctx=Load()), upper=Name(id='offset', ctx=Load())), ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='position', ctx=Store())], value=Name(id='offset', ctx=Load()))], orelse=[]), If(test=Name(id='style', ctx=Load()), body=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[IfExp(test=Name(id='closing', ctx=Load()), body=JoinedStr(values=[Constant(value='[/'), FormattedValue(value=Name(id='style', ctx=Load()), conversion=-1), Constant(value=']')]), orelse=JoinedStr(values=[Constant(value='['), FormattedValue(value=Name(id='style', ctx=Load()), conversion=-1), Constant(value=']')]))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='markup', ctx=Store())], value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='output', ctx=Load())], keywords=[])), Return(value=Name(id='markup', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='from_markup', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='text', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='style', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Style', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='emoji', annotation=Name(id='bool', ctx=Load())), arg(arg='emoji_variant', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='EmojiVariant', ctx=Load()), ctx=Load())), arg(arg='justify', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='JustifyMethod'), ctx=Load())), arg(arg='overflow', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='OverflowMethod'), ctx=Load())), arg(arg='end', annotation=Name(id='str', ctx=Load()))], kw_defaults=[Constant(value=''), Constant(value=True), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='\n')], defaults=[]), body=[Expr(value=Constant(value='Create Text instance from markup.\n\n        Args:\n            text (str): A string containing console markup.\n            emoji (bool, optional): Also render emoji code. Defaults to True.\n            justify (str, optional): Justify method: "left", "center", "full", "right". Defaults to None.\n            overflow (str, optional): Overflow method: "crop", "fold", "ellipsis". Defaults to None.\n            end (str, optional): Character to end text with. Defaults to "\\\\n".\n\n        Returns:\n            Text: A Text instance with markup rendered.\n        ')), ImportFrom(module='markup', names=[alias(name='render')], level=1), Assign(targets=[Name(id='rendered_text', ctx=Store())], value=Call(func=Name(id='render', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='style', ctx=Load())], keywords=[keyword(arg='emoji', value=Name(id='emoji', ctx=Load())), keyword(arg='emoji_variant', value=Name(id='emoji_variant', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='rendered_text', ctx=Load()), attr='justify', ctx=Store())], value=Name(id='justify', ctx=Load())), Assign(targets=[Attribute(value=Name(id='rendered_text', ctx=Load()), attr='overflow', ctx=Store())], value=Name(id='overflow', ctx=Load())), Assign(targets=[Attribute(value=Name(id='rendered_text', ctx=Load()), attr='end', ctx=Store())], value=Name(id='end', ctx=Load())), Return(value=Name(id='rendered_text', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='Text')), FunctionDef(name='from_ansi', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='text', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='style', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Style', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='justify', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='JustifyMethod'), ctx=Load())), arg(arg='overflow', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='OverflowMethod'), ctx=Load())), arg(arg='no_wrap', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='end', annotation=Name(id='str', ctx=Load())), arg(arg='tab_size', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=''), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='\n'), Constant(value=8)], defaults=[]), body=[Expr(value=Constant(value='Create a Text object from a string containing ANSI escape codes.\n\n        Args:\n            text (str): A string containing escape codes.\n            style (Union[str, Style], optional): Base style for text. Defaults to "".\n            justify (str, optional): Justify method: "left", "center", "full", "right". Defaults to None.\n            overflow (str, optional): Overflow method: "crop", "fold", "ellipsis". Defaults to None.\n            no_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None.\n            end (str, optional): Character to end text with. Defaults to "\\\\n".\n            tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to 8.\n        ')), ImportFrom(module='ansi', names=[alias(name='AnsiDecoder')], level=1), Assign(targets=[Name(id='joiner', ctx=Store())], value=Call(func=Name(id='Text', ctx=Load()), args=[Constant(value='\n')], keywords=[keyword(arg='justify', value=Name(id='justify', ctx=Load())), keyword(arg='overflow', value=Name(id='overflow', ctx=Load())), keyword(arg='no_wrap', value=Name(id='no_wrap', ctx=Load())), keyword(arg='end', value=Name(id='end', ctx=Load())), keyword(arg='tab_size', value=Name(id='tab_size', ctx=Load())), keyword(arg='style', value=Name(id='style', ctx=Load()))])), Assign(targets=[Name(id='decoder', ctx=Store())], value=Call(func=Name(id='AnsiDecoder', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='joiner', ctx=Load()), attr='join', ctx=Load()), args=[GeneratorExp(elt=Name(id='line', ctx=Load()), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='decoder', ctx=Load()), attr='decode', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='Text')), FunctionDef(name='styled', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='text', annotation=Name(id='str', ctx=Load())), arg(arg='style', annotation=Name(id='StyleType', ctx=Load()))], kwonlyargs=[arg(arg='justify', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='JustifyMethod'), ctx=Load())), arg(arg='overflow', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='OverflowMethod'), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None)], defaults=[Constant(value='')]), body=[Expr(value=Constant(value='Construct a Text instance with a pre-applied styled. A style applied in this way won\'t be used\n        to pad the text when it is justified.\n\n        Args:\n            text (str): A string containing console markup.\n            style (Union[str, Style]): Style to apply to the text. Defaults to "".\n            justify (str, optional): Justify method: "left", "center", "full", "right". Defaults to None.\n            overflow (str, optional): Overflow method: "crop", "fold", "ellipsis". Defaults to None.\n\n        Returns:\n            Text: A text instance with a style applied to the entire string.\n        ')), Assign(targets=[Name(id='styled_text', ctx=Store())], value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[keyword(arg='justify', value=Name(id='justify', ctx=Load())), keyword(arg='overflow', value=Name(id='overflow', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='styled_text', ctx=Load()), attr='stylize', ctx=Load()), args=[Name(id='style', ctx=Load())], keywords=[])), Return(value=Name(id='styled_text', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='Text')), FunctionDef(name='assemble', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='parts', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='Text'), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='StyleType', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), kwonlyargs=[arg(arg='style', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Style', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='justify', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='JustifyMethod'), ctx=Load())), arg(arg='overflow', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='OverflowMethod'), ctx=Load())), arg(arg='no_wrap', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='end', annotation=Name(id='str', ctx=Load())), arg(arg='tab_size', annotation=Name(id='int', ctx=Load())), arg(arg='meta', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=''), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='\n'), Constant(value=8), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value='Construct a text instance by combining a sequence of strings with optional styles.\n        The positional arguments should be either strings, or a tuple of string + style.\n\n        Args:\n            style (Union[str, Style], optional): Base style for text. Defaults to "".\n            justify (str, optional): Justify method: "left", "center", "full", "right". Defaults to None.\n            overflow (str, optional): Overflow method: "crop", "fold", "ellipsis". Defaults to None.\n            end (str, optional): Character to end text with. Defaults to "\\\\n".\n            tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to 8.\n            meta (Dict[str, Any], optional). Meta data to apply to text, or None for no meta data. Default to None\n\n        Returns:\n            Text: A new text instance.\n        ')), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Name(id='cls', ctx=Load()), args=[], keywords=[keyword(arg='style', value=Name(id='style', ctx=Load())), keyword(arg='justify', value=Name(id='justify', ctx=Load())), keyword(arg='overflow', value=Name(id='overflow', ctx=Load())), keyword(arg='no_wrap', value=Name(id='no_wrap', ctx=Load())), keyword(arg='end', value=Name(id='end', ctx=Load())), keyword(arg='tab_size', value=Name(id='tab_size', ctx=Load()))])), Assign(targets=[Name(id='append', ctx=Store())], value=Attribute(value=Name(id='text', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='_Text', ctx=Store())], value=Name(id='Text', ctx=Load())), For(target=Name(id='part', ctx=Store()), iter=Name(id='parts', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='part', ctx=Load()), Tuple(elts=[Name(id='_Text', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Name(id='part', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Starred(value=Name(id='part', ctx=Load()), ctx=Load())], keywords=[]))])], orelse=[]), If(test=Name(id='meta', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='apply_meta', ctx=Load()), args=[Name(id='meta', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='text', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='Text')), FunctionDef(name='plain', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the text as a single string.')), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Load()), slice=Slice(), ctx=Store())], value=List(elts=[Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Load())], keywords=[])], ctx=Load()))], orelse=[]), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Load()), slice=Constant(value=0), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='plain', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='new_text', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Set the text to a new value.')), If(test=Compare(left=Name(id='new_text', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())]), body=[Assign(targets=[Name(id='sanitized_text', ctx=Store())], value=Call(func=Name(id='strip_control_codes', ctx=Load()), args=[Name(id='new_text', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Load()), slice=Slice(), ctx=Store())], value=List(elts=[Name(id='sanitized_text', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='old_length', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sanitized_text', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='old_length', ctx=Load()), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_trim_spans', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[Attribute(value=Name(id='plain', ctx=Load()), attr='setter', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='spans', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get a reference to the internal list of spans.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Span', ctx=Load()), ctx=Load())), FunctionDef(name='spans', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='spans', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Span', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Set spans.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Store())], value=Subscript(value=Name(id='spans', ctx=Load()), slice=Slice(), ctx=Load()))], decorator_list=[Attribute(value=Name(id='spans', ctx=Load()), attr='setter', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='blank_copy', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plain', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='')]), body=[Expr(value=Constant(value='Return a new Text instance with copied meta data (but not the string or spans).')), Assign(targets=[Name(id='copy_self', ctx=Store())], value=Call(func=Name(id='Text', ctx=Load()), args=[Name(id='plain', ctx=Load())], keywords=[keyword(arg='style', value=Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load())), keyword(arg='justify', value=Attribute(value=Name(id='self', ctx=Load()), attr='justify', ctx=Load())), keyword(arg='overflow', value=Attribute(value=Name(id='self', ctx=Load()), attr='overflow', ctx=Load())), keyword(arg='no_wrap', value=Attribute(value=Name(id='self', ctx=Load()), attr='no_wrap', ctx=Load())), keyword(arg='end', value=Attribute(value=Name(id='self', ctx=Load()), attr='end', ctx=Load())), keyword(arg='tab_size', value=Attribute(value=Name(id='self', ctx=Load()), attr='tab_size', ctx=Load()))])), Return(value=Name(id='copy_self', ctx=Load()))], decorator_list=[], returns=Constant(value='Text')), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a copy of this instance.')), Assign(targets=[Name(id='copy_self', ctx=Store())], value=Call(func=Name(id='Text', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[keyword(arg='style', value=Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load())), keyword(arg='justify', value=Attribute(value=Name(id='self', ctx=Load()), attr='justify', ctx=Load())), keyword(arg='overflow', value=Attribute(value=Name(id='self', ctx=Load()), attr='overflow', ctx=Load())), keyword(arg='no_wrap', value=Attribute(value=Name(id='self', ctx=Load()), attr='no_wrap', ctx=Load())), keyword(arg='end', value=Attribute(value=Name(id='self', ctx=Load()), attr='end', ctx=Load())), keyword(arg='tab_size', value=Attribute(value=Name(id='self', ctx=Load()), attr='tab_size', ctx=Load()))])), Assign(targets=[Subscript(value=Attribute(value=Name(id='copy_self', ctx=Load()), attr='_spans', ctx=Load()), slice=Slice(), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load())), Return(value=Name(id='copy_self', ctx=Load()))], decorator_list=[], returns=Constant(value='Text')), FunctionDef(name='stylize', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='style', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Style', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='start', annotation=Name(id='int', ctx=Load())), arg(arg='end', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value='Apply a style to the text, or a portion of the text.\n\n        Args:\n            style (Union[str, Style]): Style instance or style definition to apply.\n            start (int): Start offset (negative indexing is supported). Defaults to 0.\n            end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.\n        ')), If(test=Name(id='style', ctx=Load()), body=[Assign(targets=[Name(id='length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='start', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=BinOp(left=Name(id='length', ctx=Load()), op=Add(), right=Name(id='start', ctx=Load())))], orelse=[]), If(test=Compare(left=Name(id='end', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='end', ctx=Store())], value=Name(id='length', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='end', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='end', ctx=Store())], value=BinOp(left=Name(id='length', ctx=Load()), op=Add(), right=Name(id='end', ctx=Load())))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='start', ctx=Load()), ops=[GtE()], comparators=[Name(id='length', ctx=Load())]), Compare(left=Name(id='end', ctx=Load()), ops=[LtE()], comparators=[Name(id='start', ctx=Load())])]), body=[Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='Span', ctx=Load()), args=[Name(id='start', ctx=Load()), Call(func=Name(id='min', ctx=Load()), args=[Name(id='length', ctx=Load()), Name(id='end', ctx=Load())], keywords=[]), Name(id='style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='stylize_before', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='style', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Style', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='start', annotation=Name(id='int', ctx=Load())), arg(arg='end', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value='Apply a style to the text, or a portion of the text. Styles will be applied before other styles already present.\n\n        Args:\n            style (Union[str, Style]): Style instance or style definition to apply.\n            start (int): Start offset (negative indexing is supported). Defaults to 0.\n            end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.\n        ')), If(test=Name(id='style', ctx=Load()), body=[Assign(targets=[Name(id='length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='start', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=BinOp(left=Name(id='length', ctx=Load()), op=Add(), right=Name(id='start', ctx=Load())))], orelse=[]), If(test=Compare(left=Name(id='end', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='end', ctx=Store())], value=Name(id='length', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='end', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='end', ctx=Store())], value=BinOp(left=Name(id='length', ctx=Load()), op=Add(), right=Name(id='end', ctx=Load())))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='start', ctx=Load()), ops=[GtE()], comparators=[Name(id='length', ctx=Load())]), Compare(left=Name(id='end', ctx=Load()), ops=[LtE()], comparators=[Name(id='start', ctx=Load())])]), body=[Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Call(func=Name(id='Span', ctx=Load()), args=[Name(id='start', ctx=Load()), Call(func=Name(id='min', ctx=Load()), args=[Name(id='length', ctx=Load()), Name(id='end', ctx=Load())], keywords=[]), Name(id='style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='apply_meta', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='meta', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='start', annotation=Name(id='int', ctx=Load())), arg(arg='end', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value='Apply meta data to the text, or a portion of the text.\n\n        Args:\n            meta (Dict[str, Any]): A dict of meta information.\n            start (int): Start offset (negative indexing is supported). Defaults to 0.\n            end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.\n\n        ')), Assign(targets=[Name(id='style', ctx=Store())], value=Call(func=Attribute(value=Name(id='Style', ctx=Load()), attr='from_meta', ctx=Load()), args=[Name(id='meta', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='stylize', ctx=Load()), args=[Name(id='style', ctx=Load())], keywords=[keyword(arg='start', value=Name(id='start', ctx=Load())), keyword(arg='end', value=Name(id='end', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='on', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='meta', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='handlers', annotation=Name(id='Any', ctx=Load())), defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Apply event handlers (used by Textual project).\n\n        Example:\n            >>> from rich.text import Text\n            >>> text = Text("hello world")\n            >>> text.on(click="view.toggle(\'world\')")\n\n        Args:\n            meta (Dict[str, Any]): Mapping of meta information.\n            **handlers: Keyword args are prefixed with "@" to defined handlers.\n\n        Returns:\n            Text: Self is returned to method may be chained.\n        ')), Assign(targets=[Name(id='meta', ctx=Store())], value=IfExp(test=Compare(left=Name(id='meta', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Dict(keys=[], values=[]), orelse=Name(id='meta', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='meta', ctx=Load()), attr='update', ctx=Load()), args=[DictComp(key=JoinedStr(values=[Constant(value='@'), FormattedValue(value=Name(id='key', ctx=Load()), conversion=-1)]), value=Name(id='value', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='handlers', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='stylize', ctx=Load()), args=[Call(func=Attribute(value=Name(id='Style', ctx=Load()), attr='from_meta', ctx=Load()), args=[Name(id='meta', ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='Text')), FunctionDef(name='remove_suffix', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='suffix', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove a suffix if it exists.\n\n        Args:\n            suffix (str): Suffix to remove.\n        ')), If(test=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='suffix', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='right_crop', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='suffix', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_style_at_offset', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='console', annotation=Constant(value='Console')), arg(arg='offset', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the style of a character at give offset.\n\n        Args:\n            console (~Console): Console where text will be rendered.\n            offset (int): Offset in to text (negative indexing supported)\n\n        Returns:\n            Style: A Style instance.\n        ')), If(test=Compare(left=Name(id='offset', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='offset', ctx=Store())], value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), op=Add(), right=Name(id='offset', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='get_style', ctx=Store())], value=Attribute(value=Name(id='console', ctx=Load()), attr='get_style', ctx=Load())), Assign(targets=[Name(id='style', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='get_style', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load())], keywords=[]), attr='copy', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store()), Name(id='span_style', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), body=[If(test=Compare(left=Name(id='end', ctx=Load()), ops=[Gt(), GtE()], comparators=[Name(id='offset', ctx=Load()), Name(id='start', ctx=Load())]), body=[AugAssign(target=Name(id='style', ctx=Store()), op=Add(), value=Call(func=Name(id='get_style', ctx=Load()), args=[Name(id='span_style', ctx=Load())], keywords=[keyword(arg='default', value=Constant(value=''))]))], orelse=[])], orelse=[]), Return(value=Name(id='style', ctx=Load()))], decorator_list=[], returns=Name(id='Style', ctx=Load())), FunctionDef(name='highlight_regex', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='re_highlight', annotation=Name(id='str', ctx=Load())), arg(arg='style', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='GetStyleCallable', ctx=Load()), Name(id='StyleType', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='style_prefix', annotation=Name(id='str', ctx=Load()))], kw_defaults=[Constant(value='')], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Highlight text with a regular expression, where group names are\n        translated to styles.\n\n        Args:\n            re_highlight (str): A regular expression.\n            style (Union[GetStyleCallable, StyleType]): Optional style to apply to whole match, or a callable\n                which accepts the matched text and returns a style. Defaults to None.\n            style_prefix (str, optional): Optional prefix to add to style group names.\n\n        Returns:\n            int: Number of regex matches\n        ')), Assign(targets=[Name(id='count', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='append_span', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), Assign(targets=[Name(id='plain', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())), For(target=Name(id='match', ctx=Store()), iter=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='finditer', ctx=Load()), args=[Name(id='re_highlight', ctx=Load()), Name(id='plain', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='get_span', ctx=Store())], value=Attribute(value=Name(id='match', ctx=Load()), attr='span', ctx=Load())), If(test=Name(id='style', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_span', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='match_style', ctx=Store())], value=IfExp(test=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='style', ctx=Load())], keywords=[]), body=Call(func=Name(id='style', ctx=Load()), args=[Subscript(value=Name(id='plain', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='end', ctx=Load())), ctx=Load())], keywords=[]), orelse=Name(id='style', ctx=Load()))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='match_style', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='end', ctx=Load()), ops=[Gt()], comparators=[Name(id='start', ctx=Load())])]), body=[Expr(value=Call(func=Name(id='append_span', ctx=Load()), args=[Call(func=Name(id='_Span', ctx=Load()), args=[Name(id='start', ctx=Load()), Name(id='end', ctx=Load()), Name(id='match_style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), AugAssign(target=Name(id='count', ctx=Store()), op=Add(), value=Constant(value=1)), For(target=Name(id='name', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groupdict', ctx=Load()), args=[], keywords=[]), attr='keys', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_span', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='start', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), Compare(left=Name(id='end', ctx=Load()), ops=[Gt()], comparators=[Name(id='start', ctx=Load())])]), body=[Expr(value=Call(func=Name(id='append_span', ctx=Load()), args=[Call(func=Name(id='_Span', ctx=Load()), args=[Name(id='start', ctx=Load()), Name(id='end', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='style_prefix', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1)])], keywords=[])], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='count', ctx=Load()))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='highlight_words', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='words', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='style', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Style', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='case_sensitive', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=True)], defaults=[]), body=[Expr(value=Constant(value='Highlight words with a style.\n\n        Args:\n            words (Iterable[str]): Worlds to highlight.\n            style (Union[str, Style]): Style to apply.\n            case_sensitive (bool, optional): Enable case sensitive matchings. Defaults to True.\n\n        Returns:\n            int: Number of words highlighted.\n        ')), Assign(targets=[Name(id='re_words', ctx=Store())], value=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='word', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='word', ctx=Store()), iter=Name(id='words', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='add_span', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='count', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), For(target=Name(id='match', ctx=Store()), iter=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='finditer', ctx=Load()), args=[Name(id='re_words', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[keyword(arg='flags', value=IfExp(test=Name(id='case_sensitive', ctx=Load()), body=Constant(value=0), orelse=Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load())))]), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='span', ctx=Load()), args=[Constant(value=0)], keywords=[])), Expr(value=Call(func=Name(id='add_span', ctx=Load()), args=[Call(func=Name(id='_Span', ctx=Load()), args=[Name(id='start', ctx=Load()), Name(id='end', ctx=Load()), Name(id='style', ctx=Load())], keywords=[])], keywords=[])), AugAssign(target=Name(id='count', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Return(value=Name(id='count', ctx=Load()))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='rstrip', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Strip whitespace from end of text.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), attr='rstrip', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='rstrip_end', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='size', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove whitespace beyond a certain width at the end of the text.\n\n        Args:\n            size (int): The desired size of the text.\n        ')), Assign(targets=[Name(id='text_length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='text_length', ctx=Load()), ops=[Gt()], comparators=[Name(id='size', ctx=Load())]), body=[Assign(targets=[Name(id='excess', ctx=Store())], value=BinOp(left=Name(id='text_length', ctx=Load()), op=Sub(), right=Name(id='size', ctx=Load()))), Assign(targets=[Name(id='whitespace_match', ctx=Store())], value=Call(func=Attribute(value=Name(id='_re_whitespace', ctx=Load()), attr='search', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='whitespace_match', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='whitespace_count', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='whitespace_match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=0)], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='right_crop', ctx=Load()), args=[Call(func=Name(id='min', ctx=Load()), args=[Name(id='whitespace_count', ctx=Load()), Name(id='excess', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='set_length', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='new_length', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Set new length of the text, clipping or padding is required.')), Assign(targets=[Name(id='length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='length', ctx=Load()), ops=[NotEq()], comparators=[Name(id='new_length', ctx=Load())]), body=[If(test=Compare(left=Name(id='length', ctx=Load()), ops=[Lt()], comparators=[Name(id='new_length', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='pad_right', ctx=Load()), args=[BinOp(left=Name(id='new_length', ctx=Load()), op=Sub(), right=Name(id='length', ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='right_crop', ctx=Load()), args=[BinOp(left=Name(id='length', ctx=Load()), op=Sub(), right=Name(id='new_length', ctx=Load()))], keywords=[]))])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__rich_console__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='console', annotation=Constant(value='Console')), arg(arg='options', annotation=Constant(value='ConsoleOptions'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='tab_size', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=BoolOp(op=Or(), values=[Attribute(value=Name(id='console', ctx=Load()), attr='tab_size', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='tab_size', ctx=Load()), Constant(value=8)]), simple=1), Assign(targets=[Name(id='justify', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='justify', ctx=Load()), Attribute(value=Name(id='options', ctx=Load()), attr='justify', ctx=Load()), Name(id='DEFAULT_JUSTIFY', ctx=Load())])), Assign(targets=[Name(id='overflow', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='overflow', ctx=Load()), Attribute(value=Name(id='options', ctx=Load()), attr='overflow', ctx=Load()), Name(id='DEFAULT_OVERFLOW', ctx=Load())])), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='wrap', ctx=Load()), args=[Name(id='console', ctx=Load()), Attribute(value=Name(id='options', ctx=Load()), attr='max_width', ctx=Load())], keywords=[keyword(arg='justify', value=Name(id='justify', ctx=Load())), keyword(arg='overflow', value=Name(id='overflow', ctx=Load())), keyword(arg='tab_size', value=BoolOp(op=Or(), values=[Name(id='tab_size', ctx=Load()), Constant(value=8)])), keyword(arg='no_wrap', value=Call(func=Name(id='pick_bool', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='no_wrap', ctx=Load()), Attribute(value=Name(id='options', ctx=Load()), attr='no_wrap', ctx=Load()), Constant(value=False)], keywords=[]))])), Assign(targets=[Name(id='all_lines', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Text', ctx=Load()), args=[Constant(value='\n')], keywords=[]), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])), Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='all_lines', ctx=Load()), attr='render', ctx=Load()), args=[Name(id='console', ctx=Load())], keywords=[keyword(arg='end', value=Attribute(value=Name(id='self', ctx=Load()), attr='end', ctx=Load()))])))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Segment', ctx=Load()), ctx=Load())), FunctionDef(name='__rich_measure__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='console', annotation=Constant(value='Console')), arg(arg='options', annotation=Constant(value='ConsoleOptions'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='max_text_width', ctx=Store())], value=IfExp(test=Name(id='lines', ctx=Load()), body=Call(func=Name(id='max', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='cell_len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), orelse=Constant(value=0))), Assign(targets=[Name(id='words', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='min_text_width', ctx=Store())], value=IfExp(test=Name(id='words', ctx=Load()), body=Call(func=Name(id='max', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='cell_len', ctx=Load()), args=[Name(id='word', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='word', ctx=Store()), iter=Name(id='words', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), orelse=Name(id='max_text_width', ctx=Load()))), Return(value=Call(func=Name(id='Measurement', ctx=Load()), args=[Name(id='min_text_width', ctx=Load()), Name(id='max_text_width', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Measurement', ctx=Load())), FunctionDef(name='render', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='console', annotation=Constant(value='Console')), arg(arg='end', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='')]), body=[Expr(value=Constant(value='Render the text as Segments.\n\n        Args:\n            console (Console): Console instance.\n            end (Optional[str], optional): Optional end character.\n\n        Returns:\n            Iterable[Segment]: Result of render that may be written to the console.\n        ')), Assign(targets=[Name(id='_Segment', ctx=Store())], value=Name(id='Segment', ctx=Load())), Assign(targets=[Name(id='text', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load())), body=[Expr(value=Yield(value=Call(func=Name(id='Segment', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]))), If(test=Name(id='end', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Name(id='_Segment', ctx=Load()), args=[Name(id='end', ctx=Load())], keywords=[])))], orelse=[]), Return()], orelse=[]), Assign(targets=[Name(id='get_style', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Attribute(value=Name(id='console', ctx=Load()), attr='get_style', ctx=Load())], keywords=[keyword(arg='default', value=Call(func=Attribute(value=Name(id='Style', ctx=Load()), attr='null', ctx=Load()), args=[], keywords=[]))])), Assign(targets=[Name(id='enumerated_spans', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), Constant(value=1)], keywords=[])], keywords=[])), Assign(targets=[Name(id='style_map', ctx=Store())], value=DictComp(key=Name(id='index', ctx=Load()), value=Call(func=Name(id='get_style', ctx=Load()), args=[Attribute(value=Name(id='span', ctx=Load()), attr='style', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='span', ctx=Store())], ctx=Store()), iter=Name(id='enumerated_spans', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Subscript(value=Name(id='style_map', ctx=Load()), slice=Constant(value=0), ctx=Store())], value=Call(func=Name(id='get_style', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load())], keywords=[])), Assign(targets=[Name(id='spans', ctx=Store())], value=List(elts=[Tuple(elts=[Constant(value=0), Constant(value=False), Constant(value=0)], ctx=Load()), Starred(value=GeneratorExp(elt=Tuple(elts=[Attribute(value=Name(id='span', ctx=Load()), attr='start', ctx=Load()), Constant(value=False), Name(id='index', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='span', ctx=Store())], ctx=Store()), iter=Name(id='enumerated_spans', ctx=Load()), ifs=[], is_async=0)]), ctx=Load()), Starred(value=GeneratorExp(elt=Tuple(elts=[Attribute(value=Name(id='span', ctx=Load()), attr='end', ctx=Load()), Constant(value=True), Name(id='index', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='span', ctx=Store())], ctx=Store()), iter=Name(id='enumerated_spans', ctx=Load()), ifs=[], is_async=0)]), ctx=Load()), Tuple(elts=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), Constant(value=True), Constant(value=0)], ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='spans', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Call(func=Name(id='itemgetter', ctx=Load()), args=[Constant(value=0), Constant(value=1)], keywords=[]))])), AnnAssign(target=Name(id='stack', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='stack_append', ctx=Store())], value=Attribute(value=Name(id='stack', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='stack_pop', ctx=Store())], value=Attribute(value=Name(id='stack', ctx=Load()), attr='remove', ctx=Load())), AnnAssign(target=Name(id='style_cache', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Style', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), Name(id='Style', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), Assign(targets=[Name(id='style_cache_get', ctx=Store())], value=Attribute(value=Name(id='style_cache', ctx=Load()), attr='get', ctx=Load())), Assign(targets=[Name(id='combine', ctx=Store())], value=Attribute(value=Name(id='Style', ctx=Load()), attr='combine', ctx=Load())), FunctionDef(name='get_current_style', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Construct current style from stack.')), Assign(targets=[Name(id='styles', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='style_map', ctx=Load()), slice=Name(id='_style_id', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='_style_id', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='stack', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='cached_style', ctx=Store())], value=Call(func=Name(id='style_cache_get', ctx=Load()), args=[Name(id='styles', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='cached_style', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='cached_style', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='current_style', ctx=Store())], value=Call(func=Name(id='combine', ctx=Load()), args=[Name(id='styles', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='style_cache', ctx=Load()), slice=Name(id='styles', ctx=Load()), ctx=Store())], value=Name(id='current_style', ctx=Load())), Return(value=Name(id='current_style', ctx=Load()))], decorator_list=[], returns=Name(id='Style', ctx=Load())), For(target=Tuple(elts=[Tuple(elts=[Name(id='offset', ctx=Store()), Name(id='leaving', ctx=Store()), Name(id='style_id', ctx=Store())], ctx=Store()), Tuple(elts=[Name(id='next_offset', ctx=Store()), Name(id='_', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='spans', ctx=Load()), Subscript(value=Name(id='spans', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[]), body=[If(test=Name(id='leaving', ctx=Load()), body=[Expr(value=Call(func=Name(id='stack_pop', ctx=Load()), args=[Name(id='style_id', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='stack_append', ctx=Load()), args=[Name(id='style_id', ctx=Load())], keywords=[]))]), If(test=Compare(left=Name(id='next_offset', ctx=Load()), ops=[Gt()], comparators=[Name(id='offset', ctx=Load())]), body=[Expr(value=Yield(value=Call(func=Name(id='_Segment', ctx=Load()), args=[Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Name(id='offset', ctx=Load()), upper=Name(id='next_offset', ctx=Load())), ctx=Load()), Call(func=Name(id='get_current_style', ctx=Load()), args=[], keywords=[])], keywords=[])))], orelse=[])], orelse=[]), If(test=Name(id='end', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Name(id='_Segment', ctx=Load()), args=[Name(id='end', ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Segment'), ctx=Load())), FunctionDef(name='join', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Text'), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Join text together with this instance as the separator.\n\n        Args:\n            lines (Iterable[Text]): An iterable of Text instances to join.\n\n        Returns:\n            Text: A new text instance containing join text.\n        ')), Assign(targets=[Name(id='new_text', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='blank_copy', ctx=Load()), args=[], keywords=[])), FunctionDef(name='iter_text', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='last', ctx=Store()), Name(id='line', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='loop_last', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='line', ctx=Load()))), If(test=UnaryOp(op=Not(), operand=Name(id='last', ctx=Load())), body=[Expr(value=Yield(value=Name(id='self', ctx=Load())))], orelse=[])], orelse=[])], orelse=[Expr(value=YieldFrom(value=Name(id='lines', ctx=Load())))])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='Text'), ctx=Load())), Assign(targets=[Name(id='extend_text', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='new_text', ctx=Load()), attr='_text', ctx=Load()), attr='extend', ctx=Load())), Assign(targets=[Name(id='append_span', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='new_text', ctx=Load()), attr='_spans', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='extend_spans', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='new_text', ctx=Load()), attr='_spans', ctx=Load()), attr='extend', ctx=Load())), Assign(targets=[Name(id='offset', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), For(target=Name(id='text', ctx=Store()), iter=Call(func=Name(id='iter_text', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id='extend_text', ctx=Load()), args=[Attribute(value=Name(id='text', ctx=Load()), attr='_text', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='text', ctx=Load()), attr='style', ctx=Load()), body=[Expr(value=Call(func=Name(id='append_span', ctx=Load()), args=[Call(func=Name(id='_Span', ctx=Load()), args=[Name(id='offset', ctx=Load()), BinOp(left=Name(id='offset', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Attribute(value=Name(id='text', ctx=Load()), attr='style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='extend_spans', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_Span', ctx=Load()), args=[BinOp(left=Name(id='offset', ctx=Load()), op=Add(), right=Name(id='start', ctx=Load())), BinOp(left=Name(id='offset', ctx=Load()), op=Add(), right=Name(id='end', ctx=Load())), Name(id='style', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='text', ctx=Load()), attr='_spans', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), AugAssign(target=Name(id='offset', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='new_text', ctx=Load()), attr='_length', ctx=Store())], value=Name(id='offset', ctx=Load())), Return(value=Name(id='new_text', ctx=Load()))], decorator_list=[], returns=Constant(value='Text')), FunctionDef(name='expand_tabs', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tab_size', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Converts tabs to spaces.\n\n        Args:\n            tab_size (int, optional): Size of tabs. Defaults to 8.\n\n        ')), If(test=Compare(left=Constant(value='\t'), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())]), body=[Return()], orelse=[]), Assign(targets=[Name(id='pos', ctx=Store())], value=Constant(value=0)), If(test=Compare(left=Name(id='tab_size', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='tab_size', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='tab_size', ctx=Load()))], orelse=[]), Assert(test=Compare(left=Name(id='tab_size', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='blank_copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='append', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='_style', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[keyword(arg='include_separator', value=Constant(value=True))]), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\t')], keywords=[keyword(arg='include_separator', value=Constant(value=True))])), For(target=Name(id='part', ctx=Store()), iter=Name(id='parts', ctx=Load()), body=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='part', ctx=Load()), attr='plain', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='\t')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='part', ctx=Load()), attr='_text', ctx=Store())], value=List(elts=[BinOp(left=Subscript(value=Attribute(value=Name(id='part', ctx=Load()), attr='plain', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), op=Add(), right=Constant(value=' '))], ctx=Load())), Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Name(id='part', ctx=Load())], keywords=[])), AugAssign(target=Name(id='pos', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='part', ctx=Load())], keywords=[])), Assign(targets=[Name(id='spaces', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='tab_size', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='pos', ctx=Load()), op=Sub(), right=Constant(value=1)), op=Mod(), right=Name(id='tab_size', ctx=Load()))), op=Sub(), right=Constant(value=1))), If(test=Name(id='spaces', ctx=Load()), body=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='spaces', ctx=Load())), Name(id='_style', ctx=Load())], keywords=[])), AugAssign(target=Name(id='pos', ctx=Store()), op=Add(), value=Name(id='spaces', ctx=Load()))], orelse=[])], orelse=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Name(id='part', ctx=Load())], keywords=[]))])], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Store())], value=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='plain', ctx=Load())], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), slice=Slice(), ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='_spans', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='truncate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='max_width', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[arg(arg='overflow', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='OverflowMethod'), ctx=Load())), arg(arg='pad', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=False)], defaults=[]), body=[Expr(value=Constant(value='Truncate text if it is longer that a given width.\n\n        Args:\n            max_width (int): Maximum number of characters in text.\n            overflow (str, optional): Overflow method: "crop", "fold", or "ellipsis". Defaults to None, to use self.overflow.\n            pad (bool, optional): Pad with spaces if the length is less than max_width. Defaults to False.\n        ')), Assign(targets=[Name(id='_overflow', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='overflow', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='overflow', ctx=Load()), Name(id='DEFAULT_OVERFLOW', ctx=Load())])), If(test=Compare(left=Name(id='_overflow', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='ignore')]), body=[Assign(targets=[Name(id='length', ctx=Store())], value=Call(func=Name(id='cell_len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='length', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_width', ctx=Load())]), body=[If(test=Compare(left=Name(id='_overflow', ctx=Load()), ops=[Eq()], comparators=[Constant(value='ellipsis')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Store())], value=BinOp(left=Call(func=Name(id='set_cell_size', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), BinOp(left=Name(id='max_width', ctx=Load()), op=Sub(), right=Constant(value=1))], keywords=[]), op=Add(), right=Constant(value='…')))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Store())], value=Call(func=Name(id='set_cell_size', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), Name(id='max_width', ctx=Load())], keywords=[]))])], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='pad', ctx=Load()), Compare(left=Name(id='length', ctx=Load()), ops=[Lt()], comparators=[Name(id='max_width', ctx=Load())])]), body=[Assign(targets=[Name(id='spaces', ctx=Store())], value=BinOp(left=Name(id='max_width', ctx=Load()), op=Sub(), right=Name(id='length', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Store())], value=List(elts=[JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), conversion=-1), FormattedValue(value=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='spaces', ctx=Load())), conversion=-1)])], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_trim_spans', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove or modify any spans that are over the end of the text.')), Assign(targets=[Name(id='max_offset', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), slice=Slice(), ctx=Store())], value=ListComp(elt=IfExp(test=Compare(left=Attribute(value=Name(id='span', ctx=Load()), attr='end', ctx=Load()), ops=[Lt()], comparators=[Name(id='max_offset', ctx=Load())]), body=Name(id='span', ctx=Load()), orelse=Call(func=Name(id='_Span', ctx=Load()), args=[Attribute(value=Name(id='span', ctx=Load()), attr='start', ctx=Load()), Call(func=Name(id='min', ctx=Load()), args=[Name(id='max_offset', ctx=Load()), Attribute(value=Name(id='span', ctx=Load()), attr='end', ctx=Load())], keywords=[]), Attribute(value=Name(id='span', ctx=Load()), attr='style', ctx=Load())], keywords=[])), generators=[comprehension(target=Name(id='span', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), ifs=[Compare(left=Attribute(value=Name(id='span', ctx=Load()), attr='start', ctx=Load()), ops=[Lt()], comparators=[Name(id='max_offset', ctx=Load())])], is_async=0)]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='pad', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='count', annotation=Name(id='int', ctx=Load())), arg(arg='character', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=' ')]), body=[Expr(value=Constant(value='Pad left and right with a given number of characters.\n\n        Args:\n            count (int): Width of padding.\n        ')), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='character', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), msg=Constant(value='Character must be a string of length 1')), If(test=Name(id='count', ctx=Load()), body=[Assign(targets=[Name(id='pad_characters', ctx=Store())], value=BinOp(left=Name(id='character', ctx=Load()), op=Mult(), right=Name(id='count', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='pad_characters', ctx=Load()), conversion=-1), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='pad_characters', ctx=Load()), conversion=-1)])), Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), slice=Slice(), ctx=Store())], value=ListComp(elt=Call(func=Name(id='_Span', ctx=Load()), args=[BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Name(id='count', ctx=Load())), BinOp(left=Name(id='end', ctx=Load()), op=Add(), right=Name(id='count', ctx=Load())), Name(id='style', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), ifs=[], is_async=0)]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='pad_left', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='count', annotation=Name(id='int', ctx=Load())), arg(arg='character', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=' ')]), body=[Expr(value=Constant(value='Pad the left with a given character.\n\n        Args:\n            count (int): Number of characters to pad.\n            character (str, optional): Character to pad with. Defaults to " ".\n        ')), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='character', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), msg=Constant(value='Character must be a string of length 1')), If(test=Name(id='count', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=BinOp(left=Name(id='character', ctx=Load()), op=Mult(), right=Name(id='count', ctx=Load())), conversion=-1), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), conversion=-1)])), Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), slice=Slice(), ctx=Store())], value=ListComp(elt=Call(func=Name(id='_Span', ctx=Load()), args=[BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Name(id='count', ctx=Load())), BinOp(left=Name(id='end', ctx=Load()), op=Add(), right=Name(id='count', ctx=Load())), Name(id='style', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), ifs=[], is_async=0)]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='pad_right', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='count', annotation=Name(id='int', ctx=Load())), arg(arg='character', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=' ')]), body=[Expr(value=Constant(value='Pad the right with a given character.\n\n        Args:\n            count (int): Number of characters to pad.\n            character (str, optional): Character to pad with. Defaults to " ".\n        ')), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='character', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), msg=Constant(value='Character must be a string of length 1')), If(test=Name(id='count', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), conversion=-1), FormattedValue(value=BinOp(left=Name(id='character', ctx=Load()), op=Mult(), right=Name(id='count', ctx=Load())), conversion=-1)]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='align', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='align', annotation=Name(id='AlignMethod', ctx=Load())), arg(arg='width', annotation=Name(id='int', ctx=Load())), arg(arg='character', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=' ')]), body=[Expr(value=Constant(value='Align text to a given width.\n\n        Args:\n            align (AlignMethod): One of "left", "center", or "right".\n            width (int): Desired width.\n            character (str, optional): Character to pad with. Defaults to " ".\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='truncate', ctx=Load()), args=[Name(id='width', ctx=Load())], keywords=[])), Assign(targets=[Name(id='excess_space', ctx=Store())], value=BinOp(left=Name(id='width', ctx=Load()), op=Sub(), right=Call(func=Name(id='cell_len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[]))), If(test=Name(id='excess_space', ctx=Load()), body=[If(test=Compare(left=Name(id='align', ctx=Load()), ops=[Eq()], comparators=[Constant(value='left')]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='pad_right', ctx=Load()), args=[Name(id='excess_space', ctx=Load()), Name(id='character', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='align', ctx=Load()), ops=[Eq()], comparators=[Constant(value='center')]), body=[Assign(targets=[Name(id='left', ctx=Store())], value=BinOp(left=Name(id='excess_space', ctx=Load()), op=FloorDiv(), right=Constant(value=2))), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='pad_left', ctx=Load()), args=[Name(id='left', ctx=Load()), Name(id='character', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='pad_right', ctx=Load()), args=[BinOp(left=Name(id='excess_space', ctx=Load()), op=Sub(), right=Name(id='left', ctx=Load())), Name(id='character', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='pad_left', ctx=Load()), args=[Name(id='excess_space', ctx=Load()), Name(id='character', ctx=Load())], keywords=[]))])])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='append', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='Text'), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='style', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='Style')], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Add text with an optional style.\n\n        Args:\n            text (Union[Text, str]): A str or Text to append.\n            style (str, optional): A style name. Defaults to None.\n\n        Returns:\n            Text: Returns self for chaining.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='text', ctx=Load()), Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Text', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Only str or Text can be appended to Text')], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='sanitized_text', ctx=Store())], value=Call(func=Name(id='strip_control_codes', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='sanitized_text', ctx=Load())], keywords=[])), Assign(targets=[Name(id='offset', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Name(id='text_length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sanitized_text', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='style', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='Span', ctx=Load()), args=[Name(id='offset', ctx=Load()), BinOp(left=Name(id='offset', ctx=Load()), op=Add(), right=Name(id='text_length', ctx=Load())), Name(id='style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Store()), op=Add(), value=Name(id='text_length', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='Text', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), If(test=Compare(left=Name(id='style', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='style must not be set when appending Text instance')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='text_length', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='text', ctx=Load()), attr='style', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='_Span', ctx=Load()), args=[Name(id='text_length', ctx=Load()), BinOp(left=Name(id='text_length', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Attribute(value=Name(id='text', ctx=Load()), attr='style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='text', ctx=Load()), attr='plain', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='extend', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_Span', ctx=Load()), args=[BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Name(id='text_length', ctx=Load())), BinOp(left=Name(id='end', ctx=Load()), op=Add(), right=Name(id='text_length', ctx=Load())), Name(id='style', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='text', ctx=Load()), attr='_spans', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]))], orelse=[])])], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='Text')), FunctionDef(name='append_text', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text', annotation=Constant(value='Text'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Append another Text instance. This method is more performant that Text.append, but\n        only works for Text.\n\n        Returns:\n            Text: Returns self for chaining.\n        ')), Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), Assign(targets=[Name(id='text_length', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='text', ctx=Load()), attr='style', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='_Span', ctx=Load()), args=[Name(id='text_length', ctx=Load()), BinOp(left=Name(id='text_length', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Attribute(value=Name(id='text', ctx=Load()), attr='style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='text', ctx=Load()), attr='plain', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='extend', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_Span', ctx=Load()), args=[BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Name(id='text_length', ctx=Load())), BinOp(left=Name(id='end', ctx=Load()), op=Add(), right=Name(id='text_length', ctx=Load())), Name(id='style', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='text', ctx=Load()), attr='_spans', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='Text')), FunctionDef(name='append_tokens', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tokens', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='StyleType', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Append iterable of str and style. Style may be a Style instance or a str style definition.\n\n        Args:\n            pairs (Iterable[Tuple[str, Optional[StyleType]]]): An iterable of tuples containing str content and style.\n\n        Returns:\n            Text: Returns self for chaining.\n        ')), Assign(targets=[Name(id='append_text', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='append_span', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), Assign(targets=[Name(id='offset', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='content', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store()), iter=Name(id='tokens', ctx=Load()), body=[Expr(value=Call(func=Name(id='append_text', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='style', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='append_span', ctx=Load()), args=[Call(func=Name(id='_Span', ctx=Load()), args=[Name(id='offset', ctx=Load()), BinOp(left=Name(id='offset', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[])), Name(id='style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), AugAssign(target=Name(id='offset', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Store())], value=Name(id='offset', ctx=Load())), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='Text')), FunctionDef(name='copy_styles', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text', annotation=Constant(value='Text'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Copy styles from another Text instance.\n\n        Args:\n            text (Text): A Text instance to copy styles from, must be the same length.\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='text', ctx=Load()), attr='_spans', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='split', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='separator', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='include_separator', annotation=Name(id='bool', ctx=Load())), arg(arg='allow_blank', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False), Constant(value=False)], defaults=[Constant(value='\n')]), body=[Expr(value=Constant(value='Split rich text in to lines, preserving styles.\n\n        Args:\n            separator (str, optional): String to split on. Defaults to "\\\\n".\n            include_separator (bool, optional): Include the separator in the lines. Defaults to False.\n            allow_blank (bool, optional): Return a blank line if the text ends with a separator. Defaults to False.\n\n        Returns:\n            List[RichText]: A list of rich text, one per line of the original.\n        ')), Assert(test=Name(id='separator', ctx=Load()), msg=Constant(value='separator must not be empty')), Assign(targets=[Name(id='text', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())), If(test=Compare(left=Name(id='separator', ctx=Load()), ops=[NotIn()], comparators=[Name(id='text', ctx=Load())]), body=[Return(value=Call(func=Name(id='Lines', ctx=Load()), args=[List(elts=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])], ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='include_separator', ctx=Load()), body=[Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='divide', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='match', ctx=Store()), iter=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='finditer', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='separator', ctx=Load())], keywords=[]), Name(id='text', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], orelse=[FunctionDef(name='flatten_spans', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='match', ctx=Store()), iter=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='finditer', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='separator', ctx=Load())], keywords=[]), Name(id='text', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='span', ctx=Load()), args=[], keywords=[])), Expr(value=Yield(value=Name(id='start', ctx=Load()))), Expr(value=Yield(value=Name(id='end', ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Name(id='Lines', ctx=Load()), args=[GeneratorExp(elt=Name(id='line', ctx=Load()), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='divide', ctx=Load()), args=[Call(func=Name(id='flatten_spans', ctx=Load()), args=[], keywords=[])], keywords=[]), ifs=[Compare(left=Attribute(value=Name(id='line', ctx=Load()), attr='plain', ctx=Load()), ops=[NotEq()], comparators=[Name(id='separator', ctx=Load())])], is_async=0)])], keywords=[]))]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='allow_blank', ctx=Load())), Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='separator', ctx=Load())], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='lines', ctx=Load()))], decorator_list=[], returns=Name(id='Lines', ctx=Load())), FunctionDef(name='divide', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='offsets', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Divide text in to a number of lines at given offsets.\n\n        Args:\n            offsets (Iterable[int]): Offsets used to divide text.\n\n        Returns:\n            Lines: New RichText instances between offsets.\n        ')), Assign(targets=[Name(id='_offsets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='offsets', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='_offsets', ctx=Load())), body=[Return(value=Call(func=Name(id='Lines', ctx=Load()), args=[List(elts=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])], ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='text', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())), Assign(targets=[Name(id='text_length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Assign(targets=[Name(id='divide_offsets', ctx=Store())], value=List(elts=[Constant(value=0), Starred(value=Name(id='_offsets', ctx=Load()), ctx=Load()), Name(id='text_length', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='line_ranges', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='divide_offsets', ctx=Load()), Subscript(value=Name(id='divide_offsets', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='style', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load())), Assign(targets=[Name(id='justify', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='justify', ctx=Load())), Assign(targets=[Name(id='overflow', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='overflow', ctx=Load())), Assign(targets=[Name(id='_Text', ctx=Store())], value=Name(id='Text', ctx=Load())), Assign(targets=[Name(id='new_lines', ctx=Store())], value=Call(func=Name(id='Lines', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_Text', ctx=Load()), args=[Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='end', ctx=Load())), ctx=Load())], keywords=[keyword(arg='style', value=Name(id='style', ctx=Load())), keyword(arg='justify', value=Name(id='justify', ctx=Load())), keyword(arg='overflow', value=Name(id='overflow', ctx=Load()))]), generators=[comprehension(target=Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store()), iter=Name(id='line_ranges', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load())), body=[Return(value=Name(id='new_lines', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='_line_appends', ctx=Store())], value=ListComp(elt=Attribute(value=Attribute(value=Name(id='line', ctx=Load()), attr='_spans', ctx=Load()), attr='append', ctx=Load()), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Attribute(value=Name(id='new_lines', ctx=Load()), attr='_lines', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='line_count', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='line_ranges', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), For(target=Tuple(elts=[Name(id='span_start', ctx=Store()), Name(id='span_end', ctx=Store()), Name(id='style', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), body=[Assign(targets=[Name(id='lower_bound', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='upper_bound', ctx=Store())], value=Name(id='line_count', ctx=Load())), Assign(targets=[Name(id='start_line_no', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='lower_bound', ctx=Load()), op=Add(), right=Name(id='upper_bound', ctx=Load())), op=FloorDiv(), right=Constant(value=2))), While(test=Constant(value=True), body=[Assign(targets=[Tuple(elts=[Name(id='line_start', ctx=Store()), Name(id='line_end', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='line_ranges', ctx=Load()), slice=Name(id='start_line_no', ctx=Load()), ctx=Load())), If(test=Compare(left=Name(id='span_start', ctx=Load()), ops=[Lt()], comparators=[Name(id='line_start', ctx=Load())]), body=[Assign(targets=[Name(id='upper_bound', ctx=Store())], value=BinOp(left=Name(id='start_line_no', ctx=Load()), op=Sub(), right=Constant(value=1)))], orelse=[If(test=Compare(left=Name(id='span_start', ctx=Load()), ops=[Gt()], comparators=[Name(id='line_end', ctx=Load())]), body=[Assign(targets=[Name(id='lower_bound', ctx=Store())], value=BinOp(left=Name(id='start_line_no', ctx=Load()), op=Add(), right=Constant(value=1)))], orelse=[Break()])]), Assign(targets=[Name(id='start_line_no', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='lower_bound', ctx=Load()), op=Add(), right=Name(id='upper_bound', ctx=Load())), op=FloorDiv(), right=Constant(value=2)))], orelse=[]), If(test=Compare(left=Name(id='span_end', ctx=Load()), ops=[Lt()], comparators=[Name(id='line_end', ctx=Load())]), body=[Assign(targets=[Name(id='end_line_no', ctx=Store())], value=Name(id='start_line_no', ctx=Load()))], orelse=[Assign(targets=[Name(id='end_line_no', ctx=Store()), Name(id='lower_bound', ctx=Store())], value=Name(id='start_line_no', ctx=Load())), Assign(targets=[Name(id='upper_bound', ctx=Store())], value=Name(id='line_count', ctx=Load())), While(test=Constant(value=True), body=[Assign(targets=[Tuple(elts=[Name(id='line_start', ctx=Store()), Name(id='line_end', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='line_ranges', ctx=Load()), slice=Name(id='end_line_no', ctx=Load()), ctx=Load())), If(test=Compare(left=Name(id='span_end', ctx=Load()), ops=[Lt()], comparators=[Name(id='line_start', ctx=Load())]), body=[Assign(targets=[Name(id='upper_bound', ctx=Store())], value=BinOp(left=Name(id='end_line_no', ctx=Load()), op=Sub(), right=Constant(value=1)))], orelse=[If(test=Compare(left=Name(id='span_end', ctx=Load()), ops=[Gt()], comparators=[Name(id='line_end', ctx=Load())]), body=[Assign(targets=[Name(id='lower_bound', ctx=Store())], value=BinOp(left=Name(id='end_line_no', ctx=Load()), op=Add(), right=Constant(value=1)))], orelse=[Break()])]), Assign(targets=[Name(id='end_line_no', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='lower_bound', ctx=Load()), op=Add(), right=Name(id='upper_bound', ctx=Load())), op=FloorDiv(), right=Constant(value=2)))], orelse=[])]), For(target=Name(id='line_no', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='start_line_no', ctx=Load()), BinOp(left=Name(id='end_line_no', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='line_start', ctx=Store()), Name(id='line_end', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='line_ranges', ctx=Load()), slice=Name(id='line_no', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='new_start', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), BinOp(left=Name(id='span_start', ctx=Load()), op=Sub(), right=Name(id='line_start', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='new_end', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=Name(id='span_end', ctx=Load()), op=Sub(), right=Name(id='line_start', ctx=Load())), BinOp(left=Name(id='line_end', ctx=Load()), op=Sub(), right=Name(id='line_start', ctx=Load()))], keywords=[])), If(test=Compare(left=Name(id='new_end', ctx=Load()), ops=[Gt()], comparators=[Name(id='new_start', ctx=Load())]), body=[Expr(value=Call(func=Subscript(value=Name(id='_line_appends', ctx=Load()), slice=Name(id='line_no', ctx=Load()), ctx=Load()), args=[Call(func=Name(id='_Span', ctx=Load()), args=[Name(id='new_start', ctx=Load()), Name(id='new_end', ctx=Load()), Name(id='style', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='new_lines', ctx=Load()))], decorator_list=[], returns=Name(id='Lines', ctx=Load())), FunctionDef(name='right_crop', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='amount', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1)]), body=[Expr(value=Constant(value='Remove a number of characters from the end of the text.')), Assign(targets=[Name(id='max_offset', ctx=Store())], value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[]), op=Sub(), right=Name(id='amount', ctx=Load()))), Assign(targets=[Name(id='_Span', ctx=Store())], value=Name(id='Span', ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), slice=Slice(), ctx=Store())], value=ListComp(elt=IfExp(test=Compare(left=Attribute(value=Name(id='span', ctx=Load()), attr='end', ctx=Load()), ops=[Lt()], comparators=[Name(id='max_offset', ctx=Load())]), body=Name(id='span', ctx=Load()), orelse=Call(func=Name(id='_Span', ctx=Load()), args=[Attribute(value=Name(id='span', ctx=Load()), attr='start', ctx=Load()), Call(func=Name(id='min', ctx=Load()), args=[Name(id='max_offset', ctx=Load()), Attribute(value=Name(id='span', ctx=Load()), attr='end', ctx=Load())], keywords=[]), Attribute(value=Name(id='span', ctx=Load()), attr='style', ctx=Load())], keywords=[])), generators=[comprehension(target=Name(id='span', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_spans', ctx=Load()), ifs=[Compare(left=Attribute(value=Name(id='span', ctx=Load()), attr='start', ctx=Load()), ops=[Lt()], comparators=[Name(id='max_offset', ctx=Load())])], is_async=0)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_text', ctx=Store())], value=List(elts=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Name(id='amount', ctx=Load()))), ctx=Load())], ctx=Load())), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_length', ctx=Store()), op=Sub(), value=Name(id='amount', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='wrap', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='console', annotation=Constant(value='Console')), arg(arg='width', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[arg(arg='justify', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='JustifyMethod'), ctx=Load())), arg(arg='overflow', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='OverflowMethod'), ctx=Load())), arg(arg='tab_size', annotation=Name(id='int', ctx=Load())), arg(arg='no_wrap', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=8), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value='Word wrap the text.\n\n        Args:\n            console (Console): Console instance.\n            width (int): Number of characters per line.\n            emoji (bool, optional): Also render emoji code. Defaults to True.\n            justify (str, optional): Justify method: "default", "left", "center", "full", "right". Defaults to "default".\n            overflow (str, optional): Overflow method: "crop", "fold", or "ellipsis". Defaults to None.\n            tab_size (int, optional): Default tab size. Defaults to 8.\n            no_wrap (bool, optional): Disable wrapping, Defaults to False.\n\n        Returns:\n            Lines: Number of lines.\n        ')), Assign(targets=[Name(id='wrap_justify', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='justify', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='justify', ctx=Load()), Name(id='DEFAULT_JUSTIFY', ctx=Load())])), Assign(targets=[Name(id='wrap_overflow', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='overflow', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='overflow', ctx=Load()), Name(id='DEFAULT_OVERFLOW', ctx=Load())])), Assign(targets=[Name(id='no_wrap', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Name(id='pick_bool', ctx=Load()), args=[Name(id='no_wrap', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='no_wrap', ctx=Load()), Constant(value=False)], keywords=[]), Compare(left=Name(id='overflow', ctx=Load()), ops=[Eq()], comparators=[Constant(value='ignore')])])), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Name(id='Lines', ctx=Load()), args=[], keywords=[])), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[keyword(arg='allow_blank', value=Constant(value=True))]), body=[If(test=Compare(left=Constant(value='\t'), ops=[In()], comparators=[Name(id='line', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='expand_tabs', ctx=Load()), args=[Name(id='tab_size', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='no_wrap', ctx=Load()), body=[Assign(targets=[Name(id='new_lines', ctx=Store())], value=Call(func=Name(id='Lines', ctx=Load()), args=[List(elts=[Name(id='line', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='offsets', ctx=Store())], value=Call(func=Name(id='divide_line', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), Name(id='width', ctx=Load())], keywords=[keyword(arg='fold', value=Compare(left=Name(id='wrap_overflow', ctx=Load()), ops=[Eq()], comparators=[Constant(value='fold')]))])), Assign(targets=[Name(id='new_lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='divide', ctx=Load()), args=[Name(id='offsets', ctx=Load())], keywords=[]))]), For(target=Name(id='line', ctx=Store()), iter=Name(id='new_lines', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='rstrip_end', ctx=Load()), args=[Name(id='width', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='wrap_justify', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='new_lines', ctx=Load()), attr='justify', ctx=Load()), args=[Name(id='console', ctx=Load()), Name(id='width', ctx=Load())], keywords=[keyword(arg='justify', value=Name(id='wrap_justify', ctx=Load())), keyword(arg='overflow', value=Name(id='wrap_overflow', ctx=Load()))]))], orelse=[]), For(target=Name(id='line', ctx=Store()), iter=Name(id='new_lines', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='truncate', ctx=Load()), args=[Name(id='width', ctx=Load())], keywords=[keyword(arg='overflow', value=Name(id='wrap_overflow', ctx=Load()))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='new_lines', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='lines', ctx=Load()))], decorator_list=[], returns=Name(id='Lines', ctx=Load())), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='width', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Fit the text in to given width by chopping in to lines.\n\n        Args:\n            width (int): Maximum characters in a line.\n\n        Returns:\n            Lines: Lines container.\n        ')), AnnAssign(target=Name(id='lines', ctx=Store()), annotation=Name(id='Lines', ctx=Load()), value=Call(func=Name(id='Lines', ctx=Load()), args=[], keywords=[]), simple=1), Assign(targets=[Name(id='append', ctx=Store())], value=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='set_length', ctx=Load()), args=[Name(id='width', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='lines', ctx=Load()))], decorator_list=[], returns=Name(id='Lines', ctx=Load())), FunctionDef(name='detect_indentation', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Auto-detect indentation of code.\n\n        Returns:\n            int: Number of spaces used to indent code.\n        ')), Assign(targets=[Name(id='_indentations', ctx=Store())], value=SetComp(elt=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='match', ctx=Store()), iter=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='finditer', ctx=Load()), args=[Constant(value='^( *)(.*)$'), Attribute(value=Name(id='self', ctx=Load()), attr='plain', ctx=Load())], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load()))]), ifs=[], is_async=0)])), Try(body=[Assign(targets=[Name(id='indentation', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Name(id='reduce', ctx=Load()), args=[Name(id='gcd', ctx=Load()), ListComp(elt=Name(id='indent', ctx=Load()), generators=[comprehension(target=Name(id='indent', ctx=Store()), iter=Name(id='_indentations', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=BinOp(left=Name(id='indent', ctx=Load()), op=Mod(), right=Constant(value=2)))], is_async=0)])], keywords=[]), Constant(value=1)]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Assign(targets=[Name(id='indentation', ctx=Store())], value=Constant(value=1))])], orelse=[], finalbody=[]), Return(value=Name(id='indentation', ctx=Load()))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='with_indent_guides', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='indent_size', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='character', annotation=Name(id='str', ctx=Load())), arg(arg='style', annotation=Name(id='StyleType', ctx=Load()))], kw_defaults=[Constant(value='│'), Constant(value='dim green')], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Adds indent guide lines to text.\n\n        Args:\n            indent_size (Optional[int]): Size of indentation, or None to auto detect. Defaults to None.\n            character (str, optional): Character to use for indentation. Defaults to "│".\n            style (Union[Style, str], optional): Style of indent guides.\n\n        Returns:\n            Text: New text with indentation guides.\n        ')), Assign(targets=[Name(id='_indent_size', ctx=Store())], value=IfExp(test=Compare(left=Name(id='indent_size', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='detect_indentation', ctx=Load()), args=[], keywords=[]), orelse=Name(id='indent_size', ctx=Load()))), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='expand_tabs', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='indent_line', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='character', ctx=Load()), conversion=-1), FormattedValue(value=BinOp(left=Constant(value=' '), op=Mult(), right=BinOp(left=Name(id='_indent_size', ctx=Load()), op=Sub(), right=Constant(value=1))), conversion=-1)])), Assign(targets=[Name(id='re_indent', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^( *)(.*)$')], keywords=[])), AnnAssign(target=Name(id='new_lines', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Text', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='add_line', ctx=Store())], value=Attribute(value=Name(id='new_lines', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='blank_lines', ctx=Store())], value=Constant(value=0)), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[keyword(arg='allow_blank', value=Constant(value=True))]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re_indent', ctx=Load()), attr='match', ctx=Load()), args=[Attribute(value=Name(id='line', ctx=Load()), attr='plain', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='match', ctx=Load())), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=2)], keywords=[]))]), body=[AugAssign(target=Name(id='blank_lines', ctx=Store()), op=Add(), value=Constant(value=1)), Continue()], orelse=[]), Assign(targets=[Name(id='indent', ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='full_indents', ctx=Store()), Name(id='remaining_space', ctx=Store())], ctx=Store())], value=Call(func=Name(id='divmod', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='indent', ctx=Load())], keywords=[]), Name(id='_indent_size', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_indent', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=BinOp(left=Name(id='indent_line', ctx=Load()), op=Mult(), right=Name(id='full_indents', ctx=Load())), conversion=-1), FormattedValue(value=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='remaining_space', ctx=Load())), conversion=-1)])), Assign(targets=[Attribute(value=Name(id='line', ctx=Load()), attr='plain', ctx=Store())], value=BinOp(left=Name(id='new_indent', ctx=Load()), op=Add(), right=Subscript(value=Attribute(value=Name(id='line', ctx=Load()), attr='plain', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='new_indent', ctx=Load())], keywords=[])), ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='stylize', ctx=Load()), args=[Name(id='style', ctx=Load()), Constant(value=0), Call(func=Name(id='len', ctx=Load()), args=[Name(id='new_indent', ctx=Load())], keywords=[])], keywords=[])), If(test=Name(id='blank_lines', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='new_lines', ctx=Load()), attr='extend', ctx=Load()), args=[BinOp(left=List(elts=[Call(func=Name(id='Text', ctx=Load()), args=[Name(id='new_indent', ctx=Load())], keywords=[keyword(arg='style', value=Name(id='style', ctx=Load()))])], ctx=Load()), op=Mult(), right=Name(id='blank_lines', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='blank_lines', ctx=Store())], value=Constant(value=0))], orelse=[]), Expr(value=Call(func=Name(id='add_line', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='blank_lines', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='new_lines', ctx=Load()), attr='extend', ctx=Load()), args=[BinOp(left=List(elts=[Call(func=Name(id='Text', ctx=Load()), args=[Constant(value='')], keywords=[keyword(arg='style', value=Name(id='style', ctx=Load()))])], ctx=Load()), op=Mult(), right=Name(id='blank_lines', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='new_text', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='blank_copy', ctx=Load()), args=[Constant(value='\n')], keywords=[]), attr='join', ctx=Load()), args=[Name(id='new_lines', ctx=Load())], keywords=[])), Return(value=Name(id='new_text', ctx=Load()))], decorator_list=[], returns=Constant(value='Text'))], decorator_list=[]), If(test=Compare(left=Name(id='__name__', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__main__')]), body=[ImportFrom(module='pip._vendor.rich.console', names=[alias(name='Console')], level=0), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Name(id='Text', ctx=Load()), args=[Constant(value='\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='highlight_words', ctx=Load()), args=[List(elts=[Constant(value='Lorem')], ctx=Load()), Constant(value='bold')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='highlight_words', ctx=Load()), args=[List(elts=[Constant(value='ipsum')], ctx=Load()), Constant(value='italic')], keywords=[])), Assign(targets=[Name(id='console', ctx=Store())], value=Call(func=Name(id='Console', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='rule', ctx=Load()), args=[Constant(value="justify='left'")], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[keyword(arg='style', value=Constant(value='red'))])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='rule', ctx=Load()), args=[Constant(value="justify='center'")], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[keyword(arg='style', value=Constant(value='green')), keyword(arg='justify', value=Constant(value='center'))])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='rule', ctx=Load()), args=[Constant(value="justify='right'")], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[keyword(arg='style', value=Constant(value='blue')), keyword(arg='justify', value=Constant(value='right'))])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='rule', ctx=Load()), args=[Constant(value="justify='full'")], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[keyword(arg='style', value=Constant(value='magenta')), keyword(arg='justify', value=Constant(value='full'))])), Expr(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='print', ctx=Load()), args=[], keywords=[]))], orelse=[])], type_ignores=[])