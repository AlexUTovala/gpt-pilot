Module(body=[Expr(value=Constant(value='PEP 376 implementation.')), ImportFrom(module='__future__', names=[alias(name='unicode_literals')], level=0), Import(names=[alias(name='base64')]), Import(names=[alias(name='codecs')]), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='hashlib')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='os')]), Import(names=[alias(name='posixpath')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='zipimport')]), ImportFrom(names=[alias(name='DistlibException'), alias(name='resources')], level=1), ImportFrom(module='compat', names=[alias(name='StringIO')], level=1), ImportFrom(module='version', names=[alias(name='get_scheme'), alias(name='UnsupportedVersionError')], level=1), ImportFrom(module='metadata', names=[alias(name='Metadata'), alias(name='METADATA_FILENAME'), alias(name='WHEEL_METADATA_FILENAME'), alias(name='LEGACY_METADATA_FILENAME')], level=1), ImportFrom(module='util', names=[alias(name='parse_requirement'), alias(name='cached_property'), alias(name='parse_name_and_version'), alias(name='read_exports'), alias(name='write_exports'), alias(name='CSVReader'), alias(name='CSVWriter')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Distribution'), Constant(value='BaseInstalledDistribution'), Constant(value='InstalledDistribution'), Constant(value='EggInfoDistribution'), Constant(value='DistributionPath')], ctx=Load())), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='EXPORTS_FILENAME', ctx=Store())], value=Constant(value='pydist-exports.json')), Assign(targets=[Name(id='COMMANDS_FILENAME', ctx=Store())], value=Constant(value='pydist-commands.json')), Assign(targets=[Name(id='DIST_FILES', ctx=Store())], value=Tuple(elts=[Constant(value='INSTALLER'), Name(id='METADATA_FILENAME', ctx=Load()), Constant(value='RECORD'), Constant(value='REQUESTED'), Constant(value='RESOURCES'), Name(id='EXPORTS_FILENAME', ctx=Load()), Constant(value='SHARED')], ctx=Load())), Assign(targets=[Name(id='DISTINFO_EXT', ctx=Store())], value=Constant(value='.dist-info')), ClassDef(name='_Cache', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A simple cache mapping names and .dist-info paths to distributions\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Initialise an instance. There is normally one for each DistributionPath.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='generated', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='clear', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Clear the cache, setting it to its initial state.\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='generated', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='add', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Add a distribution to the cache.\n        :param dist: The distribution to add.\n        ')), If(test=Compare(left=Attribute(value=Name(id='dist', ctx=Load()), attr='path', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), slice=Attribute(value=Name(id='dist', ctx=Load()), attr='path', ctx=Load()), ctx=Store())], value=Name(id='dist', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), attr='setdefault', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load()), List(elts=[], ctx=Load())], keywords=[]), attr='append', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='DistributionPath', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Represents a set of distributions installed on a path (typically sys.path).\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path'), arg(arg='include_egg')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='\n        Create an instance from a path, optionally including legacy (distutils/\n        setuptools/distribute) distributions.\n        :param path: The path to use, as a list of directories. If not specified,\n                     sys.path is used.\n        :param include_egg: If True, this instance will look for and return legacy\n                            distributions as well as those based on PEP 376.\n        ')), If(test=Compare(left=Name(id='path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Store())], value=Name(id='path', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_dist', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_egg', ctx=Store())], value=Name(id='include_egg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Store())], value=Call(func=Name(id='_Cache', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache_egg', ctx=Store())], value=Call(func=Name(id='_Cache', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache_enabled', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scheme', ctx=Store())], value=Call(func=Name(id='get_scheme', ctx=Load()), args=[Constant(value='default')], keywords=[]))], decorator_list=[]), FunctionDef(name='_get_cache_enabled', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache_enabled', ctx=Load()))], decorator_list=[]), FunctionDef(name='_set_cache_enabled', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache_enabled', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='cache_enabled', ctx=Store())], value=Call(func=Name(id='property', ctx=Load()), args=[Name(id='_get_cache_enabled', ctx=Load()), Name(id='_set_cache_enabled', ctx=Load())], keywords=[])), FunctionDef(name='clear_cache', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Clears the internal cache.\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache_egg', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_yield_distributions', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Yield .dist-info and/or .egg(-info) distributions.\n        ')), Assign(targets=[Name(id='seen', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='path', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), body=[Assign(targets=[Name(id='finder', ctx=Store())], value=Call(func=Attribute(value=Name(id='resources', ctx=Load()), attr='finder_for_path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='finder', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='')], keywords=[])), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='r', ctx=Load())), UnaryOp(op=Not(), operand=Attribute(value=Name(id='r', ctx=Load()), attr='is_container', ctx=Load()))]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='rset', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='resources', ctx=Load())], keywords=[])), For(target=Name(id='entry', ctx=Store()), iter=Name(id='rset', ctx=Load()), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='entry', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='r', ctx=Load())), Compare(left=Attribute(value=Name(id='r', ctx=Load()), attr='path', ctx=Load()), ops=[In()], comparators=[Name(id='seen', ctx=Load())])]), body=[Continue()], orelse=[]), Try(body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_dist', ctx=Load()), Call(func=Attribute(value=Name(id='entry', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='DISTINFO_EXT', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='possible_filenames', ctx=Store())], value=List(elts=[Name(id='METADATA_FILENAME', ctx=Load()), Name(id='WHEEL_METADATA_FILENAME', ctx=Load()), Name(id='LEGACY_METADATA_FILENAME', ctx=Load())], ctx=Load())), For(target=Name(id='metadata_filename', ctx=Store()), iter=Name(id='possible_filenames', ctx=Load()), body=[Assign(targets=[Name(id='metadata_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='entry', ctx=Load()), Name(id='metadata_filename', ctx=Load())], keywords=[])), Assign(targets=[Name(id='pydist', ctx=Store())], value=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='metadata_path', ctx=Load())], keywords=[])), If(test=Name(id='pydist', ctx=Load()), body=[Break()], orelse=[])], orelse=[Continue()]), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='closing', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pydist', ctx=Load()), attr='as_stream', ctx=Load()), args=[], keywords=[])], keywords=[]), optional_vars=Name(id='stream', ctx=Store()))], body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='Metadata', ctx=Load()), args=[], keywords=[keyword(arg='fileobj', value=Name(id='stream', ctx=Load())), keyword(arg='scheme', value=Constant(value='legacy'))]))]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Found %s'), Attribute(value=Name(id='r', ctx=Load()), attr='path', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='path', ctx=Load())], keywords=[])), Expr(value=Yield(value=Call(func=Name(id='new_dist_class', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='path', ctx=Load())], keywords=[keyword(arg='metadata', value=Name(id='metadata', ctx=Load())), keyword(arg='env', value=Name(id='self', ctx=Load()))])))], orelse=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_egg', ctx=Load()), Call(func=Attribute(value=Name(id='entry', ctx=Load()), attr='endswith', ctx=Load()), args=[Tuple(elts=[Constant(value='.egg-info'), Constant(value='.egg')], ctx=Load())], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Found %s'), Attribute(value=Name(id='r', ctx=Load()), attr='path', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='path', ctx=Load())], keywords=[])), Expr(value=Yield(value=Call(func=Name(id='old_dist_class', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='path', ctx=Load()), Name(id='self', ctx=Load())], keywords=[])))], orelse=[])])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Unable to read distribution at %s, perhaps due to bad metadata: %s')), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Name(id='msg', ctx=Load()), Attribute(value=Name(id='r', ctx=Load()), attr='path', ctx=Load()), Name(id='e', ctx=Load())], keywords=[])), Import(names=[alias(name='warnings')]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[BinOp(left=Name(id='msg', ctx=Load()), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='r', ctx=Load()), attr='path', ctx=Load()), Name(id='e', ctx=Load())], ctx=Load()))], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='_generate_cache', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Scan the path for distributions and populate the cache with\n        those that are found.\n        ')), Assign(targets=[Name(id='gen_dist', ctx=Store())], value=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='generated', ctx=Load()))), Assign(targets=[Name(id='gen_egg', ctx=Store())], value=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_egg', ctx=Load()), UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache_egg', ctx=Load()), attr='generated', ctx=Load()))])), If(test=BoolOp(op=Or(), values=[Name(id='gen_dist', ctx=Load()), Name(id='gen_egg', ctx=Load())]), body=[For(target=Name(id='dist', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_yield_distributions', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='InstalledDistribution', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache_egg', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))])], orelse=[]), If(test=Name(id='gen_dist', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='generated', ctx=Store())], value=Constant(value=True))], orelse=[]), If(test=Name(id='gen_egg', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache_egg', ctx=Load()), attr='generated', ctx=Store())], value=Constant(value=True))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='distinfo_dirname', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name'), arg(arg='version')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        The *name* and *version* parameters are converted into their\n        filename-escaped form, i.e. any ``'-'`` characters are replaced\n        with ``'_'`` other than the one in ``'dist-info'`` and the one\n        separating the name from the version number.\n\n        :parameter name: is converted to a standard distribution name by replacing\n                         any runs of non- alphanumeric characters with a single\n                         ``'-'``.\n        :type name: string\n        :parameter version: is converted to a standard version string. Spaces\n                            become dots, and all other non-alphanumeric characters\n                            (except dots) become dashes, with runs of multiple\n                            dashes condensed to a single dash.\n        :type version: string\n        :returns: directory name\n        :rtype: string")), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='_')], keywords=[])), Return(value=BinOp(left=Call(func=Attribute(value=Constant(value='-'), attr='join', ctx=Load()), args=[List(elts=[Name(id='name', ctx=Load()), Name(id='version', ctx=Load())], ctx=Load())], keywords=[]), op=Add(), right=Name(id='DISTINFO_EXT', ctx=Load())))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='get_distributions', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Provides an iterator that looks for distributions and returns\n        :class:`InstalledDistribution` or\n        :class:`EggInfoDistribution` instances for each one of them.\n\n        :rtype: iterator of :class:`InstalledDistribution` and\n                :class:`EggInfoDistribution` instances\n        ')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_cache_enabled', ctx=Load())), body=[For(target=Name(id='dist', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_yield_distributions', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Yield(value=Name(id='dist', ctx=Load())))], orelse=[])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_generate_cache', ctx=Load()), args=[], keywords=[])), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='path', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Yield(value=Name(id='dist', ctx=Load())))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_include_egg', ctx=Load()), body=[For(target=Name(id='dist', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache_egg', ctx=Load()), attr='path', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Yield(value=Name(id='dist', ctx=Load())))], orelse=[])], orelse=[])])], decorator_list=[]), FunctionDef(name='get_distribution', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Looks for a named distribution on the path.\n\n        This function only returns the first result found, as no more than one\n        value is expected. If nothing is found, ``None`` is returned.\n\n        :rtype: :class:`InstalledDistribution`, :class:`EggInfoDistribution`\n                or ``None``\n        ')), Assign(targets=[Name(id='result', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_cache_enabled', ctx=Load())), body=[For(target=Name(id='dist', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_yield_distributions', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Attribute(value=Name(id='dist', ctx=Load()), attr='key', ctx=Load()), ops=[Eq()], comparators=[Name(id='name', ctx=Load())]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Name(id='dist', ctx=Load())), Break()], orelse=[])], orelse=[])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_generate_cache', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='name', ctx=Load())]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Subscript(value=Subscript(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='name', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_egg', ctx=Load()), Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache_egg', ctx=Load()), attr='name', ctx=Load())])]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Subscript(value=Subscript(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache_egg', ctx=Load()), attr='name', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[])])]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='provides_distribution', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='version')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Iterates over all distributions to find which distributions provide *name*.\n        If a *version* is provided, it will be used to filter the results.\n\n        This function only returns the first result found, since no more than\n        one values are expected. If the directory is not found, returns ``None``.\n\n        :parameter version: a version specifier that indicates the version\n                            required, conforming to the format in ``PEP-345``\n\n        :type name: string\n        :type version: string\n        ')), Assign(targets=[Name(id='matcher', ctx=Store())], value=Constant(value=None)), If(test=Compare(left=Name(id='version', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Try(body=[Assign(targets=[Name(id='matcher', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_scheme', ctx=Load()), attr='matcher', ctx=Load()), args=[BinOp(left=Constant(value='%s (%s)'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='version', ctx=Load())], ctx=Load()))], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='invalid name or version: %r, %r'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='version', ctx=Load())], ctx=Load()))], keywords=[]))])], orelse=[], finalbody=[])], orelse=[]), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_distributions', ctx=Load()), args=[], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='dist', ctx=Load()), Constant(value='provides')], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='No "provides": %s'), Name(id='dist', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='provided', ctx=Store())], value=Attribute(value=Name(id='dist', ctx=Load()), attr='provides', ctx=Load())), For(target=Name(id='p', ctx=Store()), iter=Name(id='provided', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='p_name', ctx=Store()), Name(id='p_ver', ctx=Store())], ctx=Store())], value=Call(func=Name(id='parse_name_and_version', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='matcher', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='p_name', ctx=Load()), ops=[Eq()], comparators=[Name(id='name', ctx=Load())]), body=[Expr(value=Yield(value=Name(id='dist', ctx=Load()))), Break()], orelse=[])], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='p_name', ctx=Load()), ops=[Eq()], comparators=[Name(id='name', ctx=Load())]), Call(func=Attribute(value=Name(id='matcher', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='p_ver', ctx=Load())], keywords=[])]), body=[Expr(value=Yield(value=Name(id='dist', ctx=Load()))), Break()], orelse=[])])], orelse=[])])], orelse=[])], decorator_list=[]), FunctionDef(name='get_file_path', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='relative_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the path to a resource file.\n        ')), Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_distribution', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='LookupError', ctx=Load()), args=[BinOp(left=Constant(value='no distribution named %r found'), op=Mod(), right=Name(id='name', ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='get_resource_path', ctx=Load()), args=[Name(id='relative_path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_exported_entries', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='category'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Return all of the exported entries in a particular category.\n\n        :param category: The category to search for entries.\n        :param name: If specified, only entries with that name are returned.\n        ')), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_distributions', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Attribute(value=Name(id='dist', ctx=Load()), attr='exports', ctx=Load())), If(test=Compare(left=Name(id='category', ctx=Load()), ops=[In()], comparators=[Name(id='r', ctx=Load())]), body=[Assign(targets=[Name(id='d', ctx=Store())], value=Subscript(value=Name(id='r', ctx=Load()), slice=Name(id='category', ctx=Load()), ctx=Load())), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Name(id='d', ctx=Load())]), body=[Expr(value=Yield(value=Subscript(value=Name(id='d', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load())))], orelse=[])], orelse=[For(target=Name(id='v', ctx=Store()), iter=Call(func=Attribute(value=Name(id='d', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Yield(value=Name(id='v', ctx=Load())))], orelse=[])])], orelse=[])], orelse=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='Distribution', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    A base class for distributions, whether installed or from indexes.\n    Either way, it must have some metadata, so that's all that's needed\n    for construction.\n    ")), Assign(targets=[Name(id='build_time_dependency', ctx=Store())], value=Constant(value=False)), Expr(value=Constant(value="\n    Set to True if it's known to be only a build-time dependency (i.e.\n    not needed after installation).\n    ")), Assign(targets=[Name(id='requested', ctx=Store())], value=Constant(value=False)), Expr(value=Constant(value='A boolean that indicates whether the ``REQUESTED`` metadata file is\n    present (in other words, whether the package was installed by user\n    request or it was installed as a dependency).')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='metadata')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Initialise an instance.\n        :param metadata: The instance of :class:`Metadata` describing this\n        distribution.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Store())], value=Name(id='metadata', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Attribute(value=Name(id='metadata', ctx=Load()), attr='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='key', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Store())], value=Attribute(value=Name(id='metadata', ctx=Load()), attr='version', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='locator', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='digest', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='context', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='download_urls', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='digests', ctx=Store())], value=Dict(keys=[], values=[]))], decorator_list=[]), FunctionDef(name='source_url', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        The source archive download URL for this distribution.\n        ')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='source_url', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), Assign(targets=[Name(id='download_url', ctx=Store())], value=Name(id='source_url', ctx=Load())), FunctionDef(name='name_and_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        A utility property which displays the name and version in parentheses.\n        ')), Return(value=BinOp(left=Constant(value='%s (%s)'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load())], ctx=Load())))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='provides', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        A set of distribution names and versions provided by this distribution.\n        :return: A set of "name (version)" strings.\n        ')), Assign(targets=[Name(id='plist', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='provides', ctx=Load())), Assign(targets=[Name(id='s', ctx=Store())], value=BinOp(left=Constant(value='%s (%s)'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load())], ctx=Load()))), If(test=Compare(left=Name(id='s', ctx=Load()), ops=[NotIn()], comparators=[Name(id='plist', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='plist', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='plist', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_get_requirements', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req_attr')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='md', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load())), Assign(targets=[Name(id='reqts', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='md', ctx=Load()), Name(id='req_attr', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='%s: got requirements %r from metadata: %r'), Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Name(id='req_attr', ctx=Load()), Name(id='reqts', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='md', ctx=Load()), attr='get_requirements', ctx=Load()), args=[Name(id='reqts', ctx=Load())], keywords=[keyword(arg='extras', value=Attribute(value=Name(id='self', ctx=Load()), attr='extras', ctx=Load())), keyword(arg='env', value=Attribute(value=Name(id='self', ctx=Load()), attr='context', ctx=Load()))])], keywords=[]))], decorator_list=[]), FunctionDef(name='run_requires', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_requirements', ctx=Load()), args=[Constant(value='run_requires')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='meta_requires', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_requirements', ctx=Load()), args=[Constant(value='meta_requires')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='build_requires', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_requirements', ctx=Load()), args=[Constant(value='build_requires')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='test_requires', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_requirements', ctx=Load()), args=[Constant(value='test_requires')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='dev_requires', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_requirements', ctx=Load()), args=[Constant(value='dev_requires')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='matches_requirement', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Say if this instance matches (fulfills) a requirement.\n        :param req: The requirement to match.\n        :rtype req: str\n        :return: True if it matches, else False.\n        ')), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Name(id='parse_requirement', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[])), Assign(targets=[Name(id='scheme', ctx=Store())], value=Call(func=Name(id='get_scheme', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='scheme', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='matcher', ctx=Store())], value=Call(func=Attribute(value=Name(id='scheme', ctx=Load()), attr='matcher', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='requirement', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='UnsupportedVersionError', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='could not read version %r - using name only'), Name(id='req', ctx=Load())], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='req', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='matcher', ctx=Store())], value=Call(func=Attribute(value=Name(id='scheme', ctx=Load()), attr='matcher', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='matcher', ctx=Load()), attr='key', ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=Constant(value=False)), For(target=Name(id='p', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='provides', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='p_name', ctx=Store()), Name(id='p_ver', ctx=Store())], ctx=Store())], value=Call(func=Name(id='parse_name_and_version', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='p_name', ctx=Load()), ops=[NotEq()], comparators=[Name(id='name', ctx=Load())]), body=[Continue()], orelse=[]), Try(body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='matcher', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='p_ver', ctx=Load())], keywords=[])), Break()], handlers=[ExceptHandler(type=Name(id='UnsupportedVersionError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a textual representation of this instance,\n        ')), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='source_url', ctx=Load()), body=[Assign(targets=[Name(id='suffix', ctx=Store())], value=BinOp(left=Constant(value=' [%s]'), op=Mod(), right=Attribute(value=Name(id='self', ctx=Load()), attr='source_url', ctx=Load())))], orelse=[Assign(targets=[Name(id='suffix', ctx=Store())], value=Constant(value=''))]), Return(value=BinOp(left=Constant(value='<Distribution %s (%s)%s>'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load()), Name(id='suffix', ctx=Load())], ctx=Load())))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        See if this distribution is the same as another.\n        :param other: The distribution to compare with. To be equal to one\n                      another. distributions must have the same type, name,\n                      version and source_url.\n        :return: True if it is the same, else False.\n        ')), If(test=Compare(left=Call(func=Name(id='type', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Constant(value=False))], orelse=[Assign(targets=[Name(id='result', ctx=Store())], value=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='name', ctx=Load())]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='version', ctx=Load())]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='source_url', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='source_url', ctx=Load())])]))]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Compute hash in a way which matches the equality test.\n        ')), Return(value=BinOp(left=BinOp(left=Call(func=Name(id='hash', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='hash', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load())], keywords=[])), op=Add(), right=Call(func=Name(id='hash', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='source_url', ctx=Load())], keywords=[])))], decorator_list=[])], decorator_list=[]), ClassDef(name='BaseInstalledDistribution', bases=[Name(id='Distribution', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    This is the base class for installed distributions (whether PEP 376 or\n    legacy).\n    ')), Assign(targets=[Name(id='hasher', ctx=Store())], value=Constant(value=None)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='metadata'), arg(arg='path'), arg(arg='env')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Initialise an instance.\n        :param metadata: An instance of :class:`Metadata` which describes the\n                         distribution. This will normally have been initialised\n                         from a metadata file in the ``path``.\n        :param path:     The path of the ``.dist-info`` or ``.egg-info``\n                         directory for the distribution.\n        :param env:      This is normally the :class:`DistributionPath`\n                         instance where this distribution was found.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='BaseInstalledDistribution', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='metadata', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Store())], value=Name(id='path', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_path', ctx=Store())], value=Name(id='env', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_hash', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='data'), arg(arg='hasher')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n        Get the hash of some data, using a particular hash algorithm, if\n        specified.\n\n        :param data: The data to be hashed.\n        :type data: bytes\n        :param hasher: The name of a hash implementation, supported by hashlib,\n                       or ``None``. Examples of valid values are ``'sha1'``,\n                       ``'sha224'``, ``'sha384'``, '``sha256'``, ``'md5'`` and\n                       ``'sha512'``. If no hasher is specified, the ``hasher``\n                       attribute of the :class:`InstalledDistribution` instance\n                       is used. If the hasher is determined to be ``None``, MD5\n                       is used as the hashing algorithm.\n        :returns: The hash of the data. If a hasher was explicitly specified,\n                  the returned hash will be prefixed with the specified hasher\n                  followed by '='.\n        :rtype: str\n        ")), If(test=Compare(left=Name(id='hasher', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='hasher', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='hasher', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='hasher', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='hasher', ctx=Store())], value=Attribute(value=Name(id='hashlib', ctx=Load()), attr='md5', ctx=Load())), Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value=''))], orelse=[Assign(targets=[Name(id='hasher', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='hashlib', ctx=Load()), Name(id='hasher', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prefix', ctx=Store())], value=BinOp(left=Constant(value='%s='), op=Mod(), right=Attribute(value=Name(id='self', ctx=Load()), attr='hasher', ctx=Load())))]), Assign(targets=[Name(id='digest', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='hasher', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[]), attr='digest', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='digest', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='base64', ctx=Load()), attr='urlsafe_b64encode', ctx=Load()), args=[Name(id='digest', ctx=Load())], keywords=[]), attr='rstrip', ctx=Load()), args=[Constant(value=b'=')], keywords=[]), attr='decode', ctx=Load()), args=[Constant(value='ascii')], keywords=[])), Return(value=BinOp(left=Constant(value='%s%s'), op=Mod(), right=Tuple(elts=[Name(id='prefix', ctx=Load()), Name(id='digest', ctx=Load())], ctx=Load())))], decorator_list=[])], decorator_list=[]), ClassDef(name='InstalledDistribution', bases=[Name(id='BaseInstalledDistribution', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Created with the *path* of the ``.dist-info`` directory provided to the\n    constructor. It reads the metadata contained in ``pydist.json`` when it is\n    instantiated., or uses a passed in Metadata instance (useful for when\n    dry-run mode is being used).\n    ')), Assign(targets=[Name(id='hasher', ctx=Store())], value=Constant(value='sha256')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path'), arg(arg='metadata'), arg(arg='env')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='modules', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='finder', ctx=Store()), Name(id='finder', ctx=Store())], value=Call(func=Attribute(value=Name(id='resources', ctx=Load()), attr='finder_for_path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='finder', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='finder unavailable for %s'), op=Mod(), right=Name(id='path', ctx=Load()))], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='env', ctx=Load()), Attribute(value=Name(id='env', ctx=Load()), attr='_cache_enabled', ctx=Load()), Compare(left=Name(id='path', ctx=Load()), ops=[In()], comparators=[Attribute(value=Attribute(value=Name(id='env', ctx=Load()), attr='_cache', ctx=Load()), attr='path', ctx=Load())])]), body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Attribute(value=Name(id='env', ctx=Load()), attr='_cache', ctx=Load()), attr='path', ctx=Load()), slice=Name(id='path', ctx=Load()), ctx=Load()), attr='metadata', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='metadata', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='METADATA_FILENAME', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='r', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='WHEEL_METADATA_FILENAME', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='r', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='LEGACY_METADATA_FILENAME', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='r', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='no %s found in %s'), op=Mod(), right=Tuple(elts=[Name(id='METADATA_FILENAME', ctx=Load()), Name(id='path', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='closing', ctx=Load()), args=[Call(func=Attribute(value=Name(id='r', ctx=Load()), attr='as_stream', ctx=Load()), args=[], keywords=[])], keywords=[]), optional_vars=Name(id='stream', ctx=Store()))], body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='Metadata', ctx=Load()), args=[], keywords=[keyword(arg='fileobj', value=Name(id='stream', ctx=Load())), keyword(arg='scheme', value=Constant(value='legacy'))]))])], orelse=[])]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='InstalledDistribution', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='metadata', ctx=Load()), Name(id='path', ctx=Load()), Name(id='env', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='env', ctx=Load()), Attribute(value=Name(id='env', ctx=Load()), attr='_cache_enabled', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='env', ctx=Load()), attr='_cache', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='REQUESTED')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='requested', ctx=Store())], value=Compare(left=Name(id='r', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='top_level.txt')], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='p', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]), attr='decode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='modules', ctx=Store())], value=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='<InstalledDistribution %r %s at %r>'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], ctx=Load())))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='%s %s'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load())], ctx=Load())))], decorator_list=[]), FunctionDef(name='_get_records', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Get the list of installed files for the distribution\n        :return: A list of tuples of path, hash and size. Note that hash and\n                 size might be ``None`` for some entries. The path is exactly\n                 as stored in the file (which is as in PEP 376).\n        ')), Assign(targets=[Name(id='results', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_distinfo_resource', ctx=Load()), args=[Constant(value='RECORD')], keywords=[])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='closing', ctx=Load()), args=[Call(func=Attribute(value=Name(id='r', ctx=Load()), attr='as_stream', ctx=Load()), args=[], keywords=[])], keywords=[]), optional_vars=Name(id='stream', ctx=Store()))], body=[With(items=[withitem(context_expr=Call(func=Name(id='CSVReader', ctx=Load()), args=[], keywords=[keyword(arg='stream', value=Name(id='stream', ctx=Load()))]), optional_vars=Name(id='record_reader', ctx=Store()))], body=[For(target=Name(id='row', ctx=Store()), iter=Name(id='record_reader', ctx=Load()), body=[Assign(targets=[Name(id='missing', ctx=Store())], value=ListComp(elt=Constant(value=None), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='row', ctx=Load())], keywords=[]), Constant(value=3)], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Tuple(elts=[Name(id='path', ctx=Store()), Name(id='checksum', ctx=Store()), Name(id='size', ctx=Store())], ctx=Store())], value=BinOp(left=Name(id='row', ctx=Load()), op=Add(), right=Name(id='missing', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='results', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='path', ctx=Load()), Name(id='checksum', ctx=Load()), Name(id='size', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])])]), Return(value=Name(id='results', ctx=Load()))], decorator_list=[]), FunctionDef(name='exports', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the information exported by this distribution.\n        :return: A dictionary of exports, mapping an export category to a dict\n                 of :class:`ExportEntry` instances describing the individual\n                 export entries, and keyed by name.\n        ')), Assign(targets=[Name(id='result', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_distinfo_resource', ctx=Load()), args=[Name(id='EXPORTS_FILENAME', ctx=Load())], keywords=[])), If(test=Name(id='r', ctx=Load()), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_exports', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='cached_property', ctx=Load())]), FunctionDef(name='read_exports', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read exports data from a file in .ini format.\n\n        :return: A dictionary of exports, mapping an export category to a list\n                 of :class:`ExportEntry` instances describing the individual\n                 export entries.\n        ')), Assign(targets=[Name(id='result', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_distinfo_resource', ctx=Load()), args=[Name(id='EXPORTS_FILENAME', ctx=Load())], keywords=[])), If(test=Name(id='r', ctx=Load()), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='closing', ctx=Load()), args=[Call(func=Attribute(value=Name(id='r', ctx=Load()), attr='as_stream', ctx=Load()), args=[], keywords=[])], keywords=[]), optional_vars=Name(id='stream', ctx=Store()))], body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='read_exports', ctx=Load()), args=[Name(id='stream', ctx=Load())], keywords=[]))])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='write_exports', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exports')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Write a dictionary of exports to a file in .ini format.\n        :param exports: A dictionary of exports, mapping an export category to\n                        a list of :class:`ExportEntry` instances describing the\n                        individual export entries.\n        ')), Assign(targets=[Name(id='rf', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_distinfo_file', ctx=Load()), args=[Name(id='EXPORTS_FILENAME', ctx=Load())], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='rf', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Expr(value=Call(func=Name(id='write_exports', ctx=Load()), args=[Name(id='exports', ctx=Load()), Name(id='f', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='get_resource_path', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='relative_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        NOTE: This API may change in the future.\n\n        Return the absolute path to a resource file with the given relative\n        path.\n\n        :param relative_path: The path, relative to .dist-info, of the resource\n                              of interest.\n        :return: The absolute path where the resource is to be found.\n        ')), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_distinfo_resource', ctx=Load()), args=[Constant(value='RESOURCES')], keywords=[])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='closing', ctx=Load()), args=[Call(func=Attribute(value=Name(id='r', ctx=Load()), attr='as_stream', ctx=Load()), args=[], keywords=[])], keywords=[]), optional_vars=Name(id='stream', ctx=Store()))], body=[With(items=[withitem(context_expr=Call(func=Name(id='CSVReader', ctx=Load()), args=[], keywords=[keyword(arg='stream', value=Name(id='stream', ctx=Load()))]), optional_vars=Name(id='resources_reader', ctx=Store()))], body=[For(target=Tuple(elts=[Name(id='relative', ctx=Store()), Name(id='destination', ctx=Store())], ctx=Store()), iter=Name(id='resources_reader', ctx=Load()), body=[If(test=Compare(left=Name(id='relative', ctx=Load()), ops=[Eq()], comparators=[Name(id='relative_path', ctx=Load())]), body=[Return(value=Name(id='destination', ctx=Load()))], orelse=[])], orelse=[])])]), Raise(exc=Call(func=Name(id='KeyError', ctx=Load()), args=[BinOp(left=Constant(value='no resource file with relative path %r is installed'), op=Mod(), right=Name(id='relative_path', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='list_installed_files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Iterates over the ``RECORD`` entries and returns a tuple\n        ``(path, hash, size)`` for each line.\n\n        :returns: iterator of (path, hash, size)\n        ')), For(target=Name(id='result', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_records', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Yield(value=Name(id='result', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='write_installed_files', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='paths'), arg(arg='prefix'), arg(arg='dry_run')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n        Writes the ``RECORD`` file, using the ``paths`` iterable passed in. Any\n        existing ``RECORD`` file is silently overwritten.\n\n        prefix is used to determine when to write absolute paths.\n        ')), Assign(targets=[Name(id='prefix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='prefix', ctx=Load()), Constant(value='')], keywords=[])), Assign(targets=[Name(id='base', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='base_under_prefix', ctx=Store())], value=Call(func=Attribute(value=Name(id='base', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='prefix', ctx=Load())], keywords=[])), Assign(targets=[Name(id='base', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='base', ctx=Load()), Constant(value='')], keywords=[])), Assign(targets=[Name(id='record_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_distinfo_file', ctx=Load()), args=[Constant(value='RECORD')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Constant(value='creating %s'), Name(id='record_path', ctx=Load())], keywords=[])), If(test=Name(id='dry_run', ctx=Load()), body=[Return(value=Constant(value=None))], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='CSVWriter', ctx=Load()), args=[Name(id='record_path', ctx=Load())], keywords=[]), optional_vars=Name(id='writer', ctx=Store()))], body=[For(target=Name(id='path', ctx=Store()), iter=Name(id='paths', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='endswith', ctx=Load()), args=[Tuple(elts=[Constant(value='.pyc'), Constant(value='.pyo')], ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='hash_value', ctx=Store()), Name(id='size', ctx=Store())], value=Constant(value=''))], orelse=[Assign(targets=[Name(id='size', ctx=Store())], value=BinOp(left=Constant(value='%d'), op=Mod(), right=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='getsize', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='fp', ctx=Store()))], body=[Assign(targets=[Name(id='hash_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_hash', ctx=Load()), args=[Call(func=Attribute(value=Name(id='fp', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[])], keywords=[]))])]), If(test=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[]), BoolOp(op=And(), values=[Name(id='base_under_prefix', ctx=Load()), Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='prefix', ctx=Load())], keywords=[])])]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='relpath', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='base', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='writer', ctx=Load()), attr='writerow', ctx=Load()), args=[Tuple(elts=[Name(id='path', ctx=Load()), Name(id='hash_value', ctx=Load()), Name(id='size', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='record_path', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='record_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='relpath', ctx=Load()), args=[Name(id='record_path', ctx=Load()), Name(id='base', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='writer', ctx=Load()), attr='writerow', ctx=Load()), args=[Tuple(elts=[Name(id='record_path', ctx=Load()), Constant(value=''), Constant(value='')], ctx=Load())], keywords=[]))]), Return(value=Name(id='record_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='check_installed_files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Checks that the hashes and sizes of the files in ``RECORD`` are\n        matched by the files themselves. Returns a (possibly empty) list of\n        mismatches. Each entry in the mismatch list will be a tuple consisting\n        of the path, 'exists', 'size' or 'hash' according to what didn't match\n        (existence is checked first, then size, then hash), the expected\n        value and the actual value.\n        ")), Assign(targets=[Name(id='mismatches', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='base', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='record_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_distinfo_file', ctx=Load()), args=[Constant(value='RECORD')], keywords=[])), For(target=Tuple(elts=[Name(id='path', ctx=Store()), Name(id='hash_value', ctx=Store()), Name(id='size', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='list_installed_files', ctx=Load()), args=[], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isabs', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='base', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='path', ctx=Load()), ops=[Eq()], comparators=[Name(id='record_path', ctx=Load())]), body=[Continue()], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='mismatches', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='path', ctx=Load()), Constant(value='exists'), Constant(value=True), Constant(value=False)], ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='actual_size', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='getsize', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='size', ctx=Load()), Compare(left=Name(id='actual_size', ctx=Load()), ops=[NotEq()], comparators=[Name(id='size', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='mismatches', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='path', ctx=Load()), Constant(value='size'), Name(id='size', ctx=Load()), Name(id='actual_size', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='hash_value', ctx=Load()), body=[If(test=Compare(left=Constant(value='='), ops=[In()], comparators=[Name(id='hash_value', ctx=Load())]), body=[Assign(targets=[Name(id='hasher', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='hash_value', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='='), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load()))], orelse=[Assign(targets=[Name(id='hasher', ctx=Store())], value=Constant(value=None))]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='actual_hash', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_hash', ctx=Load()), args=[Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]), Name(id='hasher', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='actual_hash', ctx=Load()), ops=[NotEq()], comparators=[Name(id='hash_value', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='mismatches', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='path', ctx=Load()), Constant(value='hash'), Name(id='hash_value', ctx=Load()), Name(id='actual_hash', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])])], orelse=[])])], orelse=[])])], orelse=[]), Return(value=Name(id='mismatches', ctx=Load()))], decorator_list=[]), FunctionDef(name='shared_locations', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        A dictionary of shared locations whose keys are in the set 'prefix',\n        'purelib', 'platlib', 'scripts', 'headers', 'data' and 'namespace'.\n        The corresponding value is the absolute path of that category for\n        this distribution, and takes into account any paths selected by the\n        user at installation time (e.g. via command-line arguments). In the\n        case of the 'namespace' key, this would be a list of absolute paths\n        for the roots of namespace packages in this distribution.\n\n        The first time this property is accessed, the relevant information is\n        read from the SHARED file in the .dist-info directory.\n        ")), Assign(targets=[Name(id='result', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='shared_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), Constant(value='SHARED')], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='shared_path', ctx=Load())], keywords=[]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='codecs', ctx=Load()), attr='open', ctx=Load()), args=[Name(id='shared_path', ctx=Load()), Constant(value='r')], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]), attr='splitlines', ctx=Load()), args=[], keywords=[]))]), For(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='='), Constant(value=1)], keywords=[])), If(test=Compare(left=Name(id='key', ctx=Load()), ops=[Eq()], comparators=[Constant(value='namespace')]), body=[Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='key', ctx=Load()), List(elts=[], ctx=Load())], keywords=[]), attr='append', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Subscript(value=Name(id='result', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load()))])], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='cached_property', ctx=Load())]), FunctionDef(name='write_shared_locations', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='paths'), arg(arg='dry_run')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n        Write shared location information to the SHARED file in .dist-info.\n        :param paths: A dictionary as described in the documentation for\n        :meth:`shared_locations`.\n        :param dry_run: If True, the action is logged but no file is actually\n                        written.\n        :return: The path of the file written to.\n        ')), Assign(targets=[Name(id='shared_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), Constant(value='SHARED')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Constant(value='creating %s'), Name(id='shared_path', ctx=Load())], keywords=[])), If(test=Name(id='dry_run', ctx=Load()), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='lines', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='key', ctx=Store()), iter=Tuple(elts=[Constant(value='prefix'), Constant(value='lib'), Constant(value='headers'), Constant(value='scripts'), Constant(value='data')], ctx=Load()), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Subscript(value=Name(id='paths', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Subscript(value=Name(id='paths', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='%s=%s'), op=Mod(), right=Tuple(elts=[Name(id='key', ctx=Load()), Name(id='path', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[])], orelse=[]), For(target=Name(id='ns', ctx=Store()), iter=Call(func=Attribute(value=Name(id='paths', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='namespace'), Tuple(elts=[], ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='namespace=%s'), op=Mod(), right=Name(id='ns', ctx=Load()))], keywords=[]))], orelse=[]), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='codecs', ctx=Load()), attr='open', ctx=Load()), args=[Name(id='shared_path', ctx=Load()), Constant(value='w')], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='f', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])], keywords=[]))]), Return(value=Name(id='shared_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_distinfo_resource', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='path', ctx=Load()), ops=[NotIn()], comparators=[Name(id='DIST_FILES', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='invalid path for a dist-info file: %r at %r'), op=Mod(), right=Tuple(elts=[Name(id='path', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='finder', ctx=Store())], value=Call(func=Attribute(value=Name(id='resources', ctx=Load()), attr='finder_for_path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='finder', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='Unable to get a finder for %s'), op=Mod(), right=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='finder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_distinfo_file', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Returns a path located under the ``.dist-info`` directory. Returns a\n        string representing the path.\n\n        :parameter path: a ``'/'``-separated path relative to the\n                         ``.dist-info`` directory or an absolute path;\n                         If *path* is an absolute path and doesn't start\n                         with the ``.dist-info`` directory path,\n                         a :class:`DistlibException` is raised\n        :type path: str\n        :rtype: str\n        ")), If(test=Compare(left=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='find', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())], keywords=[]), ops=[GtE()], comparators=[Constant(value=0)]), body=[Assign(targets=[Tuple(elts=[Name(id='distinfo_dirname', ctx=Store()), Name(id='path', ctx=Store())], ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='split', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Constant(value=2))), ctx=Load())), If(test=Compare(left=Name(id='distinfo_dirname', ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='dist-info file %r does not belong to the %r %s distribution'), op=Mod(), right=Tuple(elts=[Name(id='path', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='path', ctx=Load()), ops=[NotIn()], comparators=[Name(id='DIST_FILES', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='invalid path for a dist-info file: %r at %r'), op=Mod(), right=Tuple(elts=[Name(id='path', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='list_distinfo_files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Iterates over the ``RECORD`` entries and returns paths for each line if\n        the path is pointing to a file located in the ``.dist-info`` directory\n        or one of its subdirectories.\n\n        :returns: iterator of paths\n        ')), Assign(targets=[Name(id='base', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='path', ctx=Store()), Name(id='checksum', ctx=Store()), Name(id='size', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_records', ctx=Load()), args=[], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isabs', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='base', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='startswith', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='path', ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='InstalledDistribution', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='path', ctx=Load())])]))], decorator_list=[]), Assign(targets=[Name(id='__hash__', ctx=Store())], value=Attribute(value=Name(id='object', ctx=Load()), attr='__hash__', ctx=Load()))], decorator_list=[]), ClassDef(name='EggInfoDistribution', bases=[Name(id='BaseInstalledDistribution', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Created with the *path* of the ``.egg-info`` directory or file provided\n    to the constructor. It reads the metadata contained in the file itself, or\n    if the given path happens to be a directory, the metadata is read from the\n    file ``PKG-INFO`` under that directory.')), Assign(targets=[Name(id='requested', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='shared_locations', ctx=Store())], value=Dict(keys=[], values=[])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path'), arg(arg='env')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[FunctionDef(name='set_name_and_version', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='n'), arg(arg='v')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='s', ctx=Load()), attr='name', ctx=Store())], value=Name(id='n', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s', ctx=Load()), attr='key', ctx=Store())], value=Call(func=Attribute(value=Name(id='n', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='s', ctx=Load()), attr='version', ctx=Store())], value=Name(id='v', ctx=Load()))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Store())], value=Name(id='path', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_path', ctx=Store())], value=Name(id='env', ctx=Load())), If(test=BoolOp(op=And(), values=[Name(id='env', ctx=Load()), Attribute(value=Name(id='env', ctx=Load()), attr='_cache_enabled', ctx=Load()), Compare(left=Name(id='path', ctx=Load()), ops=[In()], comparators=[Attribute(value=Attribute(value=Name(id='env', ctx=Load()), attr='_cache_egg', ctx=Load()), attr='path', ctx=Load())])]), body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Attribute(value=Name(id='env', ctx=Load()), attr='_cache_egg', ctx=Load()), attr='path', ctx=Load()), slice=Name(id='path', ctx=Load()), ctx=Load()), attr='metadata', ctx=Load())), Expr(value=Call(func=Name(id='set_name_and_version', ctx=Load()), args=[Name(id='self', ctx=Load()), Attribute(value=Name(id='metadata', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='metadata', ctx=Load()), attr='version', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_metadata', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='set_name_and_version', ctx=Load()), args=[Name(id='self', ctx=Load()), Attribute(value=Name(id='metadata', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='metadata', ctx=Load()), attr='version', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='env', ctx=Load()), Attribute(value=Name(id='env', ctx=Load()), attr='_cache_enabled', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='env', ctx=Load()), attr='_cache_egg', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='EggInfoDistribution', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='metadata', ctx=Load()), Name(id='path', ctx=Load()), Name(id='env', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_get_metadata', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='requires', ctx=Store())], value=Constant(value=None)), FunctionDef(name='parse_requires_data', args=arguments(posonlyargs=[], args=[arg(arg='data')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a list of dependencies from a requires.txt file.\n\n            *data*: the contents of a setuptools-produced requires.txt file.\n            ')), Assign(targets=[Name(id='reqs', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])), For(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='[')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Unexpected line: quitting requirement scan: %r'), Name(id='line', ctx=Load())], keywords=[])), Break()], orelse=[]), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Name(id='parse_requirement', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='r', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Not recognised as a requirement: %r'), Name(id='line', ctx=Load())], keywords=[])), Continue()], orelse=[]), If(test=Attribute(value=Name(id='r', ctx=Load()), attr='extras', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='extra requirements in requires.txt are not supported')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='r', ctx=Load()), attr='constraints', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='reqs', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='name', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='cons', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Constant(value='%s%s'), op=Mod(), right=Name(id='c', ctx=Load())), generators=[comprehension(target=Name(id='c', ctx=Store()), iter=Attribute(value=Name(id='r', ctx=Load()), attr='constraints', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='reqs', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='%s (%s)'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='r', ctx=Load()), attr='name', ctx=Load()), Name(id='cons', ctx=Load())], ctx=Load()))], keywords=[]))])], orelse=[]), Return(value=Name(id='reqs', ctx=Load()))], decorator_list=[]), FunctionDef(name='parse_requires_path', args=arguments(posonlyargs=[], args=[arg(arg='req_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a list of dependencies from a requires.txt file.\n\n            *req_path*: the path to a setuptools-produced requires.txt file.\n            ')), Assign(targets=[Name(id='reqs', ctx=Store())], value=List(elts=[], ctx=Load())), Try(body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='codecs', ctx=Load()), attr='open', ctx=Load()), args=[Name(id='req_path', ctx=Load()), Constant(value='r'), Constant(value='utf-8')], keywords=[]), optional_vars=Name(id='fp', ctx=Store()))], body=[Assign(targets=[Name(id='reqs', ctx=Store())], value=Call(func=Name(id='parse_requires_data', ctx=Load()), args=[Call(func=Attribute(value=Name(id='fp', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[])], keywords=[]))])], handlers=[ExceptHandler(type=Name(id='IOError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Name(id='reqs', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='tl_path', ctx=Store()), Name(id='tl_data', ctx=Store())], value=Constant(value=None)), If(test=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.egg')], keywords=[]), body=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='EGG-INFO')], keywords=[])), Assign(targets=[Name(id='meta_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='p', ctx=Load()), Constant(value='PKG-INFO')], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='Metadata', ctx=Load()), args=[], keywords=[keyword(arg='path', value=Name(id='meta_path', ctx=Load())), keyword(arg='scheme', value=Constant(value='legacy'))])), Assign(targets=[Name(id='req_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='p', ctx=Load()), Constant(value='requires.txt')], keywords=[])), Assign(targets=[Name(id='tl_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='p', ctx=Load()), Constant(value='top_level.txt')], keywords=[])), Assign(targets=[Name(id='requires', ctx=Store())], value=Call(func=Name(id='parse_requires_path', ctx=Load()), args=[Name(id='req_path', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='zipf', ctx=Store())], value=Call(func=Attribute(value=Name(id='zipimport', ctx=Load()), attr='zipimporter', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='fileobj', ctx=Store())], value=Call(func=Name(id='StringIO', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='zipf', ctx=Load()), attr='get_data', ctx=Load()), args=[Constant(value='EGG-INFO/PKG-INFO')], keywords=[]), attr='decode', ctx=Load()), args=[Constant(value='utf8')], keywords=[])], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='Metadata', ctx=Load()), args=[], keywords=[keyword(arg='fileobj', value=Name(id='fileobj', ctx=Load())), keyword(arg='scheme', value=Constant(value='legacy'))])), Try(body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='zipf', ctx=Load()), attr='get_data', ctx=Load()), args=[Constant(value='EGG-INFO/requires.txt')], keywords=[])), Assign(targets=[Name(id='tl_data', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='zipf', ctx=Load()), attr='get_data', ctx=Load()), args=[Constant(value='EGG-INFO/top_level.txt')], keywords=[]), attr='decode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[])), Assign(targets=[Name(id='requires', ctx=Store())], value=Call(func=Name(id='parse_requires_data', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='IOError', ctx=Load()), body=[Assign(targets=[Name(id='requires', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[])])], orelse=[If(test=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.egg-info')], keywords=[]), body=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='req_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='requires.txt')], keywords=[])), Assign(targets=[Name(id='requires', ctx=Store())], value=Call(func=Name(id='parse_requires_path', ctx=Load()), args=[Name(id='req_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='PKG-INFO')], keywords=[])), Assign(targets=[Name(id='tl_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='top_level.txt')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='Metadata', ctx=Load()), args=[], keywords=[keyword(arg='path', value=Name(id='path', ctx=Load())), keyword(arg='scheme', value=Constant(value='legacy'))]))], orelse=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='path must end with .egg-info or .egg, got %r'), op=Mod(), right=Name(id='path', ctx=Load()))], keywords=[]))])]), If(test=Name(id='requires', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='add_requirements', ctx=Load()), args=[Name(id='requires', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='tl_data', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='tl_path', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='tl_path', ctx=Load())], keywords=[])]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='tl_path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='tl_data', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]), attr='decode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[]))])], orelse=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='tl_data', ctx=Load())), body=[Assign(targets=[Name(id='tl_data', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[Assign(targets=[Name(id='tl_data', ctx=Store())], value=Call(func=Attribute(value=Name(id='tl_data', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='modules', ctx=Store())], value=Name(id='tl_data', ctx=Load())), Return(value=Name(id='metadata', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='<EggInfoDistribution %r %s at %r>'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], ctx=Load())))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='%s %s'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load())], ctx=Load())))], decorator_list=[]), FunctionDef(name='check_installed_files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Checks that the hashes and sizes of the files in ``RECORD`` are\n        matched by the files themselves. Returns a (possibly empty) list of\n        mismatches. Each entry in the mismatch list will be a tuple consisting\n        of the path, 'exists', 'size' or 'hash' according to what didn't match\n        (existence is checked first, then size, then hash), the expected\n        value and the actual value.\n        ")), Assign(targets=[Name(id='mismatches', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='record_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), Constant(value='installed-files.txt')], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='record_path', ctx=Load())], keywords=[]), body=[For(target=Tuple(elts=[Name(id='path', ctx=Store()), Name(id='_', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='list_installed_files', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='path', ctx=Load()), ops=[Eq()], comparators=[Name(id='record_path', ctx=Load())]), body=[Continue()], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='mismatches', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='path', ctx=Load()), Constant(value='exists'), Constant(value=True), Constant(value=False)], ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='mismatches', ctx=Load()))], decorator_list=[]), FunctionDef(name='list_installed_files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Iterates over the ``installed-files.txt`` entries and returns a tuple\n        ``(path, hash, size)`` for each line.\n\n        :returns: a list of (path, hash, size)\n        ')), FunctionDef(name='_md5', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='f', ctx=Store())], value=Call(func=Name(id='open', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='rb')], keywords=[])), Try(body=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='hashlib', ctx=Load()), attr='md5', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[]), attr='hexdigest', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_size', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='stat', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), attr='st_size', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='record_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), Constant(value='installed-files.txt')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='record_path', ctx=Load())], keywords=[]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='codecs', ctx=Load()), attr='open', ctx=Load()), args=[Name(id='record_path', ctx=Load()), Constant(value='r')], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='f', ctx=Store()))], body=[For(target=Name(id='line', ctx=Store()), iter=Name(id='f', ctx=Load()), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), Name(id='line', ctx=Load())], keywords=[])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Non-existent file: %s'), Name(id='p', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='endswith', ctx=Load()), args=[Tuple(elts=[Constant(value='.pyc'), Constant(value='.pyo')], ctx=Load())], keywords=[]), body=[Continue()], orelse=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='p', ctx=Load()), Call(func=Name(id='_md5', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[]), Call(func=Name(id='_size', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])], ctx=Load())], keywords=[]))], orelse=[])], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='record_path', ctx=Load()), Constant(value=None), Constant(value=None)], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='list_distinfo_files', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='absolute')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n        Iterates over the ``installed-files.txt`` entries and returns paths for\n        each line if the path is pointing to a file located in the\n        ``.egg-info`` directory or one of its subdirectories.\n\n        :parameter absolute: If *absolute* is ``True``, each returned path is\n                          transformed into a local absolute path. Otherwise the\n                          raw value from ``installed-files.txt`` is returned.\n        :type absolute: boolean\n        :returns: iterator of paths\n        ')), Assign(targets=[Name(id='record_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), Constant(value='installed-files.txt')], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='record_path', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='skip', ctx=Store())], value=Constant(value=True)), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='codecs', ctx=Load()), attr='open', ctx=Load()), args=[Name(id='record_path', ctx=Load()), Constant(value='r')], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='f', ctx=Store()))], body=[For(target=Name(id='line', ctx=Store()), iter=Name(id='f', ctx=Load()), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='line', ctx=Load()), ops=[Eq()], comparators=[Constant(value='./')]), body=[Assign(targets=[Name(id='skip', ctx=Store())], value=Constant(value=False)), Continue()], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='skip', ctx=Load())), body=[Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), Name(id='line', ctx=Load())], keywords=[])], keywords=[])), If(test=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='startswith', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[]), body=[If(test=Name(id='absolute', ctx=Load()), body=[Expr(value=Yield(value=Name(id='p', ctx=Load())))], orelse=[Expr(value=Yield(value=Name(id='line', ctx=Load())))])], orelse=[])], orelse=[])], orelse=[])])], orelse=[])], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='EggInfoDistribution', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='path', ctx=Load())])]))], decorator_list=[]), Assign(targets=[Name(id='__hash__', ctx=Store())], value=Attribute(value=Name(id='object', ctx=Load()), attr='__hash__', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='new_dist_class', ctx=Store())], value=Name(id='InstalledDistribution', ctx=Load())), Assign(targets=[Name(id='old_dist_class', ctx=Store())], value=Name(id='EggInfoDistribution', ctx=Load())), ClassDef(name='DependencyGraph', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Represents a dependency graph between distributions.\n\n    The dependency relationships are stored in an ``adjacency_list`` that maps\n    distributions to a list of ``(other, label)`` tuples where  ``other``\n    is a distribution and the edge is labeled with ``label`` (i.e. the version\n    specifier, if such was provided). Also, for more efficient traversal, for\n    every distribution ``x``, a list of predecessors is kept in\n    ``reverse_list[x]``. An edge from distribution ``a`` to\n    distribution ``b`` means that ``a`` depends on ``b``. If any missing\n    dependencies are found, they are stored in ``missing``, which is a\n    dictionary that maps distributions to a list of requirements that were not\n    provided by any other distributions.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='adjacency_list', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='reverse_list', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Store())], value=Dict(keys=[], values=[]))], decorator_list=[]), FunctionDef(name='add_distribution', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='distribution')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add the *distribution* to the graph.\n\n        :type distribution: :class:`distutils2.database.InstalledDistribution`\n                            or :class:`distutils2.database.EggInfoDistribution`\n        ')), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='adjacency_list', ctx=Load()), slice=Name(id='distribution', ctx=Load()), ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='reverse_list', ctx=Load()), slice=Name(id='distribution', ctx=Load()), ctx=Store())], value=List(elts=[], ctx=Load()))], decorator_list=[]), FunctionDef(name='add_edge', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x'), arg(arg='y'), arg(arg='label')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Add an edge from distribution *x* to distribution *y* with the given\n        *label*.\n\n        :type x: :class:`distutils2.database.InstalledDistribution` or\n                 :class:`distutils2.database.EggInfoDistribution`\n        :type y: :class:`distutils2.database.InstalledDistribution` or\n                 :class:`distutils2.database.EggInfoDistribution`\n        :type label: ``str`` or ``None``\n        ')), Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='adjacency_list', ctx=Load()), slice=Name(id='x', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='y', ctx=Load()), Name(id='label', ctx=Load())], ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='x', ctx=Load()), ops=[NotIn()], comparators=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='reverse_list', ctx=Load()), slice=Name(id='y', ctx=Load()), ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='reverse_list', ctx=Load()), slice=Name(id='y', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='add_missing', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='distribution'), arg(arg='requirement')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Add a missing *requirement* for the given *distribution*.\n\n        :type distribution: :class:`distutils2.database.InstalledDistribution`\n                            or :class:`distutils2.database.EggInfoDistribution`\n        :type requirement: ``str``\n        ')), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='%s missing %r'), Name(id='distribution', ctx=Load()), Name(id='requirement', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='distribution', ctx=Load()), List(elts=[], ctx=Load())], keywords=[]), attr='append', ctx=Load()), args=[Name(id='requirement', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_repr_dist', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='%s %s'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='dist', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='dist', ctx=Load()), attr='version', ctx=Load())], ctx=Load())))], decorator_list=[]), FunctionDef(name='repr_node', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist'), arg(arg='level')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1)]), body=[Expr(value=Constant(value='Prints only a subgraph')), Assign(targets=[Name(id='output', ctx=Store())], value=List(elts=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_repr_dist', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[])], ctx=Load())), For(target=Tuple(elts=[Name(id='other', ctx=Store()), Name(id='label', ctx=Store())], ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='adjacency_list', ctx=Load()), slice=Name(id='dist', ctx=Load()), ctx=Load()), body=[Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_repr_dist', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='label', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='dist', ctx=Store())], value=BinOp(left=Constant(value='%s [%s]'), op=Mod(), right=Tuple(elts=[Name(id='dist', ctx=Load()), Name(id='label', ctx=Load())], ctx=Load())))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='output', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value='    '), op=Mult(), right=Name(id='level', ctx=Load())), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], keywords=[])), Assign(targets=[Name(id='suboutput', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='repr_node', ctx=Load()), args=[Name(id='other', ctx=Load()), BinOp(left=Name(id='level', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[])), Assign(targets=[Name(id='subs', ctx=Store())], value=Call(func=Attribute(value=Name(id='suboutput', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='output', ctx=Load()), attr='extend', ctx=Load()), args=[Subscript(value=Name(id='subs', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='output', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='to_dot', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='f'), arg(arg='skip_disconnected')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Writes a DOT output for the graph to the provided file *f*.\n\n        If *skip_disconnected* is set to ``True``, then all distributions\n        that are not dependent on any other distribution are skipped.\n\n        :type f: has to support ``file``-like operations\n        :type skip_disconnected: ``bool``\n        ')), Assign(targets=[Name(id='disconnected', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='digraph dependencies {\n')], keywords=[])), For(target=Tuple(elts=[Name(id='dist', ctx=Store()), Name(id='adjs', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='adjacency_list', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='adjs', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=0)]), UnaryOp(op=Not(), operand=Name(id='skip_disconnected', ctx=Load()))]), body=[Expr(value=Call(func=Attribute(value=Name(id='disconnected', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]))], orelse=[]), For(target=Tuple(elts=[Name(id='other', ctx=Store()), Name(id='label', ctx=Store())], ctx=Store()), iter=Name(id='adjs', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='label', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])), body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[BinOp(left=Constant(value='"%s" -> "%s" [label="%s"]\n'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='dist', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='other', ctx=Load()), attr='name', ctx=Load()), Name(id='label', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[BinOp(left=Constant(value='"%s" -> "%s"\n'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='dist', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='other', ctx=Load()), attr='name', ctx=Load())], ctx=Load()))], keywords=[]))])], orelse=[])], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='skip_disconnected', ctx=Load())), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='disconnected', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=0)])]), body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='subgraph disconnected {\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='label = "Disconnected"\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='bgcolor = red\n')], keywords=[])), For(target=Name(id='dist', ctx=Store()), iter=Name(id='disconnected', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[BinOp(left=Constant(value='"%s"'), op=Mod(), right=Attribute(value=Name(id='dist', ctx=Load()), attr='name', ctx=Load()))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='\n')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='}\n')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='}\n')], keywords=[]))], decorator_list=[]), FunctionDef(name='topological_sort', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Perform a topological sort of the graph.\n        :return: A tuple, the first element of which is a topologically sorted\n                 list of distributions, and the second element of which is a\n                 list of distributions that cannot be sorted because they have\n                 circular dependencies and so form a cycle.\n        ')), Assign(targets=[Name(id='result', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='alist', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='adjacency_list', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='alist', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Store())], value=Subscript(value=Name(id='v', ctx=Load()), slice=Slice(), ctx=Load()))], orelse=[]), While(test=Constant(value=True), body=[Assign(targets=[Name(id='to_remove', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Subscript(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='alist', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[]), slice=Slice(), ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Name(id='v', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='to_remove', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Delete(targets=[Subscript(value=Name(id='alist', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Del())])], orelse=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='to_remove', ctx=Load())), body=[Break()], orelse=[]), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='alist', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='alist', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Store())], value=ListComp(elt=Tuple(elts=[Name(id='d', ctx=Load()), Name(id='r', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='d', ctx=Store()), Name(id='r', ctx=Store())], ctx=Store()), iter=Name(id='v', ctx=Load()), ifs=[Compare(left=Name(id='d', ctx=Load()), ops=[NotIn()], comparators=[Name(id='to_remove', ctx=Load())])], is_async=0)]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Moving to result: %s'), ListComp(elt=BinOp(left=Constant(value='%s (%s)'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='d', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='d', ctx=Load()), attr='version', ctx=Load())], ctx=Load())), generators=[comprehension(target=Name(id='d', ctx=Store()), iter=Name(id='to_remove', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='to_remove', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='result', ctx=Load()), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='alist', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])], ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Representation of the graph')), Assign(targets=[Name(id='output', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='dist', ctx=Store()), Name(id='adjs', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='adjacency_list', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='output', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='repr_node', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='output', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='make_graph', args=arguments(posonlyargs=[], args=[arg(arg='dists'), arg(arg='scheme')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='default')]), body=[Expr(value=Constant(value='Makes a dependency graph from the given distributions.\n\n    :parameter dists: a list of distributions\n    :type dists: list of :class:`distutils2.database.InstalledDistribution` and\n                 :class:`distutils2.database.EggInfoDistribution` instances\n    :rtype: a :class:`DependencyGraph` instance\n    ')), Assign(targets=[Name(id='scheme', ctx=Store())], value=Call(func=Name(id='get_scheme', ctx=Load()), args=[Name(id='scheme', ctx=Load())], keywords=[])), Assign(targets=[Name(id='graph', ctx=Store())], value=Call(func=Name(id='DependencyGraph', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='provided', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='dist', ctx=Store()), iter=Name(id='dists', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='graph', ctx=Load()), attr='add_distribution', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[])), For(target=Name(id='p', ctx=Store()), iter=Attribute(value=Name(id='dist', ctx=Load()), attr='provides', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='version', ctx=Store())], ctx=Store())], value=Call(func=Name(id='parse_name_and_version', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Add to provided: %s, %s, %s'), Name(id='name', ctx=Load()), Name(id='version', ctx=Load()), Name(id='dist', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='provided', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='name', ctx=Load()), List(elts=[], ctx=Load())], keywords=[]), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='version', ctx=Load()), Name(id='dist', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), For(target=Name(id='dist', ctx=Store()), iter=Name(id='dists', ctx=Load()), body=[Assign(targets=[Name(id='requires', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='dist', ctx=Load()), attr='run_requires', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='dist', ctx=Load()), attr='meta_requires', ctx=Load())), op=BitOr(), right=Attribute(value=Name(id='dist', ctx=Load()), attr='build_requires', ctx=Load())), op=BitOr(), right=Attribute(value=Name(id='dist', ctx=Load()), attr='dev_requires', ctx=Load()))), For(target=Name(id='req', ctx=Store()), iter=Name(id='requires', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='matcher', ctx=Store())], value=Call(func=Attribute(value=Name(id='scheme', ctx=Load()), attr='matcher', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='UnsupportedVersionError', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='could not read version %r - using name only'), Name(id='req', ctx=Load())], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='req', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='matcher', ctx=Store())], value=Call(func=Attribute(value=Name(id='scheme', ctx=Load()), attr='matcher', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='matcher', ctx=Load()), attr='key', ctx=Load())), Assign(targets=[Name(id='matched', ctx=Store())], value=Constant(value=False)), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Name(id='provided', ctx=Load())]), body=[For(target=Tuple(elts=[Name(id='version', ctx=Store()), Name(id='provider', ctx=Store())], ctx=Store()), iter=Subscript(value=Name(id='provided', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='matcher', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='UnsupportedVersionError', ctx=Load()), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[]), If(test=Name(id='match', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='graph', ctx=Load()), attr='add_edge', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='provider', ctx=Load()), Name(id='req', ctx=Load())], keywords=[])), Assign(targets=[Name(id='matched', ctx=Store())], value=Constant(value=True)), Break()], orelse=[])], orelse=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='matched', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='graph', ctx=Load()), attr='add_missing', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='req', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='graph', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_dependent_dists', args=arguments(posonlyargs=[], args=[arg(arg='dists'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Recursively generate a list of distributions from *dists* that are\n    dependent on *dist*.\n\n    :param dists: a list of distributions\n    :param dist: a distribution, member of *dists* for which we are interested\n    ')), If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[NotIn()], comparators=[Name(id='dists', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='given distribution %r is not a member of the list'), op=Mod(), right=Attribute(value=Name(id='dist', ctx=Load()), attr='name', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='graph', ctx=Store())], value=Call(func=Name(id='make_graph', ctx=Load()), args=[Name(id='dists', ctx=Load())], keywords=[])), Assign(targets=[Name(id='dep', ctx=Store())], value=List(elts=[Name(id='dist', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='todo', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='graph', ctx=Load()), attr='reverse_list', ctx=Load()), slice=Name(id='dist', ctx=Load()), ctx=Load())), While(test=Name(id='todo', ctx=Load()), body=[Assign(targets=[Name(id='d', ctx=Store())], value=Call(func=Attribute(value=Name(id='todo', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='dep', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='d', ctx=Load())], keywords=[])), For(target=Name(id='succ', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='graph', ctx=Load()), attr='reverse_list', ctx=Load()), slice=Name(id='d', ctx=Load()), ctx=Load()), body=[If(test=Compare(left=Name(id='succ', ctx=Load()), ops=[NotIn()], comparators=[Name(id='dep', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='todo', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='succ', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='dep', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value=0)], keywords=[])), Return(value=Name(id='dep', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_required_dists', args=arguments(posonlyargs=[], args=[arg(arg='dists'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Recursively generate a list of distributions from *dists* that are\n    required by *dist*.\n\n    :param dists: a list of distributions\n    :param dist: a distribution, member of *dists* for which we are interested\n                 in finding the dependencies.\n    ')), If(test=Compare(left=Name(id='dist', ctx=Load()), ops=[NotIn()], comparators=[Name(id='dists', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='given distribution %r is not a member of the list'), op=Mod(), right=Attribute(value=Name(id='dist', ctx=Load()), attr='name', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='graph', ctx=Store())], value=Call(func=Name(id='make_graph', ctx=Load()), args=[Name(id='dists', ctx=Load())], keywords=[])), Assign(targets=[Name(id='req', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='todo', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='graph', ctx=Load()), attr='adjacency_list', ctx=Load()), slice=Name(id='dist', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='seen', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Name(id='todo', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), While(test=Name(id='todo', ctx=Load()), body=[Assign(targets=[Name(id='d', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='todo', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[]), slice=Constant(value=0), ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='req', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='d', ctx=Load())], keywords=[])), Assign(targets=[Name(id='pred_list', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='graph', ctx=Load()), attr='adjacency_list', ctx=Load()), slice=Name(id='d', ctx=Load()), ctx=Load())), For(target=Name(id='pred', ctx=Store()), iter=Name(id='pred_list', ctx=Load()), body=[Assign(targets=[Name(id='d', ctx=Store())], value=Subscript(value=Name(id='pred', ctx=Load()), slice=Constant(value=0), ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='d', ctx=Load()), ops=[NotIn()], comparators=[Name(id='req', ctx=Load())]), Compare(left=Name(id='d', ctx=Load()), ops=[NotIn()], comparators=[Name(id='seen', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='d', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='todo', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='pred', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='req', ctx=Load()))], decorator_list=[]), FunctionDef(name='make_dist', args=arguments(posonlyargs=[], args=[arg(arg='name'), arg(arg='version')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='\n    A convenience method for making a dist given just a name and version.\n    ')), Assign(targets=[Name(id='summary', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='summary'), Constant(value='Placeholder for summary')], keywords=[])), Assign(targets=[Name(id='md', ctx=Store())], value=Call(func=Name(id='Metadata', ctx=Load()), args=[], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='md', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='md', ctx=Load()), attr='version', ctx=Store())], value=Name(id='version', ctx=Load())), Assign(targets=[Attribute(value=Name(id='md', ctx=Load()), attr='summary', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='summary', ctx=Load()), Constant(value='Placeholder for summary')])), Return(value=Call(func=Name(id='Distribution', ctx=Load()), args=[Name(id='md', ctx=Load())], keywords=[]))], decorator_list=[])], type_ignores=[])