Module(body=[Expr(value=Constant(value='\n\n    webencodings\n    ~~~~~~~~~~~~\n\n    This is a Python implementation of the `WHATWG Encoding standard\n    <http://encoding.spec.whatwg.org/>`. See README for details.\n\n    :copyright: Copyright 2012 by Simon Sapin\n    :license: BSD, see LICENSE for details.\n\n')), ImportFrom(module='__future__', names=[alias(name='unicode_literals')], level=0), Import(names=[alias(name='codecs')]), ImportFrom(module='labels', names=[alias(name='LABELS')], level=1), Assign(targets=[Name(id='VERSION', ctx=Store())], value=Constant(value='0.5.1')), Assign(targets=[Name(id='PYTHON_NAMES', ctx=Store())], value=Dict(keys=[Constant(value='iso-8859-8-i'), Constant(value='x-mac-cyrillic'), Constant(value='macintosh'), Constant(value='windows-874')], values=[Constant(value='iso-8859-8'), Constant(value='mac-cyrillic'), Constant(value='mac-roman'), Constant(value='cp874')])), Assign(targets=[Name(id='CACHE', ctx=Store())], value=Dict(keys=[], values=[])), FunctionDef(name='ascii_lower', args=arguments(posonlyargs=[], args=[arg(arg='string')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Transform (only) ASCII letters to lower case: A-Z is mapped to a-z.\n\n    :param string: An Unicode string.\n    :returns: A new Unicode string.\n\n    This is used for `ASCII case-insensitive\n    <http://encoding.spec.whatwg.org/#ascii-case-insensitive>`_\n    matching of encoding labels.\n    The same matching is also used, among other things,\n    for `CSS keywords <http://dev.w3.org/csswg/css-values/#keywords>`_.\n\n    This is different from the :meth:`~py:str.lower` method of Unicode strings\n    which also affect non-ASCII characters,\n    sometimes mapping them into the ASCII range:\n\n        >>> keyword = u'Bac\\N{KELVIN SIGN}ground'\n        >>> assert keyword.lower() == u'background'\n        >>> assert ascii_lower(keyword) != keyword.lower()\n        >>> assert ascii_lower(keyword) == u'bac\\N{KELVIN SIGN}ground'\n\n    ")), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='string', ctx=Load()), attr='encode', ctx=Load()), args=[Constant(value='utf8')], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[]), attr='decode', ctx=Load()), args=[Constant(value='utf8')], keywords=[]))], decorator_list=[]), FunctionDef(name='lookup', args=arguments(posonlyargs=[], args=[arg(arg='label')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Look for an encoding by its label.\n    This is the spec’s `get an encoding\n    <http://encoding.spec.whatwg.org/#concept-encoding-get>`_ algorithm.\n    Supported labels are listed there.\n\n    :param label: A string.\n    :returns:\n        An :class:`Encoding` object, or :obj:`None` for an unknown label.\n\n    ')), Assign(targets=[Name(id='label', ctx=Store())], value=Call(func=Name(id='ascii_lower', ctx=Load()), args=[Call(func=Attribute(value=Name(id='label', ctx=Load()), attr='strip', ctx=Load()), args=[Constant(value='\t\n\x0c\r ')], keywords=[])], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='LABELS', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='label', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='encoding', ctx=Store())], value=Call(func=Attribute(value=Name(id='CACHE', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='encoding', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='x-user-defined')]), body=[ImportFrom(module='x_user_defined', names=[alias(name='codec_info')], level=1)], orelse=[Assign(targets=[Name(id='python_name', ctx=Store())], value=Call(func=Attribute(value=Name(id='PYTHON_NAMES', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='codec_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='codecs', ctx=Load()), attr='lookup', ctx=Load()), args=[Name(id='python_name', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='encoding', ctx=Store())], value=Call(func=Name(id='Encoding', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='codec_info', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='CACHE', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Name(id='encoding', ctx=Load()))], orelse=[]), Return(value=Name(id='encoding', ctx=Load()))], decorator_list=[]), FunctionDef(name='_get_encoding', args=arguments(posonlyargs=[], args=[arg(arg='encoding_or_label')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Accept either an encoding object or label.\n\n    :param encoding: An :class:`Encoding` object or a label string.\n    :returns: An :class:`Encoding` object.\n    :raises: :exc:`~exceptions.LookupError` for an unknown label.\n\n    ')), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='encoding_or_label', ctx=Load()), Constant(value='codec_info')], keywords=[]), body=[Return(value=Name(id='encoding_or_label', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='encoding', ctx=Store())], value=Call(func=Name(id='lookup', ctx=Load()), args=[Name(id='encoding_or_label', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='encoding', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='LookupError', ctx=Load()), args=[BinOp(left=Constant(value='Unknown encoding label: %r'), op=Mod(), right=Name(id='encoding_or_label', ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Name(id='encoding', ctx=Load()))], decorator_list=[]), ClassDef(name='Encoding', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Reresents a character encoding such as UTF-8,\n    that can be used for decoding or encoding.\n\n    .. attribute:: name\n\n        Canonical name of the encoding\n\n    .. attribute:: codec_info\n\n        The actual implementation of the encoding,\n        a stdlib :class:`~codecs.CodecInfo` object.\n        See :func:`codecs.register`.\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='codec_info')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='codec_info', ctx=Store())], value=Name(id='codec_info', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='<Encoding %s>'), op=Mod(), right=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='UTF8', ctx=Store())], value=Call(func=Name(id='lookup', ctx=Load()), args=[Constant(value='utf-8')], keywords=[])), Assign(targets=[Name(id='_UTF16LE', ctx=Store())], value=Call(func=Name(id='lookup', ctx=Load()), args=[Constant(value='utf-16le')], keywords=[])), Assign(targets=[Name(id='_UTF16BE', ctx=Store())], value=Call(func=Name(id='lookup', ctx=Load()), args=[Constant(value='utf-16be')], keywords=[])), FunctionDef(name='decode', args=arguments(posonlyargs=[], args=[arg(arg='input'), arg(arg='fallback_encoding'), arg(arg='errors')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='replace')]), body=[Expr(value=Constant(value='\n    Decode a single string.\n\n    :param input: A byte string\n    :param fallback_encoding:\n        An :class:`Encoding` object or a label string.\n        The encoding to use if :obj:`input` does note have a BOM.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n    :return:\n        A ``(output, encoding)`` tuple of an Unicode string\n        and an :obj:`Encoding`.\n\n    ')), Assign(targets=[Name(id='fallback_encoding', ctx=Store())], value=Call(func=Name(id='_get_encoding', ctx=Load()), args=[Name(id='fallback_encoding', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='bom_encoding', ctx=Store()), Name(id='input', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_detect_bom', ctx=Load()), args=[Name(id='input', ctx=Load())], keywords=[])), Assign(targets=[Name(id='encoding', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='bom_encoding', ctx=Load()), Name(id='fallback_encoding', ctx=Load())])), Return(value=Tuple(elts=[Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='encoding', ctx=Load()), attr='codec_info', ctx=Load()), attr='decode', ctx=Load()), args=[Name(id='input', ctx=Load()), Name(id='errors', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), Name(id='encoding', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_detect_bom', args=arguments(posonlyargs=[], args=[arg(arg='input')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return (bom_encoding, input), with any BOM removed from the input.')), If(test=Call(func=Attribute(value=Name(id='input', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value=b'\xff\xfe')], keywords=[]), body=[Return(value=Tuple(elts=[Name(id='_UTF16LE', ctx=Load()), Subscript(value=Name(id='input', ctx=Load()), slice=Slice(lower=Constant(value=2)), ctx=Load())], ctx=Load()))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='input', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value=b'\xfe\xff')], keywords=[]), body=[Return(value=Tuple(elts=[Name(id='_UTF16BE', ctx=Load()), Subscript(value=Name(id='input', ctx=Load()), slice=Slice(lower=Constant(value=2)), ctx=Load())], ctx=Load()))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='input', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value=b'\xef\xbb\xbf')], keywords=[]), body=[Return(value=Tuple(elts=[Name(id='UTF8', ctx=Load()), Subscript(value=Name(id='input', ctx=Load()), slice=Slice(lower=Constant(value=3)), ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[Constant(value=None), Name(id='input', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='encode', args=arguments(posonlyargs=[], args=[arg(arg='input'), arg(arg='encoding'), arg(arg='errors')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='UTF8', ctx=Load()), Constant(value='strict')]), body=[Expr(value=Constant(value='\n    Encode a single string.\n\n    :param input: An Unicode string.\n    :param encoding: An :class:`Encoding` object or a label string.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n    :return: A byte string.\n\n    ')), Return(value=Subscript(value=Call(func=Attribute(value=Attribute(value=Call(func=Name(id='_get_encoding', ctx=Load()), args=[Name(id='encoding', ctx=Load())], keywords=[]), attr='codec_info', ctx=Load()), attr='encode', ctx=Load()), args=[Name(id='input', ctx=Load()), Name(id='errors', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()))], decorator_list=[]), FunctionDef(name='iter_decode', args=arguments(posonlyargs=[], args=[arg(arg='input'), arg(arg='fallback_encoding'), arg(arg='errors')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='replace')]), body=[Expr(value=Constant(value='\n    "Pull"-based decoder.\n\n    :param input:\n        An iterable of byte strings.\n\n        The input is first consumed just enough to determine the encoding\n        based on the precense of a BOM,\n        then consumed on demand when the return value is.\n    :param fallback_encoding:\n        An :class:`Encoding` object or a label string.\n        The encoding to use if :obj:`input` does note have a BOM.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n    :returns:\n        An ``(output, encoding)`` tuple.\n        :obj:`output` is an iterable of Unicode strings,\n        :obj:`encoding` is the :obj:`Encoding` that is being used.\n\n    ')), Assign(targets=[Name(id='decoder', ctx=Store())], value=Call(func=Name(id='IncrementalDecoder', ctx=Load()), args=[Name(id='fallback_encoding', ctx=Load()), Name(id='errors', ctx=Load())], keywords=[])), Assign(targets=[Name(id='generator', ctx=Store())], value=Call(func=Name(id='_iter_decode_generator', ctx=Load()), args=[Name(id='input', ctx=Load()), Name(id='decoder', ctx=Load())], keywords=[])), Assign(targets=[Name(id='encoding', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='generator', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='generator', ctx=Load()), Name(id='encoding', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_iter_decode_generator', args=arguments(posonlyargs=[], args=[arg(arg='input'), arg(arg='decoder')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a generator that first yields the :obj:`Encoding`,\n    then yields output chukns as Unicode strings.\n\n    ')), Assign(targets=[Name(id='decode', ctx=Store())], value=Attribute(value=Name(id='decoder', ctx=Load()), attr='decode', ctx=Load())), Assign(targets=[Name(id='input', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='input', ctx=Load())], keywords=[])), For(target=Name(id='chunck', ctx=Store()), iter=Name(id='input', ctx=Load()), body=[Assign(targets=[Name(id='output', ctx=Store())], value=Call(func=Name(id='decode', ctx=Load()), args=[Name(id='chunck', ctx=Load())], keywords=[])), If(test=Name(id='output', ctx=Load()), body=[Assert(test=Compare(left=Attribute(value=Name(id='decoder', ctx=Load()), attr='encoding', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Expr(value=Yield(value=Attribute(value=Name(id='decoder', ctx=Load()), attr='encoding', ctx=Load()))), Expr(value=Yield(value=Name(id='output', ctx=Load()))), Break()], orelse=[])], orelse=[Assign(targets=[Name(id='output', ctx=Store())], value=Call(func=Name(id='decode', ctx=Load()), args=[Constant(value=b'')], keywords=[keyword(arg='final', value=Constant(value=True))])), Assert(test=Compare(left=Attribute(value=Name(id='decoder', ctx=Load()), attr='encoding', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Expr(value=Yield(value=Attribute(value=Name(id='decoder', ctx=Load()), attr='encoding', ctx=Load()))), If(test=Name(id='output', ctx=Load()), body=[Expr(value=Yield(value=Name(id='output', ctx=Load())))], orelse=[]), Return()]), For(target=Name(id='chunck', ctx=Store()), iter=Name(id='input', ctx=Load()), body=[Assign(targets=[Name(id='output', ctx=Store())], value=Call(func=Name(id='decode', ctx=Load()), args=[Name(id='chunck', ctx=Load())], keywords=[])), If(test=Name(id='output', ctx=Load()), body=[Expr(value=Yield(value=Name(id='output', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='output', ctx=Store())], value=Call(func=Name(id='decode', ctx=Load()), args=[Constant(value=b'')], keywords=[keyword(arg='final', value=Constant(value=True))])), If(test=Name(id='output', ctx=Load()), body=[Expr(value=Yield(value=Name(id='output', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='iter_encode', args=arguments(posonlyargs=[], args=[arg(arg='input'), arg(arg='encoding'), arg(arg='errors')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='UTF8', ctx=Load()), Constant(value='strict')]), body=[Expr(value=Constant(value='\n    “Pull”-based encoder.\n\n    :param input: An iterable of Unicode strings.\n    :param encoding: An :class:`Encoding` object or a label string.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n    :returns: An iterable of byte strings.\n\n    ')), Assign(targets=[Name(id='encode', ctx=Store())], value=Attribute(value=Call(func=Name(id='IncrementalEncoder', ctx=Load()), args=[Name(id='encoding', ctx=Load()), Name(id='errors', ctx=Load())], keywords=[]), attr='encode', ctx=Load())), Return(value=Call(func=Name(id='_iter_encode_generator', ctx=Load()), args=[Name(id='input', ctx=Load()), Name(id='encode', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_iter_encode_generator', args=arguments(posonlyargs=[], args=[arg(arg='input'), arg(arg='encode')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='chunck', ctx=Store()), iter=Name(id='input', ctx=Load()), body=[Assign(targets=[Name(id='output', ctx=Store())], value=Call(func=Name(id='encode', ctx=Load()), args=[Name(id='chunck', ctx=Load())], keywords=[])), If(test=Name(id='output', ctx=Load()), body=[Expr(value=Yield(value=Name(id='output', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='output', ctx=Store())], value=Call(func=Name(id='encode', ctx=Load()), args=[Constant(value='')], keywords=[keyword(arg='final', value=Constant(value=True))])), If(test=Name(id='output', ctx=Load()), body=[Expr(value=Yield(value=Name(id='output', ctx=Load())))], orelse=[])], decorator_list=[]), ClassDef(name='IncrementalDecoder', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    “Push”-based decoder.\n\n    :param fallback_encoding:\n        An :class:`Encoding` object or a label string.\n        The encoding to use if :obj:`input` does note have a BOM.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fallback_encoding'), arg(arg='errors')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='replace')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fallback_encoding', ctx=Store())], value=Call(func=Name(id='_get_encoding', ctx=Load()), args=[Name(id='fallback_encoding', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_errors', ctx=Store())], value=Name(id='errors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_buffer', ctx=Store())], value=Constant(value=b'')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_decoder', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='encoding', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='decode', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='input'), arg(arg='final')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Decode one chunk of the input.\n\n        :param input: A byte string.\n        :param final:\n            Indicate that no more input is available.\n            Must be :obj:`True` if this is the last call.\n        :returns: An Unicode string.\n\n        ')), Assign(targets=[Name(id='decoder', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_decoder', ctx=Load())), If(test=Compare(left=Name(id='decoder', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='decoder', ctx=Load()), args=[Name(id='input', ctx=Load()), Name(id='final', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='input', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_buffer', ctx=Load()), op=Add(), right=Name(id='input', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='encoding', ctx=Store()), Name(id='input', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_detect_bom', ctx=Load()), args=[Name(id='input', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='encoding', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='input', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=3)]), UnaryOp(op=Not(), operand=Name(id='final', ctx=Load()))]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_buffer', ctx=Store())], value=Name(id='input', ctx=Load())), Return(value=Constant(value=''))], orelse=[Assign(targets=[Name(id='encoding', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_fallback_encoding', ctx=Load()))])], orelse=[]), Assign(targets=[Name(id='decoder', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='encoding', ctx=Load()), attr='codec_info', ctx=Load()), attr='incrementaldecoder', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_errors', ctx=Load())], keywords=[]), attr='decode', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_decoder', ctx=Store())], value=Name(id='decoder', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='encoding', ctx=Store())], value=Name(id='encoding', ctx=Load())), Return(value=Call(func=Name(id='decoder', ctx=Load()), args=[Name(id='input', ctx=Load()), Name(id='final', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='IncrementalEncoder', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    “Push”-based encoder.\n\n    :param encoding: An :class:`Encoding` object or a label string.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n\n    .. method:: encode(input, final=False)\n\n        :param input: An Unicode string.\n        :param final:\n            Indicate that no more input is available.\n            Must be :obj:`True` if this is the last call.\n        :returns: A byte string.\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='encoding'), arg(arg='errors')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='UTF8', ctx=Load()), Constant(value='strict')]), body=[Assign(targets=[Name(id='encoding', ctx=Store())], value=Call(func=Name(id='_get_encoding', ctx=Load()), args=[Name(id='encoding', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='encode', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='encoding', ctx=Load()), attr='codec_info', ctx=Load()), attr='incrementalencoder', ctx=Load()), args=[Name(id='errors', ctx=Load())], keywords=[]), attr='encode', ctx=Load()))], decorator_list=[])], decorator_list=[])], type_ignores=[])