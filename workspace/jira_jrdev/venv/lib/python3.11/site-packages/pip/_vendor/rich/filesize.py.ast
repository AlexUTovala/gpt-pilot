Module(body=[Expr(value=Constant(value='Functions for reporting filesizes. Borrowed from https://github.com/PyFilesystem/pyfilesystem2\n\nThe functions declared in this module should cover the different\nuse cases needed to generate a string representation of a file size\nusing several different units. Since there are many standards regarding\nfile size units, three different functions have been implemented.\n\nSee Also:\n    * `Wikipedia: Binary prefix <https://en.wikipedia.org/wiki/Binary_prefix>`_\n\n')), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='decimal')], ctx=Load())), ImportFrom(module='typing', names=[alias(name='Iterable'), alias(name='List'), alias(name='Optional'), alias(name='Tuple')], level=0), FunctionDef(name='_to_str', args=arguments(posonlyargs=[], args=[arg(arg='size', annotation=Name(id='int', ctx=Load())), arg(arg='suffixes', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='base', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[arg(arg='precision', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='separator', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=1), Constant(value=' ')], defaults=[]), body=[If(test=Compare(left=Name(id='size', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Constant(value='1 byte'))], orelse=[If(test=Compare(left=Name(id='size', ctx=Load()), ops=[Lt()], comparators=[Name(id='base', ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Constant(value='{:,} bytes'), attr='format', ctx=Load()), args=[Name(id='size', ctx=Load())], keywords=[]))], orelse=[])]), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='suffix', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='suffixes', ctx=Load()), Constant(value=2)], keywords=[]), body=[Assign(targets=[Name(id='unit', ctx=Store())], value=BinOp(left=Name(id='base', ctx=Load()), op=Pow(), right=Name(id='i', ctx=Load()))), If(test=Compare(left=Name(id='size', ctx=Load()), ops=[Lt()], comparators=[Name(id='unit', ctx=Load())]), body=[Break()], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='{:,.{precision}f}{separator}{}'), attr='format', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='base', ctx=Load()), op=Mult(), right=Name(id='size', ctx=Load())), op=Div(), right=Name(id='unit', ctx=Load())), Name(id='suffix', ctx=Load())], keywords=[keyword(arg='precision', value=Name(id='precision', ctx=Load())), keyword(arg='separator', value=Name(id='separator', ctx=Load()))]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='pick_unit_and_suffix', args=arguments(posonlyargs=[], args=[arg(arg='size', annotation=Name(id='int', ctx=Load())), arg(arg='suffixes', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='base', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Pick a suffix and base for the given size.')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='suffix', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='suffixes', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='unit', ctx=Store())], value=BinOp(left=Name(id='base', ctx=Load()), op=Pow(), right=Name(id='i', ctx=Load()))), If(test=Compare(left=Name(id='size', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Name(id='unit', ctx=Load()), op=Mult(), right=Name(id='base', ctx=Load()))]), body=[Break()], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='unit', ctx=Load()), Name(id='suffix', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='decimal', args=arguments(posonlyargs=[], args=[arg(arg='size', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[arg(arg='precision', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='separator', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=1), Constant(value=' ')], defaults=[]), body=[Expr(value=Constant(value='Convert a filesize in to a string (powers of 1000, SI prefixes).\n\n    In this convention, ``1000 B = 1 kB``.\n\n    This is typically the format used to advertise the storage\n    capacity of USB flash drives and the like (*256 MB* meaning\n    actually a storage capacity of more than *256 000 000 B*),\n    or used by **Mac OS X** since v10.6 to report file sizes.\n\n    Arguments:\n        int (size): A file size.\n        int (precision): The number of decimal places to include (default = 1).\n        str (separator): The string to separate the value from the units (default = " ").\n\n    Returns:\n        `str`: A string containing a abbreviated file size and units.\n\n    Example:\n        >>> filesize.decimal(30000)\n        \'30.0 kB\'\n        >>> filesize.decimal(30000, precision=2, separator="")\n        \'30.00kB\'\n\n    ')), Return(value=Call(func=Name(id='_to_str', ctx=Load()), args=[Name(id='size', ctx=Load()), Tuple(elts=[Constant(value='kB'), Constant(value='MB'), Constant(value='GB'), Constant(value='TB'), Constant(value='PB'), Constant(value='EB'), Constant(value='ZB'), Constant(value='YB')], ctx=Load()), Constant(value=1000)], keywords=[keyword(arg='precision', value=Name(id='precision', ctx=Load())), keyword(arg='separator', value=Name(id='separator', ctx=Load()))]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], type_ignores=[])