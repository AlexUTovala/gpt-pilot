Module(body=[Expr(value=Constant(value='\nClass representing the list of files in a distribution.\n\nEquivalent to distutils.filelist, but fixes some problems.\n')), Import(names=[alias(name='fnmatch')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), Import(names=[alias(name='sys')]), ImportFrom(names=[alias(name='DistlibException')], level=1), ImportFrom(module='compat', names=[alias(name='fsdecode')], level=1), ImportFrom(module='util', names=[alias(name='convert_path')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Manifest')], ctx=Load())), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_COLLAPSE_PATTERN', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\\\\w*\n'), Attribute(value=Name(id='re', ctx=Load()), attr='M', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_COMMENTED_LINE', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='#.*?(?=\n)|\n(?=$)'), BinOp(left=Attribute(value=Name(id='re', ctx=Load()), attr='M', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='re', ctx=Load()), attr='S', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='_PYTHON_VERSION', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load())), ClassDef(name='Manifest', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A list of files built by on exploring the filesystem and filtered by\n    applying various patterns to what we find there.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='base')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Initialise an instance.\n\n        :param base: The base directory to explore under.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='base', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='base', ctx=Load()), Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[])])], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='prefix', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='base', ctx=Load()), op=Add(), right=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='allfiles', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='files', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='findall', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find all files under the base and set ``allfiles`` to the absolute\n        pathnames of files found.\n        ')), ImportFrom(module='stat', names=[alias(name='S_ISREG'), alias(name='S_ISDIR'), alias(name='S_ISLNK')], level=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='allfiles', ctx=Store()), Name(id='allfiles', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='root', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='base', ctx=Load())), Assign(targets=[Name(id='stack', ctx=Store())], value=List(elts=[Name(id='root', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='pop', ctx=Store())], value=Attribute(value=Name(id='stack', ctx=Load()), attr='pop', ctx=Load())), Assign(targets=[Name(id='push', ctx=Store())], value=Attribute(value=Name(id='stack', ctx=Load()), attr='append', ctx=Load())), While(test=Name(id='stack', ctx=Load()), body=[Assign(targets=[Name(id='root', ctx=Store())], value=Call(func=Name(id='pop', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='names', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='root', ctx=Load())], keywords=[])), For(target=Name(id='name', ctx=Store()), iter=Name(id='names', ctx=Load()), body=[Assign(targets=[Name(id='fullname', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='stat', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='stat', ctx=Load()), args=[Name(id='fullname', ctx=Load())], keywords=[])), Assign(targets=[Name(id='mode', ctx=Store())], value=Attribute(value=Name(id='stat', ctx=Load()), attr='st_mode', ctx=Load())), If(test=Call(func=Name(id='S_ISREG', ctx=Load()), args=[Name(id='mode', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='allfiles', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='fsdecode', ctx=Load()), args=[Name(id='fullname', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='S_ISDIR', ctx=Load()), args=[Name(id='mode', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='S_ISLNK', ctx=Load()), args=[Name(id='mode', ctx=Load())], keywords=[]))]), body=[Expr(value=Call(func=Name(id='push', ctx=Load()), args=[Name(id='fullname', ctx=Load())], keywords=[]))], orelse=[])])], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='add', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Add a file to the manifest.\n\n        :param item: The pathname to add. This can be relative to the base.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='item', ctx=Load()), attr='startswith', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='prefix', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='base', ctx=Load()), Name(id='item', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='files', ctx=Load()), attr='add', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='add_many', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='items')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Add a list of files to the manifest.\n\n        :param items: The pathnames to add. These can be relative to the base.\n        ')), For(target=Name(id='item', ctx=Store()), iter=Name(id='items', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='sorted', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='wantdirs')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n        Return sorted files in directory order\n        ')), FunctionDef(name='add_dir', args=arguments(posonlyargs=[], args=[arg(arg='dirs'), arg(arg='d')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='dirs', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='d', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='add_dir added %s'), Name(id='d', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='d', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='base', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='parent', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='d', ctx=Load())], keywords=[])), Assert(test=Compare(left=Name(id='parent', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value=''), Constant(value='/')], ctx=Load())])), Expr(value=Call(func=Name(id='add_dir', ctx=Load()), args=[Name(id='dirs', ctx=Load()), Name(id='parent', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='files', ctx=Load())], keywords=[])), If(test=Name(id='wantdirs', ctx=Load()), body=[Assign(targets=[Name(id='dirs', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='f', ctx=Store()), iter=Name(id='result', ctx=Load()), body=[Expr(value=Call(func=Name(id='add_dir', ctx=Load()), args=[Name(id='dirs', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), AugAssign(target=Name(id='result', ctx=Store()), op=BitOr(), value=Name(id='dirs', ctx=Load()))], orelse=[]), Return(value=ListComp(elt=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Starred(value=Name(id='path_tuple', ctx=Load()), ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='path_tuple', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='path', ctx=Store()), iter=Name(id='result', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[]), FunctionDef(name='clear', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Clear all collected files.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='files', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='allfiles', ctx=Store())], value=List(elts=[], ctx=Load()))], decorator_list=[]), FunctionDef(name='process_directive', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='directive')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Process a directive which either adds some files from ``allfiles`` to\n        ``files``, or removes some files from ``files``.\n\n        :param directive: The directive to process. This should be in a format\n                     compatible with distutils ``MANIFEST.in`` files:\n\n                     http://docs.python.org/distutils/sourcedist.html#commands\n        ')), Assign(targets=[Tuple(elts=[Name(id='action', ctx=Store()), Name(id='patterns', ctx=Store()), Name(id='thedir', ctx=Store()), Name(id='dirpattern', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_directive', ctx=Load()), args=[Name(id='directive', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='include')]), body=[For(target=Name(id='pattern', ctx=Store()), iter=Name(id='patterns', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_include_pattern', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[keyword(arg='anchor', value=Constant(value=True))])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='no files found matching %r'), Name(id='pattern', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[If(test=Compare(left=Name(id='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='exclude')]), body=[For(target=Name(id='pattern', ctx=Store()), iter=Name(id='patterns', ctx=Load()), body=[Assign(targets=[Name(id='found', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_exclude_pattern', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[keyword(arg='anchor', value=Constant(value=True))]))], orelse=[])], orelse=[If(test=Compare(left=Name(id='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='global-include')]), body=[For(target=Name(id='pattern', ctx=Store()), iter=Name(id='patterns', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_include_pattern', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[keyword(arg='anchor', value=Constant(value=False))])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='no files found matching %r anywhere in distribution'), Name(id='pattern', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[If(test=Compare(left=Name(id='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='global-exclude')]), body=[For(target=Name(id='pattern', ctx=Store()), iter=Name(id='patterns', ctx=Load()), body=[Assign(targets=[Name(id='found', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_exclude_pattern', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[keyword(arg='anchor', value=Constant(value=False))]))], orelse=[])], orelse=[If(test=Compare(left=Name(id='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='recursive-include')]), body=[For(target=Name(id='pattern', ctx=Store()), iter=Name(id='patterns', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_include_pattern', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[keyword(arg='prefix', value=Name(id='thedir', ctx=Load()))])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='no files found matching %r under directory %r'), Name(id='pattern', ctx=Load()), Name(id='thedir', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[If(test=Compare(left=Name(id='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='recursive-exclude')]), body=[For(target=Name(id='pattern', ctx=Store()), iter=Name(id='patterns', ctx=Load()), body=[Assign(targets=[Name(id='found', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_exclude_pattern', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[keyword(arg='prefix', value=Name(id='thedir', ctx=Load()))]))], orelse=[])], orelse=[If(test=Compare(left=Name(id='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='graft')]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_include_pattern', ctx=Load()), args=[Constant(value=None)], keywords=[keyword(arg='prefix', value=Name(id='dirpattern', ctx=Load()))])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='no directories found matching %r'), Name(id='dirpattern', ctx=Load())], keywords=[]))], orelse=[])], orelse=[If(test=Compare(left=Name(id='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='prune')]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_exclude_pattern', ctx=Load()), args=[Constant(value=None)], keywords=[keyword(arg='prefix', value=Name(id='dirpattern', ctx=Load()))])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='no previously-included directories found matching %r'), Name(id='dirpattern', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='invalid action %r'), op=Mod(), right=Name(id='action', ctx=Load()))], keywords=[]))])])])])])])])])], decorator_list=[]), FunctionDef(name='_parse_directive', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='directive')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Validate a directive.\n        :param directive: The directive to validate.\n        :return: A tuple of action, patterns, thedir, dir_patterns\n        ')), Assign(targets=[Name(id='words', ctx=Store())], value=Call(func=Attribute(value=Name(id='directive', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='words', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), Compare(left=Subscript(value=Name(id='words', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value='include'), Constant(value='exclude'), Constant(value='global-include'), Constant(value='global-exclude'), Constant(value='recursive-include'), Constant(value='recursive-exclude'), Constant(value='graft'), Constant(value='prune')], ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='words', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Constant(value='include')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='action', ctx=Store())], value=Subscript(value=Name(id='words', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='patterns', ctx=Store()), Name(id='thedir', ctx=Store()), Name(id='dir_pattern', ctx=Store())], value=Constant(value=None)), If(test=Compare(left=Name(id='action', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='include'), Constant(value='exclude'), Constant(value='global-include'), Constant(value='global-exclude')], ctx=Load())]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='words', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=2)]), body=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='%r expects <pattern1> <pattern2> ...'), op=Mod(), right=Name(id='action', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='patterns', ctx=Store())], value=ListComp(elt=Call(func=Name(id='convert_path', ctx=Load()), args=[Name(id='word', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='word', ctx=Store()), iter=Subscript(value=Name(id='words', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), ifs=[], is_async=0)]))], orelse=[If(test=Compare(left=Name(id='action', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='recursive-include'), Constant(value='recursive-exclude')], ctx=Load())]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='words', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=3)]), body=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='%r expects <dir> <pattern1> <pattern2> ...'), op=Mod(), right=Name(id='action', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='thedir', ctx=Store())], value=Call(func=Name(id='convert_path', ctx=Load()), args=[Subscript(value=Name(id='words', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[])), Assign(targets=[Name(id='patterns', ctx=Store())], value=ListComp(elt=Call(func=Name(id='convert_path', ctx=Load()), args=[Name(id='word', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='word', ctx=Store()), iter=Subscript(value=Name(id='words', ctx=Load()), slice=Slice(lower=Constant(value=2)), ctx=Load()), ifs=[], is_async=0)]))], orelse=[If(test=Compare(left=Name(id='action', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='graft'), Constant(value='prune')], ctx=Load())]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='words', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=2)]), body=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='%r expects a single <dir_pattern>'), op=Mod(), right=Name(id='action', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='dir_pattern', ctx=Store())], value=Call(func=Name(id='convert_path', ctx=Load()), args=[Subscript(value=Name(id='words', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='DistlibException', ctx=Load()), args=[BinOp(left=Constant(value='unknown action %r'), op=Mod(), right=Name(id='action', ctx=Load()))], keywords=[]))])])]), Return(value=Tuple(elts=[Name(id='action', ctx=Load()), Name(id='patterns', ctx=Load()), Name(id='thedir', ctx=Load()), Name(id='dir_pattern', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_include_pattern', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pattern'), arg(arg='anchor'), arg(arg='prefix'), arg(arg='is_regex')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Select strings (presumably filenames) from \'self.files\' that\n        match \'pattern\', a Unix-style wildcard (glob) pattern.\n\n        Patterns are not quite the same as implemented by the \'fnmatch\'\n        module: \'*\' and \'?\'  match non-special characters, where "special"\n        is platform-dependent: slash on Unix; colon, slash, and backslash on\n        DOS/Windows; and colon on Mac OS.\n\n        If \'anchor\' is true (the default), then the pattern match is more\n        stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If\n        \'anchor\' is false, both of these will match.\n\n        If \'prefix\' is supplied, then only filenames starting with \'prefix\'\n        (itself a pattern) and ending with \'pattern\', with anything in between\n        them, will match.  \'anchor\' is ignored in this case.\n\n        If \'is_regex\' is true, \'anchor\' and \'prefix\' are ignored, and\n        \'pattern\' is assumed to be either a string containing a regex or a\n        regex object -- no translation is done, the regex is just compiled\n        and used as-is.\n\n        Selected strings will be added to self.files.\n\n        Return True if files are found.\n        ')), Assign(targets=[Name(id='found', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='pattern_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_translate_pattern', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='anchor', ctx=Load()), Name(id='prefix', ctx=Load()), Name(id='is_regex', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='allfiles', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='findall', ctx=Load()), args=[], keywords=[]))], orelse=[]), For(target=Name(id='name', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='allfiles', ctx=Load()), body=[If(test=Call(func=Attribute(value=Name(id='pattern_re', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='files', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='found', ctx=Store())], value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Name(id='found', ctx=Load()))], decorator_list=[]), FunctionDef(name='_exclude_pattern', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pattern'), arg(arg='anchor'), arg(arg='prefix'), arg(arg='is_regex')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Remove strings (presumably filenames) from 'files' that match\n        'pattern'.\n\n        Other parameters are the same as for 'include_pattern()', above.\n        The list 'self.files' is modified in place. Return True if files are\n        found.\n\n        This API is public to allow e.g. exclusion of SCM subdirs, e.g. when\n        packaging source distributions\n        ")), Assign(targets=[Name(id='found', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='pattern_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_translate_pattern', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='anchor', ctx=Load()), Name(id='prefix', ctx=Load()), Name(id='is_regex', ctx=Load())], keywords=[])), For(target=Name(id='f', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='files', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='pattern_re', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='files', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[])), Assign(targets=[Name(id='found', ctx=Store())], value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Name(id='found', ctx=Load()))], decorator_list=[]), FunctionDef(name='_translate_pattern', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pattern'), arg(arg='anchor'), arg(arg='prefix'), arg(arg='is_regex')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Translate a shell-like wildcard pattern to a compiled regular\n        expression.\n\n        Return the compiled regex.  If 'is_regex' true,\n        then 'pattern' is directly compiled to a regex (if it's a string)\n        or just returned as-is (assumes it's a regex object).\n        ")), If(test=Name(id='is_regex', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[]))], orelse=[Return(value=Name(id='pattern', ctx=Load()))])], orelse=[]), If(test=Compare(left=Name(id='_PYTHON_VERSION', ctx=Load()), ops=[Gt()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=2)], ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='_', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_glob_to_re', ctx=Load()), args=[Constant(value='_')], keywords=[]), attr='partition', ctx=Load()), args=[Constant(value='_')], keywords=[]))], orelse=[]), If(test=Name(id='pattern', ctx=Load()), body=[Assign(targets=[Name(id='pattern_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_glob_to_re', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='_PYTHON_VERSION', ctx=Load()), ops=[Gt()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=2)], ctx=Load())]), body=[Assert(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='pattern_re', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='start', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='pattern_re', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='end', ctx=Load())], keywords=[])]))], orelse=[])], orelse=[Assign(targets=[Name(id='pattern_re', ctx=Store())], value=Constant(value=''))]), Assign(targets=[Name(id='base', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='base', ctx=Load()), Constant(value='')], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='prefix', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='_PYTHON_VERSION', ctx=Load()), ops=[LtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=2)], ctx=Load())]), body=[Assign(targets=[Name(id='empty_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_glob_to_re', ctx=Load()), args=[Constant(value='')], keywords=[])), Assign(targets=[Name(id='prefix_re', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_glob_to_re', ctx=Load()), args=[Name(id='prefix', ctx=Load())], keywords=[]), slice=Slice(upper=UnaryOp(op=USub(), operand=Call(func=Name(id='len', ctx=Load()), args=[Name(id='empty_pattern', ctx=Load())], keywords=[]))), ctx=Load()))], orelse=[Assign(targets=[Name(id='prefix_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_glob_to_re', ctx=Load()), args=[Name(id='prefix', ctx=Load())], keywords=[])), Assert(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='prefix_re', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='start', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='prefix_re', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='end', ctx=Load())], keywords=[])])), Assign(targets=[Name(id='prefix_re', ctx=Store())], value=Subscript(value=Name(id='prefix_re', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='start', ctx=Load())], keywords=[]), upper=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prefix_re', ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='end', ctx=Load())], keywords=[]))), ctx=Load()))]), Assign(targets=[Name(id='sep', ctx=Store())], value=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), ops=[Eq()], comparators=[Constant(value='\\')]), body=[Assign(targets=[Name(id='sep', ctx=Store())], value=Constant(value='\\\\'))], orelse=[]), If(test=Compare(left=Name(id='_PYTHON_VERSION', ctx=Load()), ops=[LtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=2)], ctx=Load())]), body=[Assign(targets=[Name(id='pattern_re', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value='^'), op=Add(), right=Name(id='base', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='sep', ctx=Load()), attr='join', ctx=Load()), args=[Tuple(elts=[Name(id='prefix_re', ctx=Load()), BinOp(left=Constant(value='.*'), op=Add(), right=Name(id='pattern_re', ctx=Load()))], ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='pattern_re', ctx=Store())], value=Subscript(value=Name(id='pattern_re', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='start', ctx=Load())], keywords=[]), upper=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pattern_re', ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='end', ctx=Load())], keywords=[]))), ctx=Load())), Assign(targets=[Name(id='pattern_re', ctx=Store())], value=BinOp(left=Constant(value='%s%s%s%s.*%s%s'), op=Mod(), right=Tuple(elts=[Name(id='start', ctx=Load()), Name(id='base', ctx=Load()), Name(id='prefix_re', ctx=Load()), Name(id='sep', ctx=Load()), Name(id='pattern_re', ctx=Load()), Name(id='end', ctx=Load())], ctx=Load())))])], orelse=[If(test=Name(id='anchor', ctx=Load()), body=[If(test=Compare(left=Name(id='_PYTHON_VERSION', ctx=Load()), ops=[LtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=2)], ctx=Load())]), body=[Assign(targets=[Name(id='pattern_re', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value='^'), op=Add(), right=Name(id='base', ctx=Load())), op=Add(), right=Name(id='pattern_re', ctx=Load())))], orelse=[Assign(targets=[Name(id='pattern_re', ctx=Store())], value=BinOp(left=Constant(value='%s%s%s'), op=Mod(), right=Tuple(elts=[Name(id='start', ctx=Load()), Name(id='base', ctx=Load()), Subscript(value=Name(id='pattern_re', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='start', ctx=Load())], keywords=[])), ctx=Load())], ctx=Load())))])], orelse=[])]), Return(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='pattern_re', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_glob_to_re', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pattern')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Translate a shell-like glob pattern to a regular expression.\n\n        Return a string containing the regex.  Differs from\n        \'fnmatch.translate()\' in that \'*\' does not match "special characters"\n        (which are platform-specific).\n        ')), Assign(targets=[Name(id='pattern_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='fnmatch', ctx=Load()), attr='translate', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[])), Assign(targets=[Name(id='sep', ctx=Store())], value=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), ops=[Eq()], comparators=[Constant(value='\\')]), body=[Assign(targets=[Name(id='sep', ctx=Store())], value=Constant(value='\\\\\\\\'))], orelse=[]), Assign(targets=[Name(id='escaped', ctx=Store())], value=BinOp(left=Constant(value='\\1[^%s]'), op=Mod(), right=Name(id='sep', ctx=Load()))), Assign(targets=[Name(id='pattern_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='((?<!\\\\)(\\\\\\\\)*)\\.'), Name(id='escaped', ctx=Load()), Name(id='pattern_re', ctx=Load())], keywords=[])), Return(value=Name(id='pattern_re', ctx=Load()))], decorator_list=[])], decorator_list=[])], type_ignores=[])