Module(body=[Expr(value=Constant(value='\nScript which takes one or more file paths and reports on their detected\nencodings\n\nExample::\n\n    % chardetect somefile someotherfile\n    somefile: windows-1252 with confidence 0.5\n    someotherfile: ascii with confidence 1.0\n\nIf no paths are provided, it takes its input from stdin.\n\n')), Import(names=[alias(name='argparse')]), Import(names=[alias(name='sys')]), ImportFrom(module='typing', names=[alias(name='Iterable'), alias(name='List'), alias(name='Optional')], level=0), ImportFrom(names=[alias(name='__version__')], level=2), ImportFrom(module='universaldetector', names=[alias(name='UniversalDetector')], level=2), FunctionDef(name='description_of', args=arguments(posonlyargs=[], args=[arg(arg='lines', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='bytes', ctx=Load()), ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='minimal', annotation=Name(id='bool', ctx=Load())), arg(arg='should_rename_legacy', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='stdin'), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Return a string describing the probable encoding of a file or\n    list of strings.\n\n    :param lines: The lines to get the encoding of.\n    :type lines: Iterable of bytes\n    :param name: Name of file or collection of lines\n    :type name: str\n    :param should_rename_legacy:  Should we rename legacy encodings to\n                                  their more modern equivalents?\n    :type should_rename_legacy:   ``bool``\n    ')), Assign(targets=[Name(id='u', ctx=Store())], value=Call(func=Name(id='UniversalDetector', ctx=Load()), args=[], keywords=[keyword(arg='should_rename_legacy', value=Name(id='should_rename_legacy', ctx=Load()))])), For(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Name(id='bytearray', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='u', ctx=Load()), attr='feed', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='u', ctx=Load()), attr='done', ctx=Load()), body=[Break()], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='u', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Attribute(value=Name(id='u', ctx=Load()), attr='result', ctx=Load())), If(test=Name(id='minimal', ctx=Load()), body=[Return(value=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='encoding'), ctx=Load()))], orelse=[]), If(test=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='encoding'), ctx=Load()), body=[Return(value=JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='encoding'), ctx=Load()), conversion=-1), Constant(value=' with confidence '), FormattedValue(value=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='confidence'), ctx=Load()), conversion=-1)]))], orelse=[]), Return(value=JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value=': no result')]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='main', args=arguments(posonlyargs=[], args=[arg(arg='argv', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Handles command line arguments and gets things started.\n\n    :param argv: List of arguments, as if specified on the command-line.\n                 If None, ``sys.argv[1:]`` is used instead.\n    :type argv: list of str\n    ')), Assign(targets=[Name(id='parser', ctx=Store())], value=Call(func=Attribute(value=Name(id='argparse', ctx=Load()), attr='ArgumentParser', ctx=Load()), args=[], keywords=[keyword(arg='description', value=Constant(value='Takes one or more file paths and reports their detected encodings'))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='input')], keywords=[keyword(arg='help', value=Constant(value='File whose encoding we would like to determine. (default: stdin)')), keyword(arg='type', value=Call(func=Attribute(value=Name(id='argparse', ctx=Load()), attr='FileType', ctx=Load()), args=[Constant(value='rb')], keywords=[])), keyword(arg='nargs', value=Constant(value='*')), keyword(arg='default', value=List(elts=[Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stdin', ctx=Load()), attr='buffer', ctx=Load())], ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='--minimal')], keywords=[keyword(arg='help', value=Constant(value='Print only the encoding to standard output')), keyword(arg='action', value=Constant(value='store_true'))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='-l'), Constant(value='--legacy')], keywords=[keyword(arg='help', value=Constant(value='Rename legacy encodings to more modern ones.')), keyword(arg='action', value=Constant(value='store_true'))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='--version')], keywords=[keyword(arg='action', value=Constant(value='version')), keyword(arg='version', value=JoinedStr(values=[Constant(value='%(prog)s '), FormattedValue(value=Name(id='__version__', ctx=Load()), conversion=-1)]))])), Assign(targets=[Name(id='args', ctx=Store())], value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='parse_args', ctx=Load()), args=[Name(id='argv', ctx=Load())], keywords=[])), For(target=Name(id='f', ctx=Store()), iter=Attribute(value=Name(id='args', ctx=Load()), attr='input', ctx=Load()), body=[If(test=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='isatty', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='You are running chardetect interactively. Press CTRL-D twice at the start of a blank line to signal the end of your input. If you want help, run chardetect --help\n')], keywords=[keyword(arg='file', value=Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Load()))]))], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='description_of', ctx=Load()), args=[Name(id='f', ctx=Load()), Attribute(value=Name(id='f', ctx=Load()), attr='name', ctx=Load())], keywords=[keyword(arg='minimal', value=Attribute(value=Name(id='args', ctx=Load()), attr='minimal', ctx=Load())), keyword(arg='should_rename_legacy', value=Attribute(value=Name(id='args', ctx=Load()), attr='legacy', ctx=Load()))])], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), If(test=Compare(left=Name(id='__name__', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__main__')]), body=[Expr(value=Call(func=Name(id='main', ctx=Load()), args=[], keywords=[]))], orelse=[])], type_ignores=[])