Module(body=[Import(names=[alias(name='abc')]), Import(names=[alias(name='collections')]), Import(names=[alias(name='collections.abc')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='inspect')]), Import(names=[alias(name='operator')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='types', asname='_types')]), Import(names=[alias(name='typing')]), Import(names=[alias(name='warnings')]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Any'), Constant(value='ClassVar'), Constant(value='Concatenate'), Constant(value='Final'), Constant(value='LiteralString'), Constant(value='ParamSpec'), Constant(value='ParamSpecArgs'), Constant(value='ParamSpecKwargs'), Constant(value='Self'), Constant(value='Type'), Constant(value='TypeVar'), Constant(value='TypeVarTuple'), Constant(value='Unpack'), Constant(value='Awaitable'), Constant(value='AsyncIterator'), Constant(value='AsyncIterable'), Constant(value='Coroutine'), Constant(value='AsyncGenerator'), Constant(value='AsyncContextManager'), Constant(value='Buffer'), Constant(value='ChainMap'), Constant(value='ContextManager'), Constant(value='Counter'), Constant(value='Deque'), Constant(value='DefaultDict'), Constant(value='NamedTuple'), Constant(value='OrderedDict'), Constant(value='TypedDict'), Constant(value='SupportsAbs'), Constant(value='SupportsBytes'), Constant(value='SupportsComplex'), Constant(value='SupportsFloat'), Constant(value='SupportsIndex'), Constant(value='SupportsInt'), Constant(value='SupportsRound'), Constant(value='Annotated'), Constant(value='assert_never'), Constant(value='assert_type'), Constant(value='clear_overloads'), Constant(value='dataclass_transform'), Constant(value='deprecated'), Constant(value='get_overloads'), Constant(value='final'), Constant(value='get_args'), Constant(value='get_origin'), Constant(value='get_original_bases'), Constant(value='get_protocol_members'), Constant(value='get_type_hints'), Constant(value='IntVar'), Constant(value='is_protocol'), Constant(value='is_typeddict'), Constant(value='Literal'), Constant(value='NewType'), Constant(value='overload'), Constant(value='override'), Constant(value='Protocol'), Constant(value='reveal_type'), Constant(value='runtime'), Constant(value='runtime_checkable'), Constant(value='Text'), Constant(value='TypeAlias'), Constant(value='TypeAliasType'), Constant(value='TypeGuard'), Constant(value='TYPE_CHECKING'), Constant(value='Never'), Constant(value='NoReturn'), Constant(value='Required'), Constant(value='NotRequired'), Constant(value='AbstractSet'), Constant(value='AnyStr'), Constant(value='BinaryIO'), Constant(value='Callable'), Constant(value='Collection'), Constant(value='Container'), Constant(value='Dict'), Constant(value='ForwardRef'), Constant(value='FrozenSet'), Constant(value='Generator'), Constant(value='Generic'), Constant(value='Hashable'), Constant(value='IO'), Constant(value='ItemsView'), Constant(value='Iterable'), Constant(value='Iterator'), Constant(value='KeysView'), Constant(value='List'), Constant(value='Mapping'), Constant(value='MappingView'), Constant(value='Match'), Constant(value='MutableMapping'), Constant(value='MutableSequence'), Constant(value='MutableSet'), Constant(value='Optional'), Constant(value='Pattern'), Constant(value='Reversible'), Constant(value='Sequence'), Constant(value='Set'), Constant(value='Sized'), Constant(value='TextIO'), Constant(value='Tuple'), Constant(value='Union'), Constant(value='ValuesView'), Constant(value='cast'), Constant(value='no_type_check'), Constant(value='no_type_check_decorator')], ctx=Load())), Assign(targets=[Name(id='PEP_560', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='GenericMeta', ctx=Store())], value=Name(id='type', ctx=Load())), ClassDef(name='_Sentinel', bases=[], keywords=[], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='<sentinel>'))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='_marker', ctx=Store())], value=Call(func=Name(id='_Sentinel', ctx=Load()), args=[], keywords=[])), FunctionDef(name='_check_generic', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='parameters'), arg(arg='elen')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='_marker', ctx=Load())]), body=[Expr(value=Constant(value='Check correct count for parameters of a generic cls (internal helper).\n    This gives a nice error message in case of count mismatch.\n    ')), If(test=UnaryOp(op=Not(), operand=Name(id='elen', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='cls', ctx=Load()), conversion=-1), Constant(value=' is not a generic class')])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='elen', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='__parameters__')], keywords=[])), UnaryOp(op=Not(), operand=Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='cls', ctx=Load()), conversion=-1), Constant(value=' is not a generic class')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='elen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='alen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='alen', ctx=Load()), ops=[NotEq()], comparators=[Name(id='elen', ctx=Load())]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='__parameters__')], keywords=[]), body=[Assign(targets=[Name(id='parameters', ctx=Store())], value=ListComp(elt=Name(id='p', ctx=Load()), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Call(func=Name(id='_is_unpack', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[]))], is_async=0)])), Assign(targets=[Name(id='num_tv_tuples', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='TypeVarTuple', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='parameters', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_tv_tuples', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), Compare(left=Name(id='alen', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='elen', ctx=Load()), op=Sub(), right=Name(id='num_tv_tuples', ctx=Load()))])]), body=[Return()], orelse=[])], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Too '), FormattedValue(value=IfExp(test=Compare(left=Name(id='alen', ctx=Load()), ops=[Gt()], comparators=[Name(id='elen', ctx=Load())]), body=Constant(value='many'), orelse=Constant(value='few')), conversion=-1), Constant(value=' parameters for '), FormattedValue(value=Name(id='cls', ctx=Load()), conversion=-1), Constant(value='; actual '), FormattedValue(value=Name(id='alen', ctx=Load()), conversion=-1), Constant(value=', expected '), FormattedValue(value=Name(id='elen', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], decorator_list=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=10)], ctx=Load())]), body=[FunctionDef(name='_should_collect_from_parameters', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='GenericAlias', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='UnionType', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], orelse=[If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[FunctionDef(name='_should_collect_from_parameters', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='GenericAlias', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], orelse=[FunctionDef(name='_should_collect_from_parameters', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='t', ctx=Load()), attr='_special', ctx=Load()))]))], decorator_list=[])])]), FunctionDef(name='_collect_type_vars', args=arguments(posonlyargs=[], args=[arg(arg='types'), arg(arg='typevar_types')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Collect all type variable contained in types in order of\n    first appearance (lexicographic order). For example::\n\n        _collect_type_vars((T, List[S, T])) == (T, S)\n    ')), If(test=Compare(left=Name(id='typevar_types', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='typevar_types', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='tvars', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='t', ctx=Store()), iter=Name(id='types', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Name(id='typevar_types', ctx=Load())], keywords=[]), Compare(left=Name(id='t', ctx=Load()), ops=[NotIn()], comparators=[Name(id='tvars', ctx=Load())]), UnaryOp(op=Not(), operand=Call(func=Name(id='_is_unpack', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]))]), body=[Expr(value=Call(func=Attribute(value=Name(id='tvars', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='_should_collect_from_parameters', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='tvars', ctx=Load()), attr='extend', ctx=Load()), args=[ListComp(elt=Name(id='t', ctx=Load()), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Attribute(value=Name(id='t', ctx=Load()), attr='__parameters__', ctx=Load()), ifs=[Compare(left=Name(id='t', ctx=Load()), ops=[NotIn()], comparators=[Name(id='tvars', ctx=Load())])], is_async=0)])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='tvars', ctx=Load())], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='NoReturn', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NoReturn', ctx=Load())), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='T')], keywords=[])), Assign(targets=[Name(id='KT', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='KT')], keywords=[])), Assign(targets=[Name(id='VT', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='VT')], keywords=[])), Assign(targets=[Name(id='T_co', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='T_co')], keywords=[keyword(arg='covariant', value=Constant(value=True))])), Assign(targets=[Name(id='T_contra', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='T_contra')], keywords=[keyword(arg='contravariant', value=Constant(value=True))])), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=11)], ctx=Load())]), body=[ImportFrom(module='typing', names=[alias(name='Any')], level=0)], orelse=[ClassDef(name='_AnyMeta', bases=[Name(id='type', ctx=Load())], keywords=[], body=[FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='Any', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='typing_extensions.Any cannot be used with isinstance()')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__instancecheck__', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='Any', ctx=Load())]), body=[Return(value=Constant(value='typing_extensions.Any'))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__repr__', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Any', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='_AnyMeta', ctx=Load()))], body=[Expr(value=Constant(value='Special type indicating an unconstrained type.\n        - Any is compatible with every type.\n        - Any assumed to have all methods.\n        - All values assumed to be instances of Any.\n        Note that all the above statements are true from the point of view of\n        static type checkers. At runtime, Any should not be used with instance\n        checks.\n        ')), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Any', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Any cannot be instantiated')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[])]), Assign(targets=[Name(id='ClassVar', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load())), ClassDef(name='_ExtensionsSpecialForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[])], decorator_list=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Final')], keywords=[]), Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())])]), body=[Assign(targets=[Name(id='Final', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Final', ctx=Load()))], orelse=[ClassDef(name='_FinalForm', bases=[Name(id='_ExtensionsSpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Final', ctx=Store())], value=Call(func=Name(id='_FinalForm', ctx=Load()), args=[Constant(value='Final')], keywords=[keyword(arg='doc', value=Constant(value='A special typing construct to indicate that a name\n                       cannot be re-assigned or overridden in a subclass.\n                       For example:\n\n                           MAX_SIZE: Final = 9000\n                           MAX_SIZE += 1  # Error reported by type checker\n\n                           class Connection:\n                               TIMEOUT: Final[int] = 10\n                           class FastConnector(Connection):\n                               TIMEOUT = 1  # Error reported by type checker\n\n                       There is no runtime checking of these properties.'))]))]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=11)], ctx=Load())]), body=[Assign(targets=[Name(id='final', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='final', ctx=Load()))], orelse=[FunctionDef(name='final', args=arguments(posonlyargs=[], args=[arg(arg='f')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='This decorator can be used to indicate to type checkers that\n        the decorated method cannot be overridden, and decorated class\n        cannot be subclassed. For example:\n\n            class Base:\n                @final\n                def done(self) -> None:\n                    ...\n            class Sub(Base):\n                def done(self) -> None:  # Error reported by type checker\n                    ...\n            @final\n            class Leaf:\n                ...\n            class Other(Leaf):  # Error reported by type checker\n                ...\n\n        There is no runtime checking of these properties. The decorator\n        sets the ``__final__`` attribute to ``True`` on the decorated object\n        to allow runtime introspection.\n        ')), Try(body=[Assign(targets=[Attribute(value=Name(id='f', ctx=Load()), attr='__final__', ctx=Store())], value=Constant(value=True))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Name(id='f', ctx=Load()))], decorator_list=[])]), FunctionDef(name='IntVar', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=10), Constant(value=1)], ctx=Load())]), body=[Assign(targets=[Name(id='Literal', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Literal', ctx=Load()))], orelse=[FunctionDef(name='_flatten_literal_params', args=arguments(posonlyargs=[], args=[arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='An internal helper for Literal creation: flatten Literals among parameters')), Assign(targets=[Name(id='params', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='p', ctx=Store()), iter=Name(id='parameters', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='_LiteralGenericAlias', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='params', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='p', ctx=Load()), attr='__args__', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='params', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[]))])], orelse=[]), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_value_and_type_iter', args=arguments(posonlyargs=[], args=[arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='p', ctx=Store()), iter=Name(id='params', ctx=Load()), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='p', ctx=Load()), Call(func=Name(id='type', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])], ctx=Load())))], orelse=[])], decorator_list=[]), ClassDef(name='_LiteralGenericAlias', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='_LiteralGenericAlias', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='these_args_deduped', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Name(id='_value_and_type_iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='other_args_deduped', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Name(id='_value_and_type_iter', ctx=Load()), args=[Attribute(value=Name(id='other', ctx=Load()), attr='__args__', ctx=Load())], keywords=[])], keywords=[])), Return(value=Compare(left=Name(id='these_args_deduped', ctx=Load()), ops=[Eq()], comparators=[Name(id='other_args_deduped', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Call(func=Name(id='frozenset', ctx=Load()), args=[Call(func=Name(id='_value_and_type_iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='_LiteralForm', bases=[Name(id='_ExtensionsSpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='doc', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Store())], value=Constant(value='Literal')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_doc', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='__doc__', ctx=Store())], value=Name(id='doc', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='parameters', ctx=Store())], value=Tuple(elts=[Name(id='parameters', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='parameters', ctx=Store())], value=Call(func=Name(id='_flatten_literal_params', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='val_type_pairs', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='_value_and_type_iter', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])), Try(body=[Assign(targets=[Name(id='deduped_pairs', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='val_type_pairs', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Pass()])], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='deduped_pairs', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='val_type_pairs', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='new_parameters', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='pair', ctx=Store()), iter=Name(id='val_type_pairs', ctx=Load()), body=[If(test=Compare(left=Name(id='pair', ctx=Load()), ops=[In()], comparators=[Name(id='deduped_pairs', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='new_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='pair', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='deduped_pairs', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='pair', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assert(test=UnaryOp(op=Not(), operand=Name(id='deduped_pairs', ctx=Load())), msg=Name(id='deduped_pairs', ctx=Load())), Assign(targets=[Name(id='parameters', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='new_parameters', ctx=Load())], keywords=[]))], orelse=[])], finalbody=[]), Return(value=Call(func=Name(id='_LiteralGenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Literal', ctx=Store())], value=Call(func=Name(id='_LiteralForm', ctx=Load()), args=[], keywords=[keyword(arg='doc', value=Constant(value="                           A type that can be used to indicate to type checkers\n                           that the corresponding value has a value literally equivalent\n                           to the provided parameter. For example:\n\n                               var: Literal[4] = 4\n\n                           The type checker understands that 'var' is literally equal to\n                           the value 4 and no other value.\n\n                           Literal[...] cannot be subclassed. There is no runtime\n                           checking verifying that the parameter is actually a value\n                           instead of a type."))]))]), Assign(targets=[Name(id='_overload_dummy', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_overload_dummy', ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='get_overloads')], keywords=[]), body=[Assign(targets=[Name(id='overload', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())), Assign(targets=[Name(id='get_overloads', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_overloads', ctx=Load())), Assign(targets=[Name(id='clear_overloads', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='clear_overloads', ctx=Load()))], orelse=[Assign(targets=[Name(id='_overload_registry', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='defaultdict', ctx=Load()), args=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Attribute(value=Name(id='collections', ctx=Load()), attr='defaultdict', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])], keywords=[])), FunctionDef(name='overload', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Decorator for overloaded functions/methods.\n\n        In a stub file, place two or more stub definitions for the same\n        function in a row, each decorated with @overload.  For example:\n\n        @overload\n        def utf8(value: None) -> None: ...\n        @overload\n        def utf8(value: bytes) -> bytes: ...\n        @overload\n        def utf8(value: str) -> bytes: ...\n\n        In a non-stub file (i.e. a regular .py file), do the same but\n        follow it with an implementation.  The implementation should *not*\n        be decorated with @overload.  For example:\n\n        @overload\n        def utf8(value: None) -> None: ...\n        @overload\n        def utf8(value: bytes) -> bytes: ...\n        @overload\n        def utf8(value: str) -> bytes: ...\n        def utf8(value):\n            # implementation goes here\n\n        The overloads for a function can be retrieved at runtime using the\n        get_overloads() function.\n        ')), Assign(targets=[Name(id='f', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__func__'), Name(id='func', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id='_overload_registry', ctx=Load()), slice=Attribute(value=Name(id='f', ctx=Load()), attr='__module__', ctx=Load()), ctx=Load()), slice=Attribute(value=Name(id='f', ctx=Load()), attr='__qualname__', ctx=Load()), ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='f', ctx=Load()), attr='__code__', ctx=Load()), attr='co_firstlineno', ctx=Load()), ctx=Store())], value=Name(id='func', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Name(id='_overload_dummy', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_overloads', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return all defined overloads for *func* as a sequence.')), Assign(targets=[Name(id='f', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__func__'), Name(id='func', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='f', ctx=Load()), attr='__module__', ctx=Load()), ops=[NotIn()], comparators=[Name(id='_overload_registry', ctx=Load())]), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='mod_dict', ctx=Store())], value=Subscript(value=Name(id='_overload_registry', ctx=Load()), slice=Attribute(value=Name(id='f', ctx=Load()), attr='__module__', ctx=Load()), ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='f', ctx=Load()), attr='__qualname__', ctx=Load()), ops=[NotIn()], comparators=[Name(id='mod_dict', ctx=Load())]), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Name(id='mod_dict', ctx=Load()), slice=Attribute(value=Name(id='f', ctx=Load()), attr='__qualname__', ctx=Load()), ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='clear_overloads', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Clear all overloads in the registry.')), Expr(value=Call(func=Attribute(value=Name(id='_overload_registry', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[]))], decorator_list=[])]), Assign(targets=[Name(id='Type', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Type', ctx=Load())), Assign(targets=[Name(id='Awaitable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Awaitable', ctx=Load())), Assign(targets=[Name(id='Coroutine', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Coroutine', ctx=Load())), Assign(targets=[Name(id='AsyncIterable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncIterable', ctx=Load())), Assign(targets=[Name(id='AsyncIterator', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncIterator', ctx=Load())), Assign(targets=[Name(id='Deque', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Deque', ctx=Load())), Assign(targets=[Name(id='ContextManager', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ContextManager', ctx=Load())), Assign(targets=[Name(id='AsyncContextManager', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncContextManager', ctx=Load())), Assign(targets=[Name(id='DefaultDict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='DefaultDict', ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='OrderedDict')], keywords=[]), body=[Assign(targets=[Name(id='OrderedDict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='OrderedDict', ctx=Load()))], orelse=[Assign(targets=[Name(id='OrderedDict', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_alias', ctx=Load()), args=[Attribute(value=Name(id='collections', ctx=Load()), attr='OrderedDict', ctx=Load()), Tuple(elts=[Name(id='KT', ctx=Load()), Name(id='VT', ctx=Load())], ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='Counter', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Counter', ctx=Load())), Assign(targets=[Name(id='ChainMap', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ChainMap', ctx=Load())), Assign(targets=[Name(id='AsyncGenerator', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncGenerator', ctx=Load())), Assign(targets=[Name(id='Text', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Text', ctx=Load())), Assign(targets=[Name(id='TYPE_CHECKING', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TYPE_CHECKING', ctx=Load())), Assign(targets=[Name(id='_PROTO_ALLOWLIST', ctx=Store())], value=Dict(keys=[Constant(value='collections.abc'), Constant(value='contextlib'), Constant(value='typing_extensions')], values=[List(elts=[Constant(value='Callable'), Constant(value='Awaitable'), Constant(value='Iterable'), Constant(value='Iterator'), Constant(value='AsyncIterable'), Constant(value='Hashable'), Constant(value='Sized'), Constant(value='Container'), Constant(value='Collection'), Constant(value='Reversible'), Constant(value='Buffer')], ctx=Load()), List(elts=[Constant(value='AbstractContextManager'), Constant(value='AbstractAsyncContextManager')], ctx=Load()), List(elts=[Constant(value='Buffer')], ctx=Load())])), Assign(targets=[Name(id='_EXCLUDED_ATTRS', ctx=Store())], value=Set(elts=[Constant(value='__abstractmethods__'), Constant(value='__annotations__'), Constant(value='__weakref__'), Constant(value='_is_protocol'), Constant(value='_is_runtime_protocol'), Constant(value='__dict__'), Constant(value='__slots__'), Constant(value='__parameters__'), Constant(value='__orig_bases__'), Constant(value='__module__'), Constant(value='_MutableMapping__marker'), Constant(value='__doc__'), Constant(value='__subclasshook__'), Constant(value='__orig_class__'), Constant(value='__init__'), Constant(value='__new__'), Constant(value='__protocol_attrs__'), Constant(value='__callable_proto_members_only__')])), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[Lt()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[AugAssign(target=Name(id='_EXCLUDED_ATTRS', ctx=Store()), op=BitOr(), value=Set(elts=[Constant(value='_gorg'), Constant(value='__next_in_mro__'), Constant(value='__extra__'), Constant(value='__tree_hash__'), Constant(value='__args__'), Constant(value='__origin__')]))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='_EXCLUDED_ATTRS', ctx=Load()), attr='add', ctx=Load()), args=[Constant(value='__class_getitem__')], keywords=[]))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=12)], ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='_EXCLUDED_ATTRS', ctx=Load()), attr='add', ctx=Load()), args=[Constant(value='__type_params__')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='_EXCLUDED_ATTRS', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='_EXCLUDED_ATTRS', ctx=Load())], keywords=[])), FunctionDef(name='_get_protocol_attrs', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='base', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__mro__', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__name__', ctx=Load()), ops=[In()], comparators=[Set(elts=[Constant(value='Protocol'), Constant(value='Generic')])]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='annotations', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='base', ctx=Load()), Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), For(target=Name(id='attr', ctx=Store()), iter=Tuple(elts=[Starred(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), ctx=Load()), Starred(value=Name(id='annotations', ctx=Load()), ctx=Load())], ctx=Load()), body=[If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='attr', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_abc_')], keywords=[])), Compare(left=Name(id='attr', ctx=Load()), ops=[NotIn()], comparators=[Name(id='_EXCLUDED_ATTRS', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='attrs', ctx=Load()))], decorator_list=[]), FunctionDef(name='_maybe_adjust_parameters', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper function used in Protocol.__init_subclass__ and _TypedDictMeta.__new__.\n\n    The contents of this function are very similar\n    to logic found in typing.Generic.__init_subclass__\n    on the CPython main branch.\n    ')), Assign(targets=[Name(id='tvars', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Constant(value='__orig_bases__'), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Name(id='tvars', ctx=Store())], value=Call(func=Name(id='_collect_type_vars', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='__orig_bases__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='gvars', ctx=Store())], value=Constant(value=None)), For(target=Name(id='base', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__orig_bases__', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='base', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__origin__', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), Name(id='Protocol', ctx=Load())], ctx=Load())])]), body=[Assign(targets=[Name(id='the_base', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__origin__', ctx=Load()), attr='__name__', ctx=Load())), If(test=Compare(left=Name(id='gvars', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot inherit from Generic[...] and/or Protocol[...] multiple types.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='gvars', ctx=Store())], value=Attribute(value=Name(id='base', ctx=Load()), attr='__parameters__', ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='gvars', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='gvars', ctx=Store())], value=Name(id='tvars', ctx=Load()))], orelse=[Assign(targets=[Name(id='tvarset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='tvars', ctx=Load())], keywords=[])), Assign(targets=[Name(id='gvarset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='gvars', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='tvarset', ctx=Load()), ops=[LtE()], comparators=[Name(id='gvarset', ctx=Load())])), body=[Assign(targets=[Name(id='s_vars', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Name(id='tvars', ctx=Load()), ifs=[Compare(left=Name(id='t', ctx=Load()), ops=[NotIn()], comparators=[Name(id='gvarset', ctx=Load())])], is_async=0)])], keywords=[])), Assign(targets=[Name(id='s_args', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='g', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='g', ctx=Store()), iter=Name(id='gvars', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Some type variables ('), FormattedValue(value=Name(id='s_vars', ctx=Load()), conversion=-1), Constant(value=') are not listed in '), FormattedValue(value=Name(id='the_base', ctx=Load()), conversion=-1), Constant(value='['), FormattedValue(value=Name(id='s_args', ctx=Load()), conversion=-1), Constant(value=']')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='tvars', ctx=Store())], value=Name(id='gvars', ctx=Load()))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='tvars', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_caller', args=arguments(posonlyargs=[], args=[arg(arg='depth')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=2)]), body=[Try(body=[Return(value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Name(id='depth', ctx=Load())], keywords=[]), attr='f_globals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__name__'), Constant(value='__main__')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Return(value=Constant(value=None))])], orelse=[], finalbody=[])], decorator_list=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=12)], ctx=Load())]), body=[Assign(targets=[Name(id='Protocol', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Protocol', ctx=Load()))], orelse=[FunctionDef(name='_allow_reckless_class_checks', args=arguments(posonlyargs=[], args=[arg(arg='depth')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=3)]), body=[Expr(value=Constant(value='Allow instance and class checks for special stdlib modules.\n        The abc and functools modules indiscriminately call isinstance() and\n        issubclass() on the whole MRO of a user class, which may contain protocols.\n        ')), Return(value=Compare(left=Call(func=Name(id='_caller', ctx=Load()), args=[Name(id='depth', ctx=Load())], keywords=[]), ops=[In()], comparators=[Set(elts=[Constant(value='abc'), Constant(value='functools'), Constant(value=None)])]))], decorator_list=[]), FunctionDef(name='_no_init', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='_is_protocol', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Protocols cannot be instantiated')], keywords=[]))], orelse=[])], decorator_list=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[Assign(targets=[Name(id='_typing_Protocol', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Protocol', ctx=Load())), Assign(targets=[Name(id='_ProtocolMetaBase', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='_typing_Protocol', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='_typing_Protocol', ctx=Store())], value=Name(id='_marker', ctx=Load())), Assign(targets=[Name(id='_ProtocolMetaBase', ctx=Store())], value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()))]), ClassDef(name='_ProtocolMeta', bases=[Name(id='_ProtocolMetaBase', ctx=Load())], keywords=[], body=[FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='mcls'), arg(arg='name'), arg(arg='bases'), arg(arg='namespace')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='Protocol')]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bases', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=2)])]), body=[Pass()], orelse=[If(test=BinOp(left=Set(elts=[Name(id='Protocol', ctx=Load()), Name(id='_typing_Protocol', ctx=Load())]), op=BitAnd(), right=Call(func=Name(id='set', ctx=Load()), args=[Name(id='bases', ctx=Load())], keywords=[])), body=[For(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Compare(left=Name(id='base', ctx=Load()), ops=[In()], comparators=[Set(elts=[Name(id='object', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), Name(id='Protocol', ctx=Load()), Name(id='_typing_Protocol', ctx=Load())])]), Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__name__', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='_PROTO_ALLOWLIST', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='base', ctx=Load()), attr='__module__', ctx=Load()), List(elts=[], ctx=Load())], keywords=[])]), Call(func=Name(id='is_protocol', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[])])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Protocols can only inherit from other protocols, got '), FormattedValue(value=Name(id='base', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[])], orelse=[])], orelse=[])]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='mcls', ctx=Load()), Name(id='name', ctx=Load()), Name(id='bases', ctx=Load()), Name(id='namespace', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_is_protocol'), Constant(value=False)], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__protocol_attrs__', ctx=Store())], value=Call(func=Name(id='_get_protocol_attrs', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__callable_proto_members_only__', ctx=Store())], value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='callable', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='attr', ctx=Load()), Constant(value=None)], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='attr', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__protocol_attrs__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Name(id='type', ctx=Load()), attr='__subclasscheck__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_is_protocol'), Constant(value=False)], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='_allow_reckless_class_checks', ctx=Load()), args=[], keywords=[]))]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='type', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='issubclass() arg 1 must be a class')], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='cls', ctx=Load()), attr='__callable_proto_members_only__', ctx=Load())), Compare(left=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__subclasshook__')], keywords=[]), ops=[Is()], comparators=[Name(id='_proto_hook', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="Protocols with non-method members don't support issubclass()")], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_is_runtime_protocol'), Constant(value=False)], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Instance and class checks can only be used with @runtime_checkable protocols')], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()), attr='__subclasscheck__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='other', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='instance')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Name(id='type', ctx=Load()), attr='__instancecheck__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='instance', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_is_protocol'), Constant(value=False)], keywords=[])), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()), attr='__instancecheck__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='instance', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_is_runtime_protocol'), Constant(value=False)], keywords=[])), UnaryOp(op=Not(), operand=Call(func=Name(id='_allow_reckless_class_checks', ctx=Load()), args=[], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Instance and class checks can only be used with @runtime_checkable protocols')], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()), attr='__instancecheck__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='instance', ctx=Load())], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[]), For(target=Name(id='attr', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__protocol_attrs__', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='val', ctx=Store())], value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='getattr_static', ctx=Load()), args=[Name(id='instance', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Break()])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='val', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Call(func=Name(id='callable', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='attr', ctx=Load()), Constant(value=None)], keywords=[])], keywords=[])]), body=[Break()], orelse=[])], orelse=[Return(value=Constant(value=True))]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Call(func=Attribute(value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()), attr='__eq__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='other', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Constant(value=True)]), body=[Return(value=Constant(value=True))], orelse=[]), Return(value=BoolOp(op=And(), values=[Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), Compare(left=Name(id='other', ctx=Load()), ops=[Is()], comparators=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Protocol'), Call(func=Name(id='object', ctx=Load()), args=[], keywords=[])], keywords=[])])]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='type', ctx=Load()), attr='__hash__', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load()))], decorator_list=[]), FunctionDef(name='_proto_hook', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_protocol'), Constant(value=False)], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), For(target=Name(id='attr', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__protocol_attrs__', ctx=Load()), body=[For(target=Name(id='base', ctx=Store()), iter=Attribute(value=Name(id='other', ctx=Load()), attr='__mro__', ctx=Load()), body=[If(test=Compare(left=Name(id='attr', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load())]), body=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), slice=Name(id='attr', ctx=Load()), ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Break()], orelse=[]), Assign(targets=[Name(id='annotations', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='base', ctx=Load()), Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='annotations', ctx=Load()), Attribute(value=Attribute(value=Name(id='collections', ctx=Load()), attr='abc', ctx=Load()), attr='Mapping', ctx=Load())], keywords=[]), Compare(left=Name(id='attr', ctx=Load()), ops=[In()], comparators=[Name(id='annotations', ctx=Load())]), Call(func=Name(id='is_protocol', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])]), body=[Break()], orelse=[])], orelse=[Return(value=Name(id='NotImplemented', ctx=Load()))])], orelse=[]), Return(value=Constant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[ClassDef(name='Protocol', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())], keywords=[keyword(arg='metaclass', value=Name(id='_ProtocolMeta', ctx=Load()))], body=[Assign(targets=[Name(id='__doc__', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Protocol', ctx=Load()), attr='__doc__', ctx=Load())), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), Assign(targets=[Name(id='_is_protocol', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='_is_runtime_protocol', ctx=Store())], value=Constant(value=False)), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init_subclass__', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_protocol'), Constant(value=False)], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='b', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='__subclasshook__'), ops=[NotIn()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__subclasshook__', ctx=Store())], value=Name(id='_proto_hook', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Load()), Compare(left=Attribute(value=Name(id='cls', ctx=Load()), attr='__init__', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='Protocol', ctx=Load()), attr='__init__', ctx=Load())])]), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__init__', ctx=Store())], value=Name(id='_no_init', ctx=Load()))], orelse=[])], decorator_list=[])], decorator_list=[])], orelse=[ClassDef(name='Protocol', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='_ProtocolMeta', ctx=Load()))], body=[Expr(value=Constant(value='Base class for protocol classes. Protocol classes are defined as::\n\n                class Proto(Protocol):\n                    def meth(self) -> int:\n                        ...\n\n            Such classes are primarily used with static type checkers that recognize\n            structural subtyping (static duck-typing), for example::\n\n                class C:\n                    def meth(self) -> int:\n                        return 0\n\n                def func(x: Proto) -> int:\n                    return x.meth()\n\n                func(C())  # Passes static type check\n\n            See PEP 544 for details. Protocol classes decorated with\n            @typing_extensions.runtime_checkable act\n            as simple-minded runtime-checkable protocols that check\n            only the presence of given attributes, ignoring their type signatures.\n\n            Protocol classes can be generic, they are defined as::\n\n                class GenProto(Protocol[T]):\n                    def meth(self) -> T:\n                        ...\n            ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), Assign(targets=[Name(id='_is_protocol', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='_is_runtime_protocol', ctx=Store())], value=Constant(value=False)), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Type Protocol cannot be instantiated; it can only be used as a base class')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__class_getitem__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='params', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='params', ctx=Store())], value=Tuple(elts=[Name(id='params', ctx=Load())], ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='params', ctx=Load())), Compare(left=Name(id='cls', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Tuple', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Parameter list to '), FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__qualname__', ctx=Load()), conversion=-1), Constant(value='[...] cannot be empty')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Parameters to generic types must be types.')), Assign(targets=[Name(id='params', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='params', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='p', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='params', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Assign(targets=[Name(id='i', ctx=Store())], value=Constant(value=0)), While(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Parameters to Protocol[...] must all be type variables. Parameter '), FormattedValue(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), conversion=-1), Constant(value=' is '), FormattedValue(value=Subscript(value=Name(id='params', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[])], keywords=[]), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Parameters to Protocol[...] must all be unique')], keywords=[]))], orelse=[])], orelse=[Expr(value=Call(func=Name(id='_check_generic', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='params', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Load())], keywords=[])], keywords=[]))]), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='params', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Compare(left=Constant(value='__orig_bases__'), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Name(id='error', ctx=Store())], value=Compare(left=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__orig_bases__', ctx=Load())]))], orelse=[Assign(targets=[Name(id='error', ctx=Store())], value=Compare(left=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load())]))]), If(test=Name(id='error', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot inherit from plain Generic')], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='_maybe_adjust_parameters', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_protocol'), Constant(value=None)], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='b', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='__subclasshook__'), ops=[NotIn()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__subclasshook__', ctx=Store())], value=Name(id='_proto_hook', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Load()), Compare(left=Attribute(value=Name(id='cls', ctx=Load()), attr='__init__', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='Protocol', ctx=Load()), attr='__init__', ctx=Load())])]), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__init__', ctx=Store())], value=Name(id='_no_init', ctx=Load()))], orelse=[])], decorator_list=[])], decorator_list=[])])]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[Assign(targets=[Name(id='runtime_checkable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='runtime_checkable', ctx=Load()))], orelse=[FunctionDef(name='runtime_checkable', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Mark a protocol class as a runtime protocol, so that it\n        can be used with isinstance() and issubclass(). Raise TypeError\n        if applied to a non-protocol class.\n\n        This allows a simple-minded structural check very similar to the\n        one-offs in collections.abc such as Hashable.\n        ')), If(test=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='_ProtocolMeta', ctx=Load())], keywords=[]), Call(func=Name(id='issubclass', ctx=Load()), args=[Name(id='cls', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())], keywords=[])]), Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_is_protocol'), Constant(value=False)], keywords=[])])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='@runtime_checkable can be only applied to protocol classes, got '), FormattedValue(value=Name(id='cls', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='_is_runtime_protocol', ctx=Store())], value=Constant(value=True)), Return(value=Name(id='cls', ctx=Load()))], decorator_list=[])]), Assign(targets=[Name(id='runtime', ctx=Store())], value=Name(id='runtime_checkable', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=12)], ctx=Load())]), body=[Assign(targets=[Name(id='SupportsInt', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='SupportsInt', ctx=Load())), Assign(targets=[Name(id='SupportsFloat', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='SupportsFloat', ctx=Load())), Assign(targets=[Name(id='SupportsComplex', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='SupportsComplex', ctx=Load())), Assign(targets=[Name(id='SupportsBytes', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='SupportsBytes', ctx=Load())), Assign(targets=[Name(id='SupportsIndex', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='SupportsIndex', ctx=Load())), Assign(targets=[Name(id='SupportsAbs', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='SupportsAbs', ctx=Load())), Assign(targets=[Name(id='SupportsRound', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='SupportsRound', ctx=Load()))], orelse=[ClassDef(name='SupportsInt', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='An ABC with one abstract method __int__.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__int__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())]), ClassDef(name='SupportsFloat', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='An ABC with one abstract method __float__.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__float__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='float', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())]), ClassDef(name='SupportsComplex', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='An ABC with one abstract method __complex__.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__complex__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='complex', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())]), ClassDef(name='SupportsBytes', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='An ABC with one abstract method __bytes__.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__bytes__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='bytes', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())]), ClassDef(name='SupportsIndex', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__index__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())]), ClassDef(name='SupportsAbs', bases=[Subscript(value=Name(id='Protocol', ctx=Load()), slice=Name(id='T_co', ctx=Load()), ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n        An ABC with one abstract method __abs__ that is covariant in its return type.\n        ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__abs__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='T_co', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())]), ClassDef(name='SupportsRound', bases=[Subscript(value=Name(id='Protocol', ctx=Load()), slice=Name(id='T_co', ctx=Load()), ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n        An ABC with one abstract method __round__ that is covariant in its return type.\n        ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__round__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ndigits', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Pass()], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='T_co', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())])]), FunctionDef(name='_ensure_subclassable', args=arguments(posonlyargs=[], args=[arg(arg='mro_entries')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='inner', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='implementation', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='pypy')]), Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[Lt()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())])]), body=[Assign(targets=[Name(id='cls_dict', ctx=Store())], value=Dict(keys=[Constant(value='__call__'), Constant(value='__mro_entries__')], values=[Call(func=Name(id='staticmethod', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), Call(func=Name(id='staticmethod', ctx=Load()), args=[Name(id='mro_entries', ctx=Load())], keywords=[])])), Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Attribute(value=Name(id='func', ctx=Load()), attr='__name__', ctx=Load()), Tuple(elts=[], ctx=Load()), Name(id='cls_dict', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='update_wrapper', ctx=Load()), args=[Call(func=Name(id='t', ctx=Load()), args=[], keywords=[]), Name(id='func', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='func', ctx=Load()), attr='__mro_entries__', ctx=Store())], value=Name(id='mro_entries', ctx=Load())), Return(value=Name(id='func', ctx=Load()))])], decorator_list=[]), Return(value=Name(id='inner', ctx=Load()))], decorator_list=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=13)], ctx=Load())]), body=[Assign(targets=[Name(id='TypedDict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypedDict', ctx=Load())), Assign(targets=[Name(id='_TypedDictMeta', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_TypedDictMeta', ctx=Load())), Assign(targets=[Name(id='is_typeddict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='is_typeddict', ctx=Load()))], orelse=[Assign(targets=[Name(id='_TAKES_MODULE', ctx=Store())], value=Compare(left=Constant(value='module'), ops=[In()], comparators=[Attribute(value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='signature', ctx=Load()), args=[Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load())], keywords=[]), attr='parameters', ctx=Load())])), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[Assign(targets=[Name(id='_fake_name', ctx=Store())], value=Constant(value='Protocol'))], orelse=[Assign(targets=[Name(id='_fake_name', ctx=Store())], value=Constant(value='_Protocol'))]), ClassDef(name='_TypedDictMeta', bases=[Name(id='type', ctx=Load())], keywords=[], body=[FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name'), arg(arg='bases'), arg(arg='ns'), arg(arg='total')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Create new typed dict class object.\n\n            This method is called when TypedDict is subclassed,\n            or when TypedDict is instantiated. This way\n            TypedDict supports all three syntax forms described in its docstring.\n            Subclasses and instances of TypedDict return actual dictionaries.\n            ')), For(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='type', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Name(id='_TypedDictMeta', ctx=Load())]), Compare(left=Name(id='base', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='cannot inherit from both a TypedDict type and a non-TypedDict base class')], keywords=[]))], orelse=[])], orelse=[]), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='issubclass', ctx=Load()), args=[Name(id='b', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Name(id='bases', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='generic_base', ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Name(id='generic_base', ctx=Store())], value=Tuple(elts=[], ctx=Load()))]), Assign(targets=[Name(id='tp_dict', ctx=Store())], value=Call(func=Attribute(value=Name(id='type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='_TypedDictMeta', ctx=Load()), Name(id='_fake_name', ctx=Load()), Tuple(elts=[Starred(value=Name(id='generic_base', ctx=Load()), ctx=Load()), Name(id='dict', ctx=Load())], ctx=Load()), Name(id='ns', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__name__', ctx=Store())], value=Name(id='name', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__qualname__', ctx=Load()), ops=[Eq()], comparators=[Name(id='_fake_name', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__qualname__', ctx=Store())], value=Name(id='name', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='tp_dict', ctx=Load()), Constant(value='__orig_bases__')], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__orig_bases__', ctx=Store())], value=Name(id='bases', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='annotations', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='own_annotations', ctx=Store())], value=Call(func=Attribute(value=Name(id='ns', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value="TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type")), If(test=Name(id='_TAKES_MODULE', ctx=Load()), body=[Assign(targets=[Name(id='own_annotations', ctx=Store())], value=DictComp(key=Name(id='n', ctx=Load()), value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[keyword(arg='module', value=Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__module__', ctx=Load()))]), generators=[comprehension(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='tp', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='own_annotations', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], orelse=[Assign(targets=[Name(id='own_annotations', ctx=Store())], value=DictComp(key=Name(id='n', ctx=Load()), value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='tp', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='own_annotations', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))]), Assign(targets=[Name(id='required_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='optional_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='annotations', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='required_keys', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__required_keys__'), Tuple(elts=[], ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='optional_keys', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__optional_keys__'), Tuple(elts=[], ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='annotations', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='own_annotations', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='annotation_key', ctx=Store()), Name(id='annotation_type', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='own_annotations', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='annotation_origin', ctx=Store())], value=Call(func=Name(id='get_origin', ctx=Load()), args=[Name(id='annotation_type', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='annotation_origin', ctx=Load()), ops=[Is()], comparators=[Name(id='Annotated', ctx=Load())]), body=[Assign(targets=[Name(id='annotation_args', ctx=Store())], value=Call(func=Name(id='get_args', ctx=Load()), args=[Name(id='annotation_type', ctx=Load())], keywords=[])), If(test=Name(id='annotation_args', ctx=Load()), body=[Assign(targets=[Name(id='annotation_type', ctx=Store())], value=Subscript(value=Name(id='annotation_args', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='annotation_origin', ctx=Store())], value=Call(func=Name(id='get_origin', ctx=Load()), args=[Name(id='annotation_type', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='annotation_origin', ctx=Load()), ops=[Is()], comparators=[Name(id='Required', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='required_keys', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='annotation_key', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='annotation_origin', ctx=Load()), ops=[Is()], comparators=[Name(id='NotRequired', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='optional_keys', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='annotation_key', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='total', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='required_keys', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='annotation_key', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='optional_keys', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='annotation_key', ctx=Load())], keywords=[]))])])])], orelse=[]), Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__annotations__', ctx=Store())], value=Name(id='annotations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__required_keys__', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='required_keys', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__optional_keys__', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='optional_keys', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='tp_dict', ctx=Load()), Constant(value='__total__')], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__total__', ctx=Store())], value=Name(id='total', ctx=Load()))], orelse=[]), Return(value=Name(id='tp_dict', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='__call__', ctx=Store())], value=Name(id='dict', ctx=Load())), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypedDict does not support instance and class checks')], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='__instancecheck__', ctx=Store())], value=Name(id='__subclasscheck__', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_TypedDict', ctx=Store())], value=Call(func=Attribute(value=Name(id='type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='_TypedDictMeta', ctx=Load()), Constant(value='TypedDict'), Tuple(elts=[], ctx=Load()), Dict(keys=[], values=[])], keywords=[])), FunctionDef(name='TypedDict', args=arguments(posonlyargs=[], args=[arg(arg='__typename'), arg(arg='__fields')], kwonlyargs=[arg(arg='total')], kw_defaults=[Constant(value=True)], kwarg=arg(arg='kwargs'), defaults=[Name(id='_marker', ctx=Load())]), body=[Expr(value=Constant(value='A simple typed namespace. At runtime it is equivalent to a plain dict.\n\n        TypedDict creates a dictionary type such that a type checker will expect all\n        instances to have a certain set of keys, where each key is\n        associated with a value of a consistent type. This expectation\n        is not checked at runtime.\n\n        Usage::\n\n            class Point2D(TypedDict):\n                x: int\n                y: int\n                label: str\n\n            a: Point2D = {\'x\': 1, \'y\': 2, \'label\': \'good\'}  # OK\n            b: Point2D = {\'z\': 3, \'label\': \'bad\'}           # Fails type check\n\n            assert Point2D(x=1, y=2, label=\'first\') == dict(x=1, y=2, label=\'first\')\n\n        The type info can be accessed via the Point2D.__annotations__ dict, and\n        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.\n        TypedDict supports an additional equivalent form::\n\n            Point2D = TypedDict(\'Point2D\', {\'x\': int, \'y\': int, \'label\': str})\n\n        By default, all keys must be present in a TypedDict. It is possible\n        to override this by specifying totality::\n\n            class Point2D(TypedDict, total=False):\n                x: int\n                y: int\n\n        This means that a Point2D TypedDict can have any of the keys omitted. A type\n        checker is only expected to support a literal False or True as the value of\n        the total argument. True is the default, and makes all items defined in the\n        class body be required.\n\n        The Required and NotRequired special forms can also be used to mark\n        individual keys as being required or not required::\n\n            class Point2D(TypedDict):\n                x: int  # the "x" key must always be present (Required is the default)\n                y: NotRequired[int]  # the "y" key can be omitted\n\n        See PEP 655 for more details on Required and NotRequired.\n        ')), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='__fields', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), Compare(left=Name(id='__fields', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[If(test=Compare(left=Name(id='__fields', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[Assign(targets=[Name(id='deprecated_thing', ctx=Store())], value=Constant(value="Failing to pass a value for the 'fields' parameter"))], orelse=[Assign(targets=[Name(id='deprecated_thing', ctx=Store())], value=Constant(value="Passing `None` as the 'fields' parameter"))]), Assign(targets=[Name(id='example', ctx=Store())], value=JoinedStr(values=[Constant(value='`'), FormattedValue(value=Name(id='__typename', ctx=Load()), conversion=-1), Constant(value=' = TypedDict('), FormattedValue(value=Name(id='__typename', ctx=Load()), conversion=114), Constant(value=', {})`')])), Assign(targets=[Name(id='deprecation_msg', ctx=Store())], value=BinOp(left=BinOp(left=JoinedStr(values=[FormattedValue(value=Name(id='deprecated_thing', ctx=Load()), conversion=-1), Constant(value=' is deprecated and will be disallowed in Python 3.15. To create a TypedDict class with 0 fields using the functional syntax, pass an empty dictionary, e.g. ')]), op=Add(), right=Name(id='example', ctx=Load())), op=Add(), right=Constant(value='.'))), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='deprecation_msg', ctx=Load()), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Assign(targets=[Name(id='__fields', ctx=Store())], value=Name(id='kwargs', ctx=Load()))], orelse=[If(test=Name(id='kwargs', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypedDict takes either a dict or keyword arguments, but not both')], keywords=[]))], orelse=[])]), If(test=Name(id='kwargs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='The kwargs-based syntax for TypedDict definitions is deprecated in Python 3.11, will be removed in Python 3.13, and may not be understood by third-party type checkers.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))], orelse=[]), Assign(targets=[Name(id='ns', ctx=Store())], value=Dict(keys=[Constant(value='__annotations__')], values=[Call(func=Name(id='dict', ctx=Load()), args=[Name(id='__fields', ctx=Load())], keywords=[])])), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Name(id='_caller', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='module', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__module__'), ctx=Store())], value=Name(id='module', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='td', ctx=Store())], value=Call(func=Name(id='_TypedDictMeta', ctx=Load()), args=[Name(id='__typename', ctx=Load()), Tuple(elts=[], ctx=Load()), Name(id='ns', ctx=Load())], keywords=[keyword(arg='total', value=Name(id='total', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='td', ctx=Load()), attr='__orig_bases__', ctx=Store())], value=Tuple(elts=[Name(id='TypedDict', ctx=Load())], ctx=Load())), Return(value=Name(id='td', ctx=Load()))], decorator_list=[Call(func=Name(id='_ensure_subclassable', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='bases')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[Name(id='_TypedDict', ctx=Load())], ctx=Load()))], keywords=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='_TypedDictMeta')], keywords=[]), body=[Assign(targets=[Name(id='_TYPEDDICT_TYPES', ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_TypedDictMeta', ctx=Load()), Name(id='_TypedDictMeta', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Name(id='_TYPEDDICT_TYPES', ctx=Store())], value=Tuple(elts=[Name(id='_TypedDictMeta', ctx=Load())], ctx=Load()))]), FunctionDef(name='is_typeddict', args=arguments(posonlyargs=[], args=[arg(arg='tp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if an annotation is a TypedDict class\n\n        For example::\n            class Film(TypedDict):\n                title: str\n                year: int\n\n            is_typeddict(Film)  # => True\n            is_typeddict(Union[list, str])  # => False\n        ')), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypedDict')], keywords=[]), Compare(left=Name(id='tp', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='TypedDict', ctx=Load())])]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='_TYPEDDICT_TYPES', ctx=Load())], keywords=[]))], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='assert_type')], keywords=[]), body=[Assign(targets=[Name(id='assert_type', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='assert_type', ctx=Load()))], orelse=[FunctionDef(name='assert_type', args=arguments(posonlyargs=[], args=[arg(arg='__val'), arg(arg='__typ')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Assert (to the type checker) that the value is of the given type.\n\n        When the type checker encounters a call to assert_type(), it\n        emits an error if the value is not of the specified type::\n\n            def greet(name: str) -> None:\n                assert_type(name, str)  # ok\n                assert_type(name, int)  # type checker error\n\n        At runtime this returns the first argument unchanged and otherwise\n        does nothing.\n        ')), Return(value=Name(id='__val', ctx=Load()))], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Required')], keywords=[]), body=[Assign(targets=[Name(id='get_type_hints', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_type_hints', ctx=Load()))], orelse=[FunctionDef(name='_strip_extras', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Strips Annotated, Required and NotRequired from a given type.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Attribute(value=Name(id='t', ctx=Load()), attr='__origin__', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='t', ctx=Load()), Constant(value='__origin__')], keywords=[]), Compare(left=Attribute(value=Name(id='t', ctx=Load()), attr='__origin__', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Name(id='Required', ctx=Load()), Name(id='NotRequired', ctx=Load())], ctx=Load())])]), body=[Return(value=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='stripped_args', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='stripped_args', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load())]), body=[Return(value=Name(id='t', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='copy_with', ctx=Load()), args=[Name(id='stripped_args', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='_types', ctx=Load()), Constant(value='GenericAlias')], keywords=[]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='GenericAlias', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='stripped_args', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='stripped_args', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load())]), body=[Return(value=Name(id='t', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='_types', ctx=Load()), attr='GenericAlias', ctx=Load()), args=[Attribute(value=Name(id='t', ctx=Load()), attr='__origin__', ctx=Load()), Name(id='stripped_args', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='_types', ctx=Load()), Constant(value='UnionType')], keywords=[]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='UnionType', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='stripped_args', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='stripped_args', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load())]), body=[Return(value=Name(id='t', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='reduce', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='or_', ctx=Load()), Name(id='stripped_args', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='t', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_type_hints', args=arguments(posonlyargs=[], args=[arg(arg='obj'), arg(arg='globalns'), arg(arg='localns'), arg(arg='include_extras')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Return type hints for an object.\n\n        This is often the same as obj.__annotations__, but it handles\n        forward references encoded as string literals, adds Optional[t] if a\n        default value equal to None is set and recursively replaces all\n        'Annotated[T, ...]', 'Required[T]' or 'NotRequired[T]' with 'T'\n        (unless 'include_extras=True').\n\n        The argument may be a module, class, method, or function. The annotations\n        are returned as a dictionary. For classes, annotations include also\n        inherited members.\n\n        TypeError is raised if the argument is not of a type that can contain\n        annotations, and an empty dictionary is returned if no annotations are\n        present.\n\n        BEWARE -- the behavior of globalns and localns is counterintuitive\n        (unless you are familiar with how eval() and exec() work).  The\n        search order is locals first, then globals.\n\n        - If no dict arguments are passed, an attempt is made to use the\n          globals from obj (or the respective module's globals for classes),\n          and these are also used as the locals.  If the object does not appear\n          to have globals, an empty dictionary is used.\n\n        - If one dict argument is passed, it is used for both globals and\n          locals.\n\n        - If two dict arguments are passed, they specify globals and\n          locals, respectively.\n        ")), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Annotated')], keywords=[]), body=[Assign(targets=[Name(id='hint', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='get_type_hints', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[keyword(arg='globalns', value=Name(id='globalns', ctx=Load())), keyword(arg='localns', value=Name(id='localns', ctx=Load())), keyword(arg='include_extras', value=Constant(value=True))]))], orelse=[Assign(targets=[Name(id='hint', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='get_type_hints', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[keyword(arg='globalns', value=Name(id='globalns', ctx=Load())), keyword(arg='localns', value=Name(id='localns', ctx=Load()))]))]), If(test=Name(id='include_extras', ctx=Load()), body=[Return(value=Name(id='hint', ctx=Load()))], orelse=[]), Return(value=DictComp(key=Name(id='k', ctx=Load()), value=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='t', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='hint', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Annotated')], keywords=[]), body=[Assign(targets=[Name(id='Annotated', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Annotated', ctx=Load())), Assign(targets=[Name(id='_AnnotatedAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_AnnotatedAlias', ctx=Load()))], orelse=[ClassDef(name='_AnnotatedAlias', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value="Runtime representation of an annotated type.\n\n        At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'\n        with extra annotations. The alias behaves like a normal typing alias,\n        instantiating is the same as instantiating the underlying type, binding\n        it to types is also the same.\n        ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin'), arg(arg='metadata')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='origin', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='origin', ctx=Load()), attr='__metadata__', ctx=Load()), op=Add(), right=Name(id='metadata', ctx=Load()))), Assign(targets=[Name(id='origin', ctx=Store())], value=Attribute(value=Name(id='origin', ctx=Load()), attr='__origin__', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='origin', ctx=Load()), Name(id='origin', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Store())], value=Name(id='metadata', ctx=Load()))], decorator_list=[]), FunctionDef(name='copy_with', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)])), Assign(targets=[Name(id='new_type', ctx=Store())], value=Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load())), Return(value=Call(func=Name(id='_AnnotatedAlias', ctx=Load()), args=[Name(id='new_type', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='typing_extensions.Annotated['), FormattedValue(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load())], keywords=[]), conversion=-1), Constant(value=', '), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), conversion=-1), Constant(value=']')]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='operator', ctx=Load()), attr='getitem', ctx=Load()), Tuple(elts=[Name(id='Annotated', ctx=Load()), BinOp(left=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load())], ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load()))], ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__origin__', ctx=Load())]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__metadata__', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Annotated', bases=[], keywords=[], body=[Expr(value=Constant(value="Add context specific metadata to a type.\n\n        Example: Annotated[int, runtime_check.Unsigned] indicates to the\n        hypothetical runtime_check module that this type is an unsigned int.\n        Every other consumer of this type can ignore this metadata and treat\n        this type as int.\n\n        The first argument to Annotated must be a valid type (and will be in\n        the __origin__ field), the remaining arguments are kept as a tuple in\n        the __extra__ field.\n\n        Details:\n\n        - It's an error to call `Annotated` with less than two arguments.\n        - Nested Annotated are flattened::\n\n            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n        - Instantiating an annotated type is equivalent to instantiating the\n        underlying type::\n\n            Annotated[C, Ann1](5) == C(5)\n\n        - Annotated can be used as a generic type alias::\n\n            Optimized = Annotated[T, runtime.Optimize()]\n            Optimized[int] == Annotated[int, runtime.Optimize()]\n\n            OptimizedList = Annotated[List[T], runtime.Optimize()]\n            OptimizedList[int] == Annotated[List[int], runtime.Optimize()]\n        ")), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Type Annotated cannot be instantiated.')], keywords=[]))], decorator_list=[]), FunctionDef(name='__class_getitem__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='params', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=2)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Annotated[...] should be used with at least two arguments (a type and an annotation).')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='allowed_special_forms', ctx=Store())], value=Tuple(elts=[Name(id='ClassVar', ctx=Load()), Name(id='Final', ctx=Load())], ctx=Load())), If(test=Compare(left=Call(func=Name(id='get_origin', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), ops=[In()], comparators=[Name(id='allowed_special_forms', ctx=Load())]), body=[Assign(targets=[Name(id='origin', ctx=Store())], value=Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Annotated[t, ...]: t must be a type.')), Assign(targets=[Name(id='origin', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='_AnnotatedAlias', ctx=Load()), args=[Name(id='origin', ctx=Load()), Name(id='metadata', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot subclass '), FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__module__', ctx=Load()), conversion=-1), Constant(value='.Annotated')])], keywords=[]))], decorator_list=[])], decorator_list=[])]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=10)], ctx=Load())]), body=[Assign(targets=[Name(id='get_origin', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_origin', ctx=Load())), Assign(targets=[Name(id='get_args', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_args', ctx=Load()))], orelse=[Try(body=[ImportFrom(module='typing', names=[alias(name='_BaseGenericAlias')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='_BaseGenericAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()))])], orelse=[], finalbody=[]), Try(body=[ImportFrom(module='typing', names=[alias(name='GenericAlias', asname='_typing_GenericAlias')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='_typing_GenericAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()))])], orelse=[], finalbody=[]), FunctionDef(name='get_origin', args=arguments(posonlyargs=[], args=[arg(arg='tp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the unsubscripted version of a type.\n\n        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar\n        and Annotated. Return None for unsupported types. Examples::\n\n            get_origin(Literal[42]) is Literal\n            get_origin(int) is None\n            get_origin(ClassVar[int]) is ClassVar\n            get_origin(Generic) is Generic\n            get_origin(Generic[T]) is Generic\n            get_origin(Union[T, int]) is Union\n            get_origin(List[Tuple[T, T]][int]) == list\n            get_origin(P.args) is P\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Return(value=Name(id='Annotated', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), Name(id='_typing_GenericAlias', ctx=Load()), Name(id='_BaseGenericAlias', ctx=Load()), Name(id='ParamSpecArgs', ctx=Load()), Name(id='ParamSpecKwargs', ctx=Load())], ctx=Load())], keywords=[]), body=[Return(value=Attribute(value=Name(id='tp', ctx=Load()), attr='__origin__', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='tp', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())]), body=[Return(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='get_args', args=arguments(posonlyargs=[], args=[arg(arg='tp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get type arguments with all substitutions performed.\n\n        For unions, basic simplifications used by Union constructor are performed.\n        Examples::\n            get_args(Dict[str, int]) == (str, int)\n            get_args(int) == ()\n            get_args(Union[int, Union[T, int], str][int]) == (int, str)\n            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])\n            get_args(Callable[[], T][int]) == ([], int)\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Return(value=BinOp(left=Tuple(elts=[Attribute(value=Name(id='tp', ctx=Load()), attr='__origin__', ctx=Load())], ctx=Load()), op=Add(), right=Attribute(value=Name(id='tp', ctx=Load()), attr='__metadata__', ctx=Load())))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), Name(id='_typing_GenericAlias', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='tp', ctx=Load()), Constant(value='_special'), Constant(value=False)], keywords=[]), body=[Return(value=Tuple(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='res', ctx=Store())], value=Attribute(value=Name(id='tp', ctx=Load()), attr='__args__', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='get_origin', ctx=Load()), args=[Name(id='tp', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Attribute(value=Attribute(value=Name(id='collections', ctx=Load()), attr='abc', ctx=Load()), attr='Callable', ctx=Load())]), Compare(left=Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[IsNot()], comparators=[Name(id='Ellipsis', ctx=Load())])]), body=[Assign(targets=[Name(id='res', ctx=Store())], value=Tuple(elts=[Call(func=Name(id='list', ctx=Load()), args=[Subscript(value=Name(id='res', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[]), Subscript(value=Name(id='res', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[], ctx=Load()))], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeAlias')], keywords=[]), body=[Assign(targets=[Name(id='TypeAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeAlias', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[FunctionDef(name='TypeAlias', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Special marker indicating that an assignment should\n        be recognized as a proper type alias definition by type\n        checkers.\n\n        For example::\n\n            Predicate: TypeAlias = Callable[..., bool]\n\n        It's invalid when used anywhere except as in the example above.\n        ")), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not subscriptable')])], keywords=[]))], decorator_list=[Name(id='_ExtensionsSpecialForm', ctx=Load())])], orelse=[Assign(targets=[Name(id='TypeAlias', ctx=Store())], value=Call(func=Name(id='_ExtensionsSpecialForm', ctx=Load()), args=[Constant(value='TypeAlias')], keywords=[keyword(arg='doc', value=Constant(value="Special marker indicating that an assignment should\n        be recognized as a proper type alias definition by type\n        checkers.\n\n        For example::\n\n            Predicate: TypeAlias = Callable[..., bool]\n\n        It's invalid when used anywhere except as in the example\n        above."))]))])]), FunctionDef(name='_set_default', args=arguments(posonlyargs=[], args=[arg(arg='type_param'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='default', ctx=Load()), Tuple(elts=[Name(id='tuple', ctx=Load()), Name(id='list', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='type_param', ctx=Load()), attr='__default__', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='d', ctx=Load()), Constant(value='Default must be a type')], keywords=[]), generators=[comprehension(target=Name(id='d', ctx=Store()), iter=Name(id='default', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[If(test=Compare(left=Name(id='default', ctx=Load()), ops=[NotEq()], comparators=[Name(id='_marker', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='type_param', ctx=Load()), attr='__default__', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='default', ctx=Load()), Constant(value='Default must be a type')], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='type_param', ctx=Load()), attr='__default__', ctx=Store())], value=Constant(value=None))])])], decorator_list=[]), FunctionDef(name='_set_module', args=arguments(posonlyargs=[], args=[arg(arg='typevarlike')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Name(id='_caller', ctx=Load()), args=[], keywords=[keyword(arg='depth', value=Constant(value=3))])), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='typevarlike', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[])], decorator_list=[]), ClassDef(name='_DefaultMixin', bases=[], keywords=[], body=[Expr(value=Constant(value='Mixin for TypeVarLike defaults.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), Assign(targets=[Name(id='__init__', ctx=Store())], value=Name(id='_set_default', ctx=Load()))], decorator_list=[]), ClassDef(name='_TypeVarLikeMeta', bases=[Name(id='type', ctx=Load())], keywords=[], body=[FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='__instance', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='__instance', ctx=Load()), Attribute(value=Name(id='cls', ctx=Load()), attr='_backported_typevarlike', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='TypeVar', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='_TypeVarLikeMeta', ctx=Load()))], body=[Expr(value=Constant(value='Type variable.')), Assign(targets=[Name(id='_backported_typevarlike', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name')], vararg=arg(arg='constraints'), kwonlyargs=[arg(arg='bound'), arg(arg='covariant'), arg(arg='contravariant'), arg(arg='default'), arg(arg='infer_variance')], kw_defaults=[Constant(value=None), Constant(value=False), Constant(value=False), Name(id='_marker', ctx=Load()), Constant(value=False)], defaults=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeAliasType')], keywords=[]), body=[Assign(targets=[Name(id='typevar', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Name(id='name', ctx=Load()), Starred(value=Name(id='constraints', ctx=Load()), ctx=Load())], keywords=[keyword(arg='bound', value=Name(id='bound', ctx=Load())), keyword(arg='covariant', value=Name(id='covariant', ctx=Load())), keyword(arg='contravariant', value=Name(id='contravariant', ctx=Load())), keyword(arg='infer_variance', value=Name(id='infer_variance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='typevar', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Name(id='name', ctx=Load()), Starred(value=Name(id='constraints', ctx=Load()), ctx=Load())], keywords=[keyword(arg='bound', value=Name(id='bound', ctx=Load())), keyword(arg='covariant', value=Name(id='covariant', ctx=Load())), keyword(arg='contravariant', value=Name(id='contravariant', ctx=Load()))])), If(test=BoolOp(op=And(), values=[Name(id='infer_variance', ctx=Load()), BoolOp(op=Or(), values=[Name(id='covariant', ctx=Load()), Name(id='contravariant', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Variance cannot be specified with infer_variance.')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='typevar', ctx=Load()), attr='__infer_variance__', ctx=Store())], value=Name(id='infer_variance', ctx=Load()))]), Expr(value=Call(func=Name(id='_set_default', ctx=Load()), args=[Name(id='typevar', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_set_module', ctx=Load()), args=[Name(id='typevar', ctx=Load())], keywords=[])), Return(value=Name(id='typevar', ctx=Load()))], decorator_list=[]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value="type '"), FormattedValue(value=Name(id='__name__', ctx=Load()), conversion=-1), Constant(value=".TypeVar' is not an acceptable base type")])], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='ParamSpecArgs')], keywords=[]), body=[Assign(targets=[Name(id='ParamSpecArgs', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpecArgs', ctx=Load())), Assign(targets=[Name(id='ParamSpecKwargs', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpecKwargs', ctx=Load()))], orelse=[ClassDef(name='_Immutable', bases=[], keywords=[], body=[Expr(value=Constant(value='Mixin to indicate that object should not be copied.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__copy__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__deepcopy__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='memo')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='ParamSpecArgs', bases=[Name(id='_Immutable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The args for a ParamSpec object.\n\n        Given a ParamSpec object P, P.args is an instance of ParamSpecArgs.\n\n        ParamSpecArgs objects have a reference back to their ParamSpec:\n\n        P.args.__origin__ is P\n\n        This type is meant for runtime introspection and has no special meaning to\n        static type checkers.\n        ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Store())], value=Name(id='origin', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='.args')]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParamSpecArgs', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__origin__', ctx=Load())]))], decorator_list=[])], decorator_list=[]), ClassDef(name='ParamSpecKwargs', bases=[Name(id='_Immutable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The kwargs for a ParamSpec object.\n\n        Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs.\n\n        ParamSpecKwargs objects have a reference back to their ParamSpec:\n\n        P.kwargs.__origin__ is P\n\n        This type is meant for runtime introspection and has no special meaning to\n        static type checkers.\n        ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Store())], value=Name(id='origin', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='.kwargs')]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParamSpecKwargs', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__origin__', ctx=Load())]))], decorator_list=[])], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='ParamSpec')], keywords=[]), body=[ClassDef(name='ParamSpec', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='_TypeVarLikeMeta', ctx=Load()))], body=[Expr(value=Constant(value='Parameter specification.')), Assign(targets=[Name(id='_backported_typevarlike', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpec', ctx=Load())), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name')], kwonlyargs=[arg(arg='bound'), arg(arg='covariant'), arg(arg='contravariant'), arg(arg='infer_variance'), arg(arg='default')], kw_defaults=[Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=False), Name(id='_marker', ctx=Load())], defaults=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeAliasType')], keywords=[]), body=[Assign(targets=[Name(id='paramspec', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpec', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[keyword(arg='bound', value=Name(id='bound', ctx=Load())), keyword(arg='covariant', value=Name(id='covariant', ctx=Load())), keyword(arg='contravariant', value=Name(id='contravariant', ctx=Load())), keyword(arg='infer_variance', value=Name(id='infer_variance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='paramspec', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpec', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[keyword(arg='bound', value=Name(id='bound', ctx=Load())), keyword(arg='covariant', value=Name(id='covariant', ctx=Load())), keyword(arg='contravariant', value=Name(id='contravariant', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='paramspec', ctx=Load()), attr='__infer_variance__', ctx=Store())], value=Name(id='infer_variance', ctx=Load()))]), Expr(value=Call(func=Name(id='_set_default', ctx=Load()), args=[Name(id='paramspec', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_set_module', ctx=Load()), args=[Name(id='paramspec', ctx=Load())], keywords=[])), Return(value=Name(id='paramspec', ctx=Load()))], decorator_list=[]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value="type '"), FormattedValue(value=Name(id='__name__', ctx=Load()), conversion=-1), Constant(value=".ParamSpec' is not an acceptable base type")])], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[])], orelse=[ClassDef(name='ParamSpec', bases=[Name(id='list', ctx=Load()), Name(id='_DefaultMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Parameter specification variable.\n\n        Usage::\n\n           P = ParamSpec('P')\n\n        Parameter specification variables exist primarily for the benefit of static\n        type checkers.  They are used to forward the parameter types of one\n        callable to another callable, a pattern commonly found in higher order\n        functions and decorators.  They are only valid when used in ``Concatenate``,\n        or s the first argument to ``Callable``. In Python 3.10 and higher,\n        they are also supported in user-defined Generics at runtime.\n        See class Generic for more information on generic types.  An\n        example for annotating a decorator::\n\n           T = TypeVar('T')\n           P = ParamSpec('P')\n\n           def add_logging(f: Callable[P, T]) -> Callable[P, T]:\n               '''A type-safe decorator to add logging to a function.'''\n               def inner(*args: P.args, **kwargs: P.kwargs) -> T:\n                   logging.info(f'{f.__name__} was called')\n                   return f(*args, **kwargs)\n               return inner\n\n           @add_logging\n           def add_two(x: float, y: float) -> float:\n               '''Add two numbers together.'''\n               return x + y\n\n        Parameter specification variables defined with covariant=True or\n        contravariant=True can be used to declare covariant or contravariant\n        generic types.  These keyword arguments are valid, but their actual semantics\n        are yet to be decided.  See PEP 612 for details.\n\n        Parameter specification variables can be introspected. e.g.:\n\n           P.__name__ == 'T'\n           P.__bound__ == None\n           P.__covariant__ == False\n           P.__contravariant__ == False\n\n        Note that only parameter specification variables defined in global scope can\n        be pickled.\n        ")), Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())), FunctionDef(name='args', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='ParamSpecArgs', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='kwargs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='ParamSpecKwargs', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[arg(arg='bound'), arg(arg='covariant'), arg(arg='contravariant'), arg(arg='infer_variance'), arg(arg='default')], kw_defaults=[Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=False), Name(id='_marker', ctx=Load())], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__covariant__', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='covariant', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__contravariant__', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='contravariant', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__infer_variance__', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='infer_variance', ctx=Load())], keywords=[])), If(test=Name(id='bound', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__bound__', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='bound', ctx=Load()), Constant(value='Bound must be a type.')], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__bound__', ctx=Store())], value=Constant(value=None))]), Expr(value=Call(func=Attribute(value=Name(id='_DefaultMixin', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Name(id='_caller', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='__infer_variance__', ctx=Load()), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value=''))], orelse=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='__covariant__', ctx=Load()), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value='+'))], orelse=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='__contravariant__', ctx=Load()), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value='-'))], orelse=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value='~'))])])]), Return(value=BinOp(left=Name(id='prefix', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load())))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__hash__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='other', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Pass()], decorator_list=[])], decorator_list=[])]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Concatenate')], keywords=[])), body=[ClassDef(name='_ConcatenateGenericAlias', bases=[Name(id='list', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())), Assign(targets=[Name(id='_special', ctx=Store())], value=Constant(value=False)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin'), arg(arg='args')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Store())], value=Name(id='origin', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Store())], value=Name(id='args', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='_type_repr', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load())), Return(value=JoinedStr(values=[FormattedValue(value=Call(func=Name(id='_type_repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load())], keywords=[]), conversion=-1), Constant(value='['), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_type_repr', ctx=Load()), args=[Name(id='arg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='arg', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), conversion=-1), Constant(value=']')]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Pass()], decorator_list=[]), FunctionDef(name='__parameters__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Name(id='tp', ctx=Load()), generators=[comprehension(target=Name(id='tp', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load()), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), Name(id='ParamSpec', ctx=Load())], ctx=Load())], keywords=[])], is_async=0)])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())])], decorator_list=[])], orelse=[]), FunctionDef(name='_concatenate_getitem', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='parameters', ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot take a Concatenate of no types.')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='parameters', ctx=Store())], value=Tuple(elts=[Name(id='parameters', ctx=Load())], ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='parameters', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='ParamSpec', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='The last parameter to Concatenate should be a ParamSpec variable.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Concatenate[arg, ...]: each arg must be a type.')), Assign(targets=[Name(id='parameters', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='parameters', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Call(func=Name(id='_ConcatenateGenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Concatenate')], keywords=[]), body=[Assign(targets=[Name(id='Concatenate', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Concatenate', ctx=Load())), Assign(targets=[Name(id='_ConcatenateGenericAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_ConcatenateGenericAlias', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[FunctionDef(name='Concatenate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a\n        higher order function which adds, removes or transforms parameters of a\n        callable.\n\n        For example::\n\n           Callable[Concatenate[int, P], int]\n\n        See PEP 612 for detailed information.\n        ')), Return(value=Call(func=Name(id='_concatenate_getitem', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[Name(id='_ExtensionsSpecialForm', ctx=Load())])], orelse=[ClassDef(name='_ConcatenateForm', bases=[Name(id='_ExtensionsSpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='_concatenate_getitem', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Concatenate', ctx=Store())], value=Call(func=Name(id='_ConcatenateForm', ctx=Load()), args=[Constant(value='Concatenate')], keywords=[keyword(arg='doc', value=Constant(value='Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a\n        higher order function which adds, removes or transforms parameters of a\n        callable.\n\n        For example::\n\n           Callable[Concatenate[int, P], int]\n\n        See PEP 612 for detailed information.\n        '))]))])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeGuard')], keywords=[]), body=[Assign(targets=[Name(id='TypeGuard', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeGuard', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[FunctionDef(name='TypeGuard', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Special typing form used to annotate the return type of a user-defined\n        type guard function.  ``TypeGuard`` only accepts a single type argument.\n        At runtime, functions marked this way should return a boolean.\n\n        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static\n        type checkers to determine a more precise type of an expression within a\n        program\'s code flow.  Usually type narrowing is done by analyzing\n        conditional code flow and applying the narrowing to a block of code.  The\n        conditional expression here is sometimes referred to as a "type guard".\n\n        Sometimes it would be convenient to use a user-defined boolean function\n        as a type guard.  Such a function should use ``TypeGuard[...]`` as its\n        return type to alert static type checkers to this intention.\n\n        Using  ``-> TypeGuard`` tells the static type checker that for a given\n        function:\n\n        1. The return value is a boolean.\n        2. If the return value is ``True``, the type of its argument\n        is the type inside ``TypeGuard``.\n\n        For example::\n\n            def is_str(val: Union[str, float]):\n                # "isinstance" type guard\n                if isinstance(val, str):\n                    # Type of ``val`` is narrowed to ``str``\n                    ...\n                else:\n                    # Else, type of ``val`` is narrowed to ``float``.\n                    ...\n\n        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower\n        form of ``TypeA`` (it can even be a wider form) and this may lead to\n        type-unsafe results.  The main reason is to allow for things like\n        narrowing ``List[object]`` to ``List[str]`` even though the latter is not\n        a subtype of the former, since ``List`` is invariant.  The responsibility of\n        writing type-safe type guards is left to the user.\n\n        ``TypeGuard`` also works with type variables.  For more information, see\n        PEP 647 (User-Defined Type Guards).\n        ')), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_ExtensionsSpecialForm', ctx=Load())])], orelse=[ClassDef(name='_TypeGuardForm', bases=[Name(id='_ExtensionsSpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='TypeGuard', ctx=Store())], value=Call(func=Name(id='_TypeGuardForm', ctx=Load()), args=[Constant(value='TypeGuard')], keywords=[keyword(arg='doc', value=Constant(value='Special typing form used to annotate the return type of a user-defined\n        type guard function.  ``TypeGuard`` only accepts a single type argument.\n        At runtime, functions marked this way should return a boolean.\n\n        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static\n        type checkers to determine a more precise type of an expression within a\n        program\'s code flow.  Usually type narrowing is done by analyzing\n        conditional code flow and applying the narrowing to a block of code.  The\n        conditional expression here is sometimes referred to as a "type guard".\n\n        Sometimes it would be convenient to use a user-defined boolean function\n        as a type guard.  Such a function should use ``TypeGuard[...]`` as its\n        return type to alert static type checkers to this intention.\n\n        Using  ``-> TypeGuard`` tells the static type checker that for a given\n        function:\n\n        1. The return value is a boolean.\n        2. If the return value is ``True``, the type of its argument\n        is the type inside ``TypeGuard``.\n\n        For example::\n\n            def is_str(val: Union[str, float]):\n                # "isinstance" type guard\n                if isinstance(val, str):\n                    # Type of ``val`` is narrowed to ``str``\n                    ...\n                else:\n                    # Else, type of ``val`` is narrowed to ``float``.\n                    ...\n\n        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower\n        form of ``TypeA`` (it can even be a wider form) and this may lead to\n        type-unsafe results.  The main reason is to allow for things like\n        narrowing ``List[object]`` to ``List[str]`` even though the latter is not\n        a subtype of the former, since ``List`` is invariant.  The responsibility of\n        writing type-safe type guards is left to the user.\n\n        ``TypeGuard`` also works with type variables.  For more information, see\n        PEP 647 (User-Defined Type Guards).\n        '))]))])]), ClassDef(name='_SpecialForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_Final', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='_name'), Constant(value='__doc__'), Constant(value='_getitem')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='getitem')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_getitem', ctx=Store())], value=Name(id='getitem', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Store())], value=Attribute(value=Name(id='getitem', ctx=Load()), attr='__name__', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__doc__', ctx=Store())], value=Attribute(value=Name(id='getitem', ctx=Load()), attr='__doc__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='item', ctx=Load()), ops=[In()], comparators=[Set(elts=[Constant(value='__name__'), Constant(value='__qualname__')])]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__mro_entries__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='bases')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot subclass '), FormattedValue(value=Name(id='self', ctx=Load()), conversion=114)])], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='typing_extensions.'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1)]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot instantiate '), FormattedValue(value=Name(id='self', ctx=Load()), conversion=114)])], keywords=[]))], decorator_list=[]), FunctionDef(name='__or__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__ror__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='other', ctx=Load()), Name(id='self', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' cannot be used with isinstance()')])], keywords=[]))], decorator_list=[]), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' cannot be used with issubclass()')])], keywords=[]))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_getitem', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())])], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='LiteralString')], keywords=[]), body=[Assign(targets=[Name(id='LiteralString', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='LiteralString', ctx=Load()))], orelse=[FunctionDef(name='LiteralString', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Represents an arbitrary literal string.\n\n        Example::\n\n          from pip._vendor.typing_extensions import LiteralString\n\n          def query(sql: LiteralString) -> ...:\n              ...\n\n          query("SELECT * FROM table")  # ok\n          query(f"SELECT * FROM {input()}")  # not ok\n\n        See PEP 675 for details.\n\n        ')), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not subscriptable')])], keywords=[]))], decorator_list=[Name(id='_SpecialForm', ctx=Load())])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Self')], keywords=[]), body=[Assign(targets=[Name(id='Self', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Self', ctx=Load()))], orelse=[FunctionDef(name='Self', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Used to spell the type of "self" in classes.\n\n        Example::\n\n          from typing import Self\n\n          class ReturnsSelf:\n              def parse(self, data: bytes) -> Self:\n                  ...\n                  return self\n\n        ')), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not subscriptable')])], keywords=[]))], decorator_list=[Name(id='_SpecialForm', ctx=Load())])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Never')], keywords=[]), body=[Assign(targets=[Name(id='Never', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Never', ctx=Load()))], orelse=[FunctionDef(name='Never', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The bottom type, a type that has no members.\n\n        This can be used to define a function that should never be\n        called, or a function that never returns::\n\n            from pip._vendor.typing_extensions import Never\n\n            def never_call_me(arg: Never) -> None:\n                pass\n\n            def int_or_str(arg: int | str) -> None:\n                never_call_me(arg)  # type checker error\n                match arg:\n                    case int():\n                        print("It\'s an int")\n                    case str():\n                        print("It\'s a str")\n                    case _:\n                        never_call_me(arg)  # ok, arg is of type Never\n\n        ')), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not subscriptable')])], keywords=[]))], decorator_list=[Name(id='_SpecialForm', ctx=Load())])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Required')], keywords=[]), body=[Assign(targets=[Name(id='Required', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Required', ctx=Load())), Assign(targets=[Name(id='NotRequired', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NotRequired', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[FunctionDef(name='Required', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A special typing construct to mark a key of a total=False TypedDict\n        as required. For example:\n\n            class Movie(TypedDict, total=False):\n                title: Required[str]\n                year: int\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n\n        There is no runtime checking that a required key is actually provided\n        when instantiating a related TypedDict.\n        ")), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_ExtensionsSpecialForm', ctx=Load())]), FunctionDef(name='NotRequired', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A special typing construct to mark a key of a TypedDict as\n        potentially missing. For example:\n\n            class Movie(TypedDict):\n                title: str\n                year: NotRequired[int]\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n        ")), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_ExtensionsSpecialForm', ctx=Load())])], orelse=[ClassDef(name='_RequiredForm', bases=[Name(id='_ExtensionsSpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Required', ctx=Store())], value=Call(func=Name(id='_RequiredForm', ctx=Load()), args=[Constant(value='Required')], keywords=[keyword(arg='doc', value=Constant(value="A special typing construct to mark a key of a total=False TypedDict\n        as required. For example:\n\n            class Movie(TypedDict, total=False):\n                title: Required[str]\n                year: int\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n\n        There is no runtime checking that a required key is actually provided\n        when instantiating a related TypedDict.\n        "))])), Assign(targets=[Name(id='NotRequired', ctx=Store())], value=Call(func=Name(id='_RequiredForm', ctx=Load()), args=[Constant(value='NotRequired')], keywords=[keyword(arg='doc', value=Constant(value="A special typing construct to mark a key of a TypedDict as\n        potentially missing. For example:\n\n            class Movie(TypedDict):\n                title: str\n                year: NotRequired[int]\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n        "))]))])]), Assign(targets=[Name(id='_UNPACK_DOC', ctx=Store())], value=Constant(value="Type unpack operator.\n\nThe type unpack operator takes the child types from some container type,\nsuch as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For\nexample:\n\n  # For some generic class `Foo`:\n  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]\n\n  Ts = TypeVarTuple('Ts')\n  # Specifies that `Bar` is generic in an arbitrary number of types.\n  # (Think of `Ts` as a tuple of an arbitrary number of individual\n  #  `TypeVar`s, which the `Unpack` is 'pulling out' directly into the\n  #  `Generic[]`.)\n  class Bar(Generic[Unpack[Ts]]): ...\n  Bar[int]  # Valid\n  Bar[int, str]  # Also valid\n\nFrom Python 3.11, this can also be done using the `*` operator:\n\n    Foo[*tuple[int, str]]\n    class Bar(Generic[*Ts]): ...\n\nThe operator can also be used along with a `TypedDict` to annotate\n`**kwargs` in a function signature. For instance:\n\n  class Movie(TypedDict):\n    name: str\n    year: int\n\n  # This function expects two keyword arguments - *name* of type `str` and\n  # *year* of type `int`.\n  def foo(**kwargs: Unpack[Movie]): ...\n\nNote that there is only some runtime checking of this operator. Not\neverything the runtime allows may be accepted by static type checkers.\n\nFor more information, see PEP 646 and PEP 692.\n")), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=12)], ctx=Load())]), body=[Assign(targets=[Name(id='Unpack', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Unpack', ctx=Load())), FunctionDef(name='_is_unpack', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Name(id='get_origin', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Name(id='Unpack', ctx=Load())]))], decorator_list=[])], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[ClassDef(name='_UnpackSpecialForm', bases=[Name(id='_ExtensionsSpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='getitem')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='getitem', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__doc__', ctx=Store())], value=Name(id='_UNPACK_DOC', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='_UnpackAlias', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()))], decorator_list=[]), FunctionDef(name='Unpack', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Name(id='_UnpackAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_UnpackSpecialForm', ctx=Load())]), FunctionDef(name='_is_unpack', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='_UnpackAlias', ctx=Load())], keywords=[]))], decorator_list=[])], orelse=[ClassDef(name='_UnpackAlias', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()))], decorator_list=[]), ClassDef(name='_UnpackForm', bases=[Name(id='_ExtensionsSpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Name(id='_UnpackAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Unpack', ctx=Store())], value=Call(func=Name(id='_UnpackForm', ctx=Load()), args=[Constant(value='Unpack')], keywords=[keyword(arg='doc', value=Name(id='_UNPACK_DOC', ctx=Load()))])), FunctionDef(name='_is_unpack', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='_UnpackAlias', ctx=Load())], keywords=[]))], decorator_list=[])])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeVarTuple')], keywords=[]), body=[ClassDef(name='TypeVarTuple', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='_TypeVarLikeMeta', ctx=Load()))], body=[Expr(value=Constant(value='Type variable tuple.')), Assign(targets=[Name(id='_backported_typevarlike', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVarTuple', ctx=Load())), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name')], kwonlyargs=[arg(arg='default')], kw_defaults=[Name(id='_marker', ctx=Load())], defaults=[]), body=[Assign(targets=[Name(id='tvt', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVarTuple', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_set_default', ctx=Load()), args=[Name(id='tvt', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_set_module', ctx=Load()), args=[Name(id='tvt', ctx=Load())], keywords=[])), Return(value=Name(id='tvt', ctx=Load()))], decorator_list=[]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot subclass special typing classes')], keywords=[]))], decorator_list=[])], decorator_list=[])], orelse=[ClassDef(name='TypeVarTuple', bases=[Name(id='_DefaultMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Type variable tuple.\n\n        Usage::\n\n            Ts = TypeVarTuple('Ts')\n\n        In the same way that a normal type variable is a stand-in for a single\n        type such as ``int``, a type variable *tuple* is a stand-in for a *tuple*\n        type such as ``Tuple[int, str]``.\n\n        Type variable tuples can be used in ``Generic`` declarations.\n        Consider the following example::\n\n            class Array(Generic[*Ts]): ...\n\n        The ``Ts`` type variable tuple here behaves like ``tuple[T1, T2]``,\n        where ``T1`` and ``T2`` are type variables. To use these type variables\n        as type parameters of ``Array``, we must *unpack* the type variable tuple using\n        the star operator: ``*Ts``. The signature of ``Array`` then behaves\n        as if we had simply written ``class Array(Generic[T1, T2]): ...``.\n        In contrast to ``Generic[T1, T2]``, however, ``Generic[*Shape]`` allows\n        us to parameterise the class with an *arbitrary* number of type parameters.\n\n        Type variable tuples can be used anywhere a normal ``TypeVar`` can.\n        This includes class definitions, as shown above, as well as function\n        signatures and variable annotations::\n\n            class Array(Generic[*Ts]):\n\n                def __init__(self, shape: Tuple[*Ts]):\n                    self._shape: Tuple[*Ts] = shape\n\n                def get_shape(self) -> Tuple[*Ts]:\n                    return self._shape\n\n            shape = (Height(480), Width(640))\n            x: Array[Height, Width] = Array(shape)\n            y = abs(x)  # Inferred type is Array[Height, Width]\n            z = x + x   #        ...    is Array[Height, Width]\n            x.get_shape()  #     ...    is tuple[Height, Width]\n\n        ")), Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Yield(value=Attribute(value=Name(id='self', ctx=Load()), attr='__unpacked__', ctx=Load())))], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[arg(arg='default')], kw_defaults=[Name(id='_marker', ctx=Load())], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Store())], value=Name(id='name', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='_DefaultMixin', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Name(id='_caller', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__unpacked__', ctx=Store())], value=Subscript(value=Name(id='Unpack', ctx=Load()), slice=Name(id='self', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__hash__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='other', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[If(test=Compare(left=Constant(value='_root'), ops=[NotIn()], comparators=[Name(id='kwds', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot subclass special typing classes')], keywords=[]))], orelse=[])], decorator_list=[])], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='reveal_type')], keywords=[]), body=[Assign(targets=[Name(id='reveal_type', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='reveal_type', ctx=Load()))], orelse=[FunctionDef(name='reveal_type', args=arguments(posonlyargs=[], args=[arg(arg='__obj', annotation=Name(id='T', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Reveal the inferred type of a variable.\n\n        When a static type checker encounters a call to ``reveal_type()``,\n        it will emit the inferred type of the argument::\n\n            x: int = 1\n            reveal_type(x)\n\n        Running a static type checker (e.g., ``mypy``) on this example\n        will produce output similar to \'Revealed type is "builtins.int"\'.\n\n        At runtime, the function prints the runtime type of the\n        argument and returns it unchanged.\n\n        ')), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Runtime type is '), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='__obj', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=114)])], keywords=[keyword(arg='file', value=Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Load()))])), Return(value=Name(id='__obj', ctx=Load()))], decorator_list=[], returns=Name(id='T', ctx=Load()))]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='assert_never')], keywords=[]), body=[Assign(targets=[Name(id='assert_never', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='assert_never', ctx=Load()))], orelse=[FunctionDef(name='assert_never', args=arguments(posonlyargs=[], args=[arg(arg='__arg', annotation=Name(id='Never', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Assert to the type checker that a line of code is unreachable.\n\n        Example::\n\n            def int_or_str(arg: int | str) -> None:\n                match arg:\n                    case int():\n                        print("It\'s an int")\n                    case str():\n                        print("It\'s a str")\n                    case _:\n                        assert_never(arg)\n\n        If a type checker finds that a call to assert_never() is\n        reachable, it will emit an error.\n\n        At runtime, this throws an exception when called.\n\n        ')), Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Constant(value='Expected code to be unreachable')], keywords=[]))], decorator_list=[], returns=Name(id='Never', ctx=Load()))]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=12)], ctx=Load())]), body=[Assign(targets=[Name(id='dataclass_transform', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='dataclass_transform', ctx=Load()))], orelse=[FunctionDef(name='dataclass_transform', args=arguments(posonlyargs=[], args=[], kwonlyargs=[arg(arg='eq_default', annotation=Name(id='bool', ctx=Load())), arg(arg='order_default', annotation=Name(id='bool', ctx=Load())), arg(arg='kw_only_default', annotation=Name(id='bool', ctx=Load())), arg(arg='frozen_default', annotation=Name(id='bool', ctx=Load())), arg(arg='field_specifiers', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Type', ctx=Load()), slice=Attribute(value=Name(id='typing', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Attribute(value=Name(id='typing', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=True), Constant(value=False), Constant(value=False), Constant(value=False), Tuple(elts=[], ctx=Load())], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='typing', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Decorator that marks a function, class, or metaclass as providing\n        dataclass-like behavior.\n\n        Example:\n\n            from pip._vendor.typing_extensions import dataclass_transform\n\n            _T = TypeVar("_T")\n\n            # Used on a decorator function\n            @dataclass_transform()\n            def create_model(cls: type[_T]) -> type[_T]:\n                ...\n                return cls\n\n            @create_model\n            class CustomerModel:\n                id: int\n                name: str\n\n            # Used on a base class\n            @dataclass_transform()\n            class ModelBase: ...\n\n            class CustomerModel(ModelBase):\n                id: int\n                name: str\n\n            # Used on a metaclass\n            @dataclass_transform()\n            class ModelMeta(type): ...\n\n            class ModelBase(metaclass=ModelMeta): ...\n\n            class CustomerModel(ModelBase):\n                id: int\n                name: str\n\n        Each of the ``CustomerModel`` classes defined in this example will now\n        behave similarly to a dataclass created with the ``@dataclasses.dataclass``\n        decorator. For example, the type checker will synthesize an ``__init__``\n        method.\n\n        The arguments to this decorator can be used to customize this behavior:\n        - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be\n          True or False if it is omitted by the caller.\n        - ``order_default`` indicates whether the ``order`` parameter is\n          assumed to be True or False if it is omitted by the caller.\n        - ``kw_only_default`` indicates whether the ``kw_only`` parameter is\n          assumed to be True or False if it is omitted by the caller.\n        - ``frozen_default`` indicates whether the ``frozen`` parameter is\n          assumed to be True or False if it is omitted by the caller.\n        - ``field_specifiers`` specifies a static list of supported classes\n          or functions that describe fields, similar to ``dataclasses.field()``.\n\n        At runtime, this decorator records its arguments in the\n        ``__dataclass_transform__`` attribute on the decorated object.\n\n        See PEP 681 for details.\n\n        ')), FunctionDef(name='decorator', args=arguments(posonlyargs=[], args=[arg(arg='cls_or_fn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='cls_or_fn', ctx=Load()), attr='__dataclass_transform__', ctx=Store())], value=Dict(keys=[Constant(value='eq_default'), Constant(value='order_default'), Constant(value='kw_only_default'), Constant(value='frozen_default'), Constant(value='field_specifiers'), Constant(value='kwargs')], values=[Name(id='eq_default', ctx=Load()), Name(id='order_default', ctx=Load()), Name(id='kw_only_default', ctx=Load()), Name(id='frozen_default', ctx=Load()), Name(id='field_specifiers', ctx=Load()), Name(id='kwargs', ctx=Load())])), Return(value=Name(id='cls_or_fn', ctx=Load()))], decorator_list=[]), Return(value=Name(id='decorator', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='T', ctx=Load())], ctx=Load()), Name(id='T', ctx=Load())], ctx=Load()), ctx=Load()))]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='override')], keywords=[]), body=[Assign(targets=[Name(id='override', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='override', ctx=Load()))], orelse=[Assign(targets=[Name(id='_F', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='_F')], keywords=[keyword(arg='bound', value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Attribute(value=Name(id='typing', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))])), FunctionDef(name='override', args=arguments(posonlyargs=[], args=[arg(arg='__arg', annotation=Name(id='_F', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Indicate that a method is intended to override a method in a base class.\n\n        Usage:\n\n            class Base:\n                def method(self) -> None: ...\n                    pass\n\n            class Child(Base):\n                @override\n                def method(self) -> None:\n                    super().method()\n\n        When this decorator is applied to a method, the type checker will\n        validate that it overrides a method with the same name on a base class.\n        This helps prevent bugs that may occur when a base class is changed\n        without an equivalent change to a child class.\n\n        There is no runtime checking of these properties. The decorator\n        sets the ``__override__`` attribute to ``True`` on the decorated object\n        to allow runtime introspection.\n\n        See PEP 698 for details.\n\n        ')), Try(body=[Assign(targets=[Attribute(value=Name(id='__arg', ctx=Load()), attr='__override__', ctx=Store())], value=Constant(value=True))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Name(id='__arg', ctx=Load()))], decorator_list=[], returns=Name(id='_F', ctx=Load()))]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='deprecated')], keywords=[]), body=[Assign(targets=[Name(id='deprecated', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='deprecated', ctx=Load()))], orelse=[Assign(targets=[Name(id='_T', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='_T')], keywords=[])), FunctionDef(name='deprecated', args=arguments(posonlyargs=[], args=[arg(arg='__msg', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='category', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='Warning', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='stacklevel', annotation=Name(id='int', ctx=Load()))], kw_defaults=[Name(id='DeprecationWarning', ctx=Load()), Constant(value=1)], defaults=[]), body=[Expr(value=Constant(value='Indicate that a class, function or overload is deprecated.\n\n        Usage:\n\n            @deprecated("Use B instead")\n            class A:\n                pass\n\n            @deprecated("Use g instead")\n            def f():\n                pass\n\n            @overload\n            @deprecated("int support is deprecated")\n            def g(x: int) -> int: ...\n            @overload\n            def g(x: str) -> int: ...\n\n        When this decorator is applied to an object, the type checker\n        will generate a diagnostic on usage of the deprecated object.\n\n        The warning specified by ``category`` will be emitted on use\n        of deprecated objects. For functions, that happens on calls;\n        for classes, on instantiation. If the ``category`` is ``None``,\n        no warning is emitted. The ``stacklevel`` determines where the\n        warning is emitted. If it is ``1`` (the default), the warning\n        is emitted at the direct caller of the deprecated object; if it\n        is higher, it is emitted further up the stack.\n\n        The decorator sets the ``__deprecated__``\n        attribute on the decorated object to the deprecation message\n        passed to the decorator. If applied to an overload, the decorator\n        must be after the ``@overload`` decorator for the attribute to\n        exist on the overload as returned by ``get_overloads()``.\n\n        See PEP 702 for details.\n\n        ')), FunctionDef(name='decorator', args=arguments(posonlyargs=[], args=[arg(arg='__arg', annotation=Name(id='_T', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='category', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='__arg', ctx=Load()), attr='__deprecated__', ctx=Store())], value=Name(id='__msg', ctx=Load())), Return(value=Name(id='__arg', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='__arg', ctx=Load()), Name(id='type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='original_new', ctx=Store())], value=Attribute(value=Name(id='__arg', ctx=Load()), attr='__new__', ctx=Load())), Assign(targets=[Name(id='has_init', ctx=Store())], value=Compare(left=Attribute(value=Name(id='__arg', ctx=Load()), attr='__init__', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='object', ctx=Load()), attr='__init__', ctx=Load())])), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='__msg', ctx=Load())], keywords=[keyword(arg='category', value=Name(id='category', ctx=Load())), keyword(arg='stacklevel', value=BinOp(left=Name(id='stacklevel', ctx=Load()), op=Add(), right=Constant(value=1)))])), If(test=Compare(left=Name(id='original_new', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='object', ctx=Load()), attr='__new__', ctx=Load())]), body=[Return(value=Call(func=Name(id='original_new', ctx=Load()), args=[Name(id='cls', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='has_init', ctx=Load())), BoolOp(op=Or(), values=[Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='() takes no arguments')])], keywords=[]))], orelse=[Return(value=Call(func=Name(id='original_new', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]))])])], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='original_new', ctx=Load())], keywords=[])]), Assign(targets=[Attribute(value=Name(id='__arg', ctx=Load()), attr='__new__', ctx=Store())], value=Call(func=Name(id='staticmethod', ctx=Load()), args=[Name(id='__new__', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='__arg', ctx=Load()), attr='__deprecated__', ctx=Store()), Attribute(value=Name(id='__new__', ctx=Load()), attr='__deprecated__', ctx=Store())], value=Name(id='__msg', ctx=Load())), Return(value=Name(id='__arg', ctx=Load()))], orelse=[If(test=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='__arg', ctx=Load())], keywords=[]), body=[FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='__msg', ctx=Load())], keywords=[keyword(arg='category', value=Name(id='category', ctx=Load())), keyword(arg='stacklevel', value=BinOp(left=Name(id='stacklevel', ctx=Load()), op=Add(), right=Constant(value=1)))])), Return(value=Call(func=Name(id='__arg', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='wraps', ctx=Load()), args=[Name(id='__arg', ctx=Load())], keywords=[])]), Assign(targets=[Attribute(value=Name(id='__arg', ctx=Load()), attr='__deprecated__', ctx=Store()), Attribute(value=Name(id='wrapper', ctx=Load()), attr='__deprecated__', ctx=Store())], value=Name(id='__msg', ctx=Load())), Return(value=Name(id='wrapper', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='@deprecated decorator with non-None category must be applied to a class or callable, not '), FormattedValue(value=Name(id='__arg', ctx=Load()), conversion=114)])], keywords=[]))])])])], decorator_list=[], returns=Name(id='_T', ctx=Load())), Return(value=Name(id='decorator', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='_T', ctx=Load())], ctx=Load()), Name(id='_T', ctx=Load())], ctx=Load()), ctx=Load()))]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeVarTuple')], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='typing', ctx=Load()), attr='_collect_type_vars', ctx=Store())], value=Name(id='_collect_type_vars', ctx=Load())), Assign(targets=[Attribute(value=Name(id='typing', ctx=Load()), attr='_check_generic', ctx=Store())], value=Name(id='_check_generic', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=13)], ctx=Load())]), body=[Assign(targets=[Name(id='NamedTuple', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NamedTuple', ctx=Load()))], orelse=[FunctionDef(name='_make_nmtuple', args=arguments(posonlyargs=[], args=[arg(arg='name'), arg(arg='types'), arg(arg='module'), arg(arg='defaults')], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[], ctx=Load())]), body=[Assign(targets=[Name(id='fields', ctx=Store())], value=ListComp(elt=Name(id='n', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='t', ctx=Store())], ctx=Store()), iter=Name(id='types', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='annotations', ctx=Store())], value=DictComp(key=Name(id='n', ctx=Load()), value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='t', ctx=Load()), JoinedStr(values=[Constant(value='field '), FormattedValue(value=Name(id='n', ctx=Load()), conversion=-1), Constant(value=' annotation must be a type')])], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='t', ctx=Store())], ctx=Store()), iter=Name(id='types', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='nm_tpl', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='namedtuple', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='fields', ctx=Load())], keywords=[keyword(arg='defaults', value=Name(id='defaults', ctx=Load())), keyword(arg='module', value=Name(id='module', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__annotations__', ctx=Store()), Attribute(value=Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__new__', ctx=Load()), attr='__annotations__', ctx=Store())], value=Name(id='annotations', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[Lt()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='_field_types', ctx=Store())], value=Name(id='annotations', ctx=Load()))], orelse=[]), Return(value=Name(id='nm_tpl', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_prohibited_namedtuple_fields', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_prohibited', ctx=Load())), Assign(targets=[Name(id='_special_namedtuple_fields', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Set(elts=[Constant(value='__module__'), Constant(value='__name__'), Constant(value='__annotations__')])], keywords=[])), ClassDef(name='_NamedTupleMeta', bases=[Name(id='type', ctx=Load())], keywords=[], body=[FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='typename'), arg(arg='bases'), arg(arg='ns')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Name(id='_NamedTuple', ctx=Load()), ops=[In()], comparators=[Name(id='bases', ctx=Load())])), For(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='base', ctx=Load()), ops=[IsNot()], comparators=[Name(id='_NamedTuple', ctx=Load())]), Compare(left=Name(id='base', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='can only inherit from a NamedTuple type and Generic')], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='bases', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=IfExp(test=Compare(left=Name(id='base', ctx=Load()), ops=[Is()], comparators=[Name(id='_NamedTuple', ctx=Load())]), body=Name(id='tuple', ctx=Load()), orelse=Name(id='base', ctx=Load())), generators=[comprehension(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='types', ctx=Store())], value=Call(func=Attribute(value=Name(id='ns', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Name(id='default_names', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='field_name', ctx=Store()), iter=Name(id='types', ctx=Load()), body=[If(test=Compare(left=Name(id='field_name', ctx=Load()), ops=[In()], comparators=[Name(id='ns', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='default_names', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='field_name', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='default_names', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Non-default namedtuple field '), FormattedValue(value=Name(id='field_name', ctx=Load()), conversion=-1), Constant(value=' cannot follow default field'), FormattedValue(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='default_names', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=Constant(value='s'), orelse=Constant(value='')), conversion=-1), Constant(value=' '), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='default_names', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))], orelse=[])])], orelse=[]), Assign(targets=[Name(id='nm_tpl', ctx=Store())], value=Call(func=Name(id='_make_nmtuple', ctx=Load()), args=[Name(id='typename', ctx=Load()), Call(func=Attribute(value=Name(id='types', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='defaults', value=ListComp(elt=Subscript(value=Name(id='ns', ctx=Load()), slice=Name(id='n', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='n', ctx=Store()), iter=Name(id='default_names', ctx=Load()), ifs=[], is_async=0)])), keyword(arg='module', value=Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__module__'), ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__bases__', ctx=Store())], value=Name(id='bases', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), ops=[In()], comparators=[Name(id='bases', ctx=Load())]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='_generic_class_getitem')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__class_getitem__', ctx=Store())], value=Call(func=Name(id='classmethod', ctx=Load()), args=[Attribute(value=Name(id='typing', ctx=Load()), attr='_generic_class_getitem', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='class_getitem', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), attr='__class_getitem__', ctx=Load()), attr='__func__', ctx=Load())), Assign(targets=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__class_getitem__', ctx=Store())], value=Call(func=Name(id='classmethod', ctx=Load()), args=[Name(id='class_getitem', ctx=Load())], keywords=[]))])], orelse=[]), For(target=Name(id='key', ctx=Store()), iter=Name(id='ns', ctx=Load()), body=[If(test=Compare(left=Name(id='key', ctx=Load()), ops=[In()], comparators=[Name(id='_prohibited_namedtuple_fields', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[BinOp(left=Constant(value='Cannot overwrite NamedTuple attribute '), op=Add(), right=Name(id='key', ctx=Load()))], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='key', ctx=Load()), ops=[NotIn()], comparators=[Name(id='_special_namedtuple_fields', ctx=Load())]), Compare(left=Name(id='key', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='_fields', ctx=Load())])]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='nm_tpl', ctx=Load()), Name(id='key', ctx=Load()), Subscript(value=Name(id='ns', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[])])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), ops=[In()], comparators=[Name(id='bases', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__init_subclass__', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='nm_tpl', ctx=Load()))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='_NamedTuple', ctx=Store())], value=Call(func=Attribute(value=Name(id='type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='_NamedTupleMeta', ctx=Load()), Constant(value='NamedTuple'), Tuple(elts=[], ctx=Load()), Dict(keys=[], values=[])], keywords=[])), FunctionDef(name='_namedtuple_mro_entries', args=arguments(posonlyargs=[], args=[arg(arg='bases')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Name(id='NamedTuple', ctx=Load()), ops=[In()], comparators=[Name(id='bases', ctx=Load())])), Return(value=Tuple(elts=[Name(id='_NamedTuple', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='NamedTuple', args=arguments(posonlyargs=[], args=[arg(arg='__typename'), arg(arg='__fields')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Name(id='_marker', ctx=Load())]), body=[Expr(value=Constant(value="Typed version of namedtuple.\n\n        Usage::\n\n            class Employee(NamedTuple):\n                name: str\n                id: int\n\n        This is equivalent to::\n\n            Employee = collections.namedtuple('Employee', ['name', 'id'])\n\n        The resulting class has an extra __annotations__ attribute, giving a\n        dict that maps field names to types.  (The field names are also in\n        the _fields attribute, which is part of the namedtuple API.)\n        An alternative equivalent functional syntax is also accepted::\n\n            Employee = NamedTuple('Employee', [('name', str), ('id', int)])\n        ")), If(test=Compare(left=Name(id='__fields', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[If(test=Name(id='kwargs', ctx=Load()), body=[Assign(targets=[Name(id='deprecated_thing', ctx=Store())], value=Constant(value='Creating NamedTuple classes using keyword arguments')), Assign(targets=[Name(id='deprecation_msg', ctx=Store())], value=Constant(value='{name} is deprecated and will be disallowed in Python {remove}. Use the class-based or functional syntax instead.'))], orelse=[Assign(targets=[Name(id='deprecated_thing', ctx=Store())], value=Constant(value="Failing to pass a value for the 'fields' parameter")), Assign(targets=[Name(id='example', ctx=Store())], value=JoinedStr(values=[Constant(value='`'), FormattedValue(value=Name(id='__typename', ctx=Load()), conversion=-1), Constant(value=' = NamedTuple('), FormattedValue(value=Name(id='__typename', ctx=Load()), conversion=114), Constant(value=', [])`')])), Assign(targets=[Name(id='deprecation_msg', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value='{name} is deprecated and will be disallowed in Python {remove}. To create a NamedTuple class with 0 fields using the functional syntax, pass an empty list, e.g. '), op=Add(), right=Name(id='example', ctx=Load())), op=Add(), right=Constant(value='.')))])], orelse=[If(test=Compare(left=Name(id='__fields', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Name(id='kwargs', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="Cannot pass `None` as the 'fields' parameter and also specify fields using keyword arguments")], keywords=[]))], orelse=[Assign(targets=[Name(id='deprecated_thing', ctx=Store())], value=Constant(value="Passing `None` as the 'fields' parameter")), Assign(targets=[Name(id='example', ctx=Store())], value=JoinedStr(values=[Constant(value='`'), FormattedValue(value=Name(id='__typename', ctx=Load()), conversion=-1), Constant(value=' = NamedTuple('), FormattedValue(value=Name(id='__typename', ctx=Load()), conversion=114), Constant(value=', [])`')])), Assign(targets=[Name(id='deprecation_msg', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value='{name} is deprecated and will be disallowed in Python {remove}. To create a NamedTuple class with 0 fields using the functional syntax, pass an empty list, e.g. '), op=Add(), right=Name(id='example', ctx=Load())), op=Add(), right=Constant(value='.')))])], orelse=[If(test=Name(id='kwargs', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Either list of fields or keywords can be provided to NamedTuple, not both')], keywords=[]))], orelse=[])])]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='__fields', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), Compare(left=Name(id='__fields', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Name(id='deprecation_msg', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='deprecated_thing', ctx=Load())), keyword(arg='remove', value=Constant(value='3.15'))]), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Assign(targets=[Name(id='__fields', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nt', ctx=Store())], value=Call(func=Name(id='_make_nmtuple', ctx=Load()), args=[Name(id='__typename', ctx=Load()), Name(id='__fields', ctx=Load())], keywords=[keyword(arg='module', value=Call(func=Name(id='_caller', ctx=Load()), args=[], keywords=[]))])), Assign(targets=[Attribute(value=Name(id='nt', ctx=Load()), attr='__orig_bases__', ctx=Store())], value=Tuple(elts=[Name(id='NamedTuple', ctx=Load())], ctx=Load())), Return(value=Name(id='nt', ctx=Load()))], decorator_list=[Call(func=Name(id='_ensure_subclassable', ctx=Load()), args=[Name(id='_namedtuple_mro_entries', ctx=Load())], keywords=[])]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[Assign(targets=[Name(id='_new_signature', ctx=Store())], value=Constant(value='(typename, fields=None, /, **kwargs)')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='NamedTuple', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='FunctionType', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='NamedTuple', ctx=Load()), attr='__text_signature__', ctx=Store())], value=Name(id='_new_signature', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Attribute(value=Name(id='NamedTuple', ctx=Load()), attr='__call__', ctx=Load()), attr='__text_signature__', ctx=Store())], value=Name(id='_new_signature', ctx=Load()))])], orelse=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='collections', ctx=Load()), attr='abc', ctx=Load()), Constant(value='Buffer')], keywords=[]), body=[Assign(targets=[Name(id='Buffer', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='collections', ctx=Load()), attr='abc', ctx=Load()), attr='Buffer', ctx=Load()))], orelse=[ClassDef(name='Buffer', bases=[Attribute(value=Name(id='abc', ctx=Load()), attr='ABC', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Base class for classes that implement the buffer protocol.\n\n        The buffer protocol allows Python objects to expose a low-level\n        memory buffer interface. Before Python 3.12, it is not possible\n        to implement the buffer protocol in pure Python code, or even\n        to check whether a class implements the buffer protocol. In\n        Python 3.12 and higher, the ``__buffer__`` method allows access\n        to the buffer protocol from Python code, and the\n        ``collections.abc.Buffer`` ABC allows checking whether a class\n        implements the buffer protocol.\n\n        To indicate support for the buffer protocol in earlier versions,\n        inherit from this ABC, either in a stub file or at runtime,\n        or use ABC registration. This ABC provides no methods, because\n        there is no Python-accessible methods shared by pre-3.12 buffer\n        classes. It is useful primarily for static checks.\n\n        '))], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='Buffer', ctx=Load()), attr='register', ctx=Load()), args=[Name(id='memoryview', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='Buffer', ctx=Load()), attr='register', ctx=Load()), args=[Name(id='bytearray', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='Buffer', ctx=Load()), attr='register', ctx=Load()), args=[Name(id='bytes', ctx=Load())], keywords=[]))]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='_types', ctx=Load()), Constant(value='get_original_bases')], keywords=[]), body=[Assign(targets=[Name(id='get_original_bases', ctx=Store())], value=Attribute(value=Name(id='_types', ctx=Load()), attr='get_original_bases', ctx=Load()))], orelse=[FunctionDef(name='get_original_bases', args=arguments(posonlyargs=[], args=[arg(arg='__cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the class\'s "original" bases prior to modification by `__mro_entries__`.\n\n        Examples::\n\n            from typing import TypeVar, Generic\n            from pip._vendor.typing_extensions import NamedTuple, TypedDict\n\n            T = TypeVar("T")\n            class Foo(Generic[T]): ...\n            class Bar(Foo[int], float): ...\n            class Baz(list[str]): ...\n            Eggs = NamedTuple("Eggs", [("a", int), ("b", str)])\n            Spam = TypedDict("Spam", {"a": int, "b": str})\n\n            assert get_original_bases(Bar) == (Foo[int], float)\n            assert get_original_bases(Baz) == (list[str],)\n            assert get_original_bases(Eggs) == (NamedTuple,)\n            assert get_original_bases(Spam) == (TypedDict,)\n            assert get_original_bases(int) == (object,)\n        ')), Try(body=[Return(value=Attribute(value=Name(id='__cls', ctx=Load()), attr='__orig_bases__', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Try(body=[Return(value=Attribute(value=Name(id='__cls', ctx=Load()), attr='__bases__', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Expected an instance of type, not '), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='__cls', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=114)])], keywords=[]), cause=Constant(value=None))])], orelse=[], finalbody=[])])], orelse=[], finalbody=[])], decorator_list=[])]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=11)], ctx=Load())]), body=[Assign(targets=[Name(id='NewType', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NewType', ctx=Load()))], orelse=[ClassDef(name='NewType', bases=[], keywords=[], body=[Expr(value=Constant(value="NewType creates simple unique types with almost zero\n        runtime overhead. NewType(name, tp) is considered a subtype of tp\n        by static type checkers. At runtime, NewType(name, tp) returns\n        a dummy callable that simply returns its argument. Usage::\n            UserId = NewType('UserId', int)\n            def name_by_id(user_id: UserId) -> str:\n                ...\n            UserId('user')          # Fails type check\n            name_by_id(42)          # Fails type check\n            name_by_id(UserId(42))  # OK\n            num = UserId(5) + 1     # type: int\n        ")), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='obj', ctx=Load()))], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='tp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__qualname__', ctx=Store())], value=Name(id='name', ctx=Load())), If(test=Compare(left=Constant(value='.'), ops=[In()], comparators=[Name(id='name', ctx=Load())]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='rpartition', ctx=Load()), args=[Constant(value='.')], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__supertype__', ctx=Store())], value=Name(id='tp', ctx=Load())), Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Name(id='_caller', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='__mro_entries__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='bases')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='supercls_name', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load())), ClassDef(name='Dummy', bases=[], keywords=[], body=[FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='subcls_name', ctx=Store())], value=Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load())), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot subclass an instance of NewType. Perhaps you were looking for: `'), FormattedValue(value=Name(id='subcls_name', ctx=Load()), conversion=-1), Constant(value=' = NewType('), FormattedValue(value=Name(id='subcls_name', ctx=Load()), conversion=114), Constant(value=', '), FormattedValue(value=Name(id='supercls_name', ctx=Load()), conversion=-1), Constant(value=')`')])], keywords=[]))], decorator_list=[])], decorator_list=[]), Return(value=Tuple(elts=[Name(id='Dummy', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Load()), conversion=-1), Constant(value='.'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='__qualname__', ctx=Load()), conversion=-1)]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__qualname__', ctx=Load()))], decorator_list=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=10)], ctx=Load())]), body=[FunctionDef(name='__or__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__ror__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='other', ctx=Load()), Name(id='self', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[])], orelse=[])], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeAliasType')], keywords=[]), body=[Assign(targets=[Name(id='TypeAliasType', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeAliasType', ctx=Load()))], orelse=[FunctionDef(name='_is_unionable', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Corresponds to is_unionable() in unionobject.c in CPython.')), Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='obj', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='obj', ctx=Load()), Tuple(elts=[Name(id='type', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='GenericAlias', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='UnionType', ctx=Load()), Name(id='TypeAliasType', ctx=Load())], ctx=Load())], keywords=[])]))], decorator_list=[]), ClassDef(name='TypeAliasType', bases=[], keywords=[], body=[Expr(value=Constant(value='Create named, parameterized type aliases.\n\n        This provides a backport of the new `type` statement in Python 3.12:\n\n            type ListOrSet[T] = list[T] | set[T]\n\n        is equivalent to:\n\n            T = TypeVar("T")\n            ListOrSet = TypeAliasType("ListOrSet", list[T] | set[T], type_params=(T,))\n\n        The name ListOrSet can then be used as an alias for the type it refers to.\n\n        The type_params argument should contain all the type parameters used\n        in the value of the type alias. If the alias is not generic, this\n        argument is omitted.\n\n        Static type checkers should only support type aliases declared using\n        TypeAliasType that follow these rules:\n\n        - The first argument (the name) must be a string literal.\n        - The TypeAliasType instance must be immediately assigned to a variable\n          of the same name. (For example, \'X = TypeAliasType("Y", int)\' is invalid,\n          as is \'X, Y = TypeAliasType("X", int), TypeAliasType("Y", int)\').\n\n        ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='value')], kwonlyargs=[arg(arg='type_params')], kw_defaults=[Tuple(elts=[], ctx=Load())], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypeAliasType name must be a string')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__value__', ctx=Store())], value=Name(id='value', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__type_params__', ctx=Store())], value=Name(id='type_params', ctx=Load())), Assign(targets=[Name(id='parameters', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='type_param', ctx=Store()), iter=Name(id='type_params', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='type_param', ctx=Load()), Name(id='TypeVarTuple', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='parameters', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='type_param', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='parameters', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='type_param', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__parameters__', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Name(id='_caller', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Store())], value=Name(id='name', ctx=Load()))], decorator_list=[]), FunctionDef(name='__setattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='__name', annotation=Name(id='str', ctx=Load())), arg(arg='__value', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='__name__')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_attribute_error', ctx=Load()), args=[Name(id='__name', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__setattr__', ctx=Load()), args=[Name(id='__name', ctx=Load()), Name(id='__value', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__delattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='__name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_attribute_error', ctx=Load()), args=[Name(id='__name', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Never', ctx=Load())), FunctionDef(name='_raise_attribute_error', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__name__')]), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Constant(value='readonly attribute')], keywords=[]))], orelse=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Set(elts=[Constant(value='__value__'), Constant(value='__type_params__'), Constant(value='__parameters__'), Constant(value='__module__')])]), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[JoinedStr(values=[Constant(value="attribute '"), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value="' of 'typing.TypeAliasType' objects is not writable")])], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[JoinedStr(values=[Constant(value="'typing.TypeAliasType' object has no attribute '"), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[]))])])], decorator_list=[], returns=Name(id='Never', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='parameters', ctx=Store())], value=Tuple(elts=[Name(id='parameters', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='parameters', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='item', ctx=Load()), JoinedStr(values=[Constant(value='Subscripting '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value=' requires a type.')])], keywords=[]), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='parameters', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="type 'typing_extensions.TypeAliasType' is not an acceptable base type")], keywords=[]))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Type alias is not callable')], keywords=[]))], decorator_list=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=10)], ctx=Load())]), body=[FunctionDef(name='__or__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='right')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='_is_unionable', ctx=Load()), args=[Name(id='right', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='self', ctx=Load()), Name(id='right', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__ror__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='left')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='_is_unionable', ctx=Load()), args=[Name(id='left', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='left', ctx=Load()), Name(id='self', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[])], orelse=[])], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='is_protocol')], keywords=[]), body=[Assign(targets=[Name(id='is_protocol', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='is_protocol', ctx=Load())), Assign(targets=[Name(id='get_protocol_members', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_protocol_members', ctx=Load()))], orelse=[FunctionDef(name='is_protocol', args=arguments(posonlyargs=[], args=[arg(arg='__tp', annotation=Name(id='type', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return True if the given type is a Protocol.\n\n        Example::\n\n            >>> from typing_extensions import Protocol, is_protocol\n            >>> class P(Protocol):\n            ...     def a(self) -> str: ...\n            ...     b: int\n            >>> is_protocol(P)\n            True\n            >>> is_protocol(int)\n            False\n        ')), Return(value=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='__tp', ctx=Load()), Name(id='type', ctx=Load())], keywords=[]), Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='__tp', ctx=Load()), Constant(value='_is_protocol'), Constant(value=False)], keywords=[]), Compare(left=Name(id='__tp', ctx=Load()), ops=[IsNot()], comparators=[Name(id='Protocol', ctx=Load())]), Compare(left=Name(id='__tp', ctx=Load()), ops=[IsNot()], comparators=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Protocol'), Call(func=Name(id='object', ctx=Load()), args=[], keywords=[])], keywords=[])])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='get_protocol_members', args=arguments(posonlyargs=[], args=[arg(arg='__tp', annotation=Name(id='type', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the set of members defined in a Protocol.\n\n        Example::\n\n            >>> from typing_extensions import Protocol, get_protocol_members\n            >>> class P(Protocol):\n            ...     def a(self) -> str: ...\n            ...     b: int\n            >>> get_protocol_members(P)\n            frozenset({'a', 'b'})\n\n        Raise a TypeError for arguments that are not Protocols.\n        ")), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='is_protocol', ctx=Load()), args=[Name(id='__tp', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='__tp', ctx=Load()), conversion=114), Constant(value=' is not a Protocol')])], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='__tp', ctx=Load()), Constant(value='__protocol_attrs__')], keywords=[]), body=[Return(value=Call(func=Name(id='frozenset', ctx=Load()), args=[Attribute(value=Name(id='__tp', ctx=Load()), attr='__protocol_attrs__', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='frozenset', ctx=Load()), args=[Call(func=Name(id='_get_protocol_attrs', ctx=Load()), args=[Name(id='__tp', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='FrozenSet', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))]), Assign(targets=[Name(id='AbstractSet', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AbstractSet', ctx=Load())), Assign(targets=[Name(id='AnyStr', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AnyStr', ctx=Load())), Assign(targets=[Name(id='BinaryIO', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='BinaryIO', ctx=Load())), Assign(targets=[Name(id='Callable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Callable', ctx=Load())), Assign(targets=[Name(id='Collection', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Collection', ctx=Load())), Assign(targets=[Name(id='Container', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Container', ctx=Load())), Assign(targets=[Name(id='Dict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Dict', ctx=Load())), Assign(targets=[Name(id='ForwardRef', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ForwardRef', ctx=Load())), Assign(targets=[Name(id='FrozenSet', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='FrozenSet', ctx=Load())), Assign(targets=[Name(id='Generator', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Generator', ctx=Load())), Assign(targets=[Name(id='Generic', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())), Assign(targets=[Name(id='Hashable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Hashable', ctx=Load())), Assign(targets=[Name(id='IO', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='IO', ctx=Load())), Assign(targets=[Name(id='ItemsView', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ItemsView', ctx=Load())), Assign(targets=[Name(id='Iterable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Iterable', ctx=Load())), Assign(targets=[Name(id='Iterator', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Iterator', ctx=Load())), Assign(targets=[Name(id='KeysView', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='KeysView', ctx=Load())), Assign(targets=[Name(id='List', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='List', ctx=Load())), Assign(targets=[Name(id='Mapping', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Mapping', ctx=Load())), Assign(targets=[Name(id='MappingView', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='MappingView', ctx=Load())), Assign(targets=[Name(id='Match', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Match', ctx=Load())), Assign(targets=[Name(id='MutableMapping', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='MutableMapping', ctx=Load())), Assign(targets=[Name(id='MutableSequence', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='MutableSequence', ctx=Load())), Assign(targets=[Name(id='MutableSet', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='MutableSet', ctx=Load())), Assign(targets=[Name(id='Optional', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load())), Assign(targets=[Name(id='Pattern', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Pattern', ctx=Load())), Assign(targets=[Name(id='Reversible', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Reversible', ctx=Load())), Assign(targets=[Name(id='Sequence', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Sequence', ctx=Load())), Assign(targets=[Name(id='Set', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Set', ctx=Load())), Assign(targets=[Name(id='Sized', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Sized', ctx=Load())), Assign(targets=[Name(id='TextIO', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TextIO', ctx=Load())), Assign(targets=[Name(id='Tuple', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Tuple', ctx=Load())), Assign(targets=[Name(id='Union', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load())), Assign(targets=[Name(id='ValuesView', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ValuesView', ctx=Load())), Assign(targets=[Name(id='cast', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load())), Assign(targets=[Name(id='no_type_check', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='no_type_check', ctx=Load())), Assign(targets=[Name(id='no_type_check_decorator', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='no_type_check_decorator', ctx=Load()))], type_ignores=[])