Module(body=[ImportFrom(module='__future__', names=[alias(name='absolute_import')], level=0), Import(names=[alias(name='time')]), ImportFrom(module='socket', names=[alias(name='_GLOBAL_DEFAULT_TIMEOUT'), alias(name='getdefaulttimeout')], level=0), ImportFrom(module='exceptions', names=[alias(name='TimeoutStateError')], level=2), Assign(targets=[Name(id='_Default', ctx=Store())], value=Call(func=Name(id='object', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='current_time', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='time', ctx=Load()), Constant(value='monotonic'), Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load())], keywords=[])), ClassDef(name='Timeout', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Timeout configuration.\n\n    Timeouts can be defined as a default for a pool:\n\n    .. code-block:: python\n\n       timeout = Timeout(connect=2.0, read=7.0)\n       http = PoolManager(timeout=timeout)\n       response = http.request(\'GET\', \'http://example.com/\')\n\n    Or per-request (which overrides the default for the pool):\n\n    .. code-block:: python\n\n       response = http.request(\'GET\', \'http://example.com/\', timeout=Timeout(10))\n\n    Timeouts can be disabled by setting all the parameters to ``None``:\n\n    .. code-block:: python\n\n       no_timeout = Timeout(connect=None, read=None)\n       response = http.request(\'GET\', \'http://example.com/, timeout=no_timeout)\n\n\n    :param total:\n        This combines the connect and read timeouts into one; the read timeout\n        will be set to the time leftover from the connect attempt. In the\n        event that both a connect timeout and a total are specified, or a read\n        timeout and a total are specified, the shorter timeout will be applied.\n\n        Defaults to None.\n\n    :type total: int, float, or None\n\n    :param connect:\n        The maximum amount of time (in seconds) to wait for a connection\n        attempt to a server to succeed. Omitting the parameter will default the\n        connect timeout to the system default, probably `the global default\n        timeout in socket.py\n        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.\n        None will set an infinite timeout for connection attempts.\n\n    :type connect: int, float, or None\n\n    :param read:\n        The maximum amount of time (in seconds) to wait between consecutive\n        read operations for a response from the server. Omitting the parameter\n        will default the read timeout to the system default, probably `the\n        global default timeout in socket.py\n        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.\n        None will set an infinite timeout.\n\n    :type read: int, float, or None\n\n    .. note::\n\n        Many factors can affect the total amount of time for urllib3 to return\n        an HTTP response.\n\n        For example, Python\'s DNS resolver does not obey the timeout specified\n        on the socket. Other factors that can affect total request time include\n        high CPU load, high swap, the program running at a low priority level,\n        or other behaviors.\n\n        In addition, the read and total timeouts only measure the time between\n        read operations on the socket connecting the client and the server,\n        not the total amount of time for the request to return a complete\n        response. For most requests, the timeout is raised because the server\n        has not sent the first byte in the specified time. This is not always\n        the case; if a server streams one byte every fifteen seconds, a timeout\n        of 20 seconds will not trigger, even though the request will take\n        several minutes to complete.\n\n        If your goal is to cut off any request after a set amount of wall clock\n        time, consider having a second "watcher" thread to cut off a slow\n        request.\n    ')), Assign(targets=[Name(id='DEFAULT_TIMEOUT', ctx=Store())], value=Name(id='_GLOBAL_DEFAULT_TIMEOUT', ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='total'), arg(arg='connect'), arg(arg='read')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Name(id='_Default', ctx=Load()), Name(id='_Default', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_connect', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_timeout', ctx=Load()), args=[Name(id='connect', ctx=Load()), Constant(value='connect')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_read', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_timeout', ctx=Load()), args=[Name(id='read', ctx=Load()), Constant(value='read')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_timeout', ctx=Load()), args=[Name(id='total', ctx=Load()), Constant(value='total')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_start_connect', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='%s(connect=%r, read=%r, total=%r)'), op=Mod(), right=Tuple(elts=[Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_connect', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_read', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load())], ctx=Load())))], decorator_list=[]), Assign(targets=[Name(id='__str__', ctx=Store())], value=Name(id='__repr__', ctx=Load())), FunctionDef(name='resolve_default_timeout', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=IfExp(test=Compare(left=Name(id='timeout', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='DEFAULT_TIMEOUT', ctx=Load())]), body=Call(func=Name(id='getdefaulttimeout', ctx=Load()), args=[], keywords=[]), orelse=Name(id='timeout', ctx=Load())))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_validate_timeout', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='value'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check that a timeout attribute is valid.\n\n        :param value: The timeout value to validate\n        :param name: The name of the timeout attribute to validate. This is\n            used to specify in error messages.\n        :return: The validated and casted version of the given value.\n        :raises ValueError: If it is a numeric value less than or equal to\n            zero, or the type is not an integer, float, or None.\n        ')), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Name(id='_Default', ctx=Load())]), body=[Return(value=Attribute(value=Name(id='cls', ctx=Load()), attr='DEFAULT_TIMEOUT', ctx=Load()))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='DEFAULT_TIMEOUT', ctx=Load())])]), body=[Return(value=Name(id='value', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='bool', ctx=Load())], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Timeout cannot be a boolean value. It must be an int, float or None.')], keywords=[]))], orelse=[]), Try(body=[Expr(value=Call(func=Name(id='float', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TypeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='Timeout value %s was %s, but it must be an int, float or None.'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load()))], keywords=[]))])], orelse=[], finalbody=[]), Try(body=[If(test=Compare(left=Name(id='value', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='Attempted to set %s timeout to %s, but the timeout cannot be set to a value less than or equal to 0.'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='Timeout value %s was %s, but it must be an int, float or None.'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load()))], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Name(id='value', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='from_float', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a new Timeout from a legacy timeout value.\n\n        The timeout value used by httplib.py sets the same timeout on the\n        connect(), and recv() socket requests. This creates a :class:`Timeout`\n        object that sets the individual timeouts to the ``timeout`` value\n        passed to this function.\n\n        :param timeout: The legacy timeout value.\n        :type timeout: integer, float, sentinel default object, or None\n        :return: Timeout object\n        :rtype: :class:`Timeout`\n        ')), Return(value=Call(func=Name(id='Timeout', ctx=Load()), args=[], keywords=[keyword(arg='read', value=Name(id='timeout', ctx=Load())), keyword(arg='connect', value=Name(id='timeout', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='clone', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a copy of the timeout object\n\n        Timeout properties are stored per-pool but each request needs a fresh\n        Timeout object to ensure each one has its own start/stop configured.\n\n        :return: a copy of the timeout object\n        :rtype: :class:`Timeout`\n        ')), Return(value=Call(func=Name(id='Timeout', ctx=Load()), args=[], keywords=[keyword(arg='connect', value=Attribute(value=Name(id='self', ctx=Load()), attr='_connect', ctx=Load())), keyword(arg='read', value=Attribute(value=Name(id='self', ctx=Load()), attr='_read', ctx=Load())), keyword(arg='total', value=Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='start_connect', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Start the timeout clock, used during a connect() attempt\n\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to start a timer that has been started already.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start_connect', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TimeoutStateError', ctx=Load()), args=[Constant(value='Timeout timer has already been started.')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_start_connect', ctx=Store())], value=Call(func=Name(id='current_time', ctx=Load()), args=[], keywords=[])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_start_connect', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_connect_duration', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Gets the time elapsed since the call to :meth:`start_connect`.\n\n        :return: Elapsed time in seconds.\n        :rtype: float\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to get duration for a timer that hasn't been started.\n        ")), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start_connect', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TimeoutStateError', ctx=Load()), args=[Constant(value="Can't get connect duration for timer that has not started.")], keywords=[]))], orelse=[]), Return(value=BinOp(left=Call(func=Name(id='current_time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_start_connect', ctx=Load())))], decorator_list=[]), FunctionDef(name='connect_timeout', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the value to use when setting a connection timeout.\n\n        This will be a positive float or integer, the value None\n        (never timeout), or the default system timeout.\n\n        :return: Connect timeout.\n        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_connect', ctx=Load()))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_connect', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_connect', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='DEFAULT_TIMEOUT', ctx=Load())])]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='min', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_connect', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='read_timeout', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the value for the read timeout.\n\n        This assumes some time has elapsed in the connection timeout and\n        computes the read timeout appropriately.\n\n        If self.total is set, the read timeout is dependent on the amount of\n        time taken by the connect timeout. If the connection time has not been\n        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be\n        raised.\n\n        :return: Value to use for the read timeout.\n        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None\n        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`\n            has not yet been called on this object.\n        ')), If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='DEFAULT_TIMEOUT', ctx=Load())]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_read', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_read', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='DEFAULT_TIMEOUT', ctx=Load())])]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start_connect', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_read', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load()), op=Sub(), right=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_connect_duration', ctx=Load()), args=[], keywords=[])), Attribute(value=Name(id='self', ctx=Load()), attr='_read', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='DEFAULT_TIMEOUT', ctx=Load())])]), body=[Return(value=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='total', ctx=Load()), op=Sub(), right=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_connect_duration', ctx=Load()), args=[], keywords=[]))], keywords=[]))], orelse=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_read', ctx=Load()))])])], decorator_list=[Name(id='property', ctx=Load())])], decorator_list=[])], type_ignores=[])