Module(body=[Expr(value=Constant(value='Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to those\nfound in Perl. It supports both 8-bit and Unicode strings; both the pattern and\nthe strings being processed can contain null bytes and characters outside the\nUS ASCII range.\n\nRegular expressions can contain both special and ordinary characters. Most\nordinary characters, like "A", "a", or "0", are the simplest regular\nexpressions; they simply match themselves. You can concatenate ordinary\ncharacters, so last matches the string \'last\'.\n\nThere are a few differences between the old (legacy) behaviour and the new\n(enhanced) behaviour, which are indicated by VERSION0 or VERSION1.\n\nThe special characters are:\n    "."                 Matches any character except a newline.\n    "^"                 Matches the start of the string.\n    "$"                 Matches the end of the string or just before the\n                        newline at the end of the string.\n    "*"                 Matches 0 or more (greedy) repetitions of the preceding\n                        RE. Greedy means that it will match as many repetitions\n                        as possible.\n    "+"                 Matches 1 or more (greedy) repetitions of the preceding\n                        RE.\n    "?"                 Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,??            Non-greedy versions of the previous three special\n                        characters.\n    *+,++,?+            Possessive versions of the previous three special\n                        characters.\n    {m,n}               Matches from m to n repetitions of the preceding RE.\n    {m,n}?              Non-greedy version of the above.\n    {m,n}+              Possessive version of the above.\n    {...}               Fuzzy matching constraints.\n    "\\\\"                Either escapes special characters or signals a special\n                        sequence.\n    [...]               Indicates a set of characters. A "^" as the first\n                        character indicates a complementing set.\n    "|"                 A|B, creates an RE that will match either A or B.\n    (...)               Matches the RE inside the parentheses. The contents are\n                        captured and can be retrieved or matched later in the\n                        string.\n    (?flags-flags)      VERSION1: Sets/clears the flags for the remainder of\n                        the group or pattern; VERSION0: Sets the flags for the\n                        entire pattern.\n    (?:...)             Non-capturing version of regular parentheses.\n    (?>...)             Atomic non-capturing version of regular parentheses.\n    (?flags-flags:...)  Non-capturing version of regular parentheses with local\n                        flags.\n    (?P<name>...)       The substring matched by the group is accessible by\n                        name.\n    (?<name>...)        The substring matched by the group is accessible by\n                        name.\n    (?P=name)           Matches the text matched earlier by the group named\n                        name.\n    (?#...)             A comment; ignored.\n    (?=...)             Matches if ... matches next, but doesn\'t consume the\n                        string.\n    (?!...)             Matches if ... doesn\'t match next.\n    (?<=...)            Matches if preceded by ....\n    (?<!...)            Matches if not preceded by ....\n    (?(id)yes|no)       Matches yes pattern if group id matched, the (optional)\n                        no pattern otherwise.\n    (?(DEFINE)...)      If there\'s no group called "DEFINE", then ... will be\n                        ignored, but any group definitions will be available.\n    (?|...|...)         (?|A|B), creates an RE that will match either A or B,\n                        but reuses capture group numbers across the\n                        alternatives.\n    (*FAIL)             Forces matching to fail, which means immediate\n                        backtracking.\n    (*F)                Abbreviation for (*FAIL).\n    (*PRUNE)            Discards the current backtracking information. Its\n                        effect doesn\'t extend outside an atomic group or a\n                        lookaround.\n    (*SKIP)             Similar to (*PRUNE), except that it also sets where in\n                        the text the next attempt at matching the entire\n                        pattern will start. Its effect doesn\'t extend outside\n                        an atomic group or a lookaround.\n\nThe fuzzy matching constraints are: "i" to permit insertions, "d" to permit\ndeletions, "s" to permit substitutions, "e" to permit any of these. Limits are\noptional with "<=" and "<". If any type of error is provided then any type not\nprovided is not permitted.\n\nA cost equation may be provided.\n\nExamples:\n    (?:fuzzy){i<=2}\n    (?:fuzzy){i<=1,s<=2,d<=1,1i+1s+1d<3}\n\nVERSION1: Set operators are supported, and a set can include nested sets. The\nset operators, in order of increasing precedence, are:\n    ||  Set union ("x||y" means "x or y").\n    ~~  (double tilde) Symmetric set difference ("x~~y" means "x or y, but not\n        both").\n    &&  Set intersection ("x&&y" means "x and y").\n    --  (double dash) Set difference ("x--y" means "x but not y").\n\nImplicit union, ie, simple juxtaposition like in [ab], has the highest\nprecedence.\n\nVERSION0 and VERSION1:\nThe special sequences consist of "\\\\" and a character from the list below. If\nthe ordinary character is not on the list, then the resulting RE will match the\nsecond character.\n    \\number         Matches the contents of the group of the same number if\n                    number is no more than 2 digits, otherwise the character\n                    with the 3-digit octal code.\n    \\a              Matches the bell character.\n    \\A              Matches only at the start of the string.\n    \\b              Matches the empty string, but only at the start or end of a\n                    word.\n    \\B              Matches the empty string, but not at the start or end of a\n                    word.\n    \\d              Matches any decimal digit; equivalent to the set [0-9] when\n                    matching a bytestring or a Unicode string with the ASCII\n                    flag, or the whole range of Unicode digits when matching a\n                    Unicode string.\n    \\D              Matches any non-digit character; equivalent to [^\\d].\n    \\f              Matches the formfeed character.\n    \\g<name>        Matches the text matched by the group named name.\n    \\G              Matches the empty string, but only at the position where\n                    the search started.\n    \\h              Matches horizontal whitespace.\n    \\K              Keeps only what follows for the entire match.\n    \\L<name>        Named list. The list is provided as a keyword argument.\n    \\m              Matches the empty string, but only at the start of a word.\n    \\M              Matches the empty string, but only at the end of a word.\n    \\n              Matches the newline character.\n    \\N{name}        Matches the named character.\n    \\p{name=value}  Matches the character if its property has the specified\n                    value.\n    \\P{name=value}  Matches the character if its property hasn\'t the specified\n                    value.\n    \\r              Matches the carriage-return character.\n    \\s              Matches any whitespace character; equivalent to\n                    [ \\t\\n\\r\\f\\v].\n    \\S              Matches any non-whitespace character; equivalent to [^\\s].\n    \\t              Matches the tab character.\n    \\uXXXX          Matches the Unicode codepoint with 4-digit hex code XXXX.\n    \\UXXXXXXXX      Matches the Unicode codepoint with 8-digit hex code\n                    XXXXXXXX.\n    \\v              Matches the vertical tab character.\n    \\w              Matches any alphanumeric character; equivalent to\n                    [a-zA-Z0-9_] when matching a bytestring or a Unicode string\n                    with the ASCII flag, or the whole range of Unicode\n                    alphanumeric characters (letters plus digits plus\n                    underscore) when matching a Unicode string. With LOCALE, it\n                    will match the set [0-9_] plus characters defined as\n                    letters for the current locale.\n    \\W              Matches the complement of \\w; equivalent to [^\\w].\n    \\xXX            Matches the character with 2-digit hex code XX.\n    \\X              Matches a grapheme.\n    \\Z              Matches only at the end of the string.\n    \\\\              Matches a literal backslash.\n\nThis module exports the following functions:\n    match      Match a regular expression pattern at the beginning of a string.\n    fullmatch  Match a regular expression pattern against all of a string.\n    search     Search a string for the presence of a pattern.\n    sub        Substitute occurrences of a pattern found in a string using a\n               template string.\n    subf       Substitute occurrences of a pattern found in a string using a\n               format string.\n    subn       Same as sub, but also return the number of substitutions made.\n    subfn      Same as subf, but also return the number of substitutions made.\n    split      Split a string by the occurrences of a pattern. VERSION1: will\n               split at zero-width match; VERSION0: won\'t split at zero-width\n               match.\n    splititer  Return an iterator yielding the parts of a split string.\n    findall    Find all occurrences of a pattern in a string.\n    finditer   Return an iterator yielding a match object for each match.\n    compile    Compile a pattern into a Pattern object.\n    purge      Clear the regular expression cache.\n    escape     Backslash all non-alphanumerics or special characters in a\n               string.\n\nMost of the functions support a concurrent parameter: if True, the GIL will be\nreleased during matching, allowing other Python threads to run concurrently. If\nthe string changes during matching, the behaviour is undefined. This parameter\nis not needed when working on the builtin (immutable) string classes.\n\nSome of the functions in this module take flags as optional parameters. Most of\nthese flags can also be set within an RE:\n    A   a   ASCII         Make \\w, \\W, \\b, \\B, \\d, and \\D match the\n                          corresponding ASCII character categories. Default\n                          when matching a bytestring.\n    B   b   BESTMATCH     Find the best fuzzy match (default is first).\n    D       DEBUG         Print the parsed pattern.\n    E   e   ENHANCEMATCH  Attempt to improve the fit after finding the first\n                          fuzzy match.\n    F   f   FULLCASE      Use full case-folding when performing\n                          case-insensitive matching in Unicode.\n    I   i   IGNORECASE    Perform case-insensitive matching.\n    L   L   LOCALE        Make \\w, \\W, \\b, \\B, \\d, and \\D dependent on the\n                          current locale. (One byte per character only.)\n    M   m   MULTILINE     "^" matches the beginning of lines (after a newline)\n                          as well as the string. "$" matches the end of lines\n                          (before a newline) as well as the end of the string.\n    P   p   POSIX         Perform POSIX-standard matching (leftmost longest).\n    R   r   REVERSE       Searches backwards.\n    S   s   DOTALL        "." matches any character at all, including the\n                          newline.\n    U   u   UNICODE       Make \\w, \\W, \\b, \\B, \\d, and \\D dependent on the\n                          Unicode locale. Default when matching a Unicode\n                          string.\n    V0  V0  VERSION0      Turn on the old legacy behaviour.\n    V1  V1  VERSION1      Turn on the new enhanced behaviour. This flag\n                          includes the FULLCASE flag.\n    W   w   WORD          Make \\b and \\B work with default Unicode word breaks\n                          and make ".", "^" and "$" work with Unicode line\n                          breaks.\n    X   x   VERBOSE       Ignore whitespace and comments for nicer looking REs.\n\nThis module also defines an exception \'error\'.\n\n')), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='cache_all'), Constant(value='compile'), Constant(value='DEFAULT_VERSION'), Constant(value='escape'), Constant(value='findall'), Constant(value='finditer'), Constant(value='fullmatch'), Constant(value='match'), Constant(value='purge'), Constant(value='search'), Constant(value='split'), Constant(value='splititer'), Constant(value='sub'), Constant(value='subf'), Constant(value='subfn'), Constant(value='subn'), Constant(value='template'), Constant(value='Scanner'), Constant(value='A'), Constant(value='ASCII'), Constant(value='B'), Constant(value='BESTMATCH'), Constant(value='D'), Constant(value='DEBUG'), Constant(value='E'), Constant(value='ENHANCEMATCH'), Constant(value='S'), Constant(value='DOTALL'), Constant(value='F'), Constant(value='FULLCASE'), Constant(value='I'), Constant(value='IGNORECASE'), Constant(value='L'), Constant(value='LOCALE'), Constant(value='M'), Constant(value='MULTILINE'), Constant(value='P'), Constant(value='POSIX'), Constant(value='R'), Constant(value='REVERSE'), Constant(value='T'), Constant(value='TEMPLATE'), Constant(value='U'), Constant(value='UNICODE'), Constant(value='V0'), Constant(value='VERSION0'), Constant(value='V1'), Constant(value='VERSION1'), Constant(value='X'), Constant(value='VERBOSE'), Constant(value='W'), Constant(value='WORD'), Constant(value='error'), Constant(value='Regex'), Constant(value='__version__'), Constant(value='__doc__'), Constant(value='RegexFlag')], ctx=Load())), Assign(targets=[Name(id='__version__', ctx=Store())], value=Constant(value='2.5.135')), FunctionDef(name='match', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='string'), arg(arg='flags'), arg(arg='pos'), arg(arg='endpos'), arg(arg='partial'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Try to apply the pattern at the start of the string, returning a match\n    object, or None if no match was found.')), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='pos', ctx=Load()), Name(id='endpos', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='partial', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='fullmatch', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='string'), arg(arg='flags'), arg(arg='pos'), arg(arg='endpos'), arg(arg='partial'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Try to apply the pattern against all of the string, returning a match\n    object, or None if no match was found.')), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='fullmatch', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='pos', ctx=Load()), Name(id='endpos', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='partial', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='search', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='string'), arg(arg='flags'), arg(arg='pos'), arg(arg='endpos'), arg(arg='partial'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Search through string looking for a match to the pattern, returning a\n    match object, or None if no match was found.')), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='pos', ctx=Load()), Name(id='endpos', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='partial', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='sub', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='repl'), arg(arg='string'), arg(arg='count'), arg(arg='flags'), arg(arg='pos'), arg(arg='endpos'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Return the string obtained by replacing the leftmost (or rightmost with a\n    reverse pattern) non-overlapping occurrences of the pattern in string by the\n    replacement repl. repl can be either a string or a callable; if a string,\n    backslash escapes in it are processed; if a callable, it's passed the match\n    object and must return a replacement string to be used.")), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='sub', ctx=Load()), args=[Name(id='repl', ctx=Load()), Name(id='string', ctx=Load()), Name(id='count', ctx=Load()), Name(id='pos', ctx=Load()), Name(id='endpos', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='subf', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='format'), arg(arg='string'), arg(arg='count'), arg(arg='flags'), arg(arg='pos'), arg(arg='endpos'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Return the string obtained by replacing the leftmost (or rightmost with a\n    reverse pattern) non-overlapping occurrences of the pattern in string by the\n    replacement format. format can be either a string or a callable; if a string,\n    it's treated as a format string; if a callable, it's passed the match object\n    and must return a replacement string to be used.")), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='subf', ctx=Load()), args=[Name(id='format', ctx=Load()), Name(id='string', ctx=Load()), Name(id='count', ctx=Load()), Name(id='pos', ctx=Load()), Name(id='endpos', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='subn', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='repl'), arg(arg='string'), arg(arg='count'), arg(arg='flags'), arg(arg='pos'), arg(arg='endpos'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Return a 2-tuple containing (new_string, number). new_string is the string\n    obtained by replacing the leftmost (or rightmost with a reverse pattern)\n    non-overlapping occurrences of the pattern in the source string by the\n    replacement repl. number is the number of substitutions that were made. repl\n    can be either a string or a callable; if a string, backslash escapes in it\n    are processed; if a callable, it's passed the match object and must return a\n    replacement string to be used.")), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='subn', ctx=Load()), args=[Name(id='repl', ctx=Load()), Name(id='string', ctx=Load()), Name(id='count', ctx=Load()), Name(id='pos', ctx=Load()), Name(id='endpos', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='subfn', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='format'), arg(arg='string'), arg(arg='count'), arg(arg='flags'), arg(arg='pos'), arg(arg='endpos'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Return a 2-tuple containing (new_string, number). new_string is the string\n    obtained by replacing the leftmost (or rightmost with a reverse pattern)\n    non-overlapping occurrences of the pattern in the source string by the\n    replacement format. number is the number of substitutions that were made. format\n    can be either a string or a callable; if a string, it's treated as a format\n    string; if a callable, it's passed the match object and must return a\n    replacement string to be used.")), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='subfn', ctx=Load()), args=[Name(id='format', ctx=Load()), Name(id='string', ctx=Load()), Name(id='count', ctx=Load()), Name(id='pos', ctx=Load()), Name(id='endpos', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='split', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='string'), arg(arg='maxsplit'), arg(arg='flags'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Split the source string by the occurrences of the pattern, returning a\n    list containing the resulting substrings.  If capturing parentheses are used\n    in pattern, then the text of all groups in the pattern are also returned as\n    part of the resulting list.  If maxsplit is nonzero, at most maxsplit splits\n    occur, and the remainder of the string is returned as the final element of\n    the list.')), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='maxsplit', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='splititer', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='string'), arg(arg='maxsplit'), arg(arg='flags'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Return an iterator yielding the parts of a split string.')), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='splititer', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='maxsplit', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='findall', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='string'), arg(arg='flags'), arg(arg='pos'), arg(arg='endpos'), arg(arg='overlapped'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Return a list of all matches in the string. The matches may be overlapped\n    if overlapped is True. If one or more groups are present in the pattern,\n    return a list of groups; this will be a list of tuples if the pattern has\n    more than one group. Empty matches are included in the result.')), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='findall', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='pos', ctx=Load()), Name(id='endpos', ctx=Load()), Name(id='overlapped', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='finditer', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='string'), arg(arg='flags'), arg(arg='pos'), arg(arg='endpos'), arg(arg='overlapped'), arg(arg='partial'), arg(arg='concurrent'), arg(arg='timeout'), arg(arg='ignore_unused')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Return an iterator over all matches in the string. The matches may be\n    overlapped if overlapped is True. For each match, the iterator returns a\n    match object. Empty matches are included in the result.')), Assign(targets=[Name(id='pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=True)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='pat', ctx=Load()), attr='finditer', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='pos', ctx=Load()), Name(id='endpos', ctx=Load()), Name(id='overlapped', ctx=Load()), Name(id='concurrent', ctx=Load()), Name(id='partial', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='compile', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='flags'), arg(arg='ignore_unused'), arg(arg='cache_pattern')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=0), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='Compile a regular expression pattern, returning a pattern object.')), If(test=Compare(left=Name(id='cache_pattern', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='cache_pattern', ctx=Store())], value=Name(id='_cache_all', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='flags', ctx=Load()), Name(id='ignore_unused', ctx=Load()), Name(id='kwargs', ctx=Load()), Name(id='cache_pattern', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='purge', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Clear the regular expression cache')), Expr(value=Call(func=Attribute(value=Name(id='_cache', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='_locale_sensitive', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='_cache_all', ctx=Store())], value=Constant(value=True)), FunctionDef(name='cache_all', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Sets whether to cache all patterns, even those are compiled explicitly.\n    Passing None has no effect, but returns the current setting.')), Global(names=['_cache_all']), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='_cache_all', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='_cache_all', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[]), FunctionDef(name='template', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='flags')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Compile a template pattern, returning a pattern object.')), Return(value=Call(func=Name(id='_compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), BinOp(left=Name(id='flags', ctx=Load()), op=BitOr(), right=Name(id='TEMPLATE', ctx=Load())), Constant(value=False), Dict(keys=[], values=[]), Constant(value=False)], keywords=[]))], decorator_list=[]), FunctionDef(name='escape', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='special_only'), arg(arg='literal_spaces')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=False)]), body=[Expr(value=Constant(value="Escape a string for use as a literal in a pattern. If special_only is\n    True, escape only special characters, else escape all non-alphanumeric\n    characters. If literal_spaces is True, don't escape spaces.")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='bytes', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Attribute(value=Name(id='pattern', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value='latin-1')], keywords=[]))], orelse=[Assign(targets=[Name(id='p', ctx=Store())], value=Name(id='pattern', ctx=Load()))]), Assign(targets=[Name(id='s', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Name(id='special_only', ctx=Load()), body=[For(target=Name(id='c', ctx=Store()), iter=Name(id='p', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='c', ctx=Load()), ops=[Eq()], comparators=[Constant(value=' ')]), Name(id='literal_spaces', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='c', ctx=Load()), ops=[In()], comparators=[Name(id='_METACHARS', ctx=Load())]), Call(func=Attribute(value=Name(id='c', ctx=Load()), attr='isspace', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='\\')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='c', ctx=Load()), ops=[Eq()], comparators=[Constant(value='\x00')]), body=[Expr(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='\\000')], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))])])])], orelse=[])], orelse=[For(target=Name(id='c', ctx=Store()), iter=Name(id='p', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='c', ctx=Load()), ops=[Eq()], comparators=[Constant(value=' ')]), Name(id='literal_spaces', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='c', ctx=Load()), ops=[In()], comparators=[Name(id='_ALNUM', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='c', ctx=Load()), ops=[Eq()], comparators=[Constant(value='\x00')]), body=[Expr(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='\\000')], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='\\')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))])])])], orelse=[])]), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='bytes', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='r', ctx=Load()), attr='encode', ctx=Load()), args=[Constant(value='latin-1')], keywords=[]))], orelse=[]), Return(value=Name(id='r', ctx=Load()))], decorator_list=[]), Import(names=[alias(name='regex._regex_core', asname='_regex_core')]), Import(names=[alias(name='regex._regex', asname='_regex')]), ImportFrom(module='threading', names=[alias(name='RLock', asname='_RLock')], level=0), ImportFrom(module='locale', names=[alias(name='getpreferredencoding', asname='_getpreferredencoding')], level=0), ImportFrom(module='regex._regex_core', names=[alias(name='*')], level=0), ImportFrom(module='regex._regex_core', names=[alias(name='_ALL_VERSIONS'), alias(name='_ALL_ENCODINGS'), alias(name='_FirstSetError'), alias(name='_UnscopedFlagSet'), alias(name='_check_group_features'), alias(name='_compile_firstset'), alias(name='_compile_replacement'), alias(name='_flatten_code'), alias(name='_fold_case'), alias(name='_get_required_string'), alias(name='_parse_pattern'), alias(name='_shrink_cache')], level=0), ImportFrom(module='regex._regex_core', names=[alias(name='ALNUM', asname='_ALNUM'), alias(name='Info', asname='_Info'), alias(name='OP', asname='_OP'), alias(name='Source', asname='_Source'), alias(name='Fuzzy', asname='_Fuzzy')], level=0), Assign(targets=[Name(id='DEFAULT_VERSION', ctx=Store())], value=Name(id='VERSION0', ctx=Load())), Assign(targets=[Name(id='_METACHARS', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Constant(value='()[]{}?*+|^$\\.-#&~')], keywords=[])), Assign(targets=[Attribute(value=Name(id='_regex_core', ctx=Load()), attr='DEFAULT_VERSION', ctx=Store())], value=Name(id='DEFAULT_VERSION', ctx=Load())), Assign(targets=[Name(id='_cache', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='_cache_lock', ctx=Store())], value=Call(func=Name(id='_RLock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='_named_args', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='_replacement_cache', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='_locale_sensitive', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='_MAXCACHE', ctx=Store())], value=Constant(value=500)), Assign(targets=[Name(id='_MAXREPCACHE', ctx=Store())], value=Constant(value=500)), FunctionDef(name='_compile', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='flags'), arg(arg='ignore_unused'), arg(arg='kwargs'), arg(arg='cache_it')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compiles a regular expression to a PatternObject.')), Global(names=['DEFAULT_VERSION']), Try(body=[ImportFrom(module='regex', names=[alias(name='DEFAULT_VERSION')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), If(test=Compare(left=BinOp(left=Name(id='flags', ctx=Load()), op=BitAnd(), right=Name(id='DEBUG', ctx=Load())), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='cache_it', ctx=Store())], value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='locale_key', ctx=Store())], value=Tuple(elts=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[]), Name(id='pattern', ctx=Load())], ctx=Load())), If(test=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='_locale_sensitive', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='locale_key', ctx=Load()), Constant(value=True)], keywords=[]), Compare(left=BinOp(left=Name(id='flags', ctx=Load()), op=BitAnd(), right=Name(id='LOCALE', ctx=Load())), ops=[NotEq()], comparators=[Constant(value=0)])]), body=[Assign(targets=[Name(id='pattern_locale', ctx=Store())], value=Call(func=Name(id='_getpreferredencoding', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='pattern_locale', ctx=Store())], value=Constant(value=None))]), FunctionDef(name='complain_unused_args', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Name(id='ignore_unused', ctx=Load()), body=[Return()], orelse=[]), Assign(targets=[Name(id='unused_kwargs', ctx=Store())], value=BinOp(left=Call(func=Name(id='set', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[]), op=Sub(), right=SetComp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Name(id='args_needed', ctx=Load()), ifs=[], is_async=0)]))), If(test=Name(id='unused_kwargs', ctx=Load()), body=[Assign(targets=[Name(id='any_one', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Name(id='unused_kwargs', ctx=Load())], keywords=[])], keywords=[])), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='unused keyword argument {!a}'), attr='format', ctx=Load()), args=[Name(id='any_one', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], decorator_list=[]), If(test=Name(id='cache_it', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='args_key', ctx=Store())], value=Tuple(elts=[Name(id='pattern', ctx=Load()), Call(func=Name(id='type', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[]), Name(id='flags', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='args_needed', ctx=Store())], value=Subscript(value=Name(id='_named_args', ctx=Load()), slice=Name(id='args_key', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='args_supplied', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), If(test=Name(id='args_needed', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Name(id='args_needed', ctx=Load()), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='args_supplied', ctx=Load()), attr='add', ctx=Load()), args=[Tuple(elts=[Name(id='k', ctx=Load()), Call(func=Name(id='frozenset', ctx=Load()), args=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Load())], keywords=[])], ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='error', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='missing named list: {!r}'), attr='format', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[])], orelse=[]), Expr(value=Call(func=Name(id='complain_unused_args', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='args_supplied', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='args_supplied', ctx=Load())], keywords=[])), Assign(targets=[Name(id='pattern_key', ctx=Store())], value=Tuple(elts=[Name(id='pattern', ctx=Load()), Call(func=Name(id='type', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[]), Name(id='flags', ctx=Load()), Name(id='args_supplied', ctx=Load()), Name(id='DEFAULT_VERSION', ctx=Load()), Name(id='pattern_locale', ctx=Load())], ctx=Load())), Return(value=Subscript(value=Name(id='_cache', ctx=Load()), slice=Name(id='pattern_key', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='guess_encoding', ctx=Store())], value=Name(id='UNICODE', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='bytes', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='guess_encoding', ctx=Store())], value=Name(id='ASCII', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='Pattern', ctx=Load())], keywords=[]), body=[If(test=Name(id='flags', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot process flags argument with a compiled pattern')], keywords=[]))], orelse=[]), Return(value=Name(id='pattern', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='first argument must be a string or compiled pattern')], keywords=[]))])])]), Assign(targets=[Attribute(value=Name(id='_regex_core', ctx=Load()), attr='DEFAULT_VERSION', ctx=Store())], value=Name(id='DEFAULT_VERSION', ctx=Load())), Assign(targets=[Name(id='global_flags', ctx=Store())], value=Name(id='flags', ctx=Load())), While(test=Constant(value=True), body=[Assign(targets=[Name(id='caught_exception', ctx=Store())], value=Constant(value=None)), Try(body=[Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Name(id='_Source', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[])), Assign(targets=[Name(id='info', ctx=Store())], value=Call(func=Name(id='_Info', ctx=Load()), args=[Name(id='global_flags', ctx=Load()), Attribute(value=Name(id='source', ctx=Load()), attr='char_type', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='info', ctx=Load()), attr='guess_encoding', ctx=Store())], value=Name(id='guess_encoding', ctx=Load())), Assign(targets=[Attribute(value=Name(id='source', ctx=Load()), attr='ignore_space', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Load()), op=BitAnd(), right=Name(id='VERBOSE', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Name(id='_parse_pattern', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='info', ctx=Load())], keywords=[])), Break()], handlers=[ExceptHandler(type=Name(id='_UnscopedFlagSet', ctx=Load()), body=[Assign(targets=[Name(id='global_flags', ctx=Store())], value=Attribute(value=Name(id='info', ctx=Load()), attr='global_flags', ctx=Load()))]), ExceptHandler(type=Name(id='error', ctx=Load()), name='e', body=[Assign(targets=[Name(id='caught_exception', ctx=Store())], value=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), If(test=Name(id='caught_exception', ctx=Load()), body=[Raise(exc=Call(func=Name(id='error', ctx=Load()), args=[Attribute(value=Name(id='caught_exception', ctx=Load()), attr='msg', ctx=Load()), Attribute(value=Name(id='caught_exception', ctx=Load()), attr='pattern', ctx=Load()), Attribute(value=Name(id='caught_exception', ctx=Load()), attr='pos', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='source', ctx=Load()), attr='at_end', ctx=Load()), args=[], keywords=[])), body=[Raise(exc=Call(func=Name(id='error', ctx=Load()), args=[Constant(value='unbalanced parenthesis'), Name(id='pattern', ctx=Load()), Attribute(value=Name(id='source', ctx=Load()), attr='pos', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='version', ctx=Store())], value=BoolOp(op=Or(), values=[BinOp(left=Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Load()), op=BitAnd(), right=Name(id='_ALL_VERSIONS', ctx=Load())), Name(id='DEFAULT_VERSION', ctx=Load())])), If(test=Compare(left=Name(id='version', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value=0), Name(id='VERSION0', ctx=Load()), Name(id='VERSION1', ctx=Load())], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='VERSION0 and VERSION1 flags are mutually incompatible')], keywords=[]))], orelse=[]), If(test=Compare(left=BinOp(left=Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Load()), op=BitAnd(), right=Name(id='_ALL_ENCODINGS', ctx=Load())), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value=0), Name(id='ASCII', ctx=Load()), Name(id='LOCALE', ctx=Load()), Name(id='UNICODE', ctx=Load())], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='ASCII, LOCALE and UNICODE flags are mutually incompatible')], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='bytes', ctx=Load())], keywords=[]), BinOp(left=Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Load()), op=BitAnd(), right=Name(id='UNICODE', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot use UNICODE flag with a bytes pattern')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=BinOp(left=Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Load()), op=BitAnd(), right=Name(id='_ALL_ENCODINGS', ctx=Load()))), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Store()), op=BitOr(), value=Name(id='UNICODE', ctx=Load()))], orelse=[AugAssign(target=Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Store()), op=BitOr(), value=Name(id='ASCII', ctx=Load()))])], orelse=[]), Assign(targets=[Name(id='reverse', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Load()), op=BitAnd(), right=Name(id='REVERSE', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='fuzzy', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='parsed', ctx=Load()), Name(id='_Fuzzy', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='_locale_sensitive', ctx=Load()), slice=Name(id='locale_key', ctx=Load()), ctx=Store())], value=Attribute(value=Name(id='info', ctx=Load()), attr='inline_locale', ctx=Load())), Assign(targets=[Name(id='caught_exception', ctx=Store())], value=Constant(value=None)), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='parsed', ctx=Load()), attr='fix_groups', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='reverse', ctx=Load()), Constant(value=False)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='error', ctx=Load()), name='e', body=[Assign(targets=[Name(id='caught_exception', ctx=Store())], value=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), If(test=Name(id='caught_exception', ctx=Load()), body=[Raise(exc=Call(func=Name(id='error', ctx=Load()), args=[Attribute(value=Name(id='caught_exception', ctx=Load()), attr='msg', ctx=Load()), Attribute(value=Name(id='caught_exception', ctx=Load()), attr='pattern', ctx=Load()), Attribute(value=Name(id='caught_exception', ctx=Load()), attr='pos', ctx=Load())], keywords=[]))], orelse=[]), If(test=BinOp(left=Name(id='flags', ctx=Load()), op=BitAnd(), right=Name(id='DEBUG', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='parsed', ctx=Load()), attr='dump', ctx=Load()), args=[], keywords=[keyword(arg='indent', value=Constant(value=0)), keyword(arg='reverse', value=Name(id='reverse', ctx=Load()))]))], orelse=[]), Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Attribute(value=Name(id='parsed', ctx=Load()), attr='optimise', ctx=Load()), args=[Name(id='info', ctx=Load()), Name(id='reverse', ctx=Load())], keywords=[])), Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Attribute(value=Name(id='parsed', ctx=Load()), attr='pack_characters', ctx=Load()), args=[Name(id='info', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='req_offset', ctx=Store()), Name(id='req_chars', ctx=Store()), Name(id='req_flags', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_get_required_string', ctx=Load()), args=[Name(id='parsed', ctx=Load()), Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Load())], keywords=[])), Assign(targets=[Name(id='named_lists', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='named_list_indexes', ctx=Store())], value=BinOp(left=List(elts=[Constant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='info', ctx=Load()), attr='named_lists_used', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='args_needed', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='index', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='info', ctx=Load()), attr='named_lists_used', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='case_flags', ctx=Store())], ctx=Store())], value=Name(id='key', ctx=Load())), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load())], keywords=[])), If(test=Name(id='case_flags', ctx=Load()), body=[Assign(targets=[Name(id='items', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_fold_case', ctx=Load()), args=[Name(id='info', ctx=Load()), Name(id='v', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='v', ctx=Store()), iter=Name(id='values', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assign(targets=[Name(id='items', ctx=Store())], value=Name(id='values', ctx=Load()))]), Assign(targets=[Subscript(value=Name(id='named_lists', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Name(id='values', ctx=Load())), Assign(targets=[Subscript(value=Name(id='named_list_indexes', ctx=Load()), slice=Name(id='index', ctx=Load()), ctx=Store())], value=Name(id='items', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='args_needed', ctx=Load()), attr='add', ctx=Load()), args=[Tuple(elts=[Name(id='name', ctx=Load()), Name(id='values', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='complain_unused_args', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='_check_group_features', ctx=Load()), args=[Name(id='info', ctx=Load()), Name(id='parsed', ctx=Load())], keywords=[])), Assign(targets=[Name(id='code', ctx=Store())], value=Call(func=Attribute(value=Name(id='parsed', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='reverse', ctx=Load())], keywords=[])), Assign(targets=[Name(id='key', ctx=Store())], value=Tuple(elts=[Constant(value=0), Name(id='reverse', ctx=Load()), Name(id='fuzzy', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='ref', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='info', ctx=Load()), attr='call_refs', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='ref', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='code', ctx=Store())], value=BinOp(left=BinOp(left=List(elts=[Tuple(elts=[Attribute(value=Name(id='_OP', ctx=Load()), attr='CALL_REF', ctx=Load()), Name(id='ref', ctx=Load())], ctx=Load())], ctx=Load()), op=Add(), right=Name(id='code', ctx=Load())), op=Add(), right=List(elts=[Tuple(elts=[Attribute(value=Name(id='_OP', ctx=Load()), attr='END', ctx=Load())], ctx=Load())], ctx=Load())))], orelse=[]), AugAssign(target=Name(id='code', ctx=Store()), op=Add(), value=List(elts=[Tuple(elts=[Attribute(value=Name(id='_OP', ctx=Load()), attr='SUCCESS', ctx=Load())], ctx=Load())], ctx=Load())), For(target=Tuple(elts=[Name(id='group', ctx=Store()), Name(id='rev', ctx=Store()), Name(id='fuz', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='info', ctx=Load()), attr='additional_groups', ctx=Load()), body=[AugAssign(target=Name(id='code', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='rev', ctx=Load()), Name(id='fuz', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='code', ctx=Store())], value=Call(func=Name(id='_flatten_code', ctx=Load()), args=[Name(id='code', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='parsed', ctx=Load()), attr='has_simple_start', ctx=Load()), args=[], keywords=[])), body=[Try(body=[Assign(targets=[Name(id='fs_code', ctx=Store())], value=Call(func=Name(id='_compile_firstset', ctx=Load()), args=[Name(id='info', ctx=Load()), Call(func=Attribute(value=Name(id='parsed', ctx=Load()), attr='get_firstset', ctx=Load()), args=[Name(id='reverse', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='fs_code', ctx=Store())], value=Call(func=Name(id='_flatten_code', ctx=Load()), args=[Name(id='fs_code', ctx=Load())], keywords=[])), Assign(targets=[Name(id='code', ctx=Store())], value=BinOp(left=Name(id='fs_code', ctx=Load()), op=Add(), right=Name(id='code', ctx=Load())))], handlers=[ExceptHandler(type=Name(id='_FirstSetError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Assign(targets=[Name(id='index_group', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[GeneratorExp(elt=Tuple(elts=[Name(id='v', ctx=Load()), Name(id='n', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='info', ctx=Load()), attr='group_index', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='compiled_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='_regex', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='pattern', ctx=Load()), BinOp(left=Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Load()), op=BitOr(), right=Name(id='version', ctx=Load())), Name(id='code', ctx=Load()), Attribute(value=Name(id='info', ctx=Load()), attr='group_index', ctx=Load()), Name(id='index_group', ctx=Load()), Name(id='named_lists', ctx=Load()), Name(id='named_list_indexes', ctx=Load()), Name(id='req_offset', ctx=Load()), Name(id='req_chars', ctx=Load()), Name(id='req_flags', ctx=Load()), Attribute(value=Name(id='info', ctx=Load()), attr='group_count', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='_cache', ctx=Load())], keywords=[]), ops=[GtE()], comparators=[Name(id='_MAXCACHE', ctx=Load())]), body=[With(items=[withitem(context_expr=Name(id='_cache_lock', ctx=Load()))], body=[Expr(value=Call(func=Name(id='_shrink_cache', ctx=Load()), args=[Name(id='_cache', ctx=Load()), Name(id='_named_args', ctx=Load()), Name(id='_locale_sensitive', ctx=Load()), Name(id='_MAXCACHE', ctx=Load())], keywords=[]))])], orelse=[]), If(test=Name(id='cache_it', ctx=Load()), body=[If(test=Compare(left=BinOp(left=Attribute(value=Name(id='info', ctx=Load()), attr='flags', ctx=Load()), op=BitAnd(), right=Name(id='LOCALE', ctx=Load())), ops=[Eq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='pattern_locale', ctx=Store())], value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='args_needed', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='args_needed', ctx=Load())], keywords=[])), Assign(targets=[Name(id='pattern_key', ctx=Store())], value=Tuple(elts=[Name(id='pattern', ctx=Load()), Call(func=Name(id='type', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[]), Name(id='flags', ctx=Load()), Name(id='args_needed', ctx=Load()), Name(id='DEFAULT_VERSION', ctx=Load()), Name(id='pattern_locale', ctx=Load())], ctx=Load())), Assign(targets=[Subscript(value=Name(id='_cache', ctx=Load()), slice=Name(id='pattern_key', ctx=Load()), ctx=Store())], value=Name(id='compiled_pattern', ctx=Load())), Assign(targets=[Subscript(value=Name(id='_named_args', ctx=Load()), slice=Name(id='args_key', ctx=Load()), ctx=Store())], value=Name(id='args_needed', ctx=Load()))], orelse=[]), Return(value=Name(id='compiled_pattern', ctx=Load()))], decorator_list=[]), FunctionDef(name='_compile_replacement_helper', args=arguments(posonlyargs=[], args=[arg(arg='pattern'), arg(arg='template')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compiles a replacement template.')), Assign(targets=[Name(id='key', ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='pattern', ctx=Load()), attr='pattern', ctx=Load()), Attribute(value=Name(id='pattern', ctx=Load()), attr='flags', ctx=Load()), Name(id='template', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='compiled', ctx=Store())], value=Call(func=Attribute(value=Name(id='_replacement_cache', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='compiled', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='compiled', ctx=Load()))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='_replacement_cache', ctx=Load())], keywords=[]), ops=[GtE()], comparators=[Name(id='_MAXREPCACHE', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='_replacement_cache', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='is_unicode', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='template', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Name(id='_Source', ctx=Load()), args=[Name(id='template', ctx=Load())], keywords=[])), If(test=Name(id='is_unicode', ctx=Load()), body=[FunctionDef(name='make_string', args=arguments(posonlyargs=[], args=[arg(arg='char_codes')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='chr', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='c', ctx=Store()), iter=Name(id='char_codes', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[])], orelse=[FunctionDef(name='make_string', args=arguments(posonlyargs=[], args=[arg(arg='char_codes')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='bytes', ctx=Load()), args=[Name(id='char_codes', ctx=Load())], keywords=[]))], decorator_list=[])]), Assign(targets=[Name(id='compiled', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='literal', ctx=Store())], value=List(elts=[], ctx=Load())), While(test=Constant(value=True), body=[Assign(targets=[Name(id='ch', ctx=Store())], value=Call(func=Attribute(value=Name(id='source', ctx=Load()), attr='get', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='ch', ctx=Load())), body=[Break()], orelse=[]), If(test=Compare(left=Name(id='ch', ctx=Load()), ops=[Eq()], comparators=[Constant(value='\\')]), body=[Assign(targets=[Tuple(elts=[Name(id='is_group', ctx=Store()), Name(id='items', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_compile_replacement', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='pattern', ctx=Load()), Name(id='is_unicode', ctx=Load())], keywords=[])), If(test=Name(id='is_group', ctx=Load()), body=[If(test=Name(id='literal', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='compiled', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='make_string', ctx=Load()), args=[Name(id='literal', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='literal', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='compiled', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='literal', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]))])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='literal', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='ord', ctx=Load()), args=[Name(id='ch', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[]), If(test=Name(id='literal', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='compiled', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='make_string', ctx=Load()), args=[Name(id='literal', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='_replacement_cache', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='compiled', ctx=Load())), Return(value=Name(id='compiled', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_pat', ctx=Store())], value=Call(func=Name(id='_compile', ctx=Load()), args=[Constant(value=''), Constant(value=0), Constant(value=False), Dict(keys=[], values=[]), Constant(value=False)], keywords=[])), Assign(targets=[Name(id='Pattern', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='_pat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='Match', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Call(func=Attribute(value=Name(id='_pat', ctx=Load()), attr='match', ctx=Load()), args=[Constant(value='')], keywords=[])], keywords=[])), Delete(targets=[Name(id='_pat', ctx=Del())]), Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='Pattern')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='Match')], keywords=[])), Assign(targets=[Name(id='Regex', ctx=Store())], value=Name(id='compile', ctx=Load())), Import(names=[alias(name='copyreg', asname='_copy_reg')]), FunctionDef(name='_pickle', args=arguments(posonlyargs=[], args=[arg(arg='pattern')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='_regex', ctx=Load()), attr='compile', ctx=Load()), Attribute(value=Name(id='pattern', ctx=Load()), attr='_pickled_data', ctx=Load())], ctx=Load()))], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='_copy_reg', ctx=Load()), attr='pickle', ctx=Load()), args=[Name(id='Pattern', ctx=Load()), Name(id='_pickle', ctx=Load())], keywords=[]))], type_ignores=[])