Module(body=[Expr(value=Constant(value='\nNestedcompleter for completion of hierarchical data structures.\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='typing', names=[alias(name='Any'), alias(name='Iterable'), alias(name='Mapping'), alias(name='Set'), alias(name='Union')], level=0), ImportFrom(module='prompt_toolkit.completion', names=[alias(name='CompleteEvent'), alias(name='Completer'), alias(name='Completion')], level=0), ImportFrom(module='prompt_toolkit.completion.word_completer', names=[alias(name='WordCompleter')], level=0), ImportFrom(module='prompt_toolkit.document', names=[alias(name='Document')], level=0), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='NestedCompleter')], ctx=Load())), Assign(targets=[Name(id='NestedDict', ctx=Store())], value=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Any', ctx=Load()), Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Constant(value=None), Name(id='Completer', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='NestedCompleter', bases=[Name(id='Completer', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Completer which wraps around several other completers, and calls any the\n    one that corresponds with the first word of the input.\n\n    By combining multiple `NestedCompleter` instances, we can achieve multiple\n    hierarchical levels of autocompletion. This is useful when `WordCompleter`\n    is not sufficient.\n\n    If you need multiple levels, check out the `from_nested_dict` classmethod.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='options', annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), BinOp(left=Name(id='Completer', ctx=Load()), op=BitOr(), right=Constant(value=None))], ctx=Load()), ctx=Load())), arg(arg='ignore_case', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Store())], value=Name(id='options', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ignore_case', ctx=Store())], value=Name(id='ignore_case', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='NestedCompleter('), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Load()), conversion=114), Constant(value=', ignore_case='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='ignore_case', ctx=Load()), conversion=114), Constant(value=')')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='from_nested_dict', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='data', annotation=Name(id='NestedDict', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Create a `NestedCompleter`, starting from a nested dictionary data\n        structure, like this:\n\n        .. code::\n\n            data = {\n                'show': {\n                    'version': None,\n                    'interfaces': None,\n                    'clock': None,\n                    'ip': {'interface': {'brief'}}\n                },\n                'exit': None\n                'enable': None\n            }\n\n        The value should be `None` if there is no further completion at some\n        point. If all values in the dictionary are None, it is also possible to\n        use a set instead.\n\n        Values in this data structure can be a completers as well.\n        ")), AnnAssign(target=Name(id='options', ctx=Store()), annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), BinOp(left=Name(id='Completer', ctx=Load()), op=BitOr(), right=Constant(value=None))], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='Completer', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='options', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='options', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='from_nested_dict', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='set', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='options', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='from_nested_dict', ctx=Load()), args=[DictComp(key=Name(id='item', ctx=Load()), value=Constant(value=None), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='value', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assert(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])), Assign(targets=[Subscript(value=Name(id='options', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Constant(value=None))])])])], orelse=[]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='options', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='NestedCompleter', ctx=Load())), FunctionDef(name='get_completions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='document', annotation=Name(id='Document', ctx=Load())), arg(arg='complete_event', annotation=Name(id='CompleteEvent', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='document', ctx=Load()), attr='text_before_cursor', ctx=Load()), attr='lstrip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='stripped_len', ctx=Store())], value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='document', ctx=Load()), attr='text_before_cursor', ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]))), If(test=Compare(left=Constant(value=' '), ops=[In()], comparators=[Name(id='text', ctx=Load())]), body=[Assign(targets=[Name(id='first_term', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='completer', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='first_term', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='completer', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='remaining_text', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='first_term', ctx=Load())], keywords=[])), ctx=Load()), attr='lstrip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='move_cursor', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='remaining_text', ctx=Load())], keywords=[])), op=Add(), right=Name(id='stripped_len', ctx=Load()))), Assign(targets=[Name(id='new_document', ctx=Store())], value=Call(func=Name(id='Document', ctx=Load()), args=[Name(id='remaining_text', ctx=Load())], keywords=[keyword(arg='cursor_position', value=BinOp(left=Attribute(value=Name(id='document', ctx=Load()), attr='cursor_position', ctx=Load()), op=Sub(), right=Name(id='move_cursor', ctx=Load())))])), Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='completer', ctx=Load()), attr='get_completions', ctx=Load()), args=[Name(id='new_document', ctx=Load()), Name(id='complete_event', ctx=Load())], keywords=[])))], orelse=[])], orelse=[Assign(targets=[Name(id='completer', ctx=Store())], value=Call(func=Name(id='WordCompleter', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[keyword(arg='ignore_case', value=Attribute(value=Name(id='self', ctx=Load()), attr='ignore_case', ctx=Load()))])), Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='completer', ctx=Load()), attr='get_completions', ctx=Load()), args=[Name(id='document', ctx=Load()), Name(id='complete_event', ctx=Load())], keywords=[])))])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Completion', ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])