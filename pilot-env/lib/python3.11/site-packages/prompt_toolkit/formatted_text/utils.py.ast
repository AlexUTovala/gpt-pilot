Module(body=[Expr(value=Constant(value='\nUtilities for manipulating formatted text.\n\nWhen ``to_formatted_text`` has been called, we get a list of ``(style, text)``\ntuples. This file contains functions for manipulating such a list.\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='typing', names=[alias(name='Iterable'), alias(name='cast')], level=0), ImportFrom(module='prompt_toolkit.utils', names=[alias(name='get_cwidth')], level=0), ImportFrom(module='base', names=[alias(name='AnyFormattedText'), alias(name='OneStyleAndTextTuple'), alias(name='StyleAndTextTuples'), alias(name='to_formatted_text')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='to_plain_text'), Constant(value='fragment_list_len'), Constant(value='fragment_list_width'), Constant(value='fragment_list_to_text'), Constant(value='split_lines')], ctx=Load())), FunctionDef(name='to_plain_text', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='AnyFormattedText', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Turn any kind of formatted text back into plain text.\n    ')), Return(value=Call(func=Name(id='fragment_list_to_text', ctx=Load()), args=[Call(func=Name(id='to_formatted_text', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='fragment_list_len', args=arguments(posonlyargs=[], args=[arg(arg='fragments', annotation=Name(id='StyleAndTextTuples', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return the amount of characters in this text fragment list.\n\n    :param fragments: List of ``(style_str, text)`` or\n        ``(style_str, text, mouse_handler)`` tuples.\n    ')), Assign(targets=[Name(id='ZeroWidthEscape', ctx=Store())], value=Constant(value='[ZeroWidthEscape]')), Return(value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='item', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='fragments', ctx=Load()), ifs=[Compare(left=Name(id='ZeroWidthEscape', ctx=Load()), ops=[NotIn()], comparators=[Subscript(value=Name(id='item', ctx=Load()), slice=Constant(value=0), ctx=Load())])], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='fragment_list_width', args=arguments(posonlyargs=[], args=[arg(arg='fragments', annotation=Name(id='StyleAndTextTuples', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return the character width of this text fragment list.\n    (Take double width characters into account.)\n\n    :param fragments: List of ``(style_str, text)`` or\n        ``(style_str, text, mouse_handler)`` tuples.\n    ')), Assign(targets=[Name(id='ZeroWidthEscape', ctx=Store())], value=Constant(value='[ZeroWidthEscape]')), Return(value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='get_cwidth', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='fragments', ctx=Load()), ifs=[], is_async=0), comprehension(target=Name(id='c', ctx=Store()), iter=Subscript(value=Name(id='item', ctx=Load()), slice=Constant(value=1), ctx=Load()), ifs=[Compare(left=Name(id='ZeroWidthEscape', ctx=Load()), ops=[NotIn()], comparators=[Subscript(value=Name(id='item', ctx=Load()), slice=Constant(value=0), ctx=Load())])], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='fragment_list_to_text', args=arguments(posonlyargs=[], args=[arg(arg='fragments', annotation=Name(id='StyleAndTextTuples', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Concatenate all the text parts again.\n\n    :param fragments: List of ``(style_str, text)`` or\n        ``(style_str, text, mouse_handler)`` tuples.\n    ')), Assign(targets=[Name(id='ZeroWidthEscape', ctx=Store())], value=Constant(value='[ZeroWidthEscape]')), Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='item', ctx=Load()), slice=Constant(value=1), ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='fragments', ctx=Load()), ifs=[Compare(left=Name(id='ZeroWidthEscape', ctx=Load()), ops=[NotIn()], comparators=[Subscript(value=Name(id='item', ctx=Load()), slice=Constant(value=0), ctx=Load())])], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='split_lines', args=arguments(posonlyargs=[], args=[arg(arg='fragments', annotation=Name(id='StyleAndTextTuples', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Take a single list of (style_str, text) tuples and yield one such list for each\n    line. Just like str.split, this will yield at least one item.\n\n    :param fragments: List of (style_str, text) or (style_str, text, mouse_handler)\n                      tuples.\n    ')), AnnAssign(target=Name(id='line', ctx=Store()), annotation=Name(id='StyleAndTextTuples', ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Tuple(elts=[Name(id='style', ctx=Store()), Name(id='string', ctx=Store()), Starred(value=Name(id='mouse_handler', ctx=Store()), ctx=Store())], ctx=Store()), iter=Name(id='fragments', ctx=Load()), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='string', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), For(target=Name(id='part', ctx=Store()), iter=Subscript(value=Name(id='parts', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), body=[If(test=Name(id='part', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='cast', ctx=Load()), args=[Name(id='OneStyleAndTextTuple', ctx=Load()), Tuple(elts=[Name(id='style', ctx=Load()), Name(id='part', ctx=Load()), Starred(value=Name(id='mouse_handler', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Yield(value=Name(id='line', ctx=Load()))), Assign(targets=[Name(id='line', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='cast', ctx=Load()), args=[Name(id='OneStyleAndTextTuple', ctx=Load()), Tuple(elts=[Name(id='style', ctx=Load()), Subscript(value=Name(id='parts', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Starred(value=Name(id='mouse_handler', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Yield(value=Name(id='line', ctx=Load())))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='StyleAndTextTuples', ctx=Load()), ctx=Load()))], type_ignores=[])