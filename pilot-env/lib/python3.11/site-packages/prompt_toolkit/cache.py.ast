Module(body=[ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='collections', names=[alias(name='deque')], level=0), ImportFrom(module='functools', names=[alias(name='wraps')], level=0), ImportFrom(module='typing', names=[alias(name='Any'), alias(name='Callable'), alias(name='Dict'), alias(name='Generic'), alias(name='Hashable'), alias(name='Tuple'), alias(name='TypeVar'), alias(name='cast')], level=0), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='SimpleCache'), Constant(value='FastDictCache'), Constant(value='memoized')], ctx=Load())), Assign(targets=[Name(id='_T', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_T')], keywords=[keyword(arg='bound', value=Name(id='Hashable', ctx=Load()))])), Assign(targets=[Name(id='_U', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_U')], keywords=[])), ClassDef(name='SimpleCache', bases=[Subscript(value=Name(id='Generic', ctx=Load()), slice=Tuple(elts=[Name(id='_T', ctx=Load()), Name(id='_U', ctx=Load())], ctx=Load()), ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Very simple cache that discards the oldest item when the cache size is\n    exceeded.\n\n    :param maxsize: Maximum size of the cache. (Don't make it too big.)\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='maxsize', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=8)]), body=[Assert(test=Compare(left=Name(id='maxsize', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_data', ctx=Store()), annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='_T', ctx=Load()), Name(id='_U', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_keys', ctx=Store()), annotation=Subscript(value=Name(id='deque', ctx=Load()), slice=Name(id='_T', ctx=Load()), ctx=Load()), value=Call(func=Name(id='deque', ctx=Load()), args=[], keywords=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='maxsize', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Name(id='maxsize', ctx=Load()), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key', annotation=Name(id='_T', ctx=Load())), arg(arg='getter_func', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Name(id='_U', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Get object from the cache.\n        If not found, call `getter_func` to resolve it, and put that on the top\n        of the cache instead.\n        ')), Try(body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_data', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='getter_func', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_data', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_keys', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_data', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='maxsize', ctx=Load())]), body=[Assign(targets=[Name(id='key_to_remove', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_keys', ctx=Load()), attr='popleft', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='key_to_remove', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_data', ctx=Load())]), body=[Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_data', ctx=Load()), slice=Name(id='key_to_remove', ctx=Load()), ctx=Del())])], orelse=[])], orelse=[]), Return(value=Name(id='value', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='_U', ctx=Load())), FunctionDef(name='clear', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Clear cache.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_data', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keys', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), Assign(targets=[Name(id='_K', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_K')], keywords=[keyword(arg='bound', value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Hashable', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))])), Assign(targets=[Name(id='_V', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_V')], keywords=[])), ClassDef(name='FastDictCache', bases=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='_K', ctx=Load()), Name(id='_V', ctx=Load())], ctx=Load()), ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Fast, lightweight cache which keeps at most `size` items.\n    It will discard the oldest items in the cache first.\n\n    The cache is a dictionary, which doesn't keep track of access counts.\n    It is perfect to cache little immutable objects which are not expensive to\n    create, but where a dictionary lookup is still much faster than an object\n    instantiation.\n\n    :param get_value: Callable that's called in case of a missing key.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='get_value', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='_V', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='size', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1000000)]), body=[Assert(test=Compare(left=Name(id='size', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_keys', ctx=Store()), annotation=Subscript(value=Name(id='deque', ctx=Load()), slice=Name(id='_K', ctx=Load()), ctx=Load()), value=Call(func=Name(id='deque', ctx=Load()), args=[], keywords=[]), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='get_value', ctx=Store())], value=Name(id='get_value', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='size', ctx=Store())], value=Name(id='size', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__missing__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key', annotation=Name(id='_K', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='size', ctx=Load())]), body=[Assign(targets=[Name(id='key_to_remove', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_keys', ctx=Load()), attr='popleft', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='key_to_remove', ctx=Load()), ops=[In()], comparators=[Name(id='self', ctx=Load())]), body=[Delete(targets=[Subscript(value=Name(id='self', ctx=Load()), slice=Name(id='key_to_remove', ctx=Load()), ctx=Del())])], orelse=[])], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_value', ctx=Load()), args=[Starred(value=Name(id='key', ctx=Load()), ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='self', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='result', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_keys', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='_V', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_F', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_F')], keywords=[keyword(arg='bound', value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))])), FunctionDef(name='memoized', args=arguments(posonlyargs=[], args=[arg(arg='maxsize', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1024)]), body=[Expr(value=Constant(value='\n    Memoization decorator for immutable classes and pure functions.\n    ')), FunctionDef(name='decorator', args=arguments(posonlyargs=[], args=[arg(arg='obj', annotation=Name(id='_F', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='cache', ctx=Store()), annotation=Subscript(value=Name(id='SimpleCache', ctx=Load()), slice=Tuple(elts=[Name(id='Hashable', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='SimpleCache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Name(id='maxsize', ctx=Load()))]), simple=1), FunctionDef(name='new_callable', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='a', annotation=Name(id='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw', annotation=Name(id='Any', ctx=Load())), defaults=[]), body=[FunctionDef(name='create_new', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='obj', ctx=Load()), args=[Starred(value=Name(id='a', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[], returns=Name(id='Any', ctx=Load())), Assign(targets=[Name(id='key', ctx=Store())], value=Tuple(elts=[Name(id='a', ctx=Load()), Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Name(id='kw', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])], ctx=Load())), Return(value=Call(func=Attribute(value=Name(id='cache', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='create_new', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='wraps', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[])], returns=Name(id='Any', ctx=Load())), Return(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='_F', ctx=Load()), Name(id='new_callable', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='_F', ctx=Load())), Return(value=Name(id='decorator', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='_F', ctx=Load())], ctx=Load()), Name(id='_F', ctx=Load())], ctx=Load()), ctx=Load()))], type_ignores=[])