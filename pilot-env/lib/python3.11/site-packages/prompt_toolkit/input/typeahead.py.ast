Module(body=[Expr(value=Constant(value="\nStore input key strokes if we did read more than was required.\n\nThe input classes `Vt100Input` and `Win32Input` read the input text in chunks\nof a few kilobytes. This means that if we read input from stdin, it could be\nthat we read a couple of lines (with newlines in between) at once.\n\nThis creates a problem: potentially, we read too much from stdin. Sometimes\npeople paste several lines at once because they paste input in a REPL and\nexpect each input() call to process one line. Or they rely on type ahead\nbecause the application can't keep up with the processing.\n\nHowever, we need to read input in bigger chunks. We need this mostly to support\npasting of larger chunks of text. We don't want everything to become\nunresponsive because we:\n  - read one character;\n  - parse one character;\n  - call the key binding, which does a string operation with one character;\n  - and render the user interface.\nDoing text operations on single characters is very inefficient in Python, so we\nprefer to work on bigger chunks of text. This is why we have to read the input\nin bigger chunks.\n\nFurther, line buffering is also not an option, because it doesn't work well in\nthe architecture. We use lower level Posix APIs, that work better with the\nevent loop and so on. In fact, there is also nothing that defines that only \\n\ncan accept the input, you could create a key binding for any key to accept the\ninput.\n\nTo support type ahead, this module will store all the key strokes that were\nread too early, so that they can be feed into to the next `prompt()` call or to\nthe next prompt_toolkit `Application`.\n")), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='collections', names=[alias(name='defaultdict')], level=0), ImportFrom(module='key_binding', names=[alias(name='KeyPress')], level=2), ImportFrom(module='base', names=[alias(name='Input')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='store_typeahead'), Constant(value='get_typeahead'), Constant(value='clear_typeahead')], ctx=Load())), AnnAssign(target=Name(id='_buffer', ctx=Store()), annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='KeyPress', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='defaultdict', ctx=Load()), args=[Name(id='list', ctx=Load())], keywords=[]), simple=1), FunctionDef(name='store_typeahead', args=arguments(posonlyargs=[], args=[arg(arg='input_obj', annotation=Name(id='Input', ctx=Load())), arg(arg='key_presses', annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='KeyPress', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Insert typeahead key presses for the given input.\n    ')), Global(names=['_buffer']), Assign(targets=[Name(id='key', ctx=Store())], value=Call(func=Attribute(value=Name(id='input_obj', ctx=Load()), attr='typeahead_hash', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='_buffer', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='key_presses', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_typeahead', args=arguments(posonlyargs=[], args=[arg(arg='input_obj', annotation=Name(id='Input', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Retrieve typeahead and reset the buffer for this input.\n    ')), Global(names=['_buffer']), Assign(targets=[Name(id='key', ctx=Store())], value=Call(func=Attribute(value=Name(id='input_obj', ctx=Load()), attr='typeahead_hash', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Subscript(value=Name(id='_buffer', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())), Assign(targets=[Subscript(value=Name(id='_buffer', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=List(elts=[], ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='KeyPress', ctx=Load()), ctx=Load())), FunctionDef(name='clear_typeahead', args=arguments(posonlyargs=[], args=[arg(arg='input_obj', annotation=Name(id='Input', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Clear typeahead buffer.\n    ')), Global(names=['_buffer']), Assign(targets=[Name(id='key', ctx=Store())], value=Call(func=Attribute(value=Name(id='input_obj', ctx=Load()), attr='typeahead_hash', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='_buffer', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=List(elts=[], ctx=Load()))], decorator_list=[], returns=Constant(value=None))], type_ignores=[])