Module(body=[ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), Import(names=[alias(name='os')]), Import(names=[alias(name='select')]), ImportFrom(module='codecs', names=[alias(name='getincrementaldecoder')], level=0), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='PosixStdinReader')], ctx=Load())), ClassDef(name='PosixStdinReader', bases=[], keywords=[], body=[Expr(value=Constant(value="\n    Wrapper around stdin which reads (nonblocking) the next available 1024\n    bytes and decodes it.\n\n    Note that you can't be sure that the input file is closed if the ``read``\n    function returns an empty string. When ``errors=ignore`` is passed,\n    ``read`` can return an empty string if all malformed input was replaced by\n    an empty string. (We can't block here and wait for more input.) So, because\n    of that, check the ``closed`` attribute, to be sure that the file has been\n    closed.\n\n    :param stdin_fd: File descriptor from which we read.\n    :param errors:  Can be 'ignore', 'strict' or 'replace'.\n        On Python3, this can be 'surrogateescape', which is the default.\n\n        'surrogateescape' is preferred, because this allows us to transfer\n        unrecognised bytes to the key bindings. Some terminals, like lxterminal\n        and Guake, use the 'Mxx' notation to send mouse events, where each 'x'\n        can be any possible byte.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='stdin_fd', annotation=Name(id='int', ctx=Load())), arg(arg='errors', annotation=Name(id='str', ctx=Load())), arg(arg='encoding', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='surrogateescape'), Constant(value='utf-8')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stdin_fd', ctx=Store())], value=Name(id='stdin_fd', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Store())], value=Name(id='errors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_stdin_decoder_cls', ctx=Store())], value=Call(func=Name(id='getincrementaldecoder', ctx=Load()), args=[Name(id='encoding', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_stdin_decoder', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_stdin_decoder_cls', ctx=Load()), args=[], keywords=[keyword(arg='errors', value=Name(id='errors', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='closed', ctx=Store())], value=Constant(value=False))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='read', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='count', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1024)]), body=[Expr(value=Constant(value='\n        Read the input and return it as a string.\n\n        Return the text. Note that this can return an empty string, even when\n        the input stream was not yet closed. This means that something went\n        wrong during the decoding.\n        ')), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='closed', ctx=Load()), body=[Return(value=Constant(value=''))], orelse=[]), Try(body=[If(test=UnaryOp(op=Not(), operand=Subscript(value=Call(func=Attribute(value=Name(id='select', ctx=Load()), attr='select', ctx=Load()), args=[List(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='stdin_fd', ctx=Load())], ctx=Load()), List(elts=[], ctx=Load()), List(elts=[], ctx=Load()), Constant(value=0)], keywords=[]), slice=Constant(value=0), ctx=Load())), body=[Return(value=Constant(value=''))], orelse=[])], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='closed', ctx=Store())], value=Constant(value=True))])], orelse=[], finalbody=[]), Try(body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='read', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='stdin_fd', ctx=Load()), Name(id='count', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='data', ctx=Load()), ops=[Eq()], comparators=[Constant(value=b'')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='closed', ctx=Store())], value=Constant(value=True)), Return(value=Constant(value=''))], orelse=[])], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Assign(targets=[Name(id='data', ctx=Store())], value=Constant(value=b''))])], orelse=[], finalbody=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_stdin_decoder', ctx=Load()), attr='decode', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[])], type_ignores=[])