Module(body=[Expr(value=Constant(value='\n`Fish-style <http://fishshell.com/>`_  like auto-suggestion.\n\nWhile a user types input in a certain buffer, suggestions are generated\n(asynchronously.) Usually, they are displayed after the input. When the cursor\npresses the right arrow and the cursor is at the end of the input, the\nsuggestion will be inserted.\n\nIf you want the auto suggestions to be asynchronous (in a background thread),\nbecause they take too much time, and could potentially block the event loop,\nthen wrap the :class:`.AutoSuggest` instance into a\n:class:`.ThreadedAutoSuggest`.\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='abc', names=[alias(name='ABCMeta'), alias(name='abstractmethod')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Callable')], level=0), ImportFrom(module='prompt_toolkit.eventloop', names=[alias(name='run_in_executor_with_context')], level=0), ImportFrom(module='document', names=[alias(name='Document')], level=1), ImportFrom(module='filters', names=[alias(name='Filter'), alias(name='to_filter')], level=1), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='buffer', names=[alias(name='Buffer')], level=1)], orelse=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Suggestion'), Constant(value='AutoSuggest'), Constant(value='ThreadedAutoSuggest'), Constant(value='DummyAutoSuggest'), Constant(value='AutoSuggestFromHistory'), Constant(value='ConditionalAutoSuggest'), Constant(value='DynamicAutoSuggest')], ctx=Load())), ClassDef(name='Suggestion', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Suggestion returned by an auto-suggest algorithm.\n\n    :param text: The suggestion text.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='text', ctx=Store())], value=Name(id='text', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='Suggestion(%s)'), op=Mod(), right=Attribute(value=Name(id='self', ctx=Load()), attr='text', ctx=Load())))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='AutoSuggest', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='ABCMeta', ctx=Load()))], body=[Expr(value=Constant(value='\n    Base class for auto suggestion implementations.\n    ')), FunctionDef(name='get_suggestion', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='buffer', annotation=Name(id='Buffer', ctx=Load())), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Return `None` or a :class:`.Suggestion` instance.\n\n        We receive both :class:`~prompt_toolkit.buffer.Buffer` and\n        :class:`~prompt_toolkit.document.Document`. The reason is that auto\n        suggestions are retrieved asynchronously. (Like completions.) The\n        buffer text could be changed in the meantime, but ``document`` contains\n        the buffer document like it was at the start of the auto suggestion\n        call. So, from here, don't access ``buffer.text``, but use\n        ``document.text`` instead.\n\n        :param buffer: The :class:`~prompt_toolkit.buffer.Buffer` instance.\n        :param document: The :class:`~prompt_toolkit.document.Document` instance.\n        "))], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=BinOp(left=Name(id='Suggestion', ctx=Load()), op=BitOr(), right=Constant(value=None))), AsyncFunctionDef(name='get_suggestion_async', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='buff', annotation=Name(id='Buffer', ctx=Load())), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a :class:`.Future` which is set when the suggestions are ready.\n        This function can be overloaded in order to provide an asynchronous\n        implementation.\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_suggestion', ctx=Load()), args=[Name(id='buff', ctx=Load()), Name(id='document', ctx=Load())], keywords=[]))], decorator_list=[], returns=BinOp(left=Name(id='Suggestion', ctx=Load()), op=BitOr(), right=Constant(value=None)))], decorator_list=[]), ClassDef(name='ThreadedAutoSuggest', bases=[Name(id='AutoSuggest', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Wrapper that runs auto suggestions in a thread.\n    (Use this to prevent the user interface from becoming unresponsive if the\n    generation of suggestions takes too much time.)\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='auto_suggest', annotation=Name(id='AutoSuggest', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='auto_suggest', ctx=Store())], value=Name(id='auto_suggest', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_suggestion', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='buff', annotation=Name(id='Buffer', ctx=Load())), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='auto_suggest', ctx=Load()), attr='get_suggestion', ctx=Load()), args=[Name(id='buff', ctx=Load()), Name(id='document', ctx=Load())], keywords=[]))], decorator_list=[], returns=BinOp(left=Name(id='Suggestion', ctx=Load()), op=BitOr(), right=Constant(value=None))), AsyncFunctionDef(name='get_suggestion_async', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='buff', annotation=Name(id='Buffer', ctx=Load())), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Run the `get_suggestion` function in a thread.\n        ')), FunctionDef(name='run_get_suggestion_thread', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_suggestion', ctx=Load()), args=[Name(id='buff', ctx=Load()), Name(id='document', ctx=Load())], keywords=[]))], decorator_list=[], returns=BinOp(left=Name(id='Suggestion', ctx=Load()), op=BitOr(), right=Constant(value=None))), Return(value=Await(value=Call(func=Name(id='run_in_executor_with_context', ctx=Load()), args=[Name(id='run_get_suggestion_thread', ctx=Load())], keywords=[])))], decorator_list=[], returns=BinOp(left=Name(id='Suggestion', ctx=Load()), op=BitOr(), right=Constant(value=None)))], decorator_list=[]), ClassDef(name='DummyAutoSuggest', bases=[Name(id='AutoSuggest', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    AutoSuggest class that doesn't return any suggestion.\n    ")), FunctionDef(name='get_suggestion', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='buffer', annotation=Name(id='Buffer', ctx=Load())), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=None))], decorator_list=[], returns=BinOp(left=Name(id='Suggestion', ctx=Load()), op=BitOr(), right=Constant(value=None)))], decorator_list=[]), ClassDef(name='AutoSuggestFromHistory', bases=[Name(id='AutoSuggest', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Give suggestions based on the lines in the history.\n    ')), FunctionDef(name='get_suggestion', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='buffer', annotation=Name(id='Buffer', ctx=Load())), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='history', ctx=Store())], value=Attribute(value=Name(id='buffer', ctx=Load()), attr='history', ctx=Load())), Assign(targets=[Name(id='text', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='document', ctx=Load()), attr='text', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='\n'), Constant(value=1)], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), If(test=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), body=[For(target=Name(id='string', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='history', ctx=Load()), attr='get_strings', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]), body=[For(target=Name(id='line', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Attribute(value=Name(id='string', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='Suggestion', ctx=Load()), args=[Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=BinOp(left=Name(id='Suggestion', ctx=Load()), op=BitOr(), right=Constant(value=None)))], decorator_list=[]), ClassDef(name='ConditionalAutoSuggest', bases=[Name(id='AutoSuggest', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Auto suggest that can be turned on and of according to a certain condition.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='auto_suggest', annotation=Name(id='AutoSuggest', ctx=Load())), arg(arg='filter', annotation=BinOp(left=Name(id='bool', ctx=Load()), op=BitOr(), right=Name(id='Filter', ctx=Load())))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='auto_suggest', ctx=Store())], value=Name(id='auto_suggest', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='filter', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='filter', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_suggestion', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='buffer', annotation=Name(id='Buffer', ctx=Load())), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='filter', ctx=Load()), args=[], keywords=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='auto_suggest', ctx=Load()), attr='get_suggestion', ctx=Load()), args=[Name(id='buffer', ctx=Load()), Name(id='document', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=BinOp(left=Name(id='Suggestion', ctx=Load()), op=BitOr(), right=Constant(value=None)))], decorator_list=[]), ClassDef(name='DynamicAutoSuggest', bases=[Name(id='AutoSuggest', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Validator class that can dynamically returns any Validator.\n\n    :param get_validator: Callable that returns a :class:`.Validator` instance.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='get_auto_suggest', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), BinOp(left=Name(id='AutoSuggest', ctx=Load()), op=BitOr(), right=Constant(value=None))], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='get_auto_suggest', ctx=Store())], value=Name(id='get_auto_suggest', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_suggestion', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='buff', annotation=Name(id='Buffer', ctx=Load())), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='auto_suggest', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_auto_suggest', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='DummyAutoSuggest', ctx=Load()), args=[], keywords=[])])), Return(value=Call(func=Attribute(value=Name(id='auto_suggest', ctx=Load()), attr='get_suggestion', ctx=Load()), args=[Name(id='buff', ctx=Load()), Name(id='document', ctx=Load())], keywords=[]))], decorator_list=[], returns=BinOp(left=Name(id='Suggestion', ctx=Load()), op=BitOr(), right=Constant(value=None))), AsyncFunctionDef(name='get_suggestion_async', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='buff', annotation=Name(id='Buffer', ctx=Load())), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='auto_suggest', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_auto_suggest', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='DummyAutoSuggest', ctx=Load()), args=[], keywords=[])])), Return(value=Await(value=Call(func=Attribute(value=Name(id='auto_suggest', ctx=Load()), attr='get_suggestion_async', ctx=Load()), args=[Name(id='buff', ctx=Load()), Name(id='document', ctx=Load())], keywords=[])))], decorator_list=[], returns=BinOp(left=Name(id='Suggestion', ctx=Load()), op=BitOr(), right=Constant(value=None)))], decorator_list=[])], type_ignores=[])