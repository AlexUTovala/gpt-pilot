Module(body=[Expr(value=Constant(value='\nKey bindings registry.\n\nA `KeyBindings` object is a container that holds a list of key bindings. It has a\nvery efficient internal data structure for checking which key bindings apply\nfor a pressed key.\n\nTypical usage::\n\n    kb = KeyBindings()\n\n    @kb.add(Keys.ControlX, Keys.ControlC, filter=INSERT)\n    def handler(event):\n        # Handle ControlX-ControlC key sequence.\n        pass\n\nIt is also possible to combine multiple KeyBindings objects. We do this in the\ndefault key bindings. There are some KeyBindings objects that contain the Emacs\nbindings, while others contain the Vi bindings. They are merged together using\n`merge_key_bindings`.\n\nWe also have a `ConditionalKeyBindings` object that can enable/disable a group of\nkey bindings at once.\n\n\nIt is also possible to add a filter to a function, before a key binding has\nbeen assigned, through the `key_binding` decorator.::\n\n    # First define a key handler with the `filter`.\n    @key_binding(filter=condition)\n    def my_key_binding(event):\n        ...\n\n    # Later, add it to the key bindings.\n    kb.add(Keys.A, my_key_binding)\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='abc', names=[alias(name='ABCMeta'), alias(name='abstractmethod'), alias(name='abstractproperty')], level=0), ImportFrom(module='inspect', names=[alias(name='isawaitable')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Awaitable'), alias(name='Callable'), alias(name='Hashable'), alias(name='Sequence'), alias(name='Tuple'), alias(name='TypeVar'), alias(name='Union'), alias(name='cast')], level=0), ImportFrom(module='prompt_toolkit.cache', names=[alias(name='SimpleCache')], level=0), ImportFrom(module='prompt_toolkit.filters', names=[alias(name='FilterOrBool'), alias(name='Never'), alias(name='to_filter')], level=0), ImportFrom(module='prompt_toolkit.keys', names=[alias(name='KEY_ALIASES'), alias(name='Keys')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='key_processor', names=[alias(name='KeyPressEvent')], level=1), Assign(targets=[Name(id='NotImplementedOrNone', ctx=Store())], value=Name(id='object', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='NotImplementedOrNone'), Constant(value='Binding'), Constant(value='KeyBindingsBase'), Constant(value='KeyBindings'), Constant(value='ConditionalKeyBindings'), Constant(value='merge_key_bindings'), Constant(value='DynamicKeyBindings'), Constant(value='GlobalOnlyKeyBindings')], ctx=Load())), Assign(targets=[Name(id='KeyHandlerCallable', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Constant(value='KeyPressEvent')], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='NotImplementedOrNone'), Subscript(value=Name(id='Awaitable', ctx=Load()), slice=Constant(value='NotImplementedOrNone'), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='Binding', bases=[], keywords=[], body=[Expr(value=Constant(value="\n    Key binding: (key sequence + handler + filter).\n    (Immutable binding class.)\n\n    :param record_in_macro: When True, don't record this key binding when a\n        macro is recorded.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='keys', annotation=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[BinOp(left=Name(id='Keys', ctx=Load()), op=BitOr(), right=Name(id='str', ctx=Load())), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), arg(arg='handler', annotation=Name(id='KeyHandlerCallable', ctx=Load())), arg(arg='filter', annotation=Name(id='FilterOrBool', ctx=Load())), arg(arg='eager', annotation=Name(id='FilterOrBool', ctx=Load())), arg(arg='is_global', annotation=Name(id='FilterOrBool', ctx=Load())), arg(arg='save_before', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='KeyPressEvent', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='record_in_macro', annotation=Name(id='FilterOrBool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=False), Constant(value=False), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='e')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=True)), Constant(value=True)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='keys', ctx=Store())], value=Name(id='keys', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='handler', ctx=Store())], value=Name(id='handler', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='filter', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='filter', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='eager', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='eager', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='is_global', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='is_global', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='save_before', ctx=Store())], value=Name(id='save_before', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='record_in_macro', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='record_in_macro', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='call', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='event', annotation=Name(id='KeyPressEvent', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='handler', ctx=Load()), args=[Name(id='event', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isawaitable', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='awaitable', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Subscript(value=Name(id='Awaitable', ctx=Load()), slice=Constant(value='NotImplementedOrNone'), ctx=Load()), Name(id='result', ctx=Load())], keywords=[])), AsyncFunctionDef(name='bg_task', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Await(value=Name(id='awaitable', ctx=Load()))), If(test=Compare(left=Name(id='result', ctx=Load()), ops=[NotEq()], comparators=[Name(id='NotImplemented', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='event', ctx=Load()), attr='app', ctx=Load()), attr='invalidate', ctx=Load()), args=[], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='event', ctx=Load()), attr='app', ctx=Load()), attr='create_background_task', ctx=Load()), args=[Call(func=Name(id='bg_task', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[If(test=Compare(left=Name(id='result', ctx=Load()), ops=[NotEq()], comparators=[Name(id='NotImplemented', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='event', ctx=Load()), attr='app', ctx=Load()), attr='invalidate', ctx=Load()), args=[], keywords=[]))], orelse=[])])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='{}(keys={!r}, handler={!r})'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='keys', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='handler', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='KeysTuple', ctx=Store())], value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Keys', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), ClassDef(name='KeyBindingsBase', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='ABCMeta', ctx=Load()))], body=[Expr(value=Constant(value='\n    Interface for a KeyBindings.\n    ')), FunctionDef(name='_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        For cache invalidation. - This should increase every time that\n        something changes.\n        ')), Return(value=Constant(value=0))], decorator_list=[Name(id='abstractproperty', ctx=Load())], returns=Name(id='Hashable', ctx=Load())), FunctionDef(name='get_bindings_for_keys', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='keys', annotation=Name(id='KeysTuple', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a list of key bindings that can handle these keys.\n        (This return also inactive bindings, so the `filter` still has to be\n        called, for checking it.)\n\n        :param keys: tuple of keys.\n        ')), Return(value=List(elts=[], ctx=Load()))], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load())), FunctionDef(name='get_bindings_starting_with_keys', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='keys', annotation=Name(id='KeysTuple', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a list of key bindings that handle a key sequence starting with\n        `keys`. (It does only return bindings for which the sequences are\n        longer than `keys`. And like `get_bindings_for_keys`, it also includes\n        inactive bindings.)\n\n        :param keys: tuple of keys.\n        ')), Return(value=List(elts=[], ctx=Load()))], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load())), FunctionDef(name='bindings', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        List of `Binding` objects.\n        (These need to be exposed, so that `KeyBindings` objects can be merged\n        together.)\n        ')), Return(value=List(elts=[], ctx=Load()))], decorator_list=[Name(id='abstractproperty', ctx=Load())], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='T')], keywords=[keyword(arg='bound', value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='KeyHandlerCallable', ctx=Load()), Name(id='Binding', ctx=Load())], ctx=Load()), ctx=Load()))])), ClassDef(name='KeyBindings', bases=[Name(id='KeyBindingsBase', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    A container for a set of key bindings.\n\n    Example usage::\n\n        kb = KeyBindings()\n\n        @kb.add('c-t')\n        def _(event):\n            print('Control-T pressed')\n\n        @kb.add('c-a', 'c-b')\n        def _(event):\n            print('Control-A pressed, followed by Control-B')\n\n        @kb.add('c-x', filter=is_searching)\n        def _(event):\n            print('Control-X pressed')  # Works only if we are searching.\n\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_bindings', ctx=Store()), annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_get_bindings_for_keys_cache', ctx=Store()), annotation=Subscript(value=Name(id='SimpleCache', ctx=Load()), slice=Tuple(elts=[Name(id='KeysTuple', ctx=Load()), Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='SimpleCache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=10000))]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_get_bindings_starting_with_keys_cache', ctx=Store()), annotation=Subscript(value=Name(id='SimpleCache', ctx=Load()), slice=Tuple(elts=[Name(id='KeysTuple', ctx=Load()), Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='SimpleCache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=1000))]), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__version', ctx=Store())], value=Constant(value=0))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_clear_cache', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='__version', ctx=Store()), op=Add(), value=Constant(value=1)), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_get_bindings_for_keys_cache', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_get_bindings_starting_with_keys_cache', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='bindings', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_bindings', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load())), FunctionDef(name='_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__version', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Hashable', ctx=Load())), FunctionDef(name='add', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='keys', annotation=BinOp(left=Name(id='Keys', ctx=Load()), op=BitOr(), right=Name(id='str', ctx=Load()))), kwonlyargs=[arg(arg='filter', annotation=Name(id='FilterOrBool', ctx=Load())), arg(arg='eager', annotation=Name(id='FilterOrBool', ctx=Load())), arg(arg='is_global', annotation=Name(id='FilterOrBool', ctx=Load())), arg(arg='save_before', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='KeyPressEvent', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='record_in_macro', annotation=Name(id='FilterOrBool', ctx=Load()))], kw_defaults=[Constant(value=True), Constant(value=False), Constant(value=False), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='e')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=True)), Constant(value=True)], defaults=[]), body=[Expr(value=Constant(value="\n        Decorator for adding a key bindings.\n\n        :param filter: :class:`~prompt_toolkit.filters.Filter` to determine\n            when this key binding is active.\n        :param eager: :class:`~prompt_toolkit.filters.Filter` or `bool`.\n            When True, ignore potential longer matches when this key binding is\n            hit. E.g. when there is an active eager key binding for Ctrl-X,\n            execute the handler immediately and ignore the key binding for\n            Ctrl-X Ctrl-E of which it is a prefix.\n        :param is_global: When this key bindings is added to a `Container` or\n            `Control`, make it a global (always active) binding.\n        :param save_before: Callable that takes an `Event` and returns True if\n            we should save the current buffer, before handling the event.\n            (That's the default.)\n        :param record_in_macro: Record these key bindings when a macro is\n            being recorded. (True by default.)\n        ")), Assert(test=Name(id='keys', ctx=Load())), Assign(targets=[Name(id='keys', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_parse_key', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Name(id='keys', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='filter', ctx=Load()), Name(id='Never', ctx=Load())], keywords=[]), body=[FunctionDef(name='decorator', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Name(id='T', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='func', ctx=Load()))], decorator_list=[], returns=Name(id='T', ctx=Load()))], orelse=[FunctionDef(name='decorator', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Name(id='T', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='func', ctx=Load()), Name(id='Binding', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='bindings', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='Binding', ctx=Load()), args=[Name(id='keys', ctx=Load()), Attribute(value=Name(id='func', ctx=Load()), attr='handler', ctx=Load())], keywords=[keyword(arg='filter', value=BinOp(left=Attribute(value=Name(id='func', ctx=Load()), attr='filter', ctx=Load()), op=BitAnd(), right=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='filter', ctx=Load())], keywords=[]))), keyword(arg='eager', value=BinOp(left=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='eager', ctx=Load())], keywords=[]), op=BitOr(), right=Attribute(value=Name(id='func', ctx=Load()), attr='eager', ctx=Load()))), keyword(arg='is_global', value=BinOp(left=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='is_global', ctx=Load())], keywords=[]), op=BitOr(), right=Attribute(value=Name(id='func', ctx=Load()), attr='is_global', ctx=Load()))), keyword(arg='save_before', value=Attribute(value=Name(id='func', ctx=Load()), attr='save_before', ctx=Load())), keyword(arg='record_in_macro', value=Attribute(value=Name(id='func', ctx=Load()), attr='record_in_macro', ctx=Load()))])], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='bindings', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='Binding', ctx=Load()), args=[Name(id='keys', ctx=Load()), Call(func=Name(id='cast', ctx=Load()), args=[Name(id='KeyHandlerCallable', ctx=Load()), Name(id='func', ctx=Load())], keywords=[])], keywords=[keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='eager', value=Name(id='eager', ctx=Load())), keyword(arg='is_global', value=Name(id='is_global', ctx=Load())), keyword(arg='save_before', value=Name(id='save_before', ctx=Load())), keyword(arg='record_in_macro', value=Name(id='record_in_macro', ctx=Load()))])], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_clear_cache', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='func', ctx=Load()))], decorator_list=[], returns=Name(id='T', ctx=Load()))]), Return(value=Name(id='decorator', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='T', ctx=Load())], ctx=Load()), Name(id='T', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='remove', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=BinOp(left=BinOp(left=Name(id='Keys', ctx=Load()), op=BitOr(), right=Name(id='str', ctx=Load())), op=BitOr(), right=Name(id='KeyHandlerCallable', ctx=Load()))), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Remove a key binding.\n\n        This expects either a function that was given to `add` method as\n        parameter or a sequence of key bindings.\n\n        Raises `ValueError` when no bindings was found.\n\n        Usage::\n\n            remove(handler)  # Pass handler.\n            remove('c-x', 'c-a')  # Or pass the key bindings.\n        ")), Assign(targets=[Name(id='found', ctx=Store())], value=Constant(value=False)), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), body=[Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)])), Assign(targets=[Name(id='function', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load())), For(target=Name(id='b', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='bindings', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='b', ctx=Load()), attr='handler', ctx=Load()), ops=[Eq()], comparators=[Name(id='function', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='bindings', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])), Assign(targets=[Name(id='found', ctx=Store())], value=Constant(value=True))], orelse=[])], orelse=[])], orelse=[Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=0)])), Assign(targets=[Name(id='args', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Keys', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), Name(id='args', ctx=Load())], keywords=[])), Assign(targets=[Name(id='keys', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_parse_key', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Name(id='args', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), For(target=Name(id='b', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='bindings', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='b', ctx=Load()), attr='keys', ctx=Load()), ops=[Eq()], comparators=[Name(id='keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='bindings', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])), Assign(targets=[Name(id='found', ctx=Store())], value=Constant(value=True))], orelse=[])], orelse=[])]), If(test=Name(id='found', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_clear_cache', ctx=Load()), args=[], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Binding not found: '), FormattedValue(value=Name(id='function', ctx=Load()), conversion=114)])], keywords=[]))])], decorator_list=[], returns=Constant(value=None)), Assign(targets=[Name(id='add_binding', ctx=Store())], value=Name(id='add', ctx=Load())), Assign(targets=[Name(id='remove_binding', ctx=Store())], value=Name(id='remove', ctx=Load())), FunctionDef(name='get_bindings_for_keys', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='keys', annotation=Name(id='KeysTuple', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a list of key bindings that can handle this key.\n        (This return also inactive bindings, so the `filter` still has to be\n        called, for checking it.)\n\n        :param keys: tuple of keys.\n        ')), FunctionDef(name='get', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='result', ctx=Store()), annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='Binding', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Name(id='b', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='bindings', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='keys', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='b', ctx=Load()), attr='keys', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='any_count', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='j', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Name(id='b', ctx=Load()), attr='keys', ctx=Load()), Name(id='keys', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[NotEq()], comparators=[Name(id='j', ctx=Load())]), Compare(left=Name(id='i', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='Keys', ctx=Load()), attr='Any', ctx=Load())])]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Constant(value=False)), Break()], orelse=[]), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='Keys', ctx=Load()), attr='Any', ctx=Load())]), body=[AugAssign(target=Name(id='any_count', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[]), If(test=Name(id='match', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='any_count', ctx=Load()), Name(id='b', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=UnaryOp(op=USub(), operand=Subscript(value=Name(id='item', ctx=Load()), slice=Constant(value=0), ctx=Load()))))])), Return(value=ListComp(elt=Subscript(value=Name(id='item', ctx=Load()), slice=Constant(value=1), ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='result', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load())), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_get_bindings_for_keys_cache', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='keys', ctx=Load()), Name(id='get', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load())), FunctionDef(name='get_bindings_starting_with_keys', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='keys', annotation=Name(id='KeysTuple', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a list of key bindings that handle a key sequence starting with\n        `keys`. (It does only return bindings for which the sequences are\n        longer than `keys`. And like `get_bindings_for_keys`, it also includes\n        inactive bindings.)\n\n        :param keys: tuple of keys.\n        ')), FunctionDef(name='get', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='b', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='bindings', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='keys', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='b', ctx=Load()), attr='keys', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Constant(value=True)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='j', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Name(id='b', ctx=Load()), attr='keys', ctx=Load()), Name(id='keys', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[NotEq()], comparators=[Name(id='j', ctx=Load())]), Compare(left=Name(id='i', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='Keys', ctx=Load()), attr='Any', ctx=Load())])]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Constant(value=False)), Break()], orelse=[])], orelse=[]), If(test=Name(id='match', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load())), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_get_bindings_starting_with_keys_cache', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='keys', ctx=Load()), Name(id='get', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='_parse_key', args=arguments(posonlyargs=[], args=[arg(arg='key', annotation=BinOp(left=Name(id='Keys', ctx=Load()), op=BitOr(), right=Name(id='str', ctx=Load())))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Replace key by alias and verify whether it's a valid one.\n    ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='Keys', ctx=Load())], keywords=[]), body=[Return(value=Name(id='key', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='key', ctx=Store())], value=Call(func=Attribute(value=Name(id='KEY_ALIASES', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='key', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='key', ctx=Load()), ops=[Eq()], comparators=[Constant(value='space')]), body=[Assign(targets=[Name(id='key', ctx=Store())], value=Constant(value=' '))], orelse=[]), Try(body=[Return(value=Call(func=Name(id='Keys', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid key: '), FormattedValue(value=Name(id='key', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Return(value=Name(id='key', ctx=Load()))], decorator_list=[], returns=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Name(id='Keys', ctx=Load()))), FunctionDef(name='key_binding', args=arguments(posonlyargs=[], args=[arg(arg='filter', annotation=Name(id='FilterOrBool', ctx=Load())), arg(arg='eager', annotation=Name(id='FilterOrBool', ctx=Load())), arg(arg='is_global', annotation=Name(id='FilterOrBool', ctx=Load())), arg(arg='save_before', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='KeyPressEvent', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='record_in_macro', annotation=Name(id='FilterOrBool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=False), Constant(value=False), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='event')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=True)), Constant(value=True)]), body=[Expr(value=Constant(value='\n    Decorator that turn a function into a `Binding` object. This can be added\n    to a `KeyBindings` object when a key binding is assigned.\n    ')), Assert(test=BoolOp(op=Or(), values=[Compare(left=Name(id='save_before', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Call(func=Name(id='callable', ctx=Load()), args=[Name(id='save_before', ctx=Load())], keywords=[])])), Assign(targets=[Name(id='filter', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='filter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eager', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='eager', ctx=Load())], keywords=[])), Assign(targets=[Name(id='is_global', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='is_global', ctx=Load())], keywords=[])), Assign(targets=[Name(id='save_before', ctx=Store())], value=Name(id='save_before', ctx=Load())), Assign(targets=[Name(id='record_in_macro', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='record_in_macro', ctx=Load())], keywords=[])), Assign(targets=[Name(id='keys', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='decorator', args=arguments(posonlyargs=[], args=[arg(arg='function', annotation=Name(id='KeyHandlerCallable', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Binding', ctx=Load()), args=[Name(id='keys', ctx=Load()), Name(id='function', ctx=Load())], keywords=[keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='eager', value=Name(id='eager', ctx=Load())), keyword(arg='is_global', value=Name(id='is_global', ctx=Load())), keyword(arg='save_before', value=Name(id='save_before', ctx=Load())), keyword(arg='record_in_macro', value=Name(id='record_in_macro', ctx=Load()))]))], decorator_list=[], returns=Name(id='Binding', ctx=Load())), Return(value=Name(id='decorator', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='KeyHandlerCallable', ctx=Load())], ctx=Load()), Name(id='Binding', ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='_Proxy', bases=[Name(id='KeyBindingsBase', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Common part for ConditionalKeyBindings and _MergedKeyBindings.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_bindings2', ctx=Store()), annotation=Name(id='KeyBindingsBase', ctx=Load()), value=Call(func=Name(id='KeyBindings', ctx=Load()), args=[], keywords=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_last_version', ctx=Store()), annotation=Name(id='Hashable', ctx=Load()), value=Tuple(elts=[], ctx=Load()), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_update_cache', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        If `self._last_version` is outdated, then this should update\n        the version and `self._bindings2`.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='bindings', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_update_cache', ctx=Load()), args=[], keywords=[])), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_bindings2', ctx=Load()), attr='bindings', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load())), FunctionDef(name='_version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_update_cache', ctx=Load()), args=[], keywords=[])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_last_version', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Hashable', ctx=Load())), FunctionDef(name='get_bindings_for_keys', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='keys', annotation=Name(id='KeysTuple', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_update_cache', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_bindings2', ctx=Load()), attr='get_bindings_for_keys', ctx=Load()), args=[Name(id='keys', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load())), FunctionDef(name='get_bindings_starting_with_keys', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='keys', annotation=Name(id='KeysTuple', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_update_cache', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_bindings2', ctx=Load()), attr='get_bindings_starting_with_keys', ctx=Load()), args=[Name(id='keys', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Binding', ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='ConditionalKeyBindings', bases=[Name(id='_Proxy', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Wraps around a `KeyBindings`. Disable/enable all the key bindings according to\n    the given (additional) filter.::\n\n        @Condition\n        def setting_is_true():\n            return True  # or False\n\n        registry = ConditionalKeyBindings(key_bindings, setting_is_true)\n\n    When new key bindings are added to this object. They are also\n    enable/disabled according to the given `filter`.\n\n    :param registries: List of :class:`.KeyBindings` objects.\n    :param filter: :class:`~prompt_toolkit.filters.Filter` object.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key_bindings', annotation=Name(id='KeyBindingsBase', ctx=Load())), arg(arg='filter', annotation=Name(id='FilterOrBool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Call(func=Attribute(value=Name(id='_Proxy', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='key_bindings', ctx=Store())], value=Name(id='key_bindings', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='filter', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='filter', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_update_cache', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='If the original key bindings was changed. Update our copy version.')), Assign(targets=[Name(id='expected_version', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='key_bindings', ctx=Load()), attr='_version', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_last_version', ctx=Load()), ops=[NotEq()], comparators=[Name(id='expected_version', ctx=Load())]), body=[Assign(targets=[Name(id='bindings2', ctx=Store())], value=Call(func=Name(id='KeyBindings', ctx=Load()), args=[], keywords=[])), For(target=Name(id='b', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='key_bindings', ctx=Load()), attr='bindings', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='bindings2', ctx=Load()), attr='bindings', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='Binding', ctx=Load()), args=[], keywords=[keyword(arg='keys', value=Attribute(value=Name(id='b', ctx=Load()), attr='keys', ctx=Load())), keyword(arg='handler', value=Attribute(value=Name(id='b', ctx=Load()), attr='handler', ctx=Load())), keyword(arg='filter', value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='filter', ctx=Load()), op=BitAnd(), right=Attribute(value=Name(id='b', ctx=Load()), attr='filter', ctx=Load()))), keyword(arg='eager', value=Attribute(value=Name(id='b', ctx=Load()), attr='eager', ctx=Load())), keyword(arg='is_global', value=Attribute(value=Name(id='b', ctx=Load()), attr='is_global', ctx=Load())), keyword(arg='save_before', value=Attribute(value=Name(id='b', ctx=Load()), attr='save_before', ctx=Load())), keyword(arg='record_in_macro', value=Attribute(value=Name(id='b', ctx=Load()), attr='record_in_macro', ctx=Load()))])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_bindings2', ctx=Store())], value=Name(id='bindings2', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_version', ctx=Store())], value=Name(id='expected_version', ctx=Load()))], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='_MergedKeyBindings', bases=[Name(id='_Proxy', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Merge multiple registries of key bindings into one.\n\n    This class acts as a proxy to multiple :class:`.KeyBindings` objects, but\n    behaves as if this is just one bigger :class:`.KeyBindings`.\n\n    :param registries: List of :class:`.KeyBindings` objects.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='registries', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='KeyBindingsBase', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='_Proxy', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='registries', ctx=Store())], value=Name(id='registries', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_update_cache', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        If one of the original registries was changed. Update our merged\n        version.\n        ')), Assign(targets=[Name(id='expected_version', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='r', ctx=Load()), attr='_version', ctx=Load()), generators=[comprehension(target=Name(id='r', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='registries', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_last_version', ctx=Load()), ops=[NotEq()], comparators=[Name(id='expected_version', ctx=Load())]), body=[Assign(targets=[Name(id='bindings2', ctx=Store())], value=Call(func=Name(id='KeyBindings', ctx=Load()), args=[], keywords=[])), For(target=Name(id='reg', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='registries', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='bindings2', ctx=Load()), attr='bindings', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='reg', ctx=Load()), attr='bindings', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_bindings2', ctx=Store())], value=Name(id='bindings2', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_version', ctx=Store())], value=Name(id='expected_version', ctx=Load()))], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), FunctionDef(name='merge_key_bindings', args=arguments(posonlyargs=[], args=[arg(arg='bindings', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='KeyBindingsBase', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Merge multiple :class:`.Keybinding` objects together.\n\n    Usage::\n\n        bindings = merge_key_bindings([bindings1, bindings2, ...])\n    ')), Return(value=Call(func=Name(id='_MergedKeyBindings', ctx=Load()), args=[Name(id='bindings', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='_MergedKeyBindings', ctx=Load())), ClassDef(name='DynamicKeyBindings', bases=[Name(id='_Proxy', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    KeyBindings class that can dynamically returns any KeyBindings.\n\n    :param get_key_bindings: Callable that returns a :class:`.KeyBindings` instance.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='get_key_bindings', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), BinOp(left=Name(id='KeyBindingsBase', ctx=Load()), op=BitOr(), right=Constant(value=None))], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='get_key_bindings', ctx=Store())], value=Name(id='get_key_bindings', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__version', ctx=Store())], value=Constant(value=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_child_version', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_dummy', ctx=Store())], value=Call(func=Name(id='KeyBindings', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_update_cache', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='key_bindings', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_key_bindings', ctx=Load()), args=[], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='_dummy', ctx=Load())])), Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='key_bindings', ctx=Load()), Name(id='KeyBindingsBase', ctx=Load())], keywords=[])), Assign(targets=[Name(id='version', ctx=Store())], value=Tuple(elts=[Call(func=Name(id='id', ctx=Load()), args=[Name(id='key_bindings', ctx=Load())], keywords=[]), Attribute(value=Name(id='key_bindings', ctx=Load()), attr='_version', ctx=Load())], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_bindings2', ctx=Store())], value=Name(id='key_bindings', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_version', ctx=Store())], value=Name(id='version', ctx=Load()))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='GlobalOnlyKeyBindings', bases=[Name(id='_Proxy', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Wrapper around a :class:`.KeyBindings` object that only exposes the global\n    key bindings.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key_bindings', annotation=Name(id='KeyBindingsBase', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='_Proxy', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='key_bindings', ctx=Store())], value=Name(id='key_bindings', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_update_cache', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        If one of the original registries was changed. Update our merged\n        version.\n        ')), Assign(targets=[Name(id='expected_version', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='key_bindings', ctx=Load()), attr='_version', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_last_version', ctx=Load()), ops=[NotEq()], comparators=[Name(id='expected_version', ctx=Load())]), body=[Assign(targets=[Name(id='bindings2', ctx=Store())], value=Call(func=Name(id='KeyBindings', ctx=Load()), args=[], keywords=[])), For(target=Name(id='b', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='key_bindings', ctx=Load()), attr='bindings', ctx=Load()), body=[If(test=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='is_global', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='bindings2', ctx=Load()), attr='bindings', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_bindings2', ctx=Store())], value=Name(id='bindings2', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_version', ctx=Store())], value=Name(id='expected_version', ctx=Load()))], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[])], type_ignores=[])