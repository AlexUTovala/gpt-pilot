Module(body=[ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='abc', names=[alias(name='ABCMeta'), alias(name='abstractmethod')], level=0), ImportFrom(module='typing', names=[alias(name='Callable'), alias(name='Iterable'), alias(name='Union')], level=0), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Filter'), Constant(value='Never'), Constant(value='Always'), Constant(value='Condition'), Constant(value='FilterOrBool')], ctx=Load())), ClassDef(name='Filter', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='ABCMeta', ctx=Load()))], body=[Expr(value=Constant(value='\n    Base class for any filter to activate/deactivate a feature, depending on a\n    condition.\n\n    The return value of ``__call__`` will tell if the feature should be active.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_and_cache', ctx=Store()), annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='Filter', ctx=Load()), Name(id='Filter', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_or_cache', ctx=Store()), annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='Filter', ctx=Load()), Name(id='Filter', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_invert_result', ctx=Store()), annotation=BinOp(left=Name(id='Filter', ctx=Load()), op=BitOr(), right=Constant(value=None)), value=Constant(value=None), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        The actual call to evaluate the filter.\n        ')), Return(value=Constant(value=True))], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__and__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Name(id='Filter', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Chaining of filters using the & operator.\n        ')), Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Filter', ctx=Load())], keywords=[]), msg=BinOp(left=Constant(value='Expecting filter, got %r'), op=Mod(), right=Name(id='other', ctx=Load()))), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Always', ctx=Load())], keywords=[]), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Never', ctx=Load())], keywords=[]), body=[Return(value=Name(id='other', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='other', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_and_cache', ctx=Load())]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_and_cache', ctx=Load()), slice=Name(id='other', ctx=Load()), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='_AndList', ctx=Load()), attr='create', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_and_cache', ctx=Load()), slice=Name(id='other', ctx=Load()), ctx=Store())], value=Name(id='result', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='Filter', ctx=Load())), FunctionDef(name='__or__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Name(id='Filter', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Chaining of filters using the | operator.\n        ')), Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Filter', ctx=Load())], keywords=[]), msg=BinOp(left=Constant(value='Expecting filter, got %r'), op=Mod(), right=Name(id='other', ctx=Load()))), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Always', ctx=Load())], keywords=[]), body=[Return(value=Name(id='other', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Never', ctx=Load())], keywords=[]), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='other', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_or_cache', ctx=Load())]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_or_cache', ctx=Load()), slice=Name(id='other', ctx=Load()), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='_OrList', ctx=Load()), attr='create', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_or_cache', ctx=Load()), slice=Name(id='other', ctx=Load()), ctx=Store())], value=Name(id='result', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='Filter', ctx=Load())), FunctionDef(name='__invert__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Inverting of filters using the ~ operator.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_invert_result', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_invert_result', ctx=Store())], value=Call(func=Name(id='_Invert', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_invert_result', ctx=Load()))], decorator_list=[], returns=Name(id='Filter', ctx=Load())), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        By purpose, we don't allow bool(...) operations directly on a filter,\n        because the meaning is ambiguous.\n\n        Executing a filter has to be done always by calling it. Providing\n        defaults for `None` values should be done through an `is None` check\n        instead of for instance ``filter1 or Always()``.\n        ")), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='The truth value of a Filter is ambiguous. Instead, call it as a function.')], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), FunctionDef(name='_remove_duplicates', args=arguments(posonlyargs=[], args=[arg(arg='filters', annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Filter', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='f', ctx=Store()), iter=Name(id='filters', ctx=Load()), body=[If(test=Compare(left=Name(id='f', ctx=Load()), ops=[NotIn()], comparators=[Name(id='result', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Filter', ctx=Load()), ctx=Load())), ClassDef(name='_AndList', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Result of &-operation between several filters.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='filters', annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Filter', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='filters', ctx=Store())], value=Name(id='filters', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='create', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='filters', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Filter', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Create a new filter by applying an `&` operator between them.\n\n        If there's only one unique filter in the given iterable, it will return\n        that one filter instead of an `_AndList`.\n        ")), AnnAssign(target=Name(id='filters_2', ctx=Store()), annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Filter', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Name(id='f', ctx=Store()), iter=Name(id='filters', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='f', ctx=Load()), Name(id='_AndList', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='filters_2', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='f', ctx=Load()), attr='filters', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='filters_2', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Name(id='filters', ctx=Store())], value=Call(func=Name(id='_remove_duplicates', ctx=Load()), args=[Name(id='filters_2', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='filters', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Subscript(value=Name(id='filters', ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='filters', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='Filter', ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='f', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='filters', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='&'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='filters', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='_OrList', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Result of |-operation between several filters.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='filters', annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Filter', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='filters', ctx=Store())], value=Name(id='filters', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='create', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='filters', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Filter', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Create a new filter by applying an `|` operator between them.\n\n        If there's only one unique filter in the given iterable, it will return\n        that one filter instead of an `_OrList`.\n        ")), AnnAssign(target=Name(id='filters_2', ctx=Store()), annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Filter', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Name(id='f', ctx=Store()), iter=Name(id='filters', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='f', ctx=Load()), Name(id='_OrList', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='filters_2', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='f', ctx=Load()), attr='filters', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='filters_2', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Name(id='filters', ctx=Store())], value=Call(func=Name(id='_remove_duplicates', ctx=Load()), args=[Name(id='filters_2', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='filters', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Subscript(value=Name(id='filters', ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='filters', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='Filter', ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='f', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='filters', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='filters', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='_Invert', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Negation of another filter.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='filter', annotation=Name(id='Filter', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='filter', ctx=Store())], value=Name(id='filter', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='filter', ctx=Load()), args=[], keywords=[])))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='~%r'), op=Mod(), right=Attribute(value=Name(id='self', ctx=Load()), attr='filter', ctx=Load())))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='Always', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Always enable feature.\n    ')), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__or__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Name(id='Filter', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='Filter', ctx=Load())), FunctionDef(name='__invert__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Never', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Never', ctx=Load()))], decorator_list=[]), ClassDef(name='Never', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Never enable feature.\n    ')), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=False))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__and__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Name(id='Filter', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='Filter', ctx=Load())), FunctionDef(name='__invert__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Always', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Always', ctx=Load()))], decorator_list=[]), ClassDef(name='Condition', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Turn any callable into a Filter. The callable is supposed to not take any\n    arguments.\n\n    This can be used as a decorator::\n\n        @Condition\n        def feature_is_active():  # `feature_is_active` becomes a Filter.\n            return True\n\n    :param func: Callable which takes no inputs and returns a boolean.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='func', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='func', ctx=Store())], value=Name(id='func', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='func', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='Condition(%r)'), op=Mod(), right=Attribute(value=Name(id='self', ctx=Load()), attr='func', ctx=Load())))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='FilterOrBool', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Filter', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()))], type_ignores=[])