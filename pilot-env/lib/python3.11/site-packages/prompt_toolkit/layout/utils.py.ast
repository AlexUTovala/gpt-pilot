Module(body=[ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Iterable'), alias(name='List'), alias(name='TypeVar'), alias(name='cast'), alias(name='overload')], level=0), ImportFrom(module='prompt_toolkit.formatted_text.base', names=[alias(name='OneStyleAndTextTuple')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='typing_extensions', names=[alias(name='SupportsIndex')], level=0)], orelse=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='explode_text_fragments')], ctx=Load())), Assign(targets=[Name(id='_T', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_T')], keywords=[keyword(arg='bound', value=Name(id='OneStyleAndTextTuple', ctx=Load()))])), ClassDef(name='_ExplodedList', bases=[Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='_T', ctx=Load()), ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Wrapper around a list, that marks it as 'exploded'.\n\n    As soon as items are added or the list is extended, the new items are\n    automatically exploded as well.\n    ")), Assign(targets=[Name(id='exploded', ctx=Store())], value=Constant(value=True)), FunctionDef(name='append', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item', annotation=Name(id='_T', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='extend', ctx=Load()), args=[List(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='extend', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lst', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='_T', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='extend', ctx=Load()), args=[Call(func=Name(id='explode_text_fragments', ctx=Load()), args=[Name(id='lst', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='insert', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='index', annotation=Name(id='SupportsIndex', ctx=Load())), arg(arg='item', annotation=Name(id='_T', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__setitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='index', annotation=Name(id='SupportsIndex', ctx=Load())), arg(arg='value', annotation=Name(id='_T', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='__setitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='index', annotation=Name(id='slice', ctx=Load())), arg(arg='value', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='_T', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='__setitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='index', annotation=BinOp(left=Name(id='SupportsIndex', ctx=Load()), op=BitOr(), right=Name(id='slice', ctx=Load()))), arg(arg='value', annotation=BinOp(left=Name(id='_T', ctx=Load()), op=BitOr(), right=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='_T', ctx=Load()), ctx=Load())))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Ensure that when `(style_str, 'long string')` is set, the string will be\n        exploded.\n        ")), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='index', ctx=Load()), Name(id='slice', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='int_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='index', ctx=Load()), attr='__index__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='index', ctx=Store())], value=Call(func=Name(id='slice', ctx=Load()), args=[Name(id='int_index', ctx=Load()), BinOp(left=Name(id='int_index', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Constant(value='List[_T]'), List(elts=[Name(id='value', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__setitem__', ctx=Load()), args=[Name(id='index', ctx=Load()), Call(func=Name(id='explode_text_fragments', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), FunctionDef(name='explode_text_fragments', args=arguments(posonlyargs=[], args=[arg(arg='fragments', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='_T', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Turn a list of (style_str, text) tuples into another list where each string is\n    exactly one character.\n\n    It should be fine to call this function several times. Calling this on a\n    list that is already exploded, is a null operation.\n\n    :param fragments: List of (style, text) tuples.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='fragments', ctx=Load()), Name(id='_ExplodedList', ctx=Load())], keywords=[]), body=[Return(value=Name(id='fragments', ctx=Load()))], orelse=[]), AnnAssign(target=Name(id='result', ctx=Store()), annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='_T', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Tuple(elts=[Name(id='style', ctx=Store()), Name(id='string', ctx=Store()), Starred(value=Name(id='rest', ctx=Store()), ctx=Store())], ctx=Store()), iter=Name(id='fragments', ctx=Load()), body=[For(target=Name(id='c', ctx=Store()), iter=Name(id='string', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='style', ctx=Load()), Name(id='c', ctx=Load()), Starred(value=Name(id='rest', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='_ExplodedList', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='_ExplodedList', ctx=Load()), slice=Name(id='_T', ctx=Load()), ctx=Load()))], type_ignores=[])