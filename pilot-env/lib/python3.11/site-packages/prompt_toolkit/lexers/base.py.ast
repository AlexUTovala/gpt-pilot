Module(body=[Expr(value=Constant(value='\nBase classes for prompt_toolkit lexers.\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='abc', names=[alias(name='ABCMeta'), alias(name='abstractmethod')], level=0), ImportFrom(module='typing', names=[alias(name='Callable'), alias(name='Hashable')], level=0), ImportFrom(module='prompt_toolkit.document', names=[alias(name='Document')], level=0), ImportFrom(module='prompt_toolkit.formatted_text.base', names=[alias(name='StyleAndTextTuples')], level=0), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Lexer'), Constant(value='SimpleLexer'), Constant(value='DynamicLexer')], ctx=Load())), ClassDef(name='Lexer', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='ABCMeta', ctx=Load()))], body=[Expr(value=Constant(value='\n    Base class for all lexers.\n    ')), FunctionDef(name='lex_document', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Takes a :class:`~prompt_toolkit.document.Document` and returns a\n        callable that takes a line number and returns a list of\n        ``(style_str, text)`` tuples for that line.\n\n        XXX: Note that in the past, this was supposed to return a list\n             of ``(Token, text)`` tuples, just like a Pygments lexer.\n        '))], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='int', ctx=Load())], ctx=Load()), Name(id='StyleAndTextTuples', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='invalidation_hash', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        When this changes, `lex_document` could give a different output.\n        (Only used for `DynamicLexer`.)\n        ')), Return(value=Call(func=Name(id='id', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Hashable', ctx=Load()))], decorator_list=[]), ClassDef(name='SimpleLexer', bases=[Name(id='Lexer', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Lexer that doesn't do any tokenizing and returns the whole input as one\n    token.\n\n    :param style: The style string for this lexer.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='style', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Store())], value=Name(id='style', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='lex_document', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='lines', ctx=Store())], value=Attribute(value=Name(id='document', ctx=Load()), attr='lines', ctx=Load())), FunctionDef(name='get_line', args=arguments(posonlyargs=[], args=[arg(arg='lineno', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the tokens for the given line.')), Try(body=[Return(value=List(elts=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='style', ctx=Load()), Subscript(value=Name(id='lines', ctx=Load()), slice=Name(id='lineno', ctx=Load()), ctx=Load())], ctx=Load())], ctx=Load()))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[Return(value=List(elts=[], ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='StyleAndTextTuples', ctx=Load())), Return(value=Name(id='get_line', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='int', ctx=Load())], ctx=Load()), Name(id='StyleAndTextTuples', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='DynamicLexer', bases=[Name(id='Lexer', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Lexer class that can dynamically returns any Lexer.\n\n    :param get_lexer: Callable that returns a :class:`.Lexer` instance.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='get_lexer', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), BinOp(left=Name(id='Lexer', ctx=Load()), op=BitOr(), right=Constant(value=None))], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='get_lexer', ctx=Store())], value=Name(id='get_lexer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_dummy', ctx=Store())], value=Call(func=Name(id='SimpleLexer', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='lex_document', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='lexer', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_lexer', ctx=Load()), args=[], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='_dummy', ctx=Load())])), Return(value=Call(func=Attribute(value=Name(id='lexer', ctx=Load()), attr='lex_document', ctx=Load()), args=[Name(id='document', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='int', ctx=Load())], ctx=Load()), Name(id='StyleAndTextTuples', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='invalidation_hash', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='lexer', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_lexer', ctx=Load()), args=[], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='_dummy', ctx=Load())])), Return(value=Call(func=Name(id='id', ctx=Load()), args=[Name(id='lexer', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Hashable', ctx=Load()))], decorator_list=[])], type_ignores=[])