Module(body=[Expr(value=Constant(value="\nAdaptor classes for using Pygments lexers within prompt_toolkit.\n\nThis includes syntax synchronization code, so that we don't have to start\nlexing at the beginning of a document, when displaying a very large text.\n")), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), Import(names=[alias(name='re')]), ImportFrom(module='abc', names=[alias(name='ABCMeta'), alias(name='abstractmethod')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Callable'), alias(name='Dict'), alias(name='Generator'), alias(name='Iterable'), alias(name='Tuple')], level=0), ImportFrom(module='prompt_toolkit.document', names=[alias(name='Document')], level=0), ImportFrom(module='prompt_toolkit.filters', names=[alias(name='FilterOrBool'), alias(name='to_filter')], level=0), ImportFrom(module='prompt_toolkit.formatted_text.base', names=[alias(name='StyleAndTextTuples')], level=0), ImportFrom(module='prompt_toolkit.formatted_text.utils', names=[alias(name='split_lines')], level=0), ImportFrom(module='prompt_toolkit.styles.pygments', names=[alias(name='pygments_token_to_classname')], level=0), ImportFrom(module='base', names=[alias(name='Lexer'), alias(name='SimpleLexer')], level=1), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='pygments.lexer', names=[alias(name='Lexer', asname='PygmentsLexerCls')], level=0)], orelse=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='PygmentsLexer'), Constant(value='SyntaxSync'), Constant(value='SyncFromStart'), Constant(value='RegexSync')], ctx=Load())), ClassDef(name='SyntaxSync', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='ABCMeta', ctx=Load()))], body=[Expr(value=Constant(value="\n    Syntax synchroniser. This is a tool that finds a start position for the\n    lexer. This is especially important when editing big documents; we don't\n    want to start the highlighting by running the lexer from the beginning of\n    the file. That is very slow when editing.\n    ")), FunctionDef(name='get_sync_start_position', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='document', annotation=Name(id='Document', ctx=Load())), arg(arg='lineno', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the position from where we can start lexing as a (row, column)\n        tuple.\n\n        :param document: `Document` instance that contains all the lines.\n        :param lineno: The line that we want to highlight. (We need to return\n            this line, or an earlier position.)\n        '))], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='SyncFromStart', bases=[Name(id='SyntaxSync', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Always start the syntax highlighting from the beginning.\n    ')), FunctionDef(name='get_sync_start_position', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='document', annotation=Name(id='Document', ctx=Load())), arg(arg='lineno', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Constant(value=0), Constant(value=0)], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='RegexSync', bases=[Name(id='SyntaxSync', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Synchronize by starting at a line that matches the given regex pattern.\n    ')), Assign(targets=[Name(id='MAX_BACKWARDS', ctx=Store())], value=Constant(value=500)), Assign(targets=[Name(id='FROM_START_IF_NO_SYNC_POS_FOUND', ctx=Store())], value=Constant(value=100)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pattern', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_compiled_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_sync_start_position', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='document', annotation=Name(id='Document', ctx=Load())), arg(arg='lineno', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Scan backwards, and find a possible position to start.\n        ')), Assign(targets=[Name(id='pattern', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_compiled_pattern', ctx=Load())), Assign(targets=[Name(id='lines', ctx=Store())], value=Attribute(value=Name(id='document', ctx=Load()), attr='lines', ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='lineno', ctx=Load()), Call(func=Name(id='max', ctx=Load()), args=[UnaryOp(op=USub(), operand=Constant(value=1)), BinOp(left=Name(id='lineno', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='MAX_BACKWARDS', ctx=Load()))], keywords=[]), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='pattern', ctx=Load()), attr='match', ctx=Load()), args=[Subscript(value=Name(id='lines', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='i', ctx=Load()), Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[])], ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='lineno', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='FROM_START_IF_NO_SYNC_POS_FOUND', ctx=Load())]), body=[Return(value=Tuple(elts=[Constant(value=0), Constant(value=0)], ctx=Load()))], orelse=[Return(value=Tuple(elts=[Name(id='lineno', ctx=Load()), Constant(value=0)], ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='from_pygments_lexer_cls', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='lexer_cls', annotation=Name(id='PygmentsLexerCls', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Create a :class:`.RegexSync` instance for this Pygments lexer class.\n        ')), Assign(targets=[Name(id='patterns', ctx=Store())], value=Dict(keys=[Constant(value='Python'), Constant(value='Python 3'), Constant(value='HTML'), Constant(value='JavaScript')], values=[Constant(value='^\\s*(class|def)\\s+'), Constant(value='^\\s*(class|def)\\s+'), Constant(value='<[/a-zA-Z]'), Constant(value='\\bfunction\\b')])), Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Attribute(value=Name(id='patterns', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='lexer_cls', ctx=Load()), attr='name', ctx=Load()), Constant(value='^')], keywords=[])), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='RegexSync', ctx=Load()))], decorator_list=[]), ClassDef(name='_TokenCache', bases=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Cache that converts Pygments tokens into `prompt_toolkit` style objects.\n\n    ``Token.A.B.C`` will be converted into:\n    ``class:pygments,pygments.A,pygments.A.B,pygments.A.B.C``\n    ')), FunctionDef(name='__missing__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key', annotation=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=Constant(value='class:'), op=Add(), right=Call(func=Name(id='pygments_token_to_classname', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]))), Assign(targets=[Subscript(value=Name(id='self', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='result', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_token_cache', ctx=Store())], value=Call(func=Name(id='_TokenCache', ctx=Load()), args=[], keywords=[])), ClassDef(name='PygmentsLexer', bases=[Name(id='Lexer', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Lexer that calls a pygments lexer.\n\n    Example::\n\n        from pygments.lexers.html import HtmlLexer\n        lexer = PygmentsLexer(HtmlLexer)\n\n    Note: Don't forget to also load a Pygments compatible style. E.g.::\n\n        from prompt_toolkit.styles.from_pygments import style_from_pygments_cls\n        from pygments.styles import get_style_by_name\n        style = style_from_pygments_cls(get_style_by_name('monokai'))\n\n    :param pygments_lexer_cls: A `Lexer` from Pygments.\n    :param sync_from_start: Start lexing at the start of the document. This\n        will always give the best results, but it will be slow for bigger\n        documents. (When the last part of the document is display, then the\n        whole document will be lexed by Pygments on every key stroke.) It is\n        recommended to disable this for inputs that are expected to be more\n        than 1,000 lines.\n    :param syntax_sync: `SyntaxSync` object.\n    ")), Assign(targets=[Name(id='MIN_LINES_BACKWARDS', ctx=Store())], value=Constant(value=50)), Assign(targets=[Name(id='REUSE_GENERATOR_MAX_DISTANCE', ctx=Store())], value=Constant(value=100)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pygments_lexer_cls', annotation=Subscript(value=Name(id='type', ctx=Load()), slice=Name(id='PygmentsLexerCls', ctx=Load()), ctx=Load())), arg(arg='sync_from_start', annotation=Name(id='FilterOrBool', ctx=Load())), arg(arg='syntax_sync', annotation=BinOp(left=Name(id='SyntaxSync', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pygments_lexer_cls', ctx=Store())], value=Name(id='pygments_lexer_cls', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='sync_from_start', ctx=Store())], value=Call(func=Name(id='to_filter', ctx=Load()), args=[Name(id='sync_from_start', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pygments_lexer', ctx=Store())], value=Call(func=Name(id='pygments_lexer_cls', ctx=Load()), args=[], keywords=[keyword(arg='stripnl', value=Constant(value=False)), keyword(arg='stripall', value=Constant(value=False)), keyword(arg='ensurenl', value=Constant(value=False))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='syntax_sync', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='syntax_sync', ctx=Load()), Call(func=Attribute(value=Name(id='RegexSync', ctx=Load()), attr='from_pygments_lexer_cls', ctx=Load()), args=[Name(id='pygments_lexer_cls', ctx=Load())], keywords=[])]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='from_filename', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='filename', annotation=Name(id='str', ctx=Load())), arg(arg='sync_from_start', annotation=Name(id='FilterOrBool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n        Create a `Lexer` from a filename.\n        ')), ImportFrom(module='pygments.lexers', names=[alias(name='get_lexer_for_filename')], level=0), ImportFrom(module='pygments.util', names=[alias(name='ClassNotFound')], level=0), Try(body=[Assign(targets=[Name(id='pygments_lexer', ctx=Store())], value=Call(func=Name(id='get_lexer_for_filename', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ClassNotFound', ctx=Load()), body=[Return(value=Call(func=Name(id='SimpleLexer', ctx=Load()), args=[], keywords=[]))])], orelse=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Attribute(value=Name(id='pygments_lexer', ctx=Load()), attr='__class__', ctx=Load())], keywords=[keyword(arg='sync_from_start', value=Name(id='sync_from_start', ctx=Load()))]))], finalbody=[])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='Lexer', ctx=Load())), FunctionDef(name='lex_document', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='document', annotation=Name(id='Document', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Create a lexer function that takes a line number and returns the list\n        of (style_str, text) tuples as the Pygments lexer returns for that line.\n        ')), Assign(targets=[Name(id='LineGenerator', ctx=Store())], value=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='StyleAndTextTuples', ctx=Load())], ctx=Load()), ctx=Load()), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), AnnAssign(target=Name(id='cache', ctx=Store()), annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='StyleAndTextTuples', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), AnnAssign(target=Name(id='line_generators', ctx=Store()), annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='LineGenerator', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), FunctionDef(name='get_syntax_sync', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The Syntax synchronisation object that we currently use.')), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='sync_from_start', ctx=Load()), args=[], keywords=[]), body=[Return(value=Call(func=Name(id='SyncFromStart', ctx=Load()), args=[], keywords=[]))], orelse=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='syntax_sync', ctx=Load()))])], decorator_list=[], returns=Name(id='SyntaxSync', ctx=Load())), FunctionDef(name='find_closest_generator', args=arguments(posonlyargs=[], args=[arg(arg='i', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return a generator close to line 'i', or None if none was found.")), For(target=Tuple(elts=[Name(id='generator', ctx=Store()), Name(id='lineno', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='line_generators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='lineno', ctx=Load()), ops=[Lt()], comparators=[Name(id='i', ctx=Load())]), Compare(left=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='lineno', ctx=Load())), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='REUSE_GENERATOR_MAX_DISTANCE', ctx=Load())])]), body=[Return(value=Name(id='generator', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=BinOp(left=Name(id='LineGenerator', ctx=Load()), op=BitOr(), right=Constant(value=None))), FunctionDef(name='create_line_generator', args=arguments(posonlyargs=[], args=[arg(arg='start_lineno', annotation=Name(id='int', ctx=Load())), arg(arg='column', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='\n            Create a generator that yields the lexed lines.\n            Each iteration it yields a (line_number, [(style_str, text), ...]) tuple.\n            ')), FunctionDef(name='get_text_fragments', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='document', ctx=Load()), attr='lines', ctx=Load()), slice=Slice(lower=Name(id='start_lineno', ctx=Load())), ctx=Load())], keywords=[]), slice=Slice(lower=Name(id='column', ctx=Load())), ctx=Load())), For(target=Tuple(elts=[Name(id='_', ctx=Store()), Name(id='t', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pygments_lexer', ctx=Load()), attr='get_tokens_unprocessed', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Tuple(elts=[Subscript(value=Name(id='_token_cache', ctx=Load()), slice=Name(id='t', ctx=Load()), ctx=Load()), Name(id='v', ctx=Load())], ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), Expr(value=YieldFrom(value=Call(func=Name(id='enumerate', ctx=Load()), args=[Call(func=Name(id='split_lines', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='get_text_fragments', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]), Name(id='start_lineno', ctx=Load())], keywords=[])))], decorator_list=[], returns=Name(id='LineGenerator', ctx=Load())), FunctionDef(name='get_generator', args=arguments(posonlyargs=[], args=[arg(arg='i', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n            Find an already started generator that is close, or create a new one.\n            ')), Assign(targets=[Name(id='generator', ctx=Store())], value=Call(func=Name(id='find_closest_generator', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])), If(test=Name(id='generator', ctx=Load()), body=[Return(value=Name(id='generator', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='i', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='MIN_LINES_BACKWARDS', ctx=Load()))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='row', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='column', ctx=Store())], value=Constant(value=0))], orelse=[Assign(targets=[Tuple(elts=[Name(id='row', ctx=Store()), Name(id='column', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='get_syntax_sync', ctx=Load()), args=[], keywords=[]), attr='get_sync_start_position', ctx=Load()), args=[Name(id='document', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='generator', ctx=Store())], value=Call(func=Name(id='find_closest_generator', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])), If(test=Name(id='generator', ctx=Load()), body=[Return(value=Name(id='generator', ctx=Load()))], orelse=[Assign(targets=[Name(id='generator', ctx=Store())], value=Call(func=Name(id='create_line_generator', ctx=Load()), args=[Name(id='row', ctx=Load()), Name(id='column', ctx=Load())], keywords=[]))]), If(test=Name(id='column', ctx=Load()), body=[Expr(value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='generator', ctx=Load())], keywords=[])), AugAssign(target=Name(id='row', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Assign(targets=[Subscript(value=Name(id='line_generators', ctx=Load()), slice=Name(id='generator', ctx=Load()), ctx=Store())], value=Name(id='row', ctx=Load())), Return(value=Name(id='generator', ctx=Load()))], decorator_list=[], returns=Name(id='LineGenerator', ctx=Load())), FunctionDef(name='get_line', args=arguments(posonlyargs=[], args=[arg(arg='i', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the tokens for a given line number.')), Try(body=[Return(value=Subscript(value=Name(id='cache', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Assign(targets=[Name(id='generator', ctx=Store())], value=Call(func=Name(id='get_generator', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='num', ctx=Store()), Name(id='line', ctx=Store())], ctx=Store()), iter=Name(id='generator', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='cache', ctx=Load()), slice=Name(id='num', ctx=Load()), ctx=Store())], value=Name(id='line', ctx=Load())), If(test=Compare(left=Name(id='num', ctx=Load()), ops=[Eq()], comparators=[Name(id='i', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='line_generators', ctx=Load()), slice=Name(id='generator', ctx=Load()), ctx=Store())], value=Name(id='i', ctx=Load())), If(test=Compare(left=BinOp(left=Name(id='num', ctx=Load()), op=Add(), right=Constant(value=1)), ops=[In()], comparators=[Name(id='cache', ctx=Load())]), body=[Delete(targets=[Subscript(value=Name(id='cache', ctx=Load()), slice=BinOp(left=Name(id='num', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Del())])], orelse=[]), Return(value=Subscript(value=Name(id='cache', ctx=Load()), slice=Name(id='num', ctx=Load()), ctx=Load()))], orelse=[])], orelse=[])])], orelse=[], finalbody=[]), Return(value=List(elts=[], ctx=Load()))], decorator_list=[], returns=Name(id='StyleAndTextTuples', ctx=Load())), Return(value=Name(id='get_line', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='int', ctx=Load())], ctx=Load()), Name(id='StyleAndTextTuples', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])