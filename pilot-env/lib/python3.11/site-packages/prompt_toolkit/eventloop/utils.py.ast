Module(body=[ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), Import(names=[alias(name='asyncio')]), Import(names=[alias(name='contextvars')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='time')]), ImportFrom(module='asyncio', names=[alias(name='get_running_loop')], level=0), ImportFrom(module='types', names=[alias(name='TracebackType')], level=0), ImportFrom(module='typing', names=[alias(name='Any'), alias(name='Awaitable'), alias(name='Callable'), alias(name='TypeVar'), alias(name='cast')], level=0), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='run_in_executor_with_context'), Constant(value='call_soon_threadsafe'), Constant(value='get_traceback_from_context')], ctx=Load())), Assign(targets=[Name(id='_T', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_T')], keywords=[])), FunctionDef(name='run_in_executor_with_context', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='_T', ctx=Load())], ctx=Load()), ctx=Load()))], vararg=arg(arg='args', annotation=Name(id='Any', ctx=Load())), kwonlyargs=[arg(arg='loop', annotation=BinOp(left=Attribute(value=Name(id='asyncio', ctx=Load()), attr='AbstractEventLoop', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kw_defaults=[Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value='\n    Run a function in an executor, but make sure it uses the same contextvars.\n    This is required so that the function will see the right application.\n\n    See also: https://bugs.python.org/issue34014\n    ')), Assign(targets=[Name(id='loop', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='loop', ctx=Load()), Call(func=Name(id='get_running_loop', ctx=Load()), args=[], keywords=[])])), AnnAssign(target=Name(id='ctx', ctx=Store()), annotation=Attribute(value=Name(id='contextvars', ctx=Load()), attr='Context', ctx=Load()), value=Call(func=Attribute(value=Name(id='contextvars', ctx=Load()), attr='copy_context', ctx=Load()), args=[], keywords=[]), simple=1), Return(value=Call(func=Attribute(value=Name(id='loop', ctx=Load()), attr='run_in_executor', ctx=Load()), args=[Constant(value=None), Attribute(value=Name(id='ctx', ctx=Load()), attr='run', ctx=Load()), Name(id='func', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Awaitable', ctx=Load()), slice=Name(id='_T', ctx=Load()), ctx=Load())), FunctionDef(name='call_soon_threadsafe', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load())), arg(arg='max_postpone_time', annotation=BinOp(left=Name(id='float', ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='loop', annotation=BinOp(left=Attribute(value=Name(id='asyncio', ctx=Load()), attr='AbstractEventLoop', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="\n    Wrapper around asyncio's `call_soon_threadsafe`.\n\n    This takes a `max_postpone_time` which can be used to tune the urgency of\n    the method.\n\n    Asyncio runs tasks in first-in-first-out. However, this is not what we\n    want for the render function of the prompt_toolkit UI. Rendering is\n    expensive, but since the UI is invalidated very often, in some situations\n    we render the UI too often, so much that the rendering CPU usage slows down\n    the rest of the processing of the application.  (Pymux is an example where\n    we have to balance the CPU time spend on rendering the UI, and parsing\n    process output.)\n    However, we want to set a deadline value, for when the rendering should\n    happen. (The UI should stay responsive).\n    ")), Assign(targets=[Name(id='loop2', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='loop', ctx=Load()), Call(func=Name(id='get_running_loop', ctx=Load()), args=[], keywords=[])])), If(test=Compare(left=Name(id='max_postpone_time', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='loop2', ctx=Load()), attr='call_soon_threadsafe', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])), Return()], orelse=[]), Assign(targets=[Name(id='max_postpone_until', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[]), op=Add(), right=Name(id='max_postpone_time', ctx=Load()))), FunctionDef(name='schedule', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='loop2', ctx=Load()), Constant(value='_ready'), List(elts=[], ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[])), Return()], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[]), ops=[Gt()], comparators=[Name(id='max_postpone_until', ctx=Load())]), body=[Expr(value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[])), Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='loop2', ctx=Load()), attr='call_soon_threadsafe', ctx=Load()), args=[Name(id='schedule', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), Expr(value=Call(func=Attribute(value=Name(id='loop2', ctx=Load()), attr='call_soon_threadsafe', ctx=Load()), args=[Name(id='schedule', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_traceback_from_context', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Get the traceback object from the context.\n    ')), Assign(targets=[Name(id='exception', ctx=Store())], value=Call(func=Attribute(value=Name(id='context', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='exception')], keywords=[])), If(test=Name(id='exception', ctx=Load()), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='exception', ctx=Load()), Constant(value='__traceback__')], keywords=[]), body=[Return(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='TracebackType', ctx=Load()), Attribute(value=Name(id='exception', ctx=Load()), attr='__traceback__', ctx=Load())], keywords=[]))], orelse=[Return(value=Subscript(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='exc_info', ctx=Load()), args=[], keywords=[]), slice=Constant(value=2), ctx=Load()))])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=BinOp(left=Name(id='TracebackType', ctx=Load()), op=BitOr(), right=Constant(value=None)))], type_ignores=[])