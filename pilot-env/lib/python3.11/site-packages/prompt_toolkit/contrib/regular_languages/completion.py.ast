Module(body=[Expr(value=Constant(value='\nCompleter for a regular grammar.\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='prompt_toolkit.completion', names=[alias(name='CompleteEvent'), alias(name='Completer'), alias(name='Completion')], level=0), ImportFrom(module='prompt_toolkit.document', names=[alias(name='Document')], level=0), ImportFrom(module='compiler', names=[alias(name='Match'), alias(name='_CompiledGrammar')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='GrammarCompleter')], ctx=Load())), ClassDef(name='GrammarCompleter', bases=[Name(id='Completer', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Completer which can be used for autocompletion according to variables in\n    the grammar. Each variable can have a different autocompleter.\n\n    :param compiled_grammar: `GrammarCompleter` instance.\n    :param completers: `dict` mapping variable names of the grammar to the\n                       `Completer` instances to be used for each variable.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='compiled_grammar', annotation=Name(id='_CompiledGrammar', ctx=Load())), arg(arg='completers', annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Completer', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='compiled_grammar', ctx=Store())], value=Name(id='compiled_grammar', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='completers', ctx=Store())], value=Name(id='completers', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_completions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='document', annotation=Name(id='Document', ctx=Load())), arg(arg='complete_event', annotation=Name(id='CompleteEvent', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='m', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='compiled_grammar', ctx=Load()), attr='match_prefix', ctx=Load()), args=[Attribute(value=Name(id='document', ctx=Load()), attr='text_before_cursor', ctx=Load())], keywords=[])), If(test=Name(id='m', ctx=Load()), body=[Assign(targets=[Name(id='completions', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_remove_duplicates', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_completions_for_match', ctx=Load()), args=[Name(id='m', ctx=Load()), Name(id='complete_event', ctx=Load())], keywords=[])], keywords=[])), Expr(value=YieldFrom(value=Name(id='completions', ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Completion', ctx=Load()), ctx=Load())), FunctionDef(name='_get_completions_for_match', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='match', annotation=Name(id='Match', ctx=Load())), arg(arg='complete_event', annotation=Name(id='CompleteEvent', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Yield all the possible completions for this input string.\n        (The completer assumes that the cursor position was at the end of the\n        input string.)\n        ')), For(target=Name(id='match_variable', ctx=Store()), iter=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='end_nodes', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='varname', ctx=Store())], value=Attribute(value=Name(id='match_variable', ctx=Load()), attr='varname', ctx=Load())), Assign(targets=[Name(id='start', ctx=Store())], value=Attribute(value=Name(id='match_variable', ctx=Load()), attr='start', ctx=Load())), Assign(targets=[Name(id='completer', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='completers', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='varname', ctx=Load())], keywords=[])), If(test=Name(id='completer', ctx=Load()), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Attribute(value=Name(id='match_variable', ctx=Load()), attr='value', ctx=Load())), Assign(targets=[Name(id='unwrapped_text', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='compiled_grammar', ctx=Load()), attr='unescape', ctx=Load()), args=[Name(id='varname', ctx=Load()), Name(id='text', ctx=Load())], keywords=[])), Assign(targets=[Name(id='document', ctx=Store())], value=Call(func=Name(id='Document', ctx=Load()), args=[Name(id='unwrapped_text', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='unwrapped_text', ctx=Load())], keywords=[])], keywords=[])), For(target=Name(id='completion', ctx=Store()), iter=Call(func=Attribute(value=Name(id='completer', ctx=Load()), attr='get_completions', ctx=Load()), args=[Name(id='document', ctx=Load()), Name(id='complete_event', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='new_text', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='unwrapped_text', ctx=Load()), slice=Slice(upper=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), op=Add(), right=Attribute(value=Name(id='completion', ctx=Load()), attr='start_position', ctx=Load()))), ctx=Load()), op=Add(), right=Attribute(value=Name(id='completion', ctx=Load()), attr='text', ctx=Load()))), Expr(value=Yield(value=Call(func=Name(id='Completion', ctx=Load()), args=[], keywords=[keyword(arg='text', value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='compiled_grammar', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='varname', ctx=Load()), Name(id='new_text', ctx=Load())], keywords=[])), keyword(arg='start_position', value=BinOp(left=Name(id='start', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='match', ctx=Load()), attr='string', ctx=Load())], keywords=[]))), keyword(arg='display', value=Attribute(value=Name(id='completion', ctx=Load()), attr='display', ctx=Load())), keyword(arg='display_meta', value=Attribute(value=Name(id='completion', ctx=Load()), attr='display_meta', ctx=Load()))])))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Completion', ctx=Load()), ctx=Load())), FunctionDef(name='_remove_duplicates', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='items', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Completion', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Remove duplicates, while keeping the order.\n        (Sometimes we have duplicates, because the there several matches of the\n        same grammar, each yielding similar completions.)\n        ')), AnnAssign(target=Name(id='result', ctx=Store()), annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Completion', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Name(id='i', ctx=Store()), iter=Name(id='items', ctx=Load()), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Name(id='result', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='Completion', ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])