Module(body=[Expr(value=Constant(value='\nTool for expressing the grammar of an input as a regular language.\n==================================================================\n\nThe grammar for the input of many simple command line interfaces can be\nexpressed by a regular language. Examples are PDB (the Python debugger); a\nsimple (bash-like) shell with "pwd", "cd", "cat" and "ls" commands; arguments\nthat you can pass to an executable; etc. It is possible to use regular\nexpressions for validation and parsing of such a grammar. (More about regular\nlanguages: http://en.wikipedia.org/wiki/Regular_language)\n\nExample\n-------\n\nLet\'s take the pwd/cd/cat/ls example. We want to have a shell that accepts\nthese three commands. "cd" is followed by a quoted directory name and "cat" is\nfollowed by a quoted file name. (We allow quotes inside the filename when\nthey\'re escaped with a backslash.) We could define the grammar using the\nfollowing regular expression::\n\n    grammar = \\s* (\n        pwd |\n        ls |\n        (cd  \\s+ " ([^"]|\\.)+ ") |\n        (cat \\s+ " ([^"]|\\.)+ ")\n    ) \\s*\n\n\nWhat can we do with this grammar?\n---------------------------------\n\n- Syntax highlighting: We could use this for instance to give file names\n                       different colour.\n- Parse the result: .. We can extract the file names and commands by using a\n                       regular expression with named groups.\n- Input validation: .. Don\'t accept anything that does not match this grammar.\n                       When combined with a parser, we can also recursively do\n                       filename validation (and accept only existing files.)\n- Autocompletion: .... Each part of the grammar can have its own autocompleter.\n                       "cat" has to be completed using file names, while "cd"\n                       has to be completed using directory names.\n\nHow does it work?\n-----------------\n\nAs a user of this library, you have to define the grammar of the input as a\nregular expression. The parts of this grammar where autocompletion, validation\nor any other processing is required need to be marked using a regex named\ngroup. Like ``(?P<varname>...)`` for instance.\n\nWhen the input is processed for validation (for instance), the regex will\nexecute, the named group is captured, and the validator associated with this\nnamed group will test the captured string.\n\nThere is one tricky bit:\n\n    Often we operate on incomplete input (this is by definition the case for\n    autocompletion) and we have to decide for the cursor position in which\n    possible state the grammar it could be and in which way variables could be\n    matched up to that point.\n\nTo solve this problem, the compiler takes the original regular expression and\ntranslates it into a set of other regular expressions which each match certain\nprefixes of the original regular expression. We generate one prefix regular\nexpression for every named variable (with this variable being the end of that\nexpression).\n\n\nTODO: some examples of:\n    - How to create a highlighter from this grammar.\n    - How to create a validator from this grammar.\n    - How to create an autocompleter from this grammar.\n    - How to create a parser from this grammar.\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='compiler', names=[alias(name='compile')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='compile')], ctx=Load()))], type_ignores=[])