Module(body=[Import(names=[alias(name='sys')]), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='List'), alias(name='Dict')], level=0), ImportFrom(module='distutils.command.build', names=[alias(name='build', asname='_build')], level=0), ImportFrom(module='warnings', names=[alias(name='SetuptoolsDeprecationWarning')], level=2), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[ImportFrom(module='typing', names=[alias(name='Protocol')], level=0)], orelse=[If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='typing_extensions', names=[alias(name='Protocol')], level=0)], orelse=[ImportFrom(module='abc', names=[alias(name='ABC', asname='Protocol')], level=0)])]), Assign(targets=[Name(id='_ORIGINAL_SUBCOMMANDS', ctx=Store())], value=Set(elts=[Constant(value='build_py'), Constant(value='build_clib'), Constant(value='build_ext'), Constant(value='build_scripts')])), ClassDef(name='build', bases=[Name(id='_build', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='sub_commands', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='_build', ctx=Load()), attr='sub_commands', ctx=Load()), slice=Slice(), ctx=Load())), FunctionDef(name='get_sub_commands', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='subcommands', ctx=Store())], value=SetComp(elt=Subscript(value=Name(id='cmd', ctx=Load()), slice=Constant(value=0), ctx=Load()), generators=[comprehension(target=Name(id='cmd', ctx=Store()), iter=Attribute(value=Name(id='_build', ctx=Load()), attr='sub_commands', ctx=Load()), ifs=[], is_async=0)])), If(test=BinOp(left=Name(id='subcommands', ctx=Load()), op=Sub(), right=Name(id='_ORIGINAL_SUBCOMMANDS', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='SetuptoolsDeprecationWarning', ctx=Load()), attr='emit', ctx=Load()), args=[Constant(value='Direct usage of `distutils` commands'), Constant(value='\n                It seems that you are using `distutils.command.build` to add\n                new subcommands. Using `distutils` directly is considered deprecated,\n                please use `setuptools.command.build`.\n                ')], keywords=[keyword(arg='due_date', value=Tuple(elts=[Constant(value=2023), Constant(value=12), Constant(value=13)], ctx=Load())), keyword(arg='see_url', value=Constant(value='https://peps.python.org/pep-0632/'))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='sub_commands', ctx=Store())], value=Attribute(value=Name(id='_build', ctx=Load()), attr='sub_commands', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='get_sub_commands', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='SubCommand', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='In order to support editable installations (see :pep:`660`) all\n    build subcommands **SHOULD** implement this protocol. They also **MUST** inherit\n    from ``setuptools.Command``.\n\n    When creating an :pep:`editable wheel <660>`, ``setuptools`` will try to evaluate\n    custom ``build`` subcommands using the following procedure:\n\n    1. ``setuptools`` will set the ``editable_mode`` attribute to ``True``\n    2. ``setuptools`` will execute the ``run()`` command.\n\n       .. important::\n          Subcommands **SHOULD** take advantage of ``editable_mode=True`` to adequate\n          its behaviour or perform optimisations.\n\n          For example, if a subcommand doesn\'t need to generate an extra file and\n          all it does is to copy a source file into the build directory,\n          ``run()`` **SHOULD** simply "early return".\n\n          Similarly, if the subcommand creates files that would be placed alongside\n          Python files in the final distribution, during an editable install\n          the command **SHOULD** generate these files "in place" (i.e. write them to\n          the original source directory, instead of using the build directory).\n          Note that ``get_output_mapping()`` should reflect that and include mappings\n          for "in place" builds accordingly.\n\n    3. ``setuptools`` use any knowledge it can derive from the return values of\n       ``get_outputs()`` and ``get_output_mapping()`` to create an editable wheel.\n       When relevant ``setuptools`` **MAY** attempt to use file links based on the value\n       of ``get_output_mapping()``. Alternatively, ``setuptools`` **MAY** attempt to use\n       :doc:`import hooks <python:reference/import>` to redirect any attempt to import\n       to the directory with the original source code and other files built in place.\n\n    Please note that custom sub-commands **SHOULD NOT** rely on ``run()`` being\n    executed (or not) to provide correct return values for ``get_outputs()``,\n    ``get_output_mapping()`` or ``get_source_files()``. The ``get_*`` methods should\n    work independently of ``run()``.\n    ')), AnnAssign(target=Name(id='editable_mode', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=Constant(value=False), simple=1), Expr(value=Constant(value='Boolean flag that will be set to ``True`` when setuptools is used for an\n    editable installation (see :pep:`660`).\n    Implementations **SHOULD** explicitly set the default value of this attribute to\n    ``False``.\n    When subcommands run, they can use this flag to perform optimizations or change\n    their behaviour accordingly.\n    ')), AnnAssign(target=Name(id='build_lib', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), Expr(value=Constant(value='String representing the directory where the build artifacts should be stored,\n    e.g. ``build/lib``.\n    For example, if a distribution wants to provide a Python module named ``pkg.mod``,\n    then a corresponding file should be written to ``{build_lib}/package/module.py``.\n    A way of thinking about this is that the files saved under ``build_lib``\n    would be eventually copied to one of the directories in :obj:`site.PREFIXES`\n    upon installation.\n\n    A command that produces platform-independent files (e.g. compiling text templates\n    into Python functions), **CAN** initialize ``build_lib`` by copying its value from\n    the ``build_py`` command. On the other hand, a command that produces\n    platform-specific files **CAN** initialize ``build_lib`` by copying its value from\n    the ``build_ext`` command. In general this is done inside the ``finalize_options``\n    method with the help of the ``set_undefined_options`` command::\n\n        def finalize_options(self):\n            self.set_undefined_options("build_py", ("build_lib", "build_lib"))\n            ...\n    ')), FunctionDef(name='initialize_options', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='(Required by the original :class:`setuptools.Command` interface)'))], decorator_list=[]), FunctionDef(name='finalize_options', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='(Required by the original :class:`setuptools.Command` interface)'))], decorator_list=[]), FunctionDef(name='run', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='(Required by the original :class:`setuptools.Command` interface)'))], decorator_list=[]), FunctionDef(name='get_source_files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a list of all files that are used by the command to create the expected\n        outputs.\n        For example, if your build command transpiles Java files into Python, you should\n        list here all the Java files.\n        The primary purpose of this function is to help populating the ``sdist``\n        with all the files necessary to build the distribution.\n        All files should be strings relative to the project root directory.\n        '))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='get_outputs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a list of files intended for distribution as they would have been\n        produced by the build.\n        These files should be strings in the form of\n        ``"{build_lib}/destination/file/path"``.\n\n        .. note::\n           The return value of ``get_output()`` should include all files used as keys\n           in ``get_output_mapping()`` plus files that are generated during the build\n           and don\'t correspond to any source file already present in the project.\n        '))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='get_output_mapping', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a mapping between destination files as they would be produced by the\n        build (dict keys) into the respective existing (source) files (dict values).\n        Existing (source) files should be represented as strings relative to the project\n        root directory.\n        Destination files should be strings in the form of\n        ``"{build_lib}/destination/file/path"``.\n        '))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])