Module(body=[Import(names=[alias(name='abc')]), Import(names=[alias(name='collections')]), Import(names=[alias(name='collections.abc')]), Import(names=[alias(name='operator')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='typing')]), Assign(targets=[Name(id='PEP_560', ctx=Store())], value=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=3)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7), Constant(value=0)], ctx=Load())])), If(test=Name(id='PEP_560', ctx=Load()), body=[Assign(targets=[Name(id='GenericMeta', ctx=Store())], value=Name(id='type', ctx=Load()))], orelse=[ImportFrom(module='typing', names=[alias(name='GenericMeta'), alias(name='_type_vars')], level=0)]), FunctionDef(name='_no_slots_copy', args=arguments(posonlyargs=[], args=[arg(arg='dct')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='dict_copy', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Name(id='dct', ctx=Load())], keywords=[])), If(test=Compare(left=Constant(value='__slots__'), ops=[In()], comparators=[Name(id='dict_copy', ctx=Load())]), body=[For(target=Name(id='slot', ctx=Store()), iter=Subscript(value=Name(id='dict_copy', ctx=Load()), slice=Constant(value='__slots__'), ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='dict_copy', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='slot', ctx=Load()), Constant(value=None)], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='dict_copy', ctx=Load()))], decorator_list=[]), FunctionDef(name='_check_generic', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='cls', ctx=Load()), conversion=-1), Constant(value=' is not a generic class')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='alen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='elen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='alen', ctx=Load()), ops=[NotEq()], comparators=[Name(id='elen', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Too '), FormattedValue(value=IfExp(test=Compare(left=Name(id='alen', ctx=Load()), ops=[Gt()], comparators=[Name(id='elen', ctx=Load())]), body=Constant(value='many'), orelse=Constant(value='few')), conversion=-1), Constant(value=' arguments for '), FormattedValue(value=Name(id='cls', ctx=Load()), conversion=-1), Constant(value='; actual '), FormattedValue(value=Name(id='alen', ctx=Load()), conversion=-1), Constant(value=', expected '), FormattedValue(value=Name(id='elen', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='ClassVar'), Constant(value='Concatenate'), Constant(value='Final'), Constant(value='ParamSpec'), Constant(value='Self'), Constant(value='Type'), Constant(value='Awaitable'), Constant(value='AsyncIterator'), Constant(value='AsyncIterable'), Constant(value='Coroutine'), Constant(value='AsyncGenerator'), Constant(value='AsyncContextManager'), Constant(value='ChainMap'), Constant(value='ContextManager'), Constant(value='Counter'), Constant(value='Deque'), Constant(value='DefaultDict'), Constant(value='OrderedDict'), Constant(value='TypedDict'), Constant(value='SupportsIndex'), Constant(value='Annotated'), Constant(value='final'), Constant(value='IntVar'), Constant(value='Literal'), Constant(value='NewType'), Constant(value='overload'), Constant(value='Protocol'), Constant(value='runtime'), Constant(value='runtime_checkable'), Constant(value='Text'), Constant(value='TypeAlias'), Constant(value='TypeGuard'), Constant(value='TYPE_CHECKING')], ctx=Load())), If(test=Name(id='PEP_560', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='extend', ctx=Load()), args=[List(elts=[Constant(value='get_args'), Constant(value='get_origin'), Constant(value='get_type_hints')], ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='NoReturn')], keywords=[]), body=[Assign(targets=[Name(id='NoReturn', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NoReturn', ctx=Load()))], orelse=[ClassDef(name='_NoReturn', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_FinalTypingBase', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value="Special type indicating functions that never return.\n        Example::\n\n          from typing import NoReturn\n\n          def stop() -> NoReturn:\n              raise Exception('no way')\n\n        This type is invalid in other positions, e.g., ``List[NoReturn]``\n        will fail in static type checkers.\n        ")), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='NoReturn cannot be used with isinstance().')], keywords=[]))], decorator_list=[]), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='NoReturn cannot be used with issubclass().')], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='NoReturn', ctx=Store())], value=Call(func=Name(id='_NoReturn', ctx=Load()), args=[], keywords=[keyword(arg='_root', value=Constant(value=True))]))]), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='T')], keywords=[])), Assign(targets=[Name(id='KT', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='KT')], keywords=[])), Assign(targets=[Name(id='VT', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='VT')], keywords=[])), Assign(targets=[Name(id='T_co', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='T_co')], keywords=[keyword(arg='covariant', value=Constant(value=True))])), Assign(targets=[Name(id='T_contra', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='T_contra')], keywords=[keyword(arg='contravariant', value=Constant(value=True))])), Assign(targets=[Name(id='ClassVar', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load())), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Final')], keywords=[]), Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())])]), body=[Assign(targets=[Name(id='Final', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Final', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())]), body=[ClassDef(name='_FinalForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only single type')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Final', ctx=Store())], value=Call(func=Name(id='_FinalForm', ctx=Load()), args=[Constant(value='Final')], keywords=[keyword(arg='doc', value=Constant(value='A special typing construct to indicate that a name\n                       cannot be re-assigned or overridden in a subclass.\n                       For example:\n\n                           MAX_SIZE: Final = 9000\n                           MAX_SIZE += 1  # Error reported by type checker\n\n                           class Connection:\n                               TIMEOUT: Final[int] = 10\n                           class FastConnector(Connection):\n                               TIMEOUT = 1  # Error reported by type checker\n\n                       There is no runtime checking of these properties.'))]))], orelse=[ClassDef(name='_Final', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_FinalTypingBase', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value='A special typing construct to indicate that a name\n        cannot be re-assigned or overridden in a subclass.\n        For example:\n\n            MAX_SIZE: Final = 9000\n            MAX_SIZE += 1  # Error reported by type checker\n\n            class Connection:\n                TIMEOUT: Final[int] = 10\n            class FastConnector(Connection):\n                TIMEOUT = 1  # Error reported by type checker\n\n        There is no runtime checking of these properties.\n        ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='__type__')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tp')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Store())], value=Name(id='tp', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='cls', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='item', ctx=Load()), JoinedStr(values=[FormattedValue(value=Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), conversion=-1), Constant(value=' accepts only single type.')])], keywords=[])], keywords=[keyword(arg='_root', value=Constant(value=True))]))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), conversion=-1), Constant(value=' cannot be further subscripted')])], keywords=[]))], decorator_list=[]), FunctionDef(name='_eval_type', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='globalns'), arg(arg='localns')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='new_tp', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_eval_type', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), Name(id='globalns', ctx=Load()), Name(id='localns', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='new_tp', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load())]), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), Return(value=Call(func=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), args=[Name(id='new_tp', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__repr__', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='r', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load())], keywords=[]), conversion=-1), Constant(value=']')]))], orelse=[]), Return(value=Name(id='r', ctx=Load()))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='_Final', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__type__', ctx=Load())]))], orelse=[]), Return(value=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='other', ctx=Load())]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Final', ctx=Store())], value=Call(func=Name(id='_Final', ctx=Load()), args=[], keywords=[keyword(arg='_root', value=Constant(value=True))]))])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='final')], keywords=[]), body=[Assign(targets=[Name(id='final', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='final', ctx=Load()))], orelse=[FunctionDef(name='final', args=arguments(posonlyargs=[], args=[arg(arg='f')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='This decorator can be used to indicate to type checkers that\n        the decorated method cannot be overridden, and decorated class\n        cannot be subclassed. For example:\n\n            class Base:\n                @final\n                def done(self) -> None:\n                    ...\n            class Sub(Base):\n                def done(self) -> None:  # Error reported by type checker\n                    ...\n            @final\n            class Leaf:\n                ...\n            class Other(Leaf):  # Error reported by type checker\n                ...\n\n        There is no runtime checking of these properties.\n        ')), Return(value=Name(id='f', ctx=Load()))], decorator_list=[])]), FunctionDef(name='IntVar', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Literal')], keywords=[]), body=[Assign(targets=[Name(id='Literal', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Literal', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())]), body=[ClassDef(name='_LiteralForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Literal', ctx=Store())], value=Call(func=Name(id='_LiteralForm', ctx=Load()), args=[Constant(value='Literal')], keywords=[keyword(arg='doc', value=Constant(value="A type that can be used to indicate to type checkers\n                           that the corresponding value has a value literally equivalent\n                           to the provided parameter. For example:\n\n                               var: Literal[4] = 4\n\n                           The type checker understands that 'var' is literally equal to\n                           the value 4 and no other value.\n\n                           Literal[...] cannot be subclassed. There is no runtime\n                           checking verifying that the parameter is actually a value\n                           instead of a type."))]))], orelse=[ClassDef(name='_Literal', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_FinalTypingBase', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value="A type that can be used to indicate to type checkers that the\n        corresponding value has a value literally equivalent to the\n        provided parameter. For example:\n\n            var: Literal[4] = 4\n\n        The type checker understands that 'var' is literally equal to the\n        value 4 and no other value.\n\n        Literal[...] cannot be subclassed. There is no runtime checking\n        verifying that the parameter is actually a value instead of a type.\n        ")), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='__values__')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='values')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__values__', ctx=Store())], value=Name(id='values', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='values')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='cls', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__values__', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='values', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='values', ctx=Store())], value=Tuple(elts=[Name(id='values', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))]))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), conversion=-1), Constant(value=' cannot be further subscripted')])], keywords=[]))], decorator_list=[]), FunctionDef(name='_eval_type', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='globalns'), arg(arg='localns')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__repr__', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__values__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='r', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__values__', ctx=Load())], keywords=[])], keywords=[]), conversion=-1), Constant(value=']')]))], orelse=[]), Return(value=Name(id='r', ctx=Load()))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__values__', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='_Literal', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__values__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__values__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__values__', ctx=Load())]))], orelse=[]), Return(value=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='other', ctx=Load())]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Literal', ctx=Store())], value=Call(func=Name(id='_Literal', ctx=Load()), args=[], keywords=[keyword(arg='_root', value=Constant(value=True))]))])]), Assign(targets=[Name(id='_overload_dummy', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_overload_dummy', ctx=Load())), Assign(targets=[Name(id='overload', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())), Assign(targets=[Name(id='Type', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Type', ctx=Load())), ClassDef(name='_ExtensionsGenericMeta', bases=[Name(id='GenericMeta', ctx=Load())], keywords=[], body=[FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='subclass')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='This mimics a more modern GenericMeta.__subclasscheck__() logic\n        (that does not have problems with recursion) to work around interactions\n        between collections, typing, and typing_extensions on older\n        versions of Python, see https://github.com/python/typing/issues/501.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), slice=Constant(value='__name__'), ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='abc'), Constant(value='functools')], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Parameterized generics cannot be used with class or instance checks')], keywords=[]))], orelse=[]), Return(value=Constant(value=False))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='__extra__', ctx=Load())), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__subclasscheck__', ctx=Load()), args=[Name(id='subclass', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__extra__', ctx=Load()), attr='__subclasshook__', ctx=Load()), args=[Name(id='subclass', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='res', ctx=Load()), ops=[IsNot()], comparators=[Name(id='NotImplemented', ctx=Load())]), body=[Return(value=Name(id='res', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__extra__', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='subclass', ctx=Load()), attr='__mro__', ctx=Load())]), body=[Return(value=Constant(value=True))], orelse=[]), For(target=Name(id='scls', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__extra__', ctx=Load()), attr='__subclasses__', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='scls', ctx=Load()), Name(id='GenericMeta', ctx=Load())], keywords=[]), body=[Continue()], orelse=[]), If(test=Call(func=Name(id='issubclass', ctx=Load()), args=[Name(id='subclass', ctx=Load()), Name(id='scls', ctx=Load())], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Constant(value=False))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Awaitable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Awaitable', ctx=Load())), Assign(targets=[Name(id='Coroutine', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Coroutine', ctx=Load())), Assign(targets=[Name(id='AsyncIterable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncIterable', ctx=Load())), Assign(targets=[Name(id='AsyncIterator', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncIterator', ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Deque')], keywords=[]), body=[Assign(targets=[Name(id='Deque', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Deque', ctx=Load()))], orelse=[ClassDef(name='Deque', bases=[Attribute(value=Name(id='collections', ctx=Load()), attr='deque', ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='MutableSequence', ctx=Load()), slice=Name(id='T', ctx=Load()), ctx=Load())], keywords=[keyword(arg='metaclass', value=Name(id='_ExtensionsGenericMeta', ctx=Load())), keyword(arg='extra', value=Attribute(value=Name(id='collections', ctx=Load()), attr='deque', ctx=Load()))], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='cls', ctx=Load()), attr='_gorg', ctx=Load()), ops=[Is()], comparators=[Name(id='Deque', ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='deque', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwds', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_generic_new', ctx=Load()), args=[Attribute(value=Name(id='collections', ctx=Load()), attr='deque', ctx=Load()), Name(id='cls', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwds', ctx=Load()))]))], decorator_list=[])], decorator_list=[])]), Assign(targets=[Name(id='ContextManager', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ContextManager', ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='AsyncContextManager')], keywords=[]), body=[Assign(targets=[Name(id='AsyncContextManager', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncContextManager', ctx=Load()))], orelse=[ImportFrom(module='_collections_abc', names=[alias(name='_check_methods', asname='_check_methods_in_mro')], level=0), ClassDef(name='AsyncContextManager', bases=[Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), slice=Name(id='T_co', ctx=Load()), ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), AsyncFunctionDef(name='__aenter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), AsyncFunctionDef(name='__aexit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exc_type'), arg(arg='exc_value'), arg(arg='traceback')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=None))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())]), FunctionDef(name='__subclasshook__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='C')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='AsyncContextManager', ctx=Load())]), body=[Return(value=Call(func=Name(id='_check_methods_in_mro', ctx=Load()), args=[Name(id='C', ctx=Load()), Constant(value='__aenter__'), Constant(value='__aexit__')], keywords=[]))], orelse=[]), Return(value=Name(id='NotImplemented', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())])], decorator_list=[])]), Assign(targets=[Name(id='DefaultDict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='DefaultDict', ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='OrderedDict')], keywords=[]), body=[Assign(targets=[Name(id='OrderedDict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='OrderedDict', ctx=Load()))], orelse=[If(test=Compare(left=Tuple(elts=[Constant(value=3), Constant(value=7), Constant(value=0)], ctx=Load()), ops=[LtE(), Lt()], comparators=[Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=3)), ctx=Load()), Tuple(elts=[Constant(value=3), Constant(value=7), Constant(value=2)], ctx=Load())]), body=[Assign(targets=[Name(id='OrderedDict', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_alias', ctx=Load()), args=[Attribute(value=Name(id='collections', ctx=Load()), attr='OrderedDict', ctx=Load()), Tuple(elts=[Name(id='KT', ctx=Load()), Name(id='VT', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[ClassDef(name='OrderedDict', bases=[Attribute(value=Name(id='collections', ctx=Load()), attr='OrderedDict', ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='KT', ctx=Load()), Name(id='VT', ctx=Load())], ctx=Load()), ctx=Load())], keywords=[keyword(arg='metaclass', value=Name(id='_ExtensionsGenericMeta', ctx=Load())), keyword(arg='extra', value=Attribute(value=Name(id='collections', ctx=Load()), attr='OrderedDict', ctx=Load()))], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='cls', ctx=Load()), attr='_gorg', ctx=Load()), ops=[Is()], comparators=[Name(id='OrderedDict', ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='OrderedDict', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwds', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_generic_new', ctx=Load()), args=[Attribute(value=Name(id='collections', ctx=Load()), attr='OrderedDict', ctx=Load()), Name(id='cls', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwds', ctx=Load()))]))], decorator_list=[])], decorator_list=[])])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Counter')], keywords=[]), body=[Assign(targets=[Name(id='Counter', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Counter', ctx=Load()))], orelse=[ClassDef(name='Counter', bases=[Attribute(value=Name(id='collections', ctx=Load()), attr='Counter', ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='T', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())], keywords=[keyword(arg='metaclass', value=Name(id='_ExtensionsGenericMeta', ctx=Load())), keyword(arg='extra', value=Attribute(value=Name(id='collections', ctx=Load()), attr='Counter', ctx=Load()))], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='cls', ctx=Load()), attr='_gorg', ctx=Load()), ops=[Is()], comparators=[Name(id='Counter', ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='Counter', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwds', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_generic_new', ctx=Load()), args=[Attribute(value=Name(id='collections', ctx=Load()), attr='Counter', ctx=Load()), Name(id='cls', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwds', ctx=Load()))]))], decorator_list=[])], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='ChainMap')], keywords=[]), body=[Assign(targets=[Name(id='ChainMap', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ChainMap', ctx=Load()))], orelse=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='collections', ctx=Load()), Constant(value='ChainMap')], keywords=[]), body=[ClassDef(name='ChainMap', bases=[Attribute(value=Name(id='collections', ctx=Load()), attr='ChainMap', ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='KT', ctx=Load()), Name(id='VT', ctx=Load())], ctx=Load()), ctx=Load())], keywords=[keyword(arg='metaclass', value=Name(id='_ExtensionsGenericMeta', ctx=Load())), keyword(arg='extra', value=Attribute(value=Name(id='collections', ctx=Load()), attr='ChainMap', ctx=Load()))], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='cls', ctx=Load()), attr='_gorg', ctx=Load()), ops=[Is()], comparators=[Name(id='ChainMap', ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='ChainMap', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwds', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_generic_new', ctx=Load()), args=[Attribute(value=Name(id='collections', ctx=Load()), attr='ChainMap', ctx=Load()), Name(id='cls', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwds', ctx=Load()))]))], decorator_list=[])], decorator_list=[])], orelse=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='AsyncGenerator')], keywords=[]), body=[Assign(targets=[Name(id='AsyncGenerator', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncGenerator', ctx=Load()))], orelse=[ClassDef(name='AsyncGenerator', bases=[Subscript(value=Name(id='AsyncIterator', ctx=Load()), slice=Name(id='T_co', ctx=Load()), ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), slice=Tuple(elts=[Name(id='T_co', ctx=Load()), Name(id='T_contra', ctx=Load())], ctx=Load()), ctx=Load())], keywords=[keyword(arg='metaclass', value=Name(id='_ExtensionsGenericMeta', ctx=Load())), keyword(arg='extra', value=Attribute(value=Attribute(value=Name(id='collections', ctx=Load()), attr='abc', ctx=Load()), attr='AsyncGenerator', ctx=Load()))], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load()))], decorator_list=[])]), Assign(targets=[Name(id='NewType', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NewType', ctx=Load())), Assign(targets=[Name(id='Text', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Text', ctx=Load())), Assign(targets=[Name(id='TYPE_CHECKING', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TYPE_CHECKING', ctx=Load())), FunctionDef(name='_gorg', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='This function exists for compatibility with old typing versions.')), Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='GenericMeta', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_gorg')], keywords=[]), body=[Return(value=Attribute(value=Name(id='cls', ctx=Load()), attr='_gorg', ctx=Load()))], orelse=[]), While(test=Compare(left=Attribute(value=Name(id='cls', ctx=Load()), attr='__origin__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='cls', ctx=Store())], value=Attribute(value=Name(id='cls', ctx=Load()), attr='__origin__', ctx=Load()))], orelse=[]), Return(value=Name(id='cls', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_PROTO_WHITELIST', ctx=Store())], value=List(elts=[Constant(value='Callable'), Constant(value='Awaitable'), Constant(value='Iterable'), Constant(value='Iterator'), Constant(value='AsyncIterable'), Constant(value='AsyncIterator'), Constant(value='Hashable'), Constant(value='Sized'), Constant(value='Container'), Constant(value='Collection'), Constant(value='Reversible'), Constant(value='ContextManager'), Constant(value='AsyncContextManager')], ctx=Load())), FunctionDef(name='_get_protocol_attrs', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='base', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__mro__', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__name__', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='Protocol'), Constant(value='Generic')], ctx=Load())]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='annotations', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='base', ctx=Load()), Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), For(target=Name(id='attr', ctx=Store()), iter=BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Add(), right=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='annotations', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), body=[If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='attr', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_abc_')], keywords=[])), Compare(left=Name(id='attr', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value='__abstractmethods__'), Constant(value='__annotations__'), Constant(value='__weakref__'), Constant(value='_is_protocol'), Constant(value='_is_runtime_protocol'), Constant(value='__dict__'), Constant(value='__args__'), Constant(value='__slots__'), Constant(value='__next_in_mro__'), Constant(value='__parameters__'), Constant(value='__origin__'), Constant(value='__orig_bases__'), Constant(value='__extra__'), Constant(value='__tree_hash__'), Constant(value='__doc__'), Constant(value='__subclasshook__'), Constant(value='__init__'), Constant(value='__new__'), Constant(value='__module__'), Constant(value='_MutableMapping__marker'), Constant(value='_gorg')], ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='attrs', ctx=Load()))], decorator_list=[]), FunctionDef(name='_is_callable_members_only', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='callable', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='attr', ctx=Load()), Constant(value=None)], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='attr', ctx=Store()), iter=Call(func=Name(id='_get_protocol_attrs', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Protocol')], keywords=[]), body=[Assign(targets=[Name(id='Protocol', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Protocol', ctx=Load()))], orelse=[If(test=Name(id='PEP_560', ctx=Load()), body=[ImportFrom(module='typing', names=[alias(name='_collect_type_vars')], level=0), FunctionDef(name='_no_init', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='_is_protocol', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Protocols cannot be instantiated')], keywords=[]))], orelse=[])], decorator_list=[]), ClassDef(name='_ProtocolMeta', bases=[Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load())], keywords=[], body=[FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='instance')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_is_protocol'), Constant(value=False)], keywords=[])), Call(func=Name(id='_is_callable_members_only', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[])]), Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Name(id='instance', ctx=Load()), attr='__class__', ctx=Load()), Name(id='cls', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=True))], orelse=[]), If(test=Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Load()), body=[If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='instance', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='attr', ctx=Load()), Constant(value=None)], keywords=[])], keywords=[])), Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='instance', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)])])]), generators=[comprehension(target=Name(id='attr', ctx=Store()), iter=Call(func=Name(id='_get_protocol_attrs', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__instancecheck__', ctx=Load()), args=[Name(id='instance', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Protocol', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='_ProtocolMeta', ctx=Load()))], body=[Expr(value=Constant(value='Base class for protocol classes. Protocol classes are defined as::\n\n            class Proto(Protocol):\n                def meth(self) -> int:\n                    ...\n\n        Such classes are primarily used with static type checkers that recognize\n        structural subtyping (static duck-typing), for example::\n\n            class C:\n                def meth(self) -> int:\n                    return 0\n\n            def func(x: Proto) -> int:\n                return x.meth()\n\n            func(C())  # Passes static type check\n\n        See PEP 544 for details. Protocol classes decorated with\n        @typing_extensions.runtime act as simple-minded runtime protocol that checks\n        only the presence of given attributes, ignoring their type signatures.\n\n        Protocol classes can be generic, they are defined as::\n\n            class GenProto(Protocol[T]):\n                def meth(self) -> T:\n                    ...\n        ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), Assign(targets=[Name(id='_is_protocol', ctx=Store())], value=Constant(value=True)), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Type Protocol cannot be instantiated; it can only be used as a base class')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__class_getitem__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='params', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='params', ctx=Store())], value=Tuple(elts=[Name(id='params', ctx=Load())], ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='params', ctx=Load())), Compare(left=Name(id='cls', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Tuple', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Parameter list to '), FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__qualname__', ctx=Load()), conversion=-1), Constant(value='[...] cannot be empty')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Parameters to generic types must be types.')), Assign(targets=[Name(id='params', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='params', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='p', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='params', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Assign(targets=[Name(id='i', ctx=Store())], value=Constant(value=0)), While(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Parameters to Protocol[...] must all be type variables. Parameter '), FormattedValue(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), conversion=-1), Constant(value=' is '), FormattedValue(value=Subscript(value=Name(id='params', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[])], keywords=[]), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Parameters to Protocol[...] must all be unique')], keywords=[]))], orelse=[])], orelse=[Expr(value=Call(func=Name(id='_check_generic', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='params', ctx=Load())], keywords=[]))]), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='params', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Assign(targets=[Name(id='tvars', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Constant(value='__orig_bases__'), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Name(id='error', ctx=Store())], value=Compare(left=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__orig_bases__', ctx=Load())]))], orelse=[Assign(targets=[Name(id='error', ctx=Store())], value=Compare(left=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load())]))]), If(test=Name(id='error', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot inherit from plain Generic')], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='__orig_bases__'), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Name(id='tvars', ctx=Store())], value=Call(func=Name(id='_collect_type_vars', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='__orig_bases__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='gvars', ctx=Store())], value=Constant(value=None)), For(target=Name(id='base', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__orig_bases__', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='base', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__origin__', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), Name(id='Protocol', ctx=Load())], ctx=Load())])]), body=[Assign(targets=[Name(id='the_base', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__origin__', ctx=Load()), attr='__name__', ctx=Load())), If(test=Compare(left=Name(id='gvars', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot inherit from Generic[...] and/or Protocol[...] multiple types.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='gvars', ctx=Store())], value=Attribute(value=Name(id='base', ctx=Load()), attr='__parameters__', ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='gvars', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='gvars', ctx=Store())], value=Name(id='tvars', ctx=Load()))], orelse=[Assign(targets=[Name(id='tvarset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='tvars', ctx=Load())], keywords=[])), Assign(targets=[Name(id='gvarset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='gvars', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='tvarset', ctx=Load()), ops=[LtE()], comparators=[Name(id='gvarset', ctx=Load())])), body=[Assign(targets=[Name(id='s_vars', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Name(id='tvars', ctx=Load()), ifs=[Compare(left=Name(id='t', ctx=Load()), ops=[NotIn()], comparators=[Name(id='gvarset', ctx=Load())])], is_async=0)])], keywords=[])), Assign(targets=[Name(id='s_args', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='g', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='g', ctx=Store()), iter=Name(id='gvars', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Some type variables ('), FormattedValue(value=Name(id='s_vars', ctx=Load()), conversion=-1), Constant(value=') are not listed in '), FormattedValue(value=Name(id='the_base', ctx=Load()), conversion=-1), Constant(value='['), FormattedValue(value=Name(id='s_args', ctx=Load()), conversion=-1), Constant(value=']')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='tvars', ctx=Store())], value=Name(id='gvars', ctx=Load()))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='tvars', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_protocol'), Constant(value=None)], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='b', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), FunctionDef(name='_proto_hook', args=arguments(posonlyargs=[], args=[arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_protocol'), Constant(value=None)], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_is_runtime_protocol'), Constant(value=False)], keywords=[])), body=[If(test=Compare(left=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=2)], keywords=[]), attr='f_globals', ctx=Load()), slice=Constant(value='__name__'), ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='abc'), Constant(value='functools')], ctx=Load())]), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Instance and class checks can only be used with @runtime protocols')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='_is_callable_members_only', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[])), body=[If(test=Compare(left=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=2)], keywords=[]), attr='f_globals', ctx=Load()), slice=Constant(value='__name__'), ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='abc'), Constant(value='functools')], ctx=Load())]), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="Protocols with non-method members don't support issubclass()")], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='type', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='issubclass() arg 1 must be a class')], keywords=[]))], orelse=[]), For(target=Name(id='attr', ctx=Store()), iter=Call(func=Name(id='_get_protocol_attrs', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), body=[For(target=Name(id='base', ctx=Store()), iter=Attribute(value=Name(id='other', ctx=Load()), attr='__mro__', ctx=Load()), body=[If(test=Compare(left=Name(id='attr', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load())]), body=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), slice=Name(id='attr', ctx=Load()), ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Break()], orelse=[]), Assign(targets=[Name(id='annotations', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='base', ctx=Load()), Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='annotations', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Mapping', ctx=Load())], keywords=[]), Compare(left=Name(id='attr', ctx=Load()), ops=[In()], comparators=[Name(id='annotations', ctx=Load())]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='_ProtocolMeta', ctx=Load())], keywords=[]), Attribute(value=Name(id='other', ctx=Load()), attr='_is_protocol', ctx=Load())]), body=[Break()], orelse=[])], orelse=[Return(value=Name(id='NotImplemented', ctx=Load()))])], orelse=[]), Return(value=Constant(value=True))], decorator_list=[]), If(test=Compare(left=Constant(value='__subclasshook__'), ops=[NotIn()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__subclasshook__', ctx=Store())], value=Name(id='_proto_hook', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Load())), body=[Return()], orelse=[]), For(target=Name(id='base', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Compare(left=Name(id='base', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Name(id='object', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())], ctx=Load())]), BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__module__', ctx=Load()), ops=[Eq()], comparators=[Constant(value='collections.abc')]), Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__name__', ctx=Load()), ops=[In()], comparators=[Name(id='_PROTO_WHITELIST', ctx=Load())])]), BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='base', ctx=Load()), Name(id='_ProtocolMeta', ctx=Load())], keywords=[]), Attribute(value=Name(id='base', ctx=Load()), attr='_is_protocol', ctx=Load())])])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Protocols can only inherit from other protocols, got '), FormattedValue(value=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__init__', ctx=Store())], value=Name(id='_no_init', ctx=Load()))], decorator_list=[])], decorator_list=[])], orelse=[ImportFrom(module='typing', names=[alias(name='_next_in_mro'), alias(name='_type_check')], level=0), FunctionDef(name='_no_init', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='_is_protocol', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Protocols cannot be instantiated')], keywords=[]))], orelse=[])], decorator_list=[]), ClassDef(name='_ProtocolMeta', bases=[Name(id='GenericMeta', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Internal metaclass for Protocol.\n\n        This exists so Protocol classes can be generic without deriving\n        from Generic.\n        ')), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name'), arg(arg='bases'), arg(arg='namespace'), arg(arg='tvars'), arg(arg='args'), arg(arg='origin'), arg(arg='extra'), arg(arg='orig_bases')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Assert(test=Compare(left=Name(id='extra', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])), If(test=Compare(left=Name(id='tvars', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assert(test=Compare(left=Name(id='origin', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assert(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Name(id='tvars', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), msg=Name(id='tvars', ctx=Load()))], orelse=[Assign(targets=[Name(id='tvars', ctx=Store())], value=Call(func=Name(id='_type_vars', ctx=Load()), args=[Name(id='bases', ctx=Load())], keywords=[])), Assign(targets=[Name(id='gvars', ctx=Store())], value=Constant(value=None)), For(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), body=[If(test=Compare(left=Name(id='base', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot inherit from plain Generic')], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='base', ctx=Load()), Name(id='GenericMeta', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__origin__', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), Name(id='Protocol', ctx=Load())], ctx=Load())])]), body=[If(test=Compare(left=Name(id='gvars', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot inherit from Generic[...] or Protocol[...] multiple times.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='gvars', ctx=Store())], value=Attribute(value=Name(id='base', ctx=Load()), attr='__parameters__', ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='gvars', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='gvars', ctx=Store())], value=Name(id='tvars', ctx=Load()))], orelse=[Assign(targets=[Name(id='tvarset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='tvars', ctx=Load())], keywords=[])), Assign(targets=[Name(id='gvarset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='gvars', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='tvarset', ctx=Load()), ops=[LtE()], comparators=[Name(id='gvarset', ctx=Load())])), body=[Assign(targets=[Name(id='s_vars', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Name(id='tvars', ctx=Load()), ifs=[Compare(left=Name(id='t', ctx=Load()), ops=[NotIn()], comparators=[Name(id='gvarset', ctx=Load())])], is_async=0)])], keywords=[])), Assign(targets=[Name(id='s_args', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='g', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='g', ctx=Store()), iter=Name(id='gvars', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='cls_name', ctx=Store())], value=IfExp(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Attribute(value=Name(id='b', ctx=Load()), attr='__origin__', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())]), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Name(id='bases', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=Constant(value='Generic'), orelse=Constant(value='Protocol'))), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Some type variables ('), FormattedValue(value=Name(id='s_vars', ctx=Load()), conversion=-1), Constant(value=') are not listed in '), FormattedValue(value=Name(id='cls_name', ctx=Load()), conversion=-1), Constant(value='['), FormattedValue(value=Name(id='s_args', ctx=Load()), conversion=-1), Constant(value=']')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='tvars', ctx=Store())], value=Name(id='gvars', ctx=Load()))])]), Assign(targets=[Name(id='initial_bases', ctx=Store())], value=Name(id='bases', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='extra', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Call(func=Name(id='type', ctx=Load()), args=[Name(id='extra', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load())]), Compare(left=Name(id='extra', ctx=Load()), ops=[NotIn()], comparators=[Name(id='bases', ctx=Load())])]), body=[Assign(targets=[Name(id='bases', ctx=Store())], value=BinOp(left=Tuple(elts=[Name(id='extra', ctx=Load())], ctx=Load()), op=Add(), right=Name(id='bases', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='bases', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='b', ctx=Load()), Name(id='GenericMeta', ctx=Load())], keywords=[]), body=Call(func=Name(id='_gorg', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), orelse=Name(id='b', ctx=Load())), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Name(id='bases', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='b', ctx=Load()), Name(id='GenericMeta', ctx=Load())], keywords=[]), Compare(left=Name(id='b', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())])]), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Name(id='bases', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='bases', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Name(id='b', ctx=Load()), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Name(id='bases', ctx=Load()), ifs=[Compare(left=Name(id='b', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())])], is_async=0)])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='namespace', ctx=Load()), attr='update', ctx=Load()), args=[Dict(keys=[Constant(value='__origin__'), Constant(value='__extra__')], values=[Name(id='origin', ctx=Load()), Name(id='extra', ctx=Load())])], keywords=[])), Assign(targets=[Name(id='self', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='GenericMeta', ctx=Load()), Name(id='cls', ctx=Load())], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='name', ctx=Load()), Name(id='bases', ctx=Load()), Name(id='namespace', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='GenericMeta', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__setattr__', ctx=Load()), args=[Constant(value='_gorg'), IfExp(test=UnaryOp(op=Not(), operand=Name(id='origin', ctx=Load())), body=Name(id='self', ctx=Load()), orelse=Call(func=Name(id='_gorg', ctx=Load()), args=[Name(id='origin', ctx=Load())], keywords=[]))], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__parameters__', ctx=Store())], value=Name(id='tvars', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Store())], value=IfExp(test=Name(id='args', ctx=Load()), body=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=IfExp(test=Compare(left=Name(id='a', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='_TypingEllipsis', ctx=Load())]), body=Constant(value=Ellipsis), orelse=IfExp(test=Compare(left=Name(id='a', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='_TypingEmpty', ctx=Load())]), body=Tuple(elts=[], ctx=Load()), orelse=Name(id='a', ctx=Load()))), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Name(id='args', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), orelse=Constant(value=None))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__next_in_mro__', ctx=Store())], value=Call(func=Name(id='_next_in_mro', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='orig_bases', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__orig_bases__', ctx=Store())], value=Name(id='initial_bases', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='origin', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_abc_registry', ctx=Store())], value=Attribute(value=Name(id='origin', ctx=Load()), attr='_abc_registry', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_abc_cache', ctx=Store())], value=Attribute(value=Name(id='origin', ctx=Load()), attr='_abc_cache', ctx=Load()))], orelse=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='_subs_tree')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__tree_hash__', ctx=Store())], value=IfExp(test=Name(id='origin', ctx=Load()), body=Call(func=Name(id='hash', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_subs_tree', ctx=Load()), args=[], keywords=[])], keywords=[]), orelse=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='GenericMeta', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__hash__', ctx=Load()), args=[], keywords=[])))], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_protocol'), Constant(value=None)], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=Or(), values=[Compare(left=Name(id='b', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='b', ctx=Load()), Name(id='_ProtocolMeta', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='b', ctx=Load()), attr='__origin__', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())])])]), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), If(test=Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Load()), body=[For(target=Name(id='base', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__mro__', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Compare(left=Name(id='base', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Name(id='object', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())], ctx=Load())]), BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__module__', ctx=Load()), ops=[Eq()], comparators=[Constant(value='collections.abc')]), Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__name__', ctx=Load()), ops=[In()], comparators=[Name(id='_PROTO_WHITELIST', ctx=Load())])]), BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='base', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='TypingMeta', ctx=Load())], keywords=[]), Attribute(value=Name(id='base', ctx=Load()), attr='_is_protocol', ctx=Load())]), BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='base', ctx=Load()), Name(id='GenericMeta', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__origin__', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())])])])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Protocols can only inherit from other protocols, got '), FormattedValue(value=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__init__', ctx=Store())], value=Name(id='_no_init', ctx=Load()))], orelse=[]), FunctionDef(name='_proto_hook', args=arguments(posonlyargs=[], args=[arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_protocol'), Constant(value=None)], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='type', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='issubclass() arg 1 must be a class')], keywords=[]))], orelse=[]), For(target=Name(id='attr', ctx=Store()), iter=Call(func=Name(id='_get_protocol_attrs', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), body=[For(target=Name(id='base', ctx=Store()), iter=Attribute(value=Name(id='other', ctx=Load()), attr='__mro__', ctx=Load()), body=[If(test=Compare(left=Name(id='attr', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load())]), body=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), slice=Name(id='attr', ctx=Load()), ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Break()], orelse=[]), Assign(targets=[Name(id='annotations', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='base', ctx=Load()), Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='annotations', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Mapping', ctx=Load())], keywords=[]), Compare(left=Name(id='attr', ctx=Load()), ops=[In()], comparators=[Name(id='annotations', ctx=Load())]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='_ProtocolMeta', ctx=Load())], keywords=[]), Attribute(value=Name(id='other', ctx=Load()), attr='_is_protocol', ctx=Load())]), body=[Break()], orelse=[])], orelse=[Return(value=Name(id='NotImplemented', ctx=Load()))])], orelse=[]), Return(value=Constant(value=True))], decorator_list=[]), If(test=Compare(left=Constant(value='__subclasshook__'), ops=[NotIn()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__subclasshook__', ctx=Store())], value=Name(id='_proto_hook', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instance')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='_is_protocol'), Constant(value=False)], keywords=[])), Call(func=Name(id='_is_callable_members_only', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])]), Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Name(id='instance', ctx=Load()), attr='__class__', ctx=Load()), Name(id='self', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=True))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_is_protocol', ctx=Load()), body=[If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='instance', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='attr', ctx=Load()), Constant(value=None)], keywords=[])], keywords=[])), Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='instance', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)])])]), generators=[comprehension(target=Name(id='attr', ctx=Store()), iter=Call(func=Name(id='_get_protocol_attrs', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='GenericMeta', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__instancecheck__', ctx=Load()), args=[Name(id='instance', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), slice=Constant(value='__name__'), ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='abc'), Constant(value='functools')], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Parameterized generics cannot be used with class or instance checks')], keywords=[]))], orelse=[]), Return(value=Constant(value=False))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_protocol'), Constant(value=None)], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_runtime_protocol'), Constant(value=None)], keywords=[]))]), body=[If(test=Compare(left=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), slice=Constant(value='__name__'), ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='abc'), Constant(value='functools'), Constant(value='typing')], ctx=Load())]), body=[Return(value=Constant(value=False))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Instance and class checks can only be used with @runtime protocols')], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_runtime_protocol'), Constant(value=None)], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='_is_callable_members_only', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))]), body=[If(test=Compare(left=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), slice=Constant(value='__name__'), ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='abc'), Constant(value='functools'), Constant(value='typing')], ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='GenericMeta', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__subclasscheck__', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="Protocols with non-method members don't support issubclass()")], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='GenericMeta', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__subclasscheck__', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='params', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='params', ctx=Store())], value=Tuple(elts=[Name(id='params', ctx=Load())], ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='params', ctx=Load())), Compare(left=Call(func=Name(id='_gorg', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Tuple', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Parameter list to '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='__qualname__', ctx=Load()), conversion=-1), Constant(value='[...] cannot be empty')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Parameters to generic types must be types.')), Assign(targets=[Name(id='params', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_type_check', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='params', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='self', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), Name(id='Protocol', ctx=Load())], ctx=Load())]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='p', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='params', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Parameters to '), FormattedValue(value=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), conversion=-1), Constant(value='[...] must all be type variables')])], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[])], keywords=[]), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Parameters to '), FormattedValue(value=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), conversion=-1), Constant(value='[...] must all be unique')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='tvars', ctx=Store())], value=Name(id='params', ctx=Load())), Assign(targets=[Name(id='args', ctx=Store())], value=Name(id='params', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='self', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='Tuple', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Callable', ctx=Load())], ctx=Load())]), body=[Assign(targets=[Name(id='tvars', ctx=Store())], value=Call(func=Name(id='_type_vars', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[])), Assign(targets=[Name(id='args', ctx=Store())], value=Name(id='params', ctx=Load()))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), Name(id='Protocol', ctx=Load())], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot subscript already-subscripted '), FormattedValue(value=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='_check_generic', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='params', ctx=Load())], keywords=[])), Assign(targets=[Name(id='tvars', ctx=Store())], value=Call(func=Name(id='_type_vars', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[])), Assign(targets=[Name(id='args', ctx=Store())], value=Name(id='params', ctx=Load()))])])]), Assign(targets=[Name(id='prepend', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Tuple(elts=[Name(id='self', ctx=Load())], ctx=Load()), orelse=Tuple(elts=[], ctx=Load()))), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()), BinOp(left=Name(id='prepend', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='__bases__', ctx=Load())), Call(func=Name(id='_no_slots_copy', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load())], keywords=[])], keywords=[keyword(arg='tvars', value=Name(id='tvars', ctx=Load())), keyword(arg='args', value=Name(id='args', ctx=Load())), keyword(arg='origin', value=Name(id='self', ctx=Load())), keyword(arg='extra', value=Attribute(value=Name(id='self', ctx=Load()), attr='__extra__', ctx=Load())), keyword(arg='orig_bases', value=Attribute(value=Name(id='self', ctx=Load()), attr='__orig_bases__', ctx=Load()))]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())])], decorator_list=[]), ClassDef(name='Protocol', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='_ProtocolMeta', ctx=Load()))], body=[Expr(value=Constant(value='Base class for protocol classes. Protocol classes are defined as::\n\n          class Proto(Protocol):\n              def meth(self) -> int:\n                  ...\n\n        Such classes are primarily used with static type checkers that recognize\n        structural subtyping (static duck-typing), for example::\n\n          class C:\n              def meth(self) -> int:\n                  return 0\n\n          def func(x: Proto) -> int:\n              return x.meth()\n\n          func(C())  # Passes static type check\n\n        See PEP 544 for details. Protocol classes decorated with\n        @typing_extensions.runtime act as simple-minded runtime protocol that checks\n        only the presence of given attributes, ignoring their type signatures.\n\n        Protocol classes can be generic, they are defined as::\n\n          class GenProto(Protocol[T]):\n              def meth(self) -> T:\n                  ...\n        ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), Assign(targets=[Name(id='_is_protocol', ctx=Store())], value=Constant(value=True)), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[If(test=Compare(left=Call(func=Name(id='_gorg', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Type Protocol cannot be instantiated; it can be used only as a base class')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_generic_new', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='__next_in_mro__', ctx=Load()), Name(id='cls', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwds', ctx=Load()))]))], decorator_list=[])], decorator_list=[])])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='runtime_checkable')], keywords=[]), body=[Assign(targets=[Name(id='runtime_checkable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='runtime_checkable', ctx=Load()))], orelse=[FunctionDef(name='runtime_checkable', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Mark a protocol class as a runtime protocol, so that it\n        can be used with isinstance() and issubclass(). Raise TypeError\n        if applied to a non-protocol class.\n\n        This allows a simple-minded structural check very similar to the\n        one-offs in collections.abc such as Hashable.\n        ')), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='_ProtocolMeta', ctx=Load())], keywords=[])), UnaryOp(op=Not(), operand=Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='@runtime_checkable can be only applied to protocol classes, got '), FormattedValue(value=Name(id='cls', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='_is_runtime_protocol', ctx=Store())], value=Constant(value=True)), Return(value=Name(id='cls', ctx=Load()))], decorator_list=[])]), Assign(targets=[Name(id='runtime', ctx=Store())], value=Name(id='runtime_checkable', ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='SupportsIndex')], keywords=[]), body=[Assign(targets=[Name(id='SupportsIndex', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='SupportsIndex', ctx=Load()))], orelse=[ClassDef(name='SupportsIndex', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__index__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())])]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9), Constant(value=2)], ctx=Load())]), body=[Assign(targets=[Name(id='TypedDict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypedDict', ctx=Load()))], orelse=[FunctionDef(name='_check_fails', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[If(test=Compare(left=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), slice=Constant(value='__name__'), ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='abc'), Constant(value='functools'), Constant(value='typing')], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypedDict does not support instance and class checks')], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='_dict_new', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='args', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypedDict.__new__(): not enough arguments')], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='args', ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], ctx=Load())), Return(value=Call(func=Name(id='dict', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='_dict_new', ctx=Load()), attr='__text_signature__', ctx=Store())], value=Constant(value='($cls, _typename, _fields=None, /, **kwargs)')), FunctionDef(name='_typeddict_new', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[arg(arg='total')], kw_defaults=[Constant(value=True)], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='args', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypedDict.__new__(): not enough arguments')], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='args', ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], ctx=Load())), If(test=Name(id='args', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='typename', ctx=Store()), Name(id='args', ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], ctx=Load()))], orelse=[If(test=Compare(left=Constant(value='_typename'), ops=[In()], comparators=[Name(id='kwargs', ctx=Load())]), body=[Assign(targets=[Name(id='typename', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='_typename')], keywords=[])), Import(names=[alias(name='warnings')]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value="Passing '_typename' as keyword argument is deprecated"), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="TypedDict.__new__() missing 1 required positional argument: '_typename'")], keywords=[]))])]), If(test=Name(id='args', ctx=Load()), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='fields', ctx=Store())], ctx=Store())], value=Name(id='args', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='TypedDict.__new__() takes from 2 to 3 positional arguments but '), FormattedValue(value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=2)), conversion=-1), Constant(value=' were given')])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='_fields'), ops=[In()], comparators=[Name(id='kwargs', ctx=Load())]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)])]), body=[Assign(targets=[Name(id='fields', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='_fields')], keywords=[])), Import(names=[alias(name='warnings')]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value="Passing '_fields' as keyword argument is deprecated"), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))], orelse=[Assign(targets=[Name(id='fields', ctx=Store())], value=Constant(value=None))])]), If(test=Compare(left=Name(id='fields', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='fields', ctx=Store())], value=Name(id='kwargs', ctx=Load()))], orelse=[If(test=Name(id='kwargs', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypedDict takes either a dict or keyword arguments, but not both')], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='ns', ctx=Store())], value=Dict(keys=[Constant(value='__annotations__')], values=[Call(func=Name(id='dict', ctx=Load()), args=[Name(id='fields', ctx=Load())], keywords=[])])), Try(body=[Assign(targets=[Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__module__'), ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__name__'), Constant(value='__main__')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Call(func=Name(id='_TypedDictMeta', ctx=Load()), args=[Name(id='typename', ctx=Load()), Tuple(elts=[], ctx=Load()), Name(id='ns', ctx=Load())], keywords=[keyword(arg='total', value=Name(id='total', ctx=Load()))]))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='_typeddict_new', ctx=Load()), attr='__text_signature__', ctx=Store())], value=Constant(value='($cls, _typename, _fields=None, /, *, total=True, **kwargs)')), ClassDef(name='_TypedDictMeta', bases=[Name(id='type', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name'), arg(arg='bases'), arg(arg='ns'), arg(arg='total')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='bases', ctx=Load()), Name(id='ns', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name'), arg(arg='bases'), arg(arg='ns'), arg(arg='total')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__new__'), ctx=Store())], value=IfExp(test=Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='TypedDict')]), body=Name(id='_typeddict_new', ctx=Load()), orelse=Name(id='_dict_new', ctx=Load()))), Assign(targets=[Name(id='tp_dict', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='name', ctx=Load()), Tuple(elts=[Name(id='dict', ctx=Load())], ctx=Load()), Name(id='ns', ctx=Load())], keywords=[])), Assign(targets=[Name(id='annotations', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='own_annotations', ctx=Store())], value=Call(func=Attribute(value=Name(id='ns', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Name(id='own_annotation_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='own_annotations', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value="TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type")), Assign(targets=[Name(id='own_annotations', ctx=Store())], value=DictComp(key=Name(id='n', ctx=Load()), value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='tp', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='own_annotations', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='required_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='optional_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='annotations', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='required_keys', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__required_keys__'), Tuple(elts=[], ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='optional_keys', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__optional_keys__'), Tuple(elts=[], ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='annotations', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='own_annotations', ctx=Load())], keywords=[])), If(test=Name(id='total', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='required_keys', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='own_annotation_keys', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='optional_keys', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='own_annotation_keys', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__annotations__', ctx=Store())], value=Name(id='annotations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__required_keys__', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='required_keys', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__optional_keys__', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='optional_keys', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='tp_dict', ctx=Load()), Constant(value='__total__')], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__total__', ctx=Store())], value=Name(id='total', ctx=Load()))], orelse=[]), Return(value=Name(id='tp_dict', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='__instancecheck__', ctx=Store()), Name(id='__subclasscheck__', ctx=Store())], value=Name(id='_check_fails', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='TypedDict', ctx=Store())], value=Call(func=Name(id='_TypedDictMeta', ctx=Load()), args=[Constant(value='TypedDict'), Tuple(elts=[Name(id='dict', ctx=Load())], ctx=Load()), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='TypedDict', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='__name__', ctx=Load())), Assign(targets=[Attribute(value=Name(id='TypedDict', ctx=Load()), attr='__doc__', ctx=Store())], value=Constant(value="A simple typed name space. At runtime it is equivalent to a plain dict.\n\n        TypedDict creates a dictionary type that expects all of its\n        instances to have a certain set of keys, with each key\n        associated with a value of a consistent type. This expectation\n        is not checked at runtime but is only enforced by type checkers.\n        Usage::\n\n            class Point2D(TypedDict):\n                x: int\n                y: int\n                label: str\n\n            a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\n            b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check\n\n            assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')\n\n        The type info can be accessed via the Point2D.__annotations__ dict, and\n        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.\n        TypedDict supports two additional equivalent forms::\n\n            Point2D = TypedDict('Point2D', x=int, y=int, label=str)\n            Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})\n\n        The class syntax is only supported in Python 3.6+, while two other\n        syntax forms work for Python 2.7 and 3.2+\n        "))]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Annotated')], keywords=[]), body=[Assign(targets=[Name(id='Annotated', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Annotated', ctx=Load())), Assign(targets=[Name(id='get_type_hints', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_type_hints', ctx=Load())), Assign(targets=[Name(id='_AnnotatedAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_AnnotatedAlias', ctx=Load()))], orelse=[If(test=Name(id='PEP_560', ctx=Load()), body=[ClassDef(name='_AnnotatedAlias', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value="Runtime representation of an annotated type.\n\n        At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'\n        with extra annotations. The alias behaves like a normal typing alias,\n        instantiating is the same as instantiating the underlying type, binding\n        it to types is also the same.\n        ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin'), arg(arg='metadata')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='origin', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='origin', ctx=Load()), attr='__metadata__', ctx=Load()), op=Add(), right=Name(id='metadata', ctx=Load()))), Assign(targets=[Name(id='origin', ctx=Store())], value=Attribute(value=Name(id='origin', ctx=Load()), attr='__origin__', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='origin', ctx=Load()), Name(id='origin', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Store())], value=Name(id='metadata', ctx=Load()))], decorator_list=[]), FunctionDef(name='copy_with', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)])), Assign(targets=[Name(id='new_type', ctx=Store())], value=Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load())), Return(value=Call(func=Name(id='_AnnotatedAlias', ctx=Load()), args=[Name(id='new_type', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='typing_extensions.Annotated['), FormattedValue(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load())], keywords=[]), conversion=-1), Constant(value=', '), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), conversion=-1), Constant(value=']')]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='operator', ctx=Load()), attr='getitem', ctx=Load()), Tuple(elts=[Name(id='Annotated', ctx=Load()), BinOp(left=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load())], ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load()))], ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__origin__', ctx=Load())]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__metadata__', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Annotated', bases=[], keywords=[], body=[Expr(value=Constant(value="Add context specific metadata to a type.\n\n        Example: Annotated[int, runtime_check.Unsigned] indicates to the\n        hypothetical runtime_check module that this type is an unsigned int.\n        Every other consumer of this type can ignore this metadata and treat\n        this type as int.\n\n        The first argument to Annotated must be a valid type (and will be in\n        the __origin__ field), the remaining arguments are kept as a tuple in\n        the __extra__ field.\n\n        Details:\n\n        - It's an error to call `Annotated` with less than two arguments.\n        - Nested Annotated are flattened::\n\n            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n        - Instantiating an annotated type is equivalent to instantiating the\n        underlying type::\n\n            Annotated[C, Ann1](5) == C(5)\n\n        - Annotated can be used as a generic type alias::\n\n            Optimized = Annotated[T, runtime.Optimize()]\n            Optimized[int] == Annotated[int, runtime.Optimize()]\n\n            OptimizedList = Annotated[List[T], runtime.Optimize()]\n            OptimizedList[int] == Annotated[List[int], runtime.Optimize()]\n        ")), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Type Annotated cannot be instantiated.')], keywords=[]))], decorator_list=[]), FunctionDef(name='__class_getitem__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='params', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=2)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Annotated[...] should be used with at least two arguments (a type and an annotation).')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Annotated[t, ...]: t must be a type.')), Assign(targets=[Name(id='origin', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='msg', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='_AnnotatedAlias', ctx=Load()), args=[Name(id='origin', ctx=Load()), Name(id='metadata', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot subclass '), FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__module__', ctx=Load()), conversion=-1), Constant(value='.Annotated')])], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='_strip_annotations', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Strips the annotations from a given type.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='_strip_annotations', ctx=Load()), args=[Attribute(value=Name(id='t', ctx=Load()), attr='__origin__', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='stripped_args', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_strip_annotations', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='stripped_args', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load())]), body=[Return(value=Name(id='t', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='copy_with', ctx=Load()), args=[Name(id='stripped_args', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='res', ctx=Load()), attr='_special', ctx=Store())], value=Attribute(value=Name(id='t', ctx=Load()), attr='_special', ctx=Load())), Return(value=Name(id='res', ctx=Load()))], orelse=[]), Return(value=Name(id='t', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_type_hints', args=arguments(posonlyargs=[], args=[arg(arg='obj'), arg(arg='globalns'), arg(arg='localns'), arg(arg='include_extras')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Return type hints for an object.\n\n        This is often the same as obj.__annotations__, but it handles\n        forward references encoded as string literals, adds Optional[t] if a\n        default value equal to None is set and recursively replaces all\n        'Annotated[T, ...]' with 'T' (unless 'include_extras=True').\n\n        The argument may be a module, class, method, or function. The annotations\n        are returned as a dictionary. For classes, annotations include also\n        inherited members.\n\n        TypeError is raised if the argument is not of a type that can contain\n        annotations, and an empty dictionary is returned if no annotations are\n        present.\n\n        BEWARE -- the behavior of globalns and localns is counterintuitive\n        (unless you are familiar with how eval() and exec() work).  The\n        search order is locals first, then globals.\n\n        - If no dict arguments are passed, an attempt is made to use the\n          globals from obj (or the respective module's globals for classes),\n          and these are also used as the locals.  If the object does not appear\n          to have globals, an empty dictionary is used.\n\n        - If one dict argument is passed, it is used for both globals and\n          locals.\n\n        - If two dict arguments are passed, they specify globals and\n          locals, respectively.\n        ")), Assign(targets=[Name(id='hint', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='get_type_hints', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[keyword(arg='globalns', value=Name(id='globalns', ctx=Load())), keyword(arg='localns', value=Name(id='localns', ctx=Load()))])), If(test=Name(id='include_extras', ctx=Load()), body=[Return(value=Name(id='hint', ctx=Load()))], orelse=[]), Return(value=DictComp(key=Name(id='k', ctx=Load()), value=Call(func=Name(id='_strip_annotations', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='t', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='hint', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[])], orelse=[FunctionDef(name='_is_dunder', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns True if name is a __dunder_variable_name__.')), Return(value=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=4)]), Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='__')], keywords=[]), Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='__')], keywords=[])]))], decorator_list=[]), ClassDef(name='AnnotatedMeta', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='GenericMeta', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Metaclass for Annotated')), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name'), arg(arg='bases'), arg(arg='namespace')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='b', ctx=Load()), ops=[IsNot()], comparators=[Name(id='object', ctx=Load())]), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Name(id='bases', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Constant(value='Cannot subclass '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='Annotated', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='name', ctx=Load()), Name(id='bases', ctx=Load()), Name(id='namespace', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='__metadata__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_subs_tree', ctx=Load()), args=[], keywords=[]), slice=Constant(value=2), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_tree_repr', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tree')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='cls', ctx=Store()), Name(id='origin', ctx=Store()), Name(id='metadata', ctx=Store())], ctx=Store())], value=Name(id='tree', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='origin', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='tp_repr', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load()), args=[Name(id='origin', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='tp_repr', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='origin', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='_tree_repr', ctx=Load()), args=[Name(id='origin', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='metadata_reprs', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='arg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='arg', ctx=Store()), iter=Name(id='metadata', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=JoinedStr(values=[FormattedValue(value=Name(id='cls', ctx=Load()), conversion=-1), Constant(value='['), FormattedValue(value=Name(id='tp_repr', ctx=Load()), conversion=-1), Constant(value=', '), FormattedValue(value=Name(id='metadata_reprs', ctx=Load()), conversion=-1), Constant(value=']')]))], decorator_list=[]), FunctionDef(name='_subs_tree', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tvars'), arg(arg='args')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[If(test=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='Annotated', ctx=Load())]), body=[Return(value=Name(id='Annotated', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='_subs_tree', ctx=Load()), args=[], keywords=[keyword(arg='tvars', value=Name(id='tvars', ctx=Load())), keyword(arg='args', value=Name(id='args', ctx=Load()))])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value=1), ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), Compare(left=Subscript(value=Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value=1), ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Is()], comparators=[Name(id='Annotated', ctx=Load())])]), body=[Assign(targets=[Name(id='sub_tp', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value=1), ctx=Load()), slice=Constant(value=1), ctx=Load())), Assign(targets=[Name(id='sub_annot', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value=1), ctx=Load()), slice=Constant(value=2), ctx=Load())), Return(value=Tuple(elts=[Name(id='Annotated', ctx=Load()), Name(id='sub_tp', ctx=Load()), BinOp(left=Name(id='sub_annot', ctx=Load()), op=Add(), right=Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value=2), ctx=Load()))], ctx=Load()))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], decorator_list=[]), FunctionDef(name='_get_cons', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the class used to create instance of this type.')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot get the underlying type of a non-specialized Annotated type.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='tree', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_subs_tree', ctx=Load()), args=[], keywords=[])), While(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tree', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), Compare(left=Subscript(value=Name(id='tree', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Is()], comparators=[Name(id='Annotated', ctx=Load())])]), body=[Assign(targets=[Name(id='tree', ctx=Store())], value=Subscript(value=Name(id='tree', ctx=Load()), slice=Constant(value=1), ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tree', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), body=[Return(value=Subscript(value=Name(id='tree', ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[Return(value=Name(id='tree', ctx=Load()))])], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='params', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='params', ctx=Store())], value=Tuple(elts=[Name(id='params', ctx=Load())], ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__getitem__', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[]))], orelse=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='params', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=2)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Annotated[...] should be instantiated with at least two arguments (a type and an annotation).')], keywords=[]))], orelse=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Annotated[t, ...]: t must be a type.')), Assign(targets=[Name(id='tp', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='msg', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[]))])]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__bases__', ctx=Load()), Call(func=Name(id='_no_slots_copy', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load())], keywords=[])], keywords=[keyword(arg='tvars', value=Call(func=Name(id='_type_vars', ctx=Load()), args=[Tuple(elts=[Name(id='tp', ctx=Load())], ctx=Load())], keywords=[])), keyword(arg='args', value=Tuple(elts=[Name(id='tp', ctx=Load()), Name(id='metadata', ctx=Load())], ctx=Load())), keyword(arg='origin', value=Name(id='self', ctx=Load()))]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Assign(targets=[Name(id='cons', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_cons', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='cons', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Try(body=[Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='__orig_class__', ctx=Store())], value=Name(id='self', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='attr')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Name(id='_is_dunder', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[]))]), body=[Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_cons', ctx=Load()), args=[], keywords=[]), Name(id='attr', ctx=Load())], keywords=[]))], orelse=[]), Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__setattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Call(func=Name(id='_is_dunder', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='attr', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_abc_')], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__setattr__', ctx=Load()), args=[Name(id='attr', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_cons', ctx=Load()), args=[], keywords=[]), Name(id='attr', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))])])], decorator_list=[]), FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Annotated cannot be used with isinstance().')], keywords=[]))], decorator_list=[]), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Annotated cannot be used with issubclass().')], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Annotated', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='AnnotatedMeta', ctx=Load()))], body=[Expr(value=Constant(value="Add context specific metadata to a type.\n\n        Example: Annotated[int, runtime_check.Unsigned] indicates to the\n        hypothetical runtime_check module that this type is an unsigned int.\n        Every other consumer of this type can ignore this metadata and treat\n        this type as int.\n\n        The first argument to Annotated must be a valid type, the remaining\n        arguments are kept as a tuple in the __metadata__ field.\n\n        Details:\n\n        - It's an error to call `Annotated` with less than two arguments.\n        - Nested Annotated are flattened::\n\n            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n        - Instantiating an annotated type is equivalent to instantiating the\n        underlying type::\n\n            Annotated[C, Ann1](5) == C(5)\n\n        - Annotated can be used as a generic type alias::\n\n            Optimized = Annotated[T, runtime.Optimize()]\n            Optimized[int] == Annotated[int, runtime.Optimize()]\n\n            OptimizedList = Annotated[List[T], runtime.Optimize()]\n            OptimizedList[int] == Annotated[List[int], runtime.Optimize()]\n        "))], decorator_list=[])])]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=10)], ctx=Load())]), body=[Assign(targets=[Name(id='get_origin', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_origin', ctx=Load())), Assign(targets=[Name(id='get_args', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_args', ctx=Load()))], orelse=[If(test=Name(id='PEP_560', ctx=Load()), body=[Try(body=[ImportFrom(module='typing', names=[alias(name='_BaseGenericAlias')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='_BaseGenericAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()))])], orelse=[], finalbody=[]), Try(body=[ImportFrom(module='typing', names=[alias(name='GenericAlias')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='GenericAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()))])], orelse=[], finalbody=[]), FunctionDef(name='get_origin', args=arguments(posonlyargs=[], args=[arg(arg='tp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the unsubscripted version of a type.\n\n        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar\n        and Annotated. Return None for unsupported types. Examples::\n\n            get_origin(Literal[42]) is Literal\n            get_origin(int) is None\n            get_origin(ClassVar[int]) is ClassVar\n            get_origin(Generic) is Generic\n            get_origin(Generic[T]) is Generic\n            get_origin(Union[T, int]) is Union\n            get_origin(List[Tuple[T, T]][int]) == list\n            get_origin(P.args) is P\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Return(value=Name(id='Annotated', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), Name(id='GenericAlias', ctx=Load()), Name(id='_BaseGenericAlias', ctx=Load()), Name(id='ParamSpecArgs', ctx=Load()), Name(id='ParamSpecKwargs', ctx=Load())], ctx=Load())], keywords=[]), body=[Return(value=Attribute(value=Name(id='tp', ctx=Load()), attr='__origin__', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='tp', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())]), body=[Return(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='get_args', args=arguments(posonlyargs=[], args=[arg(arg='tp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get type arguments with all substitutions performed.\n\n        For unions, basic simplifications used by Union constructor are performed.\n        Examples::\n            get_args(Dict[str, int]) == (str, int)\n            get_args(int) == ()\n            get_args(Union[int, Union[T, int], str][int]) == (int, str)\n            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])\n            get_args(Callable[[], T][int]) == ([], int)\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Return(value=BinOp(left=Tuple(elts=[Attribute(value=Name(id='tp', ctx=Load()), attr='__origin__', ctx=Load())], ctx=Load()), op=Add(), right=Attribute(value=Name(id='tp', ctx=Load()), attr='__metadata__', ctx=Load())))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), Name(id='GenericAlias', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='tp', ctx=Load()), Constant(value='_special'), Constant(value=False)], keywords=[]), body=[Return(value=Tuple(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='res', ctx=Store())], value=Attribute(value=Name(id='tp', ctx=Load()), attr='__args__', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='get_origin', ctx=Load()), args=[Name(id='tp', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Attribute(value=Attribute(value=Name(id='collections', ctx=Load()), attr='abc', ctx=Load()), attr='Callable', ctx=Load())]), Compare(left=Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[IsNot()], comparators=[Name(id='Ellipsis', ctx=Load())])]), body=[Assign(targets=[Name(id='res', ctx=Store())], value=Tuple(elts=[Call(func=Name(id='list', ctx=Load()), args=[Subscript(value=Name(id='res', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[]), Subscript(value=Name(id='res', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[], ctx=Load()))], decorator_list=[])], orelse=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeAlias')], keywords=[]), body=[Assign(targets=[Name(id='TypeAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeAlias', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[ClassDef(name='_TypeAliasForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[])], decorator_list=[]), FunctionDef(name='TypeAlias', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Special marker indicating that an assignment should\n        be recognized as a proper type alias definition by type\n        checkers.\n\n        For example::\n\n            Predicate: TypeAlias = Callable[..., bool]\n\n        It's invalid when used anywhere except as in the example above.\n        ")), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not subscriptable')])], keywords=[]))], decorator_list=[Name(id='_TypeAliasForm', ctx=Load())])], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())]), body=[ClassDef(name='_TypeAliasForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='TypeAlias', ctx=Store())], value=Call(func=Name(id='_TypeAliasForm', ctx=Load()), args=[Constant(value='TypeAlias')], keywords=[keyword(arg='doc', value=Constant(value="Special marker indicating that an assignment should\n                               be recognized as a proper type alias definition by type\n                               checkers.\n\n                               For example::\n\n                                   Predicate: TypeAlias = Callable[..., bool]\n\n                               It's invalid when used anywhere except as in the example\n                               above."))]))], orelse=[ClassDef(name='_TypeAliasMeta', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='TypingMeta', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Metaclass for TypeAlias')), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='typing_extensions.TypeAlias'))], decorator_list=[])], decorator_list=[]), ClassDef(name='_TypeAliasBase', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_FinalTypingBase', ctx=Load())], keywords=[keyword(arg='metaclass', value=Name(id='_TypeAliasMeta', ctx=Load())), keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value="Special marker indicating that an assignment should\n        be recognized as a proper type alias definition by type\n        checkers.\n\n        For example::\n\n            Predicate: TypeAlias = Callable[..., bool]\n\n        It's invalid when used anywhere except as in the example above.\n        ")), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypeAlias cannot be used with isinstance().')], keywords=[]))], decorator_list=[]), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypeAlias cannot be used with issubclass().')], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='typing_extensions.TypeAlias'))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='TypeAlias', ctx=Store())], value=Call(func=Name(id='_TypeAliasBase', ctx=Load()), args=[], keywords=[keyword(arg='_root', value=Constant(value=True))]))])])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='ParamSpecArgs')], keywords=[]), body=[Assign(targets=[Name(id='ParamSpecArgs', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpecArgs', ctx=Load())), Assign(targets=[Name(id='ParamSpecKwargs', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpecKwargs', ctx=Load()))], orelse=[ClassDef(name='_Immutable', bases=[], keywords=[], body=[Expr(value=Constant(value='Mixin to indicate that object should not be copied.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__copy__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__deepcopy__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='memo')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='ParamSpecArgs', bases=[Name(id='_Immutable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The args for a ParamSpec object.\n\n        Given a ParamSpec object P, P.args is an instance of ParamSpecArgs.\n\n        ParamSpecArgs objects have a reference back to their ParamSpec:\n\n        P.args.__origin__ is P\n\n        This type is meant for runtime introspection and has no special meaning to\n        static type checkers.\n        ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Store())], value=Name(id='origin', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='.args')]))], decorator_list=[])], decorator_list=[]), ClassDef(name='ParamSpecKwargs', bases=[Name(id='_Immutable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The kwargs for a ParamSpec object.\n\n        Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs.\n\n        ParamSpecKwargs objects have a reference back to their ParamSpec:\n\n        P.kwargs.__origin__ is P\n\n        This type is meant for runtime introspection and has no special meaning to\n        static type checkers.\n        ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Store())], value=Name(id='origin', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='.kwargs')]))], decorator_list=[])], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='ParamSpec')], keywords=[]), body=[Assign(targets=[Name(id='ParamSpec', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpec', ctx=Load()))], orelse=[ClassDef(name='ParamSpec', bases=[Name(id='list', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Parameter specification variable.\n\n        Usage::\n\n           P = ParamSpec('P')\n\n        Parameter specification variables exist primarily for the benefit of static\n        type checkers.  They are used to forward the parameter types of one\n        callable to another callable, a pattern commonly found in higher order\n        functions and decorators.  They are only valid when used in ``Concatenate``,\n        or s the first argument to ``Callable``. In Python 3.10 and higher,\n        they are also supported in user-defined Generics at runtime.\n        See class Generic for more information on generic types.  An\n        example for annotating a decorator::\n\n           T = TypeVar('T')\n           P = ParamSpec('P')\n\n           def add_logging(f: Callable[P, T]) -> Callable[P, T]:\n               '''A type-safe decorator to add logging to a function.'''\n               def inner(*args: P.args, **kwargs: P.kwargs) -> T:\n                   logging.info(f'{f.__name__} was called')\n                   return f(*args, **kwargs)\n               return inner\n\n           @add_logging\n           def add_two(x: float, y: float) -> float:\n               '''Add two numbers together.'''\n               return x + y\n\n        Parameter specification variables defined with covariant=True or\n        contravariant=True can be used to declare covariant or contravariant\n        generic types.  These keyword arguments are valid, but their actual semantics\n        are yet to be decided.  See PEP 612 for details.\n\n        Parameter specification variables can be introspected. e.g.:\n\n           P.__name__ == 'T'\n           P.__bound__ == None\n           P.__covariant__ == False\n           P.__contravariant__ == False\n\n        Note that only parameter specification variables defined in global scope can\n        be pickled.\n        ")), Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())), FunctionDef(name='args', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='ParamSpecArgs', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='kwargs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='ParamSpecKwargs', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[arg(arg='bound'), arg(arg='covariant'), arg(arg='contravariant')], kw_defaults=[Constant(value=None), Constant(value=False), Constant(value=False)], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__covariant__', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='covariant', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__contravariant__', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='contravariant', ctx=Load())], keywords=[])), If(test=Name(id='bound', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__bound__', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='bound', ctx=Load()), Constant(value='Bound must be a type.')], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__bound__', ctx=Store())], value=Constant(value=None))]), Try(body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__name__'), Constant(value='__main__')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='__covariant__', ctx=Load()), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value='+'))], orelse=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='__contravariant__', ctx=Load()), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value='-'))], orelse=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value='~'))])]), Return(value=BinOp(left=Name(id='prefix', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load())))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__hash__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='other', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Pass()], decorator_list=[]), If(test=UnaryOp(op=Not(), operand=Name(id='PEP_560', ctx=Load())), body=[FunctionDef(name='_get_type_vars', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tvars')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='self', ctx=Load()), ops=[NotIn()], comparators=[Name(id='tvars', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='tvars', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])], orelse=[])], decorator_list=[])]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Concatenate')], keywords=[])), body=[ClassDef(name='_ConcatenateGenericAlias', bases=[Name(id='list', ctx=Load())], keywords=[], body=[If(test=Name(id='PEP_560', ctx=Load()), body=[Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()))], orelse=[Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_TypingBase', ctx=Load()))]), Assign(targets=[Name(id='_special', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='_gorg', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin'), arg(arg='args')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Store())], value=Name(id='origin', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Store())], value=Name(id='args', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='_type_repr', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load())), Return(value=JoinedStr(values=[FormattedValue(value=Call(func=Name(id='_type_repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load())], keywords=[]), conversion=-1), Constant(value='['), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_type_repr', ctx=Load()), args=[Name(id='arg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='arg', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), conversion=-1), Constant(value=']')]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Pass()], decorator_list=[]), FunctionDef(name='__parameters__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Name(id='tp', ctx=Load()), generators=[comprehension(target=Name(id='tp', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load()), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), Name(id='ParamSpec', ctx=Load())], ctx=Load())], keywords=[])], is_async=0)])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), If(test=UnaryOp(op=Not(), operand=Name(id='PEP_560', ctx=Load())), body=[FunctionDef(name='_get_type_vars', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tvars')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__parameters__', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_get_type_vars', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__parameters__', ctx=Load()), Name(id='tvars', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])], orelse=[])], decorator_list=[])], orelse=[]), FunctionDef(name='_concatenate_getitem', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='parameters', ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot take a Concatenate of no types.')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='parameters', ctx=Store())], value=Tuple(elts=[Name(id='parameters', ctx=Load())], ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='parameters', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='ParamSpec', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='The last parameter to Concatenate should be a ParamSpec variable.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Concatenate[arg, ...]: each arg must be a type.')), Assign(targets=[Name(id='parameters', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='parameters', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Call(func=Name(id='_ConcatenateGenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Concatenate')], keywords=[]), body=[Assign(targets=[Name(id='Concatenate', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Concatenate', ctx=Load())), Assign(targets=[Name(id='_ConcatenateGenericAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_ConcatenateGenericAlias', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[FunctionDef(name='Concatenate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a\n        higher order function which adds, removes or transforms parameters of a\n        callable.\n\n        For example::\n\n           Callable[Concatenate[int, P], int]\n\n        See PEP 612 for detailed information.\n        ')), Return(value=Call(func=Name(id='_concatenate_getitem', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[Name(id='_TypeAliasForm', ctx=Load())])], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())]), body=[ClassDef(name='_ConcatenateForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='_concatenate_getitem', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Concatenate', ctx=Store())], value=Call(func=Name(id='_ConcatenateForm', ctx=Load()), args=[Constant(value='Concatenate')], keywords=[keyword(arg='doc', value=Constant(value='Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a\n        higher order function which adds, removes or transforms parameters of a\n        callable.\n\n        For example::\n\n           Callable[Concatenate[int, P], int]\n\n        See PEP 612 for detailed information.\n        '))]))], orelse=[ClassDef(name='_ConcatenateAliasMeta', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='TypingMeta', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Metaclass for Concatenate.')), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='typing_extensions.Concatenate'))], decorator_list=[])], decorator_list=[]), ClassDef(name='_ConcatenateAliasBase', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_FinalTypingBase', ctx=Load())], keywords=[keyword(arg='metaclass', value=Name(id='_ConcatenateAliasMeta', ctx=Load())), keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value='Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a\n        higher order function which adds, removes or transforms parameters of a\n        callable.\n\n        For example::\n\n           Callable[Concatenate[int, P], int]\n\n        See PEP 612 for detailed information.\n        ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Concatenate cannot be used with isinstance().')], keywords=[]))], decorator_list=[]), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Concatenate cannot be used with issubclass().')], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='typing_extensions.Concatenate'))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='_concatenate_getitem', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Concatenate', ctx=Store())], value=Call(func=Name(id='_ConcatenateAliasBase', ctx=Load()), args=[], keywords=[keyword(arg='_root', value=Constant(value=True))]))])])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeGuard')], keywords=[]), body=[Assign(targets=[Name(id='TypeGuard', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeGuard', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[ClassDef(name='_TypeGuardForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[])], decorator_list=[]), FunctionDef(name='TypeGuard', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Special typing form used to annotate the return type of a user-defined\n        type guard function.  ``TypeGuard`` only accepts a single type argument.\n        At runtime, functions marked this way should return a boolean.\n\n        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static\n        type checkers to determine a more precise type of an expression within a\n        program\'s code flow.  Usually type narrowing is done by analyzing\n        conditional code flow and applying the narrowing to a block of code.  The\n        conditional expression here is sometimes referred to as a "type guard".\n\n        Sometimes it would be convenient to use a user-defined boolean function\n        as a type guard.  Such a function should use ``TypeGuard[...]`` as its\n        return type to alert static type checkers to this intention.\n\n        Using  ``-> TypeGuard`` tells the static type checker that for a given\n        function:\n\n        1. The return value is a boolean.\n        2. If the return value is ``True``, the type of its argument\n        is the type inside ``TypeGuard``.\n\n        For example::\n\n            def is_str(val: Union[str, float]):\n                # "isinstance" type guard\n                if isinstance(val, str):\n                    # Type of ``val`` is narrowed to ``str``\n                    ...\n                else:\n                    # Else, type of ``val`` is narrowed to ``float``.\n                    ...\n\n        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower\n        form of ``TypeA`` (it can even be a wider form) and this may lead to\n        type-unsafe results.  The main reason is to allow for things like\n        narrowing ``List[object]`` to ``List[str]`` even though the latter is not\n        a subtype of the former, since ``List`` is invariant.  The responsibility of\n        writing type-safe type guards is left to the user.\n\n        ``TypeGuard`` also works with type variables.  For more information, see\n        PEP 647 (User-Defined Type Guards).\n        ')), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' accepts only single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_TypeGuardForm', ctx=Load())])], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())]), body=[ClassDef(name='_TypeGuardForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='TypeGuard', ctx=Store())], value=Call(func=Name(id='_TypeGuardForm', ctx=Load()), args=[Constant(value='TypeGuard')], keywords=[keyword(arg='doc', value=Constant(value='Special typing form used to annotate the return type of a user-defined\n        type guard function.  ``TypeGuard`` only accepts a single type argument.\n        At runtime, functions marked this way should return a boolean.\n\n        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static\n        type checkers to determine a more precise type of an expression within a\n        program\'s code flow.  Usually type narrowing is done by analyzing\n        conditional code flow and applying the narrowing to a block of code.  The\n        conditional expression here is sometimes referred to as a "type guard".\n\n        Sometimes it would be convenient to use a user-defined boolean function\n        as a type guard.  Such a function should use ``TypeGuard[...]`` as its\n        return type to alert static type checkers to this intention.\n\n        Using  ``-> TypeGuard`` tells the static type checker that for a given\n        function:\n\n        1. The return value is a boolean.\n        2. If the return value is ``True``, the type of its argument\n        is the type inside ``TypeGuard``.\n\n        For example::\n\n            def is_str(val: Union[str, float]):\n                # "isinstance" type guard\n                if isinstance(val, str):\n                    # Type of ``val`` is narrowed to ``str``\n                    ...\n                else:\n                    # Else, type of ``val`` is narrowed to ``float``.\n                    ...\n\n        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower\n        form of ``TypeA`` (it can even be a wider form) and this may lead to\n        type-unsafe results.  The main reason is to allow for things like\n        narrowing ``List[object]`` to ``List[str]`` even though the latter is not\n        a subtype of the former, since ``List`` is invariant.  The responsibility of\n        writing type-safe type guards is left to the user.\n\n        ``TypeGuard`` also works with type variables.  For more information, see\n        PEP 647 (User-Defined Type Guards).\n        '))]))], orelse=[ClassDef(name='_TypeGuard', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_FinalTypingBase', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value='Special typing form used to annotate the return type of a user-defined\n        type guard function.  ``TypeGuard`` only accepts a single type argument.\n        At runtime, functions marked this way should return a boolean.\n\n        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static\n        type checkers to determine a more precise type of an expression within a\n        program\'s code flow.  Usually type narrowing is done by analyzing\n        conditional code flow and applying the narrowing to a block of code.  The\n        conditional expression here is sometimes referred to as a "type guard".\n\n        Sometimes it would be convenient to use a user-defined boolean function\n        as a type guard.  Such a function should use ``TypeGuard[...]`` as its\n        return type to alert static type checkers to this intention.\n\n        Using  ``-> TypeGuard`` tells the static type checker that for a given\n        function:\n\n        1. The return value is a boolean.\n        2. If the return value is ``True``, the type of its argument\n        is the type inside ``TypeGuard``.\n\n        For example::\n\n            def is_str(val: Union[str, float]):\n                # "isinstance" type guard\n                if isinstance(val, str):\n                    # Type of ``val`` is narrowed to ``str``\n                    ...\n                else:\n                    # Else, type of ``val`` is narrowed to ``float``.\n                    ...\n\n        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower\n        form of ``TypeA`` (it can even be a wider form) and this may lead to\n        type-unsafe results.  The main reason is to allow for things like\n        narrowing ``List[object]`` to ``List[str]`` even though the latter is not\n        a subtype of the former, since ``List`` is invariant.  The responsibility of\n        writing type-safe type guards is left to the user.\n\n        ``TypeGuard`` also works with type variables.  For more information, see\n        PEP 647 (User-Defined Type Guards).\n        ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='__type__')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tp')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Store())], value=Name(id='tp', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='cls', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='item', ctx=Load()), JoinedStr(values=[FormattedValue(value=Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])], keywords=[keyword(arg='_root', value=Constant(value=True))]))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), conversion=-1), Constant(value=' cannot be further subscripted')])], keywords=[]))], decorator_list=[]), FunctionDef(name='_eval_type', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='globalns'), arg(arg='localns')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='new_tp', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_eval_type', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), Name(id='globalns', ctx=Load()), Name(id='localns', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='new_tp', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load())]), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), Return(value=Call(func=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), args=[Name(id='new_tp', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__repr__', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='r', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load())], keywords=[]), conversion=-1), Constant(value=']')]))], orelse=[]), Return(value=Name(id='r', ctx=Load()))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='_TypeGuard', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__type__', ctx=Load())]))], orelse=[]), Return(value=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='other', ctx=Load())]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='TypeGuard', ctx=Store())], value=Call(func=Name(id='_TypeGuard', ctx=Load()), args=[], keywords=[keyword(arg='_root', value=Constant(value=True))]))])])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Self')], keywords=[]), body=[Assign(targets=[Name(id='Self', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Self', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())]), body=[ClassDef(name='_SpecialForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_Final', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='_name'), Constant(value='__doc__'), Constant(value='_getitem')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='getitem')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_getitem', ctx=Store())], value=Name(id='getitem', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Store())], value=Attribute(value=Name(id='getitem', ctx=Load()), attr='__name__', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__doc__', ctx=Store())], value=Attribute(value=Name(id='getitem', ctx=Load()), attr='__doc__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='item', ctx=Load()), ops=[In()], comparators=[Set(elts=[Constant(value='__name__'), Constant(value='__qualname__')])]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__mro_entries__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='bases')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot subclass '), FormattedValue(value=Name(id='self', ctx=Load()), conversion=114)])], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='typing_extensions.'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1)]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot instantiate '), FormattedValue(value=Name(id='self', ctx=Load()), conversion=114)])], keywords=[]))], decorator_list=[]), FunctionDef(name='__or__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__ror__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='other', ctx=Load()), Name(id='self', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' cannot be used with isinstance()')])], keywords=[]))], decorator_list=[]), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' cannot be used with issubclass()')])], keywords=[]))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_getitem', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())])], decorator_list=[]), FunctionDef(name='Self', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Used to spell the type of "self" in classes.\n\n        Example::\n\n          from typing import Self\n\n          class ReturnsSelf:\n              def parse(self, data: bytes) -> Self:\n                  ...\n                  return self\n\n        ')), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not subscriptable')])], keywords=[]))], decorator_list=[Name(id='_SpecialForm', ctx=Load())])], orelse=[ClassDef(name='_Self', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_FinalTypingBase', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value='Used to spell the type of "self" in classes.\n\n        Example::\n\n          from typing import Self\n\n          class ReturnsSelf:\n              def parse(self, data: bytes) -> Self:\n                  ...\n                  return self\n\n        ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' cannot be used with isinstance().')])], keywords=[]))], decorator_list=[]), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' cannot be used with issubclass().')])], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Self', ctx=Store())], value=Call(func=Name(id='_Self', ctx=Load()), args=[], keywords=[keyword(arg='_root', value=Constant(value=True))]))])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Required')], keywords=[]), body=[Assign(targets=[Name(id='Required', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Required', ctx=Load())), Assign(targets=[Name(id='NotRequired', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NotRequired', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[ClassDef(name='_ExtensionsSpecialForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[])], decorator_list=[]), FunctionDef(name='Required', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A special typing construct to mark a key of a total=False TypedDict\n        as required. For example:\n\n            class Movie(TypedDict, total=False):\n                title: Required[str]\n                year: int\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n\n        There is no runtime checking that a required key is actually provided\n        when instantiating a related TypedDict.\n        ")), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only single type')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_ExtensionsSpecialForm', ctx=Load())]), FunctionDef(name='NotRequired', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A special typing construct to mark a key of a TypedDict as\n        potentially missing. For example:\n\n            class Movie(TypedDict):\n                title: str\n                year: NotRequired[int]\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n        ")), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only single type')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_ExtensionsSpecialForm', ctx=Load())])], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())]), body=[ClassDef(name='_RequiredForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Call(func=Attribute(value=Constant(value='{} accepts only single type'), attr='format', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())], keywords=[])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Required', ctx=Store())], value=Call(func=Name(id='_RequiredForm', ctx=Load()), args=[Constant(value='Required')], keywords=[keyword(arg='doc', value=Constant(value="A special typing construct to mark a key of a total=False TypedDict\n        as required. For example:\n\n            class Movie(TypedDict, total=False):\n                title: Required[str]\n                year: int\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n\n        There is no runtime checking that a required key is actually provided\n        when instantiating a related TypedDict.\n        "))])), Assign(targets=[Name(id='NotRequired', ctx=Store())], value=Call(func=Name(id='_RequiredForm', ctx=Load()), args=[Constant(value='NotRequired')], keywords=[keyword(arg='doc', value=Constant(value="A special typing construct to mark a key of a TypedDict as\n        potentially missing. For example:\n\n            class Movie(TypedDict):\n                title: str\n                year: NotRequired[int]\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n        "))]))], orelse=[ClassDef(name='_MaybeRequired', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_FinalTypingBase', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='__type__')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tp')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Store())], value=Name(id='tp', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='cls', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='item', ctx=Load()), Call(func=Attribute(value=Constant(value='{} accepts only single type.'), attr='format', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[])], keywords=[])], keywords=[keyword(arg='_root', value=Constant(value=True))]))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{} cannot be further subscripted'), attr='format', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_eval_type', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='globalns'), arg(arg='localns')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='new_tp', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_eval_type', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), Name(id='globalns', ctx=Load()), Name(id='localns', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='new_tp', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load())]), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), Return(value=Call(func=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), args=[Name(id='new_tp', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__repr__', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='r', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Constant(value='[{}]'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='r', ctx=Load()))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__type__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__type__', ctx=Load())]))], orelse=[]), Return(value=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='other', ctx=Load())]))], decorator_list=[])], decorator_list=[]), ClassDef(name='_Required', bases=[Name(id='_MaybeRequired', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value="A special typing construct to mark a key of a total=False TypedDict\n        as required. For example:\n\n            class Movie(TypedDict, total=False):\n                title: Required[str]\n                year: int\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n\n        There is no runtime checking that a required key is actually provided\n        when instantiating a related TypedDict.\n        "))], decorator_list=[]), ClassDef(name='_NotRequired', bases=[Name(id='_MaybeRequired', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value="A special typing construct to mark a key of a TypedDict as\n        potentially missing. For example:\n\n            class Movie(TypedDict):\n                title: str\n                year: NotRequired[int]\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n        "))], decorator_list=[]), Assign(targets=[Name(id='Required', ctx=Store())], value=Call(func=Name(id='_Required', ctx=Load()), args=[], keywords=[keyword(arg='_root', value=Constant(value=True))])), Assign(targets=[Name(id='NotRequired', ctx=Store())], value=Call(func=Name(id='_NotRequired', ctx=Load()), args=[], keywords=[keyword(arg='_root', value=Constant(value=True))]))])])])], type_ignores=[])