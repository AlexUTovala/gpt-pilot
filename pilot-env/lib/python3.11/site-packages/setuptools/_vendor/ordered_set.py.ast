Module(body=[Expr(value=Constant(value='\nAn OrderedSet is a custom MutableSet that remembers its order, so that every\nentry has an index that can be looked up.\n\nBased on a recipe originally posted to ActiveState Recipes by Raymond Hettiger,\nand released under the MIT license.\n')), Import(names=[alias(name='itertools', asname='it')]), ImportFrom(module='collections', names=[alias(name='deque')], level=0), Try(body=[ImportFrom(module='collections.abc', names=[alias(name='MutableSet'), alias(name='Sequence')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[ImportFrom(module='collections', names=[alias(name='MutableSet'), alias(name='Sequence')], level=0)])], orelse=[], finalbody=[]), Assign(targets=[Name(id='SLICE_ALL', ctx=Store())], value=Call(func=Name(id='slice', ctx=Load()), args=[Constant(value=None)], keywords=[])), Assign(targets=[Name(id='__version__', ctx=Store())], value=Constant(value='3.1')), FunctionDef(name='is_iterable', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Are we being asked to look up a list of things, instead of a single thing?\n    We check for the `__iter__` attribute so that this can cover types that\n    don't have to be known by this module, such as NumPy arrays.\n\n    Strings, however, should be considered as atomic values to look up, not\n    iterables. The same goes for tuples, since they are immutable and therefore\n    valid entries.\n\n    We don't need to check for the Python 2 `unicode` type, because it doesn't\n    have an `__iter__` attribute anyway.\n    ")), Return(value=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Constant(value='__iter__')], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]))]))], decorator_list=[]), ClassDef(name='OrderedSet', bases=[Name(id='MutableSet', ctx=Load()), Name(id='Sequence', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    An OrderedSet is a custom MutableSet that remembers its order, so that\n    every entry has an index that can be looked up.\n\n    Example:\n        >>> OrderedSet([1, 1, 2, 3, 2])\n        OrderedSet([1, 2, 3])\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Store())], value=Dict(keys=[], values=[])), If(test=Compare(left=Name(id='iterable', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='self', ctx=Store()), op=BitOr(), value=Name(id='iterable', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='__len__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returns the number of unique elements in the ordered set\n\n        Example:\n            >>> len(OrderedSet([]))\n            0\n            >>> len(OrderedSet([1, 2]))\n            2\n        ')), Return(value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Get the item at a given index.\n\n        If `index` is a slice, you will get back that slice of items, as a\n        new OrderedSet.\n\n        If `index` is a list or a similar iterable, you\'ll get a list of\n        items corresponding to those indices. This is similar to NumPy\'s\n        "fancy indexing". The result is not an OrderedSet because you may ask\n        for duplicate indices, and the number of elements returned should be\n        the number of elements asked for.\n\n        Example:\n            >>> oset = OrderedSet([1, 2, 3])\n            >>> oset[1]\n            2\n        ')), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='index', ctx=Load()), Name(id='slice', ctx=Load())], keywords=[]), Compare(left=Name(id='index', ctx=Load()), ops=[Eq()], comparators=[Name(id='SLICE_ALL', ctx=Load())])]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))], orelse=[If(test=Call(func=Name(id='is_iterable', ctx=Load()), args=[Name(id='index', ctx=Load())], keywords=[]), body=[Return(value=ListComp(elt=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Name(id='index', ctx=Load()), ifs=[], is_async=0)]))], orelse=[If(test=BoolOp(op=Or(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='index', ctx=Load()), Constant(value='__index__')], keywords=[]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='index', ctx=Load()), Name(id='slice', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), slice=Name(id='index', ctx=Load()), ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))], orelse=[Return(value=Name(id='result', ctx=Load()))])], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Constant(value="Don't know how to index an OrderedSet by %r"), op=Mod(), right=Name(id='index', ctx=Load()))], keywords=[]))])])])], decorator_list=[]), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a shallow copy of this object.\n\n        Example:\n            >>> this = OrderedSet([1, 2, 3])\n            >>> other = this.copy()\n            >>> this == other\n            True\n            >>> this is other\n            False\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__getstate__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Tuple(elts=[Constant(value=None)], ctx=Load()))], orelse=[Return(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='__setstate__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='state')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='state', ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[Constant(value=None)], ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__init__', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Test if the item is in this ordered set\n\n        Example:\n            >>> 1 in OrderedSet([1, 3, 2])\n            True\n            >>> 5 in OrderedSet([1, 3, 2])\n            False\n        ')), Return(value=Compare(left=Name(id='key', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load())]))], decorator_list=[]), FunctionDef(name='add', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Add `key` as an item to this OrderedSet, then return its index.\n\n        If `key` is already in the OrderedSet, return the index it already\n        had.\n\n        Example:\n            >>> oset = OrderedSet()\n            >>> oset.append(3)\n            0\n            >>> print(oset)\n            OrderedSet([3])\n        ')), If(test=Compare(left=Name(id='key', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load())]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='append', ctx=Store())], value=Name(id='add', ctx=Load())), FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='sequence')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Update the set with the given iterable sequence, then return the index\n        of the last element inserted.\n\n        Example:\n            >>> oset = OrderedSet([1, 2, 3])\n            >>> oset.update([3, 1, 5, 1, 4])\n            4\n            >>> print(oset)\n            OrderedSet([1, 2, 3, 5, 4])\n        ')), Assign(targets=[Name(id='item_index', ctx=Store())], value=Constant(value=None)), Try(body=[For(target=Name(id='item', ctx=Store()), iter=Name(id='sequence', ctx=Load()), body=[Assign(targets=[Name(id='item_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='Argument needs to be an iterable, got %s'), op=Mod(), right=Call(func=Name(id='type', ctx=Load()), args=[Name(id='sequence', ctx=Load())], keywords=[]))], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Name(id='item_index', ctx=Load()))], decorator_list=[]), FunctionDef(name='index', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Get the index of a given entry, raising an IndexError if it's not\n        present.\n\n        `key` can be an iterable of entries that is not a string, in which case\n        this returns a list of indices.\n\n        Example:\n            >>> oset = OrderedSet([1, 2, 3])\n            >>> oset.index(2)\n            1\n        ")), If(test=Call(func=Name(id='is_iterable', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]), body=[Return(value=ListComp(elt=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='index', ctx=Load()), args=[Name(id='subkey', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='subkey', ctx=Store()), iter=Name(id='key', ctx=Load()), ifs=[], is_async=0)]))], orelse=[]), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='get_loc', ctx=Store())], value=Name(id='index', ctx=Load())), Assign(targets=[Name(id='get_indexer', ctx=Store())], value=Name(id='index', ctx=Load())), FunctionDef(name='pop', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Remove and return the last element from the set.\n\n        Raises KeyError if the set is empty.\n\n        Example:\n            >>> oset = OrderedSet([1, 2, 3])\n            >>> oset.pop()\n            3\n        ')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load())), body=[Raise(exc=Call(func=Name(id='KeyError', ctx=Load()), args=[Constant(value='Set is empty')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='elem', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Del())]), Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load()), slice=Name(id='elem', ctx=Load()), ctx=Del())]), Return(value=Name(id='elem', ctx=Load()))], decorator_list=[]), FunctionDef(name='discard', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Remove an element.  Do not raise an exception if absent.\n\n        The MutableSet mixin uses this to implement the .remove() method, which\n        *does* raise an error when asked to remove a non-existent item.\n\n        Example:\n            >>> oset = OrderedSet([1, 2, 3])\n            >>> oset.discard(2)\n            >>> print(oset)\n            OrderedSet([1, 3])\n            >>> oset.discard(2)\n            >>> print(oset)\n            OrderedSet([1, 3])\n        ')), If(test=Compare(left=Name(id='key', ctx=Load()), ops=[In()], comparators=[Name(id='self', ctx=Load())]), body=[Assign(targets=[Name(id='i', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())), Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Del())]), Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Del())]), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='v', ctx=Load()), ops=[GtE()], comparators=[Name(id='i', ctx=Load())]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Sub(), right=Constant(value=1)))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='clear', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Remove all items from this OrderedSet.\n        ')), Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), slice=Slice(), ctx=Del())]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Example:\n            >>> list(iter(OrderedSet([1, 2, 3])))\n            [1, 2, 3]\n        ')), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__reversed__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Example:\n            >>> list(reversed(OrderedSet([1, 2, 3])))\n            [3, 2, 1]\n        ')), Return(value=Call(func=Name(id='reversed', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='self', ctx=Load())), body=[Return(value=BinOp(left=Constant(value='%s()'), op=Mod(), right=Tuple(elts=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], ctx=Load())))], orelse=[]), Return(value=BinOp(left=Constant(value='%s(%r)'), op=Mod(), right=Tuple(elts=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), Call(func=Name(id='list', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])], ctx=Load())))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returns true if the containers have the same items. If `other` is a\n        Sequence, then order is checked, otherwise it is ignored.\n\n        Example:\n            >>> oset = OrderedSet([1, 3, 2])\n            >>> oset == [1, 3, 2]\n            True\n            >>> oset == [1, 2, 3]\n            False\n            >>> oset == [2, 3]\n            False\n            >>> oset == OrderedSet([3, 2, 1])\n            False\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Tuple(elts=[Name(id='Sequence', ctx=Load()), Name(id='deque', ctx=Load())], ctx=Load())], keywords=[]), body=[Return(value=Compare(left=Call(func=Name(id='list', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='list', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])]))], orelse=[]), Try(body=[Assign(targets=[Name(id='other_as_set', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[Return(value=Compare(left=Call(func=Name(id='set', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Name(id='other_as_set', ctx=Load())]))], finalbody=[])], decorator_list=[]), FunctionDef(name='union', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='sets'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Combines all unique items.\n        Each items order is defined by its first appearance.\n\n        Example:\n            >>> oset = OrderedSet.union(OrderedSet([3, 1, 4, 1, 5]), [1, 3], [2, 0])\n            >>> print(oset)\n            OrderedSet([3, 1, 4, 5, 2, 0])\n            >>> oset.union([8, 9])\n            OrderedSet([3, 1, 4, 5, 2, 0, 8, 9])\n            >>> oset | {10}\n            OrderedSet([3, 1, 4, 5, 2, 0, 10])\n        ')), Assign(targets=[Name(id='cls', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='OrderedSet', ctx=Load())], keywords=[]), body=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), orelse=Name(id='OrderedSet', ctx=Load()))), Assign(targets=[Name(id='containers', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='list', ctx=Load()), Call(func=Attribute(value=Name(id='it', ctx=Load()), attr='chain', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load())], ctx=Load()), Name(id='sets', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='items', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='it', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Name(id='containers', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__and__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='intersection', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='intersection', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='sets'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returns elements in common between all sets. Order is defined only\n        by the first set.\n\n        Example:\n            >>> oset = OrderedSet.intersection(OrderedSet([0, 1, 2, 3]), [1, 2, 3])\n            >>> print(oset)\n            OrderedSet([1, 2, 3])\n            >>> oset.intersection([2, 4, 5], [1, 2, 3, 4])\n            OrderedSet([2])\n            >>> oset.intersection()\n            OrderedSet([1, 2, 3])\n        ')), Assign(targets=[Name(id='cls', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='OrderedSet', ctx=Load())], keywords=[]), body=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), orelse=Name(id='OrderedSet', ctx=Load()))), If(test=Name(id='sets', ctx=Load()), body=[Assign(targets=[Name(id='common', ctx=Store())], value=Call(func=Attribute(value=Name(id='set', ctx=Load()), attr='intersection', ctx=Load()), args=[Starred(value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='set', ctx=Load()), Name(id='sets', ctx=Load())], keywords=[]), ctx=Load())], keywords=[])), Assign(targets=[Name(id='items', ctx=Store())], value=GeneratorExp(elt=Name(id='item', ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[Compare(left=Name(id='item', ctx=Load()), ops=[In()], comparators=[Name(id='common', ctx=Load())])], is_async=0)]))], orelse=[Assign(targets=[Name(id='items', ctx=Store())], value=Name(id='self', ctx=Load()))]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='difference', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='sets'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returns all elements that are in this set but not the others.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).difference(OrderedSet([2]))\n            OrderedSet([1, 3])\n            >>> OrderedSet([1, 2, 3]).difference(OrderedSet([2]), OrderedSet([3]))\n            OrderedSet([1])\n            >>> OrderedSet([1, 2, 3]) - OrderedSet([2])\n            OrderedSet([1, 3])\n            >>> OrderedSet([1, 2, 3]).difference()\n            OrderedSet([1, 2, 3])\n        ')), Assign(targets=[Name(id='cls', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())), If(test=Name(id='sets', ctx=Load()), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='set', ctx=Load()), attr='union', ctx=Load()), args=[Starred(value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='set', ctx=Load()), Name(id='sets', ctx=Load())], keywords=[]), ctx=Load())], keywords=[])), Assign(targets=[Name(id='items', ctx=Store())], value=GeneratorExp(elt=Name(id='item', ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[Compare(left=Name(id='item', ctx=Load()), ops=[NotIn()], comparators=[Name(id='other', ctx=Load())])], is_async=0)]))], orelse=[Assign(targets=[Name(id='items', ctx=Store())], value=Name(id='self', ctx=Load()))]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='issubset', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        ')), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='item', ctx=Load()), ops=[In()], comparators=[Name(id='other', ctx=Load())]), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='issuperset', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Report whether this set contains another set.\n\n        Example:\n            >>> OrderedSet([1, 2]).issuperset([1, 2, 3])\n            False\n            >>> OrderedSet([1, 2, 3, 4]).issuperset({1, 2, 3})\n            True\n            >>> OrderedSet([1, 4, 3, 5]).issuperset({1, 2, 3})\n            False\n        ')), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='item', ctx=Load()), ops=[In()], comparators=[Name(id='self', ctx=Load())]), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='other', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='symmetric_difference', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the symmetric difference of two OrderedSets as a new set.\n        That is, the new set will contain all elements that are in exactly\n        one of the sets.\n\n        Their order will be preserved, with elements from `self` preceding\n        elements from `other`.\n\n        Example:\n            >>> this = OrderedSet([1, 4, 3, 5, 7])\n            >>> other = OrderedSet([9, 7, 1, 3, 2])\n            >>> this.symmetric_difference(other)\n            OrderedSet([4, 5, 9, 2])\n        ')), Assign(targets=[Name(id='cls', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='OrderedSet', ctx=Load())], keywords=[]), body=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), orelse=Name(id='OrderedSet', ctx=Load()))), Assign(targets=[Name(id='diff1', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='difference', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), Assign(targets=[Name(id='diff2', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]), attr='difference', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='diff1', ctx=Load()), attr='union', ctx=Load()), args=[Name(id='diff2', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_update_items', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='items')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Replace the 'items' list of this OrderedSet with a new one, updating\n        self.map accordingly.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Store())], value=Name(id='items', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='map', ctx=Store())], value=DictComp(key=Name(id='item', ctx=Load()), value=Name(id='idx', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[]), FunctionDef(name='difference_update', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='sets'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Update this OrderedSet to remove items from one or more other sets.\n\n        Example:\n            >>> this = OrderedSet([1, 2, 3])\n            >>> this.difference_update(OrderedSet([2, 4]))\n            >>> print(this)\n            OrderedSet([1, 3])\n\n            >>> this = OrderedSet([1, 2, 3, 4, 5])\n            >>> this.difference_update(OrderedSet([2, 4]), OrderedSet([1, 4, 6]))\n            >>> print(this)\n            OrderedSet([3, 5])\n        ')), Assign(targets=[Name(id='items_to_remove', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='other', ctx=Store()), iter=Name(id='sets', ctx=Load()), body=[AugAssign(target=Name(id='items_to_remove', ctx=Store()), op=BitOr(), value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_update_items', ctx=Load()), args=[ListComp(elt=Name(id='item', ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), ifs=[Compare(left=Name(id='item', ctx=Load()), ops=[NotIn()], comparators=[Name(id='items_to_remove', ctx=Load())])], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='intersection_update', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Update this OrderedSet to keep only items in another set, preserving\n        their order in this set.\n\n        Example:\n            >>> this = OrderedSet([1, 4, 3, 5, 7])\n            >>> other = OrderedSet([9, 7, 1, 3, 2])\n            >>> this.intersection_update(other)\n            >>> print(this)\n            OrderedSet([1, 3, 7])\n        ')), Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_update_items', ctx=Load()), args=[ListComp(elt=Name(id='item', ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), ifs=[Compare(left=Name(id='item', ctx=Load()), ops=[In()], comparators=[Name(id='other', ctx=Load())])], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='symmetric_difference_update', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Update this OrderedSet to remove items from another set, then\n        add items from the other set that were not present in this set.\n\n        Example:\n            >>> this = OrderedSet([1, 4, 3, 5, 7])\n            >>> other = OrderedSet([9, 7, 1, 3, 2])\n            >>> this.symmetric_difference_update(other)\n            >>> print(this)\n            OrderedSet([4, 5, 9, 2])\n        ')), Assign(targets=[Name(id='items_to_add', ctx=Store())], value=ListComp(elt=Name(id='item', ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='other', ctx=Load()), ifs=[Compare(left=Name(id='item', ctx=Load()), ops=[NotIn()], comparators=[Name(id='self', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='items_to_remove', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_update_items', ctx=Load()), args=[BinOp(left=ListComp(elt=Name(id='item', ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), ifs=[Compare(left=Name(id='item', ctx=Load()), ops=[NotIn()], comparators=[Name(id='items_to_remove', ctx=Load())])], is_async=0)]), op=Add(), right=Name(id='items_to_add', ctx=Load()))], keywords=[]))], decorator_list=[])], decorator_list=[])], type_ignores=[])