Module(body=[Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), Import(names=[alias(name='abc')]), Import(names=[alias(name='csv')]), Import(names=[alias(name='sys')]), ImportFrom(names=[alias(name='zipp')], level=2), Import(names=[alias(name='email')]), Import(names=[alias(name='pathlib')]), Import(names=[alias(name='operator')]), Import(names=[alias(name='textwrap')]), Import(names=[alias(name='warnings')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='posixpath')]), Import(names=[alias(name='collections')]), ImportFrom(names=[alias(name='_adapters'), alias(name='_meta'), alias(name='_py39compat')], level=1), ImportFrom(module='_collections', names=[alias(name='FreezableDefaultDict'), alias(name='Pair')], level=1), ImportFrom(module='_compat', names=[alias(name='NullFinder'), alias(name='install'), alias(name='pypy_partial')], level=1), ImportFrom(module='_functools', names=[alias(name='method_cache'), alias(name='pass_none')], level=1), ImportFrom(module='_itertools', names=[alias(name='always_iterable'), alias(name='unique_everseen')], level=1), ImportFrom(module='_meta', names=[alias(name='PackageMetadata'), alias(name='SimplePath')], level=1), ImportFrom(module='contextlib', names=[alias(name='suppress')], level=0), ImportFrom(module='importlib', names=[alias(name='import_module')], level=0), ImportFrom(module='importlib.abc', names=[alias(name='MetaPathFinder')], level=0), ImportFrom(module='itertools', names=[alias(name='starmap')], level=0), ImportFrom(module='typing', names=[alias(name='List'), alias(name='Mapping'), alias(name='Optional')], level=0), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Distribution'), Constant(value='DistributionFinder'), Constant(value='PackageMetadata'), Constant(value='PackageNotFoundError'), Constant(value='distribution'), Constant(value='distributions'), Constant(value='entry_points'), Constant(value='files'), Constant(value='metadata'), Constant(value='packages_distributions'), Constant(value='requires'), Constant(value='version')], ctx=Load())), ClassDef(name='PackageNotFoundError', bases=[Name(id='ModuleNotFoundError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The package was not found.')), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='No package metadata was found for '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1)]))], decorator_list=[]), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store())], ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load())), Return(value=Name(id='name', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())])], decorator_list=[]), ClassDef(name='Sectioned', bases=[], keywords=[], body=[Expr(value=Constant(value="\n    A simple entry point config parser for performance\n\n    >>> for item in Sectioned.read(Sectioned._sample):\n    ...     print(item)\n    Pair(name='sec1', value='# comments ignored')\n    Pair(name='sec1', value='a = 1')\n    Pair(name='sec1', value='b = 2')\n    Pair(name='sec2', value='a = 2')\n\n    >>> res = Sectioned.section_pairs(Sectioned._sample)\n    >>> item = next(res)\n    >>> item.name\n    'sec1'\n    >>> item.value\n    Pair(name='a', value='1')\n    >>> item = next(res)\n    >>> item.value\n    Pair(name='b', value='2')\n    >>> item = next(res)\n    >>> item.name\n    'sec2'\n    >>> item.value\n    Pair(name='a', value='2')\n    >>> list(res)\n    []\n    ")), Assign(targets=[Name(id='_sample', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='textwrap', ctx=Load()), attr='dedent', ctx=Load()), args=[Constant(value='\n        [sec1]\n        # comments ignored\n        a = 1\n        b = 2\n\n        [sec2]\n        a = 2\n        ')], keywords=[]), attr='lstrip', ctx=Load()), args=[], keywords=[])), FunctionDef(name='section_pairs', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=GeneratorExp(elt=Call(func=Attribute(value=Name(id='section', ctx=Load()), attr='_replace', ctx=Load()), args=[], keywords=[keyword(arg='value', value=Call(func=Attribute(value=Name(id='Pair', ctx=Load()), attr='parse', ctx=Load()), args=[Attribute(value=Name(id='section', ctx=Load()), attr='value', ctx=Load())], keywords=[]))]), generators=[comprehension(target=Name(id='section', ctx=Store()), iter=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='read', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[keyword(arg='filter_', value=Attribute(value=Name(id='cls', ctx=Load()), attr='valid', ctx=Load()))]), ifs=[Compare(left=Attribute(value=Name(id='section', ctx=Load()), attr='name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])], is_async=0)]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='read', args=arguments(posonlyargs=[], args=[arg(arg='text'), arg(arg='filter_')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Name(id='filter', ctx=Load()), args=[Name(id='filter_', ctx=Load()), Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='str', ctx=Load()), attr='strip', ctx=Load()), Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=Constant(value=None)), For(target=Name(id='value', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[Assign(targets=[Name(id='section_match', ctx=Store())], value=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='[')], keywords=[]), Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value=']')], keywords=[])])), If(test=Name(id='section_match', ctx=Load()), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='strip', ctx=Load()), args=[Constant(value='[]')], keywords=[])), Continue()], orelse=[]), Expr(value=Yield(value=Call(func=Name(id='Pair', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='valid', args=arguments(posonlyargs=[], args=[arg(arg='line')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Name(id='line', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='#')], keywords=[]))]))], decorator_list=[Name(id='staticmethod', ctx=Load())])], decorator_list=[]), ClassDef(name='DeprecatedTuple', bases=[], keywords=[], body=[Expr(value=Constant(value="\n    Provide subscript item access for backward compatibility.\n\n    >>> recwarn = getfixture('recwarn')\n    >>> ep = EntryPoint(name='name', value='value', group='group')\n    >>> ep[:]\n    ('name', 'value', 'group')\n    >>> ep[0]\n    'name'\n    >>> len(recwarn)\n    1\n    ")), Assign(targets=[Name(id='_warn', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), Constant(value='EntryPoint tuple interface is deprecated. Access members by name.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Call(func=Name(id='pypy_partial', ctx=Load()), args=[Constant(value=2)], keywords=[]))])), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_warn', ctx=Load()), args=[], keywords=[])), Return(value=Subscript(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_key', ctx=Load()), args=[], keywords=[]), slice=Name(id='item', ctx=Load()), ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='EntryPoint', bases=[Name(id='DeprecatedTuple', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="An entry point as defined by Python packaging conventions.\n\n    See `the packaging docs on entry points\n    <https://packaging.python.org/specifications/entry-points/>`_\n    for more information.\n\n    >>> ep = EntryPoint(\n    ...     name=None, group=None, value='package.module:attr [extra1, extra2]')\n    >>> ep.module\n    'package.module'\n    >>> ep.attr\n    'attr'\n    >>> ep.extras\n    ['extra1', 'extra2']\n    ")), Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='(?P<module>[\\w.]+)\\s*(:\\s*(?P<attr>[\\w.]+)\\s*)?((?P<extras>\\[.*\\])\\s*)?$')], keywords=[])), Expr(value=Constant(value="\n    A regular expression describing the syntax for an entry point,\n    which might look like:\n\n        - module\n        - package.module\n        - package.module:attribute\n        - package.module:object.attribute\n        - package.module:attr [extra1, extra2]\n\n    Other combinations are possible as well.\n\n    The expression is lenient about whitespace around the ':',\n    following the attr, and following any extras.\n    ")), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='value', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='group', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='dist', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='Distribution'), ctx=Load()), value=Constant(value=None), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='value'), arg(arg='group')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='update', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load())), keyword(arg='group', value=Name(id='group', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='load', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Load the entry point from its definition. If only a module\n        is indicated by the value, return that module. Otherwise,\n        return the named object.\n        ')), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()), attr='match', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Name(id='import_module', ctx=Load()), args=[Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='module')], keywords=[])], keywords=[])), Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Name(id='filter', ctx=Load()), args=[Constant(value=None), Call(func=Attribute(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='attr')], keywords=[]), Constant(value='')]), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='reduce', ctx=Load()), args=[Name(id='getattr', ctx=Load()), Name(id='attrs', ctx=Load()), Name(id='module', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='module', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()), attr='match', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='module')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='attr', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()), attr='match', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='attr')], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='extras', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()), attr='match', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='findall', ctx=Load()), args=[Constant(value='\\w+'), BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='extras')], keywords=[]), Constant(value='')])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_for', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='update', ctx=Load()), args=[], keywords=[keyword(arg='dist', value=Name(id='dist', ctx=Load()))])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='matches', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='params'), defaults=[]), body=[Expr(value=Constant(value="\n        EntryPoint matches the given parameters.\n\n        >>> ep = EntryPoint(group='foo', name='bar', value='bing:bong [extra1, extra2]')\n        >>> ep.matches(group='foo')\n        True\n        >>> ep.matches(name='bar', value='bing:bong [extra1, extra2]')\n        True\n        >>> ep.matches(group='foo', name='other')\n        False\n        >>> ep.matches()\n        True\n        >>> ep.matches(extras=['extra1', 'extra2'])\n        True\n        >>> ep.matches(module='bing')\n        True\n        >>> ep.matches(attr='bong')\n        True\n        ")), Assign(targets=[Name(id='attrs', ctx=Store())], value=GeneratorExp(elt=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='param', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='param', ctx=Store()), iter=Name(id='params', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Name(id='all', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='eq', ctx=Load()), Call(func=Attribute(value=Name(id='params', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), Name(id='attrs', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_key', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='group', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__lt__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_key', ctx=Load()), args=[], keywords=[]), ops=[Lt()], comparators=[Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='_key', ctx=Load()), args=[], keywords=[])]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_key', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='_key', ctx=Load()), args=[], keywords=[])]))], decorator_list=[]), FunctionDef(name='__setattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Constant(value='EntryPoint objects are immutable.')], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='EntryPoint(name='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=114), Constant(value=', value='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load()), conversion=114), Constant(value=', group='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='group', ctx=Load()), conversion=114), Constant(value=')')]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_key', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='EntryPoints', bases=[Name(id='tuple', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    An immutable collection of selectable EntryPoint objects.\n    ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Get the EntryPoint in self matching name.\n        ')), Try(body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='select', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load()))])], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Raise(exc=Call(func=Name(id='KeyError', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='select', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='params'), defaults=[]), body=[Expr(value=Constant(value='\n        Select entry points from self that match the\n        given parameters (typically group and/or name).\n        ')), Return(value=Call(func=Name(id='EntryPoints', ctx=Load()), args=[GeneratorExp(elt=Name(id='ep', ctx=Load()), generators=[comprehension(target=Name(id='ep', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='_py39compat', ctx=Load()), attr='ep_matches', ctx=Load()), args=[Name(id='ep', ctx=Load())], keywords=[keyword(value=Name(id='params', ctx=Load()))])], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='names', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the set of all names of all entry points.\n        ')), Return(value=SetComp(elt=Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), generators=[comprehension(target=Name(id='ep', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='groups', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the set of all groups of all entry points.\n        ')), Return(value=SetComp(elt=Attribute(value=Name(id='ep', ctx=Load()), attr='group', ctx=Load()), generators=[comprehension(target=Name(id='ep', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_from_text_for', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='text'), arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='ep', ctx=Load()), attr='_for', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='ep', ctx=Store()), iter=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_from_text', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_from_text', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=GeneratorExp(elt=Call(func=Name(id='EntryPoint', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Attribute(value=Name(id='item', ctx=Load()), attr='value', ctx=Load()), attr='name', ctx=Load())), keyword(arg='value', value=Attribute(value=Attribute(value=Name(id='item', ctx=Load()), attr='value', ctx=Load()), attr='value', ctx=Load())), keyword(arg='group', value=Attribute(value=Name(id='item', ctx=Load()), attr='name', ctx=Load()))]), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Call(func=Attribute(value=Name(id='Sectioned', ctx=Load()), attr='section_pairs', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='text', ctx=Load()), Constant(value='')])], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[Name(id='staticmethod', ctx=Load())])], decorator_list=[]), ClassDef(name='PackagePath', bases=[Attribute(value=Name(id='pathlib', ctx=Load()), attr='PurePosixPath', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A reference to a path in a package')), FunctionDef(name='read_text', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='encoding')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='utf-8')]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='locate', ctx=Load()), args=[], keywords=[]), attr='open', ctx=Load()), args=[], keywords=[keyword(arg='encoding', value=Name(id='encoding', ctx=Load()))]), optional_vars=Name(id='stream', ctx=Store()))], body=[Return(value=Call(func=Attribute(value=Name(id='stream', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='read_binary', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='locate', ctx=Load()), args=[], keywords=[]), attr='open', ctx=Load()), args=[Constant(value='rb')], keywords=[]), optional_vars=Name(id='stream', ctx=Store()))], body=[Return(value=Call(func=Attribute(value=Name(id='stream', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='locate', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a path-like object for this path')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load()), attr='locate_file', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='FileHash', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='spec')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='mode', ctx=Store()), Name(id='_', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='spec', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value='=')], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<FileHash mode: '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='mode', ctx=Load()), conversion=-1), Constant(value=' value: '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load()), conversion=-1), Constant(value='>')]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Distribution', bases=[], keywords=[keyword(arg='metaclass', value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()))], body=[Expr(value=Constant(value='A Python distribution package.')), FunctionDef(name='read_text', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='filename')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Attempt to load metadata file given by the name.\n\n        :param filename: The name of the file in the distribution info.\n        :return: The text if found, otherwise None.\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())]), FunctionDef(name='locate_file', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Given a path to a file in this distribution, return a path\n        to it.\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())]), FunctionDef(name='from_name', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the Distribution for the given package name.\n\n        :param name: The name of the distribution package to search for.\n        :return: The Distribution instance (or subclass thereof) for the named\n            package, if found.\n        :raises PackageNotFoundError: When the named package's distribution\n            metadata cannot be found.\n        :raises ValueError: When an invalid value is supplied for name.\n        ")), If(test=UnaryOp(op=Not(), operand=Name(id='name', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='A distribution name is required.')], keywords=[]))], orelse=[]), Try(body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='discover', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load()))])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Raise(exc=Call(func=Name(id='PackageNotFoundError', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='discover', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Return an iterable of Distribution objects for all packages.\n\n        Pass a ``context`` or pass keyword arguments for constructing\n        a context.\n\n        :context: A ``DistributionFinder.Context`` object.\n        :return: Iterable of Distribution objects for all packages.\n        ')), Assign(targets=[Name(id='context', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='context'), Constant(value=None)], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='context', ctx=Load()), Name(id='kwargs', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot accept context and kwargs')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='context', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='context', ctx=Load()), Call(func=Attribute(value=Name(id='DistributionFinder', ctx=Load()), attr='Context', ctx=Load()), args=[], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='resolver', ctx=Load()), args=[Name(id='context', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='resolver', ctx=Store()), iter=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_discover_resolvers', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='at', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a Distribution for the indicated metadata path\n\n        :param path: a string or path-like object\n        :return: a concrete Distribution instance for the path\n        ')), Return(value=Call(func=Name(id='PathDistribution', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_discover_resolvers', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Search the meta_path for resolvers.')), Assign(targets=[Name(id='declared', ctx=Store())], value=GeneratorExp(elt=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='finder', ctx=Load()), Constant(value='find_distributions'), Constant(value=None)], keywords=[]), generators=[comprehension(target=Name(id='finder', ctx=Store()), iter=Attribute(value=Name(id='sys', ctx=Load()), attr='meta_path', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Name(id='filter', ctx=Load()), args=[Constant(value=None), Name(id='declared', ctx=Load())], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='metadata', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the parsed metadata for this Distribution.\n\n        The returned object will have keys that name the various bits of\n        metadata.  See PEP 566 for details.\n        ')), Assign(targets=[Name(id='text', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='METADATA')], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='PKG-INFO')], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='')], keywords=[])])), Return(value=Call(func=Attribute(value=Name(id='_adapters', ctx=Load()), attr='Message', ctx=Load()), args=[Call(func=Attribute(value=Name(id='email', ctx=Load()), attr='message_from_string', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Attribute(value=Name(id='_meta', ctx=Load()), attr='PackageMetadata', ctx=Load())), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the 'Name' metadata for the distribution package.")), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), slice=Constant(value='Name'), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_normalized_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a normalized version of the name.')), Return(value=Call(func=Attribute(value=Name(id='Prepared', ctx=Load()), attr='normalize', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the 'Version' metadata for the distribution package.")), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), slice=Constant(value='Version'), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='entry_points', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='EntryPoints', ctx=Load()), attr='_from_text_for', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='entry_points.txt')], keywords=[]), Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Files in this distribution.\n\n        :return: List of PackagePath for this distribution or None\n\n        Result is `None` if the metadata file that enumerates files\n        (i.e. RECORD for dist-info or SOURCES.txt for egg-info) is\n        missing.\n        Result may be empty if the metadata exists but is empty.\n        ')), FunctionDef(name='make_file', args=arguments(posonlyargs=[], args=[arg(arg='name'), arg(arg='hash'), arg(arg='size_str')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='PackagePath', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='hash', ctx=Store())], value=IfExp(test=Name(id='hash', ctx=Load()), body=Call(func=Name(id='FileHash', ctx=Load()), args=[Name(id='hash', ctx=Load())], keywords=[]), orelse=Constant(value=None))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='size', ctx=Store())], value=IfExp(test=Name(id='size_str', ctx=Load()), body=Call(func=Name(id='int', ctx=Load()), args=[Name(id='size_str', ctx=Load())], keywords=[]), orelse=Constant(value=None))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='dist', ctx=Store())], value=Name(id='self', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='make_files', args=arguments(posonlyargs=[], args=[arg(arg='lines')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='starmap', ctx=Load()), args=[Name(id='make_file', ctx=Load()), Call(func=Attribute(value=Name(id='csv', ctx=Load()), attr='reader', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[Name(id='pass_none', ctx=Load())]), Return(value=Call(func=Name(id='make_files', ctx=Load()), args=[BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_read_files_distinfo', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_read_files_egginfo', ctx=Load()), args=[], keywords=[])])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_read_files_distinfo', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read the lines of RECORD\n        ')), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='RECORD')], keywords=[])), Return(value=BoolOp(op=And(), values=[Name(id='text', ctx=Load()), Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])]))], decorator_list=[]), FunctionDef(name='_read_files_egginfo', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        SOURCES.txt might contain literal commas, so wrap each line\n        in quotes.\n        ')), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='SOURCES.txt')], keywords=[])), Return(value=BoolOp(op=And(), values=[Name(id='text', ctx=Load()), Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Constant(value='"{}"'), attr='format', ctx=Load()), Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])], keywords=[])]))], decorator_list=[]), FunctionDef(name='requires', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Generated requirements specified for this Distribution')), Assign(targets=[Name(id='reqs', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_read_dist_info_reqs', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_read_egg_info_reqs', ctx=Load()), args=[], keywords=[])])), Return(value=BoolOp(op=And(), values=[Name(id='reqs', ctx=Load()), Call(func=Name(id='list', ctx=Load()), args=[Name(id='reqs', ctx=Load())], keywords=[])]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_read_dist_info_reqs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='get_all', ctx=Load()), args=[Constant(value='Requires-Dist')], keywords=[]))], decorator_list=[]), FunctionDef(name='_read_egg_info_reqs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='requires.txt')], keywords=[])), Return(value=Call(func=Call(func=Name(id='pass_none', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_deps_from_requires_text', ctx=Load())], keywords=[]), args=[Name(id='source', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_deps_from_requires_text', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='source')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_convert_egg_info_reqs_to_simple_reqs', ctx=Load()), args=[Call(func=Attribute(value=Name(id='Sectioned', ctx=Load()), attr='read', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_convert_egg_info_reqs_to_simple_reqs', args=arguments(posonlyargs=[], args=[arg(arg='sections')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Historically, setuptools would solicit and store 'extra'\n        requirements, including those with environment markers,\n        in separate sections. More modern tools expect each\n        dependency to be defined separately, with any relevant\n        extras and environment markers attached directly to that\n        requirement. This method converts the former to the\n        latter. See _test_deps_from_requires_text for an example.\n        ")), FunctionDef(name='make_condition', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Name(id='name', ctx=Load()), JoinedStr(values=[Constant(value='extra == "'), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='"')])]))], decorator_list=[]), FunctionDef(name='quoted_marker', args=arguments(posonlyargs=[], args=[arg(arg='section')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='section', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='section', ctx=Load()), Constant(value='')])), Assign(targets=[Tuple(elts=[Name(id='extra', ctx=Store()), Name(id='sep', ctx=Store()), Name(id='markers', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='section', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value=':')], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='extra', ctx=Load()), Name(id='markers', ctx=Load())]), body=[Assign(targets=[Name(id='markers', ctx=Store())], value=JoinedStr(values=[Constant(value='('), FormattedValue(value=Name(id='markers', ctx=Load()), conversion=-1), Constant(value=')')]))], orelse=[]), Assign(targets=[Name(id='conditions', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='filter', ctx=Load()), args=[Constant(value=None), List(elts=[Name(id='markers', ctx=Load()), Call(func=Name(id='make_condition', ctx=Load()), args=[Name(id='extra', ctx=Load())], keywords=[])], ctx=Load())], keywords=[])], keywords=[])), Return(value=IfExp(test=Name(id='conditions', ctx=Load()), body=BinOp(left=Constant(value='; '), op=Add(), right=Call(func=Attribute(value=Constant(value=' and '), attr='join', ctx=Load()), args=[Name(id='conditions', ctx=Load())], keywords=[])), orelse=Constant(value='')))], decorator_list=[]), FunctionDef(name='url_req_space', args=arguments(posonlyargs=[], args=[arg(arg='req')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n            PEP 508 requires a space between the url_spec and the quoted_marker.\n            Ref python/importlib_metadata#357.\n            ')), Return(value=BinOp(left=Constant(value=' '), op=Mult(), right=Compare(left=Constant(value='@'), ops=[In()], comparators=[Name(id='req', ctx=Load())])))], decorator_list=[]), For(target=Name(id='section', ctx=Store()), iter=Name(id='sections', ctx=Load()), body=[Assign(targets=[Name(id='space', ctx=Store())], value=Call(func=Name(id='url_req_space', ctx=Load()), args=[Attribute(value=Name(id='section', ctx=Load()), attr='value', ctx=Load())], keywords=[])), Expr(value=Yield(value=BinOp(left=BinOp(left=Attribute(value=Name(id='section', ctx=Load()), attr='value', ctx=Load()), op=Add(), right=Name(id='space', ctx=Load())), op=Add(), right=Call(func=Name(id='quoted_marker', ctx=Load()), args=[Attribute(value=Name(id='section', ctx=Load()), attr='name', ctx=Load())], keywords=[]))))], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())])], decorator_list=[]), ClassDef(name='DistributionFinder', bases=[Name(id='MetaPathFinder', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A MetaPathFinder capable of discovering installed distributions.\n    ')), ClassDef(name='Context', bases=[], keywords=[], body=[Expr(value=Constant(value='\n        Keyword arguments presented by the caller to\n        ``distributions()`` or ``Distribution.discover()``\n        to narrow the scope of a search for distributions\n        in all DistributionFinders.\n\n        Each DistributionFinder may expect any parameters\n        and should attempt to honor the canonical\n        parameters defined below when appropriate.\n        ')), Assign(targets=[Name(id='name', ctx=Store())], value=Constant(value=None)), Expr(value=Constant(value='\n        Specific name for which a distribution finder should match.\n        A name of ``None`` matches all distributions.\n        ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='update', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='path', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n            The sequence of directory path that a distribution finder\n            should search.\n\n            Typically refers to Python installed package paths such as\n            "site-packages" directories and defaults to ``sys.path``.\n            ')), Return(value=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='get', ctx=Load()), args=[Constant(value='path'), Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())])], decorator_list=[]), FunctionDef(name='find_distributions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='context')], kwonlyargs=[], kw_defaults=[], defaults=[Call(func=Name(id='Context', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Constant(value='\n        Find distributions.\n\n        Return an iterable of all Distribution instances capable of\n        loading the metadata for packages matching the ``context``,\n        a DistributionFinder.Context instance.\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())])], decorator_list=[]), ClassDef(name='FastPath', bases=[], keywords=[], body=[Expr(value=Constant(value="\n    Micro-optimized class for searching a path for\n    children.\n\n    >>> FastPath('').children()\n    ['...']\n    ")), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='root')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='lru_cache', ctx=Load()), args=[], keywords=[])]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='root')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Store())], value=Name(id='root', ctx=Load()))], decorator_list=[]), FunctionDef(name='joinpath', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='child')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load()), Name(id='child', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='children', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='suppress', ctx=Load()), args=[Name(id='Exception', ctx=Load())], keywords=[]))], body=[Return(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load()), Constant(value='.')])], keywords=[]))]), With(items=[withitem(context_expr=Call(func=Name(id='suppress', ctx=Load()), args=[Name(id='Exception', ctx=Load())], keywords=[]))], body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='zip_children', ctx=Load()), args=[], keywords=[]))]), Return(value=List(elts=[], ctx=Load()))], decorator_list=[]), FunctionDef(name='zip_children', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='zip_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='zipp', ctx=Load()), attr='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load())], keywords=[])), Assign(targets=[Name(id='names', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='zip_path', ctx=Load()), attr='root', ctx=Load()), attr='namelist', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='joinpath', ctx=Store())], value=Attribute(value=Name(id='zip_path', ctx=Load()), attr='joinpath', ctx=Load())), Return(value=Call(func=Attribute(value=Name(id='dict', ctx=Load()), attr='fromkeys', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Call(func=Attribute(value=Name(id='child', ctx=Load()), attr='split', ctx=Load()), args=[Attribute(value=Name(id='posixpath', ctx=Load()), attr='sep', ctx=Load()), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load()), generators=[comprehension(target=Name(id='child', ctx=Store()), iter=Name(id='names', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='search', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='lookup', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='mtime', ctx=Load())], keywords=[]), attr='search', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='mtime', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='suppress', ctx=Load()), args=[Name(id='OSError', ctx=Load())], keywords=[]))], body=[Return(value=Attribute(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='stat', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load())], keywords=[]), attr='st_mtime', ctx=Load()))]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='lookup', ctx=Load()), attr='cache_clear', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='lookup', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mtime')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Lookup', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[Name(id='method_cache', ctx=Load())])], decorator_list=[]), ClassDef(name='Lookup', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path', annotation=Name(id='FastPath', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='base', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Attribute(value=Name(id='path', ctx=Load()), attr='root', ctx=Load())], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='base_is_egg', ctx=Store())], value=Call(func=Attribute(value=Name(id='base', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.egg')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='infos', ctx=Store())], value=Call(func=Name(id='FreezableDefaultDict', ctx=Load()), args=[Name(id='list', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='eggs', ctx=Store())], value=Call(func=Name(id='FreezableDefaultDict', ctx=Load()), args=[Name(id='list', ctx=Load())], keywords=[])), For(target=Name(id='child', ctx=Store()), iter=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='children', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='low', ctx=Store())], value=Call(func=Attribute(value=Name(id='child', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Attribute(value=Name(id='low', ctx=Load()), attr='endswith', ctx=Load()), args=[Tuple(elts=[Constant(value='.dist-info'), Constant(value='.egg-info')], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='low', ctx=Load()), attr='rpartition', ctx=Load()), args=[Constant(value='.')], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value='-')], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='normalized', ctx=Store())], value=Call(func=Attribute(value=Name(id='Prepared', ctx=Load()), attr='normalize', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='infos', ctx=Load()), slice=Name(id='normalized', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Name(id='child', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Name(id='base_is_egg', ctx=Load()), Compare(left=Name(id='low', ctx=Load()), ops=[Eq()], comparators=[Constant(value='egg-info')])]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='base', ctx=Load()), attr='rpartition', ctx=Load()), args=[Constant(value='.')], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value='-')], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='legacy_normalized', ctx=Store())], value=Call(func=Attribute(value=Name(id='Prepared', ctx=Load()), attr='legacy_normalize', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='eggs', ctx=Load()), slice=Name(id='legacy_normalized', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Name(id='child', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])])], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='infos', ctx=Load()), attr='freeze', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='eggs', ctx=Load()), attr='freeze', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='search', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prepared')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='infos', ctx=Store())], value=IfExp(test=Name(id='prepared', ctx=Load()), body=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='infos', ctx=Load()), slice=Attribute(value=Name(id='prepared', ctx=Load()), attr='normalized', ctx=Load()), ctx=Load()), orelse=Call(func=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='infos', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))), Assign(targets=[Name(id='eggs', ctx=Store())], value=IfExp(test=Name(id='prepared', ctx=Load()), body=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='eggs', ctx=Load()), slice=Attribute(value=Name(id='prepared', ctx=Load()), attr='legacy_normalized', ctx=Load()), ctx=Load()), orelse=Call(func=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='eggs', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))), Return(value=Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), args=[Name(id='infos', ctx=Load()), Name(id='eggs', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Prepared', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    A prepared search for metadata on a possibly-named package.\n    ')), Assign(targets=[Name(id='normalized', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='legacy_normalized', ctx=Store())], value=Constant(value=None)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load())), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return()], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='normalized', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='normalize', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='legacy_normalized', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='legacy_normalize', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='normalize', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        PEP 503 normalization plus dashes as underscores.\n        ')), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='[-_.]+'), Constant(value='-'), Name(id='name', ctx=Load())], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='_')], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='legacy_normalize', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Normalize the package name as found in the convention in\n        older packaging tools versions and specs.\n        ')), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='_')], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='bool', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='MetadataPathFinder', bases=[Name(id='NullFinder', ctx=Load()), Name(id='DistributionFinder', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A degenerate finder for distribution packages on the file system.\n\n    This finder supplies only a find_distributions() method for versions\n    of Python that do not have a PathFinder find_distributions().\n    ')), FunctionDef(name='find_distributions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='context')], kwonlyargs=[], kw_defaults=[], defaults=[Call(func=Attribute(value=Name(id='DistributionFinder', ctx=Load()), attr='Context', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Constant(value='\n        Find distributions.\n\n        Return an iterable of all Distribution instances capable of\n        loading the metadata for packages matching ``context.name``\n        (or all names if ``None`` indicated) along the paths in the list\n        of directories ``context.path``.\n        ')), Assign(targets=[Name(id='found', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_search_paths', ctx=Load()), args=[Attribute(value=Name(id='context', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='context', ctx=Load()), attr='path', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='PathDistribution', ctx=Load()), Name(id='found', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_search_paths', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name'), arg(arg='paths')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find metadata directories in paths heuristically.')), Assign(targets=[Name(id='prepared', ctx=Store())], value=Call(func=Name(id='Prepared', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='prepared', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='path', ctx=Store()), iter=Call(func=Name(id='map', ctx=Load()), args=[Name(id='FastPath', ctx=Load()), Name(id='paths', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='invalidate_caches', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='FastPath', ctx=Load()), attr='__new__', ctx=Load()), attr='cache_clear', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], decorator_list=[Name(id='install', ctx=Load())]), ClassDef(name='PathDistribution', bases=[Name(id='Distribution', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path', annotation=Name(id='SimplePath', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Construct a distribution.\n\n        :param path: SimplePath indicating the metadata directory.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_path', ctx=Store())], value=Name(id='path', ctx=Load()))], decorator_list=[]), FunctionDef(name='read_text', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='filename')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='suppress', ctx=Load()), args=[Name(id='FileNotFoundError', ctx=Load()), Name(id='IsADirectoryError', ctx=Load()), Name(id='KeyError', ctx=Load()), Name(id='NotADirectoryError', ctx=Load()), Name(id='PermissionError', ctx=Load())], keywords=[]))], body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), attr='read_text', ctx=Load()), args=[], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]))])], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='read_text', ctx=Load()), attr='__doc__', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='Distribution', ctx=Load()), attr='read_text', ctx=Load()), attr='__doc__', ctx=Load())), FunctionDef(name='locate_file', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_path', ctx=Load()), attr='parent', ctx=Load()), op=Div(), right=Name(id='path', ctx=Load())))], decorator_list=[]), FunctionDef(name='_normalized_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Performance optimization: where possible, resolve the\n        normalized name from the file system path.\n        ')), Assign(targets=[Name(id='stem', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_path', ctx=Load())], keywords=[])], keywords=[])), Return(value=BoolOp(op=Or(), values=[Call(func=Call(func=Name(id='pass_none', ctx=Load()), args=[Attribute(value=Name(id='Prepared', ctx=Load()), attr='normalize', ctx=Load())], keywords=[]), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_name_from_stem', ctx=Load()), args=[Name(id='stem', ctx=Load())], keywords=[])], keywords=[]), Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='_normalized_name', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_name_from_stem', args=arguments(posonlyargs=[], args=[arg(arg='stem')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        >>> PathDistribution._name_from_stem('foo-3.0.egg-info')\n        'foo'\n        >>> PathDistribution._name_from_stem('CherryPy-3.0.dist-info')\n        'CherryPy'\n        >>> PathDistribution._name_from_stem('face.egg-info')\n        'face'\n        >>> PathDistribution._name_from_stem('foo.bar')\n        ")), Assign(targets=[Tuple(elts=[Name(id='filename', ctx=Store()), Name(id='ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='stem', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='ext', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value='.dist-info'), Constant(value='.egg-info')], ctx=Load())]), body=[Return()], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='sep', ctx=Store()), Name(id='rest', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='filename', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value='-')], keywords=[])), Return(value=Name(id='name', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())])], decorator_list=[]), FunctionDef(name='distribution', args=arguments(posonlyargs=[], args=[arg(arg='distribution_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the ``Distribution`` instance for the named package.\n\n    :param distribution_name: The name of the distribution package as a string.\n    :return: A ``Distribution`` instance (or subclass thereof).\n    ')), Return(value=Call(func=Attribute(value=Name(id='Distribution', ctx=Load()), attr='from_name', ctx=Load()), args=[Name(id='distribution_name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='distributions', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Get all ``Distribution`` instances in the current environment.\n\n    :return: An iterable of ``Distribution`` instances.\n    ')), Return(value=Call(func=Attribute(value=Name(id='Distribution', ctx=Load()), attr='discover', ctx=Load()), args=[], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='metadata', args=arguments(posonlyargs=[], args=[arg(arg='distribution_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the metadata for the named package.\n\n    :param distribution_name: The name of the distribution package to query.\n    :return: A PackageMetadata containing the parsed metadata.\n    ')), Return(value=Attribute(value=Call(func=Attribute(value=Name(id='Distribution', ctx=Load()), attr='from_name', ctx=Load()), args=[Name(id='distribution_name', ctx=Load())], keywords=[]), attr='metadata', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='_meta', ctx=Load()), attr='PackageMetadata', ctx=Load())), FunctionDef(name='version', args=arguments(posonlyargs=[], args=[arg(arg='distribution_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the version string for the named package.\n\n    :param distribution_name: The name of the distribution package to query.\n    :return: The version string for the package as defined in the package\'s\n        "Version" metadata key.\n    ')), Return(value=Attribute(value=Call(func=Name(id='distribution', ctx=Load()), args=[Name(id='distribution_name', ctx=Load())], keywords=[]), attr='version', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_unique', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Name(id='unique_everseen', ctx=Load())], keywords=[keyword(arg='key', value=Attribute(value=Name(id='_py39compat', ctx=Load()), attr='normalized_name', ctx=Load()))])), Expr(value=Constant(value='\nWrapper for ``distributions`` to return unique distributions by name.\n')), FunctionDef(name='entry_points', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='params'), defaults=[]), body=[Expr(value=Constant(value='Return EntryPoint objects for all installed packages.\n\n    Pass selection parameters (group or name) to filter the\n    result to entry points matching those properties (see\n    EntryPoints.select()).\n\n    :return: EntryPoints for all installed packages.\n    ')), Assign(targets=[Name(id='eps', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='dist', ctx=Load()), attr='entry_points', ctx=Load()), generators=[comprehension(target=Name(id='dist', ctx=Store()), iter=Call(func=Name(id='_unique', ctx=Load()), args=[Call(func=Name(id='distributions', ctx=Load()), args=[], keywords=[])], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='EntryPoints', ctx=Load()), args=[Name(id='eps', ctx=Load())], keywords=[]), attr='select', ctx=Load()), args=[], keywords=[keyword(value=Name(id='params', ctx=Load()))]))], decorator_list=[], returns=Name(id='EntryPoints', ctx=Load())), FunctionDef(name='files', args=arguments(posonlyargs=[], args=[arg(arg='distribution_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a list of files for the named package.\n\n    :param distribution_name: The name of the distribution package to query.\n    :return: List of files composing the distribution.\n    ')), Return(value=Attribute(value=Call(func=Name(id='distribution', ctx=Load()), args=[Name(id='distribution_name', ctx=Load())], keywords=[]), attr='files', ctx=Load()))], decorator_list=[]), FunctionDef(name='requires', args=arguments(posonlyargs=[], args=[arg(arg='distribution_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return a list of requirements for the named package.\n\n    :return: An iterator of requirements, suitable for\n        packaging.requirement.Requirement.\n    ')), Return(value=Attribute(value=Call(func=Name(id='distribution', ctx=Load()), args=[Name(id='distribution_name', ctx=Load())], keywords=[]), attr='requires', ctx=Load()))], decorator_list=[]), FunctionDef(name='packages_distributions', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return a mapping of top-level packages to their\n    distributions.\n\n    >>> import collections.abc\n    >>> pkgs = packages_distributions()\n    >>> all(isinstance(dist, collections.abc.Sequence) for dist in pkgs.values())\n    True\n    ')), Assign(targets=[Name(id='pkg_to_dist', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='defaultdict', ctx=Load()), args=[Name(id='list', ctx=Load())], keywords=[])), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Name(id='distributions', ctx=Load()), args=[], keywords=[]), body=[For(target=Name(id='pkg', ctx=Store()), iter=BoolOp(op=Or(), values=[Call(func=Name(id='_top_level_declared', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[]), Call(func=Name(id='_top_level_inferred', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='pkg_to_dist', ctx=Load()), slice=Name(id='pkg', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='dist', ctx=Load()), attr='metadata', ctx=Load()), slice=Constant(value='Name'), ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='dict', ctx=Load()), args=[Name(id='pkg_to_dist', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_top_level_declared', args=arguments(posonlyargs=[], args=[arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='top_level.txt')], keywords=[]), Constant(value='')]), attr='split', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_top_level_inferred', args=arguments(posonlyargs=[], args=[arg(arg='dist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=SetComp(elt=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='f', ctx=Load()), attr='parts', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=Subscript(value=Attribute(value=Name(id='f', ctx=Load()), attr='parts', ctx=Load()), slice=Constant(value=0), ctx=Load()), orelse=Attribute(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='with_suffix', ctx=Load()), args=[Constant(value='')], keywords=[]), attr='name', ctx=Load())), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Call(func=Name(id='always_iterable', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='files', ctx=Load())], keywords=[]), ifs=[Compare(left=Attribute(value=Name(id='f', ctx=Load()), attr='suffix', ctx=Load()), ops=[Eq()], comparators=[Constant(value='.py')])], is_async=0)]))], decorator_list=[])], type_ignores=[])