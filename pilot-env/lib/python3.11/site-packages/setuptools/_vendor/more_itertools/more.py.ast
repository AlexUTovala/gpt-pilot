Module(body=[Import(names=[alias(name='warnings')]), ImportFrom(module='collections', names=[alias(name='Counter'), alias(name='defaultdict'), alias(name='deque'), alias(name='abc')], level=0), ImportFrom(module='collections.abc', names=[alias(name='Sequence')], level=0), ImportFrom(module='functools', names=[alias(name='partial'), alias(name='reduce'), alias(name='wraps')], level=0), ImportFrom(module='heapq', names=[alias(name='merge'), alias(name='heapify'), alias(name='heapreplace'), alias(name='heappop')], level=0), ImportFrom(module='itertools', names=[alias(name='chain'), alias(name='compress'), alias(name='count'), alias(name='cycle'), alias(name='dropwhile'), alias(name='groupby'), alias(name='islice'), alias(name='repeat'), alias(name='starmap'), alias(name='takewhile'), alias(name='tee'), alias(name='zip_longest')], level=0), ImportFrom(module='math', names=[alias(name='exp'), alias(name='factorial'), alias(name='floor'), alias(name='log')], level=0), ImportFrom(module='queue', names=[alias(name='Empty'), alias(name='Queue')], level=0), ImportFrom(module='random', names=[alias(name='random'), alias(name='randrange'), alias(name='uniform')], level=0), ImportFrom(module='operator', names=[alias(name='itemgetter'), alias(name='mul'), alias(name='sub'), alias(name='gt'), alias(name='lt')], level=0), ImportFrom(module='sys', names=[alias(name='hexversion'), alias(name='maxsize')], level=0), ImportFrom(module='time', names=[alias(name='monotonic')], level=0), ImportFrom(module='recipes', names=[alias(name='consume'), alias(name='flatten'), alias(name='pairwise'), alias(name='powerset'), alias(name='take'), alias(name='unique_everseen')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='AbortThread'), Constant(value='adjacent'), Constant(value='always_iterable'), Constant(value='always_reversible'), Constant(value='bucket'), Constant(value='callback_iter'), Constant(value='chunked'), Constant(value='circular_shifts'), Constant(value='collapse'), Constant(value='collate'), Constant(value='consecutive_groups'), Constant(value='consumer'), Constant(value='countable'), Constant(value='count_cycle'), Constant(value='mark_ends'), Constant(value='difference'), Constant(value='distinct_combinations'), Constant(value='distinct_permutations'), Constant(value='distribute'), Constant(value='divide'), Constant(value='exactly_n'), Constant(value='filter_except'), Constant(value='first'), Constant(value='groupby_transform'), Constant(value='ilen'), Constant(value='interleave_longest'), Constant(value='interleave'), Constant(value='intersperse'), Constant(value='islice_extended'), Constant(value='iterate'), Constant(value='ichunked'), Constant(value='is_sorted'), Constant(value='last'), Constant(value='locate'), Constant(value='lstrip'), Constant(value='make_decorator'), Constant(value='map_except'), Constant(value='map_reduce'), Constant(value='nth_or_last'), Constant(value='nth_permutation'), Constant(value='nth_product'), Constant(value='numeric_range'), Constant(value='one'), Constant(value='only'), Constant(value='padded'), Constant(value='partitions'), Constant(value='set_partitions'), Constant(value='peekable'), Constant(value='repeat_last'), Constant(value='replace'), Constant(value='rlocate'), Constant(value='rstrip'), Constant(value='run_length'), Constant(value='sample'), Constant(value='seekable'), Constant(value='SequenceView'), Constant(value='side_effect'), Constant(value='sliced'), Constant(value='sort_together'), Constant(value='split_at'), Constant(value='split_after'), Constant(value='split_before'), Constant(value='split_when'), Constant(value='split_into'), Constant(value='spy'), Constant(value='stagger'), Constant(value='strip'), Constant(value='substrings'), Constant(value='substrings_indexes'), Constant(value='time_limited'), Constant(value='unique_to_each'), Constant(value='unzip'), Constant(value='windowed'), Constant(value='with_iter'), Constant(value='UnequalIterablesError'), Constant(value='zip_equal'), Constant(value='zip_offset'), Constant(value='windowed_complete'), Constant(value='all_unique'), Constant(value='value_chain'), Constant(value='product_index'), Constant(value='combination_index'), Constant(value='permutation_index')], ctx=Load())), Assign(targets=[Name(id='_marker', ctx=Store())], value=Call(func=Name(id='object', ctx=Load()), args=[], keywords=[])), FunctionDef(name='chunked', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n'), arg(arg='strict')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Break *iterable* into lists of length *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6], 3))\n        [[1, 2, 3], [4, 5, 6]]\n\n    By the default, the last yielded list will have fewer than *n* elements\n    if the length of *iterable* is not divisible by *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))\n        [[1, 2, 3], [4, 5, 6], [7, 8]]\n\n    To use a fill-in value instead, see the :func:`grouper` recipe.\n\n    If the length of *iterable* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    list is yielded.\n\n    ')), Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Name(id='partial', ctx=Load()), args=[Name(id='take', ctx=Load()), Name(id='n', ctx=Load()), Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])], keywords=[]), List(elts=[], ctx=Load())], keywords=[])), If(test=Name(id='strict', ctx=Load()), body=[FunctionDef(name='ret', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='chunk', ctx=Store()), iter=Name(id='iterator', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='chunk', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='n', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='iterable is not divisible by n.')], keywords=[]))], orelse=[]), Expr(value=Yield(value=Name(id='chunk', ctx=Load())))], orelse=[])], decorator_list=[]), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Name(id='ret', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[Return(value=Name(id='iterator', ctx=Load()))])], decorator_list=[]), FunctionDef(name='first', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='_marker', ctx=Load())]), body=[Expr(value=Constant(value="Return the first item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> first([0, 1, 2, 3])\n        0\n        >>> first([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n\n    :func:`first` is useful when you have a generator of expensive-to-retrieve\n    values and want any arbitrary one. It is marginally shorter than\n    ``next(iter(iterable), default)``.\n\n    ")), Try(body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), name='e', body=[If(test=Compare(left=Name(id='default', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='first() was called on an empty iterable, and no default value was provided.')], keywords=[]), cause=Name(id='e', ctx=Load()))], orelse=[]), Return(value=Name(id='default', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='last', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='_marker', ctx=Load())]), body=[Expr(value=Constant(value="Return the last item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> last([0, 1, 2, 3])\n        3\n        >>> last([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    ")), Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='Sequence', ctx=Load())], keywords=[]), body=[Return(value=Subscript(value=Name(id='iterable', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Constant(value='__reversed__')], keywords=[]), Compare(left=Name(id='hexversion', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=50856176)])]), body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])], keywords=[]))], orelse=[Return(value=Subscript(value=Call(func=Name(id='deque', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[keyword(arg='maxlen', value=Constant(value=1))]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()))])])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='IndexError', ctx=Load()), Name(id='TypeError', ctx=Load()), Name(id='StopIteration', ctx=Load())], ctx=Load()), body=[If(test=Compare(left=Name(id='default', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='last() was called on an empty iterable, and no default was provided.')], keywords=[]))], orelse=[]), Return(value=Name(id='default', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='nth_or_last', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='_marker', ctx=Load())]), body=[Expr(value=Constant(value="Return the nth or the last item of *iterable*,\n    or *default* if *iterable* is empty.\n\n        >>> nth_or_last([0, 1, 2, 3], 2)\n        2\n        >>> nth_or_last([0, 1], 2)\n        1\n        >>> nth_or_last([], 0, 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    ")), Return(value=Call(func=Name(id='last', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='iterable', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[])], keywords=[keyword(arg='default', value=Name(id='default', ctx=Load()))]))], decorator_list=[]), ClassDef(name='peekable', bases=[], keywords=[], body=[Expr(value=Constant(value='Wrap an iterator to allow lookahead and prepending elements.\n\n    Call :meth:`peek` on the result to get the value that will be returned\n    by :func:`next`. This won\'t advance the iterator:\n\n        >>> p = peekable([\'a\', \'b\'])\n        >>> p.peek()\n        \'a\'\n        >>> next(p)\n        \'a\'\n\n    Pass :meth:`peek` a default value to return that instead of raising\n    ``StopIteration`` when the iterator is exhausted.\n\n        >>> p = peekable([])\n        >>> p.peek(\'hi\')\n        \'hi\'\n\n    peekables also offer a :meth:`prepend` method, which "inserts" items\n    at the head of the iterable:\n\n        >>> p = peekable([1, 2, 3])\n        >>> p.prepend(10, 11, 12)\n        >>> next(p)\n        10\n        >>> p.peek()\n        11\n        >>> list(p)\n        [11, 12, 1, 2, 3]\n\n    peekables can be indexed. Index 0 is the item that will be returned by\n    :func:`next`, index 1 is the item after that, and so on:\n    The values up to the given index will be cached.\n\n        >>> p = peekable([\'a\', \'b\', \'c\', \'d\'])\n        >>> p[0]\n        \'a\'\n        >>> p[1]\n        \'b\'\n        >>> next(p)\n        \'a\'\n\n    Negative indexes are supported, but be aware that they will cache the\n    remaining items in the source iterator, which may require significant\n    storage.\n\n    To check whether a peekable is exhausted, check its truth value:\n\n        >>> p = peekable([\'a\', \'b\'])\n        >>> if p:  # peekable has items\n        ...     list(p)\n        [\'a\', \'b\']\n        >>> if not p:  # peekable is exhausted\n        ...     list(p)\n        []\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='peek', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='peek', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='_marker', ctx=Load())]), body=[Expr(value=Constant(value='Return the item that will be next returned from ``next()``.\n\n        Return ``default`` if there are no items left. If ``default`` is not\n        provided, raise ``StopIteration``.\n\n        ')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load())), body=[Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='next', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[If(test=Compare(left=Name(id='default', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[Raise()], orelse=[]), Return(value=Name(id='default', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[]), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), slice=Constant(value=0), ctx=Load()))], decorator_list=[]), FunctionDef(name='prepend', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='items'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Stack up items to be the next ones returned from ``next()`` or\n        ``self.peek()``. The items will be returned in\n        first in, first out order::\n\n            >>> p = peekable([1, 2, 3])\n            >>> p.prepend(10, 11, 12)\n            >>> next(p)\n            10\n            >>> list(p)\n            [11, 12, 1, 2, 3]\n\n        It is possible, by prepending items, to "resurrect" a peekable that\n        previously raised ``StopIteration``.\n\n            >>> p = peekable([])\n            >>> next(p)\n            Traceback (most recent call last):\n              ...\n            StopIteration\n            >>> p.prepend(1)\n            >>> next(p)\n            1\n            >>> next(p)\n            Traceback (most recent call last):\n              ...\n            StopIteration\n\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='extendleft', ctx=Load()), args=[Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='__next__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='popleft', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='next', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_get_slice', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='step', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='index', ctx=Load()), attr='step', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Constant(value=1), orelse=Attribute(value=Name(id='index', ctx=Load()), attr='step', ctx=Load()))), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='index', ctx=Load()), attr='start', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Constant(value=0), orelse=Attribute(value=Name(id='index', ctx=Load()), attr='start', ctx=Load()))), Assign(targets=[Name(id='stop', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='index', ctx=Load()), attr='stop', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Name(id='maxsize', ctx=Load()), orelse=Attribute(value=Name(id='index', ctx=Load()), attr='stop', ctx=Load())))], orelse=[If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='index', ctx=Load()), attr='start', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=UnaryOp(op=USub(), operand=Constant(value=1)), orelse=Attribute(value=Name(id='index', ctx=Load()), attr='start', ctx=Load()))), Assign(targets=[Name(id='stop', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='index', ctx=Load()), attr='stop', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=BinOp(left=UnaryOp(op=USub(), operand=Name(id='maxsize', ctx=Load())), op=Sub(), right=Constant(value=1)), orelse=Attribute(value=Name(id='index', ctx=Load()), attr='stop', ctx=Load())))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='slice step cannot be zero')], keywords=[]))])]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='start', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), Compare(left=Name(id='stop', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)])]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[Name(id='start', ctx=Load()), Name(id='stop', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1)), Name(id='maxsize', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cache_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[GtE()], comparators=[Name(id='cache_len', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='cache_len', ctx=Load()))], keywords=[])], keywords=[]))], orelse=[])]), Return(value=Subscript(value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load())], keywords=[]), slice=Name(id='index', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='index', ctx=Load()), Name(id='slice', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_slice', ctx=Load()), args=[Name(id='index', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='cache_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='index', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='index', ctx=Load()), ops=[GtE()], comparators=[Name(id='cache_len', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Load()), BinOp(left=BinOp(left=Name(id='index', ctx=Load()), op=Add(), right=Constant(value=1)), op=Sub(), right=Name(id='cache_len', ctx=Load()))], keywords=[])], keywords=[]))], orelse=[])]), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), slice=Name(id='index', ctx=Load()), ctx=Load()))], decorator_list=[])], decorator_list=[]), FunctionDef(name='collate', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='iterables'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value="Return a sorted merge of the items from each of several already-sorted\n    *iterables*.\n\n        >>> list(collate('ACDZ', 'AZ', 'JKL'))\n        ['A', 'A', 'C', 'D', 'J', 'K', 'L', 'Z', 'Z']\n\n    Works lazily, keeping only the next value from each iterable in memory. Use\n    :func:`collate` to, for example, perform a n-way mergesort of items that\n    don't fit in memory.\n\n    If a *key* function is specified, the iterables will be sorted according\n    to its result:\n\n        >>> key = lambda s: int(s)  # Sort by numeric value, not by string\n        >>> list(collate(['1', '10'], ['2', '11'], key=key))\n        ['1', '2', '10', '11']\n\n\n    If the *iterables* are sorted in descending order, set *reverse* to\n    ``True``:\n\n        >>> list(collate([5, 3, 1], [4, 2, 0], reverse=True))\n        [5, 4, 3, 2, 1, 0]\n\n    If the elements of the passed-in iterables are out of order, you might get\n    unexpected results.\n\n    On Python 3.5+, this function is an alias for :func:`heapq.merge`.\n\n    ")), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='collate is no longer part of more_itertools, use heapq.merge'), Name(id='DeprecationWarning', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='merge', ctx=Load()), args=[Starred(value=Name(id='iterables', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='consumer', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Decorator that automatically advances a PEP-342-style "reverse iterator"\n    to its first yield point so you don\'t have to call ``next()`` on it\n    manually.\n\n        >>> @consumer\n        ... def tally():\n        ...     i = 0\n        ...     while True:\n        ...         print(\'Thing number %s is %s.\' % (i, (yield)))\n        ...         i += 1\n        ...\n        >>> t = tally()\n        >>> t.send(\'red\')\n        Thing number 0 is red.\n        >>> t.send(\'fish\')\n        Thing number 1 is fish.\n\n    Without the decorator, you would have to call ``next(t)`` before\n    ``t.send()`` could be used.\n\n    ')), FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Assign(targets=[Name(id='gen', ctx=Store())], value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Expr(value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='gen', ctx=Load())], keywords=[])), Return(value=Name(id='gen', ctx=Load()))], decorator_list=[Call(func=Name(id='wraps', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])]), Return(value=Name(id='wrapper', ctx=Load()))], decorator_list=[]), FunctionDef(name='ilen', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the number of items in *iterable*.\n\n        >>> ilen(x for x in range(1000000) if x % 3 == 0)\n        333334\n\n    This consumes the iterable, so handle with care.\n\n    ')), Assign(targets=[Name(id='counter', ctx=Store())], value=Call(func=Name(id='count', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='deque', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='counter', ctx=Load())], keywords=[])], keywords=[keyword(arg='maxlen', value=Constant(value=0))])), Return(value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='counter', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='iterate', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='start')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return ``start``, ``func(start)``, ``func(func(start))``, ...\n\n    >>> from itertools import islice\n    >>> list(islice(iterate(lambda x: 2*x, 1), 10))\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n\n    ')), While(test=Constant(value=True), body=[Expr(value=Yield(value=Name(id='start', ctx=Load()))), Assign(targets=[Name(id='start', ctx=Store())], value=Call(func=Name(id='func', ctx=Load()), args=[Name(id='start', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='with_iter', args=arguments(posonlyargs=[], args=[arg(arg='context_manager')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Wrap an iterable in a ``with`` statement, so it closes once exhausted.\n\n    For example, this will close the file when the iterator is exhausted::\n\n        upper_lines = (line.upper() for line in with_iter(open('foo')))\n\n    Any context manager which returns an iterable is a candidate for\n    ``with_iter``.\n\n    ")), With(items=[withitem(context_expr=Name(id='context_manager', ctx=Load()), optional_vars=Name(id='iterable', ctx=Store()))], body=[Expr(value=YieldFrom(value=Name(id='iterable', ctx=Load())))])], decorator_list=[]), FunctionDef(name='one', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='too_short'), arg(arg='too_long')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Return the first item from *iterable*, which is expected to contain only\n    that item. Raise an exception if *iterable* is empty or has more than one\n    item.\n\n    :func:`one` is useful for ensuring that an iterable contains only one item.\n    For example, it can be used to retrieve the result of a database query\n    that is expected to return a single row.\n\n    If *iterable* is empty, ``ValueError`` will be raised. You may specify a\n    different exception with the *too_short* keyword:\n\n        >>> it = []\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too many items in iterable (expected 1)'\n        >>> too_short = IndexError('too few items')\n        >>> one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        IndexError: too few items\n\n    Similarly, if *iterable* contains more than one item, ``ValueError`` will\n    be raised. You may specify a different exception with the *too_long*\n    keyword:\n\n        >>> it = ['too', 'many']\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: Expected exactly one item in iterable, but got 'too',\n        'many', and perhaps more.\n        >>> too_long = RuntimeError\n        >>> one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        RuntimeError\n\n    Note that :func:`one` attempts to advance *iterable* twice to ensure there\n    is only one item. See :func:`spy` or :func:`peekable` to check iterable\n    contents less destructively.\n\n    ")), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='first_value', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), name='e', body=[Raise(exc=BoolOp(op=Or(), values=[Name(id='too_short', ctx=Load()), Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='too few items in iterable (expected 1)')], keywords=[])]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), Try(body=[Assign(targets=[Name(id='second_value', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Pass()])], orelse=[Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Constant(value='Expected exactly one item in iterable, but got {!r}, {!r}, and perhaps more.'), attr='format', ctx=Load()), args=[Name(id='first_value', ctx=Load()), Name(id='second_value', ctx=Load())], keywords=[])), Raise(exc=BoolOp(op=Or(), values=[Name(id='too_long', ctx=Load()), Call(func=Name(id='ValueError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[])]))], finalbody=[]), Return(value=Name(id='first_value', ctx=Load()))], decorator_list=[]), FunctionDef(name='distinct_permutations', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Yield successive distinct permutations of the elements in *iterable*.\n\n        >>> sorted(distinct_permutations([1, 0, 1]))\n        [(0, 1, 1), (1, 0, 1), (1, 1, 0)]\n\n    Equivalent to ``set(permutations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    Duplicate permutations arise when there are duplicated elements in the\n    input iterable. The number of items returned is\n    `n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of\n    items input, and each `x_i` is the count of a distinct item in the input\n    sequence.\n\n    If *r* is given, only the *r*-length permutations are yielded.\n\n        >>> sorted(distinct_permutations([1, 0, 1], r=2))\n        [(0, 1), (1, 0), (1, 1)]\n        >>> sorted(distinct_permutations(range(3), r=2))\n        [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]\n\n    ')), FunctionDef(name='_full', args=arguments(posonlyargs=[], args=[arg(arg='A')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[While(test=Constant(value=True), body=[Expr(value=Yield(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='A', ctx=Load())], keywords=[]))), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='size', ctx=Load()), op=Sub(), right=Constant(value=2)), UnaryOp(op=USub(), operand=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='A', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), ops=[Lt()], comparators=[Subscript(value=Name(id='A', ctx=Load()), slice=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Load())]), body=[Break()], orelse=[])], orelse=[Return()]), For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='size', ctx=Load()), op=Sub(), right=Constant(value=1)), Name(id='i', ctx=Load()), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='A', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), ops=[Lt()], comparators=[Subscript(value=Name(id='A', ctx=Load()), slice=Name(id='j', ctx=Load()), ctx=Load())]), body=[Break()], orelse=[])], orelse=[]), Assign(targets=[Tuple(elts=[Subscript(value=Name(id='A', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store()), Subscript(value=Name(id='A', ctx=Load()), slice=Name(id='j', ctx=Load()), ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='A', ctx=Load()), slice=Name(id='j', ctx=Load()), ctx=Load()), Subscript(value=Name(id='A', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())], ctx=Load())), Assign(targets=[Subscript(value=Name(id='A', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Store())], value=Subscript(value=Name(id='A', ctx=Load()), slice=Slice(upper=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='size', ctx=Load())), step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='_partial', args=arguments(posonlyargs=[], args=[arg(arg='A'), arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='head', ctx=Store()), Name(id='tail', ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='A', ctx=Load()), slice=Slice(upper=Name(id='r', ctx=Load())), ctx=Load()), Subscript(value=Name(id='A', ctx=Load()), slice=Slice(lower=Name(id='r', ctx=Load())), ctx=Load())], ctx=Load())), Assign(targets=[Name(id='right_head_indexes', ctx=Store())], value=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='r', ctx=Load()), op=Sub(), right=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[])), Assign(targets=[Name(id='left_tail_indexes', ctx=Store())], value=Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='tail', ctx=Load())], keywords=[])], keywords=[])), While(test=Constant(value=True), body=[Expr(value=Yield(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='head', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='pivot', ctx=Store())], value=Subscript(value=Name(id='tail', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Name(id='right_head_indexes', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), ops=[Lt()], comparators=[Name(id='pivot', ctx=Load())]), body=[Break()], orelse=[]), Assign(targets=[Name(id='pivot', ctx=Store())], value=Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()))], orelse=[Return()]), For(target=Name(id='j', ctx=Store()), iter=Name(id='left_tail_indexes', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='tail', ctx=Load()), slice=Name(id='j', ctx=Load()), ctx=Load()), ops=[Gt()], comparators=[Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store()), Subscript(value=Name(id='tail', ctx=Load()), slice=Name(id='j', ctx=Load()), ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='tail', ctx=Load()), slice=Name(id='j', ctx=Load()), ctx=Load()), Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())], ctx=Load())), Break()], orelse=[])], orelse=[For(target=Name(id='j', ctx=Store()), iter=Name(id='right_head_indexes', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='j', ctx=Load()), ctx=Load()), ops=[Gt()], comparators=[Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store()), Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='j', ctx=Load()), ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='j', ctx=Load()), ctx=Load()), Subscript(value=Name(id='head', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())], ctx=Load())), Break()], orelse=[])], orelse=[])]), AugAssign(target=Name(id='tail', ctx=Store()), op=Add(), value=Subscript(value=Name(id='head', ctx=Load()), slice=Slice(upper=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='r', ctx=Load())), step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Tuple(elts=[Subscript(value=Name(id='head', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load())), ctx=Store()), Subscript(value=Name(id='tail', ctx=Load()), slice=Slice(), ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='tail', ctx=Load()), slice=Slice(upper=BinOp(left=Name(id='r', ctx=Load()), op=Sub(), right=Name(id='i', ctx=Load()))), ctx=Load()), Subscript(value=Name(id='tail', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='r', ctx=Load()), op=Sub(), right=Name(id='i', ctx=Load()))), ctx=Load())], ctx=Load()))], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='items', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='size', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='r', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Name(id='size', ctx=Load()))], orelse=[]), If(test=Compare(left=Constant(value=0), ops=[Lt(), LtE()], comparators=[Name(id='r', ctx=Load()), Name(id='size', ctx=Load())]), body=[Return(value=IfExp(test=Compare(left=Name(id='r', ctx=Load()), ops=[Eq()], comparators=[Name(id='size', ctx=Load())]), body=Call(func=Name(id='_full', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]), orelse=Call(func=Name(id='_partial', ctx=Load()), args=[Name(id='items', ctx=Load()), Name(id='r', ctx=Load())], keywords=[])))], orelse=[]), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[IfExp(test=Name(id='r', ctx=Load()), body=Tuple(elts=[], ctx=Load()), orelse=Tuple(elts=[Tuple(elts=[], ctx=Load())], ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='intersperse', args=arguments(posonlyargs=[], args=[arg(arg='e'), arg(arg='iterable'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1)]), body=[Expr(value=Constant(value="Intersperse filler element *e* among the items in *iterable*, leaving\n    *n* items between each filler element.\n\n        >>> list(intersperse('!', [1, 2, 3, 4, 5]))\n        [1, '!', 2, '!', 3, '!', 4, '!', 5]\n\n        >>> list(intersperse(None, [1, 2, 3, 4, 5], n=2))\n        [1, 2, None, 3, 4, None, 5]\n\n    ")), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='n must be > 0')], keywords=[]))], orelse=[If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Call(func=Name(id='islice', ctx=Load()), args=[Call(func=Name(id='interleave', ctx=Load()), args=[Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), Name(id='iterable', ctx=Load())], keywords=[]), Constant(value=1), Constant(value=None)], keywords=[]))], orelse=[Assign(targets=[Name(id='filler', ctx=Store())], value=Call(func=Name(id='repeat', ctx=Load()), args=[List(elts=[Name(id='e', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='chunks', ctx=Store())], value=Call(func=Name(id='chunked', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='n', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='flatten', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Call(func=Name(id='interleave', ctx=Load()), args=[Name(id='filler', ctx=Load()), Name(id='chunks', ctx=Load())], keywords=[]), Constant(value=1), Constant(value=None)], keywords=[])], keywords=[]))])])], decorator_list=[]), FunctionDef(name='unique_to_each', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='iterables'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the elements from each of the input iterables that aren\'t in the\n    other input iterables.\n\n    For example, suppose you have a set of packages, each with a set of\n    dependencies::\n\n        {\'pkg_1\': {\'A\', \'B\'}, \'pkg_2\': {\'B\', \'C\'}, \'pkg_3\': {\'B\', \'D\'}}\n\n    If you remove one package, which dependencies can also be removed?\n\n    If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not\n    associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for\n    ``pkg_2``, and ``D`` is only needed for ``pkg_3``::\n\n        >>> unique_to_each({\'A\', \'B\'}, {\'B\', \'C\'}, {\'B\', \'D\'})\n        [[\'A\'], [\'C\'], [\'D\']]\n\n    If there are duplicates in one input iterable that aren\'t in the others\n    they will be duplicated in the output. Input order is preserved::\n\n        >>> unique_to_each("mississippi", "missouri")\n        [[\'p\', \'p\'], [\'o\', \'u\', \'r\']]\n\n    It is assumed that the elements of each iterable are hashable.\n\n    ')), Assign(targets=[Name(id='pool', ctx=Store())], value=ListComp(elt=Call(func=Name(id='list', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='it', ctx=Store()), iter=Name(id='iterables', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Name(id='Counter', ctx=Load()), args=[Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='set', ctx=Load()), Name(id='pool', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='uniques', ctx=Store())], value=SetComp(elt=Name(id='element', ctx=Load()), generators=[comprehension(target=Name(id='element', ctx=Store()), iter=Name(id='counts', ctx=Load()), ifs=[Compare(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Name(id='element', ctx=Load()), ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)])], is_async=0)])), Return(value=ListComp(elt=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='filter', ctx=Load()), args=[Attribute(value=Name(id='uniques', ctx=Load()), attr='__contains__', ctx=Load()), Name(id='it', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='it', ctx=Store()), iter=Name(id='pool', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[]), FunctionDef(name='windowed', args=arguments(posonlyargs=[], args=[arg(arg='seq'), arg(arg='n'), arg(arg='fillvalue'), arg(arg='step')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=1)]), body=[Expr(value=Constant(value="Return a sliding window of width *n* over the given iterable.\n\n        >>> all_windows = windowed([1, 2, 3, 4, 5], 3)\n        >>> list(all_windows)\n        [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n\n    When the window is larger than the iterable, *fillvalue* is used in place\n    of missing values:\n\n        >>> list(windowed([1, 2, 3], 4))\n        [(1, 2, 3, None)]\n\n    Each window will advance in increments of *step*:\n\n        >>> list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue='!', step=2))\n        [(1, 2, 3), (3, 4, 5), (5, 6, '!')]\n\n    To slide into the iterable's items, use :func:`chain` to add filler items\n    to the left:\n\n        >>> iterable = [1, 2, 3, 4]\n        >>> n = 3\n        >>> padding = [None] * (n - 1)\n        >>> list(windowed(chain(padding, iterable), 3))\n        [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]\n    ")), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='n must be >= 0')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Yield(value=Call(func=Name(id='tuple', ctx=Load()), args=[], keywords=[]))), Return()], orelse=[]), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='step must be >= 1')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='window', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[], keywords=[keyword(arg='maxlen', value=Name(id='n', ctx=Load()))])), Assign(targets=[Name(id='i', ctx=Store())], value=Name(id='n', ctx=Load())), For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='window', ctx=Load()), attr='append', ctx=Load()), Name(id='seq', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='i', ctx=Store()), op=Sub(), value=Constant(value=1)), If(test=UnaryOp(op=Not(), operand=Name(id='i', ctx=Load())), body=[Assign(targets=[Name(id='i', ctx=Store())], value=Name(id='step', ctx=Load())), Expr(value=Yield(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='window', ctx=Load())], keywords=[])))], orelse=[])], orelse=[]), Assign(targets=[Name(id='size', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='window', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='size', ctx=Load()), ops=[Lt()], comparators=[Name(id='n', ctx=Load())]), body=[Expr(value=Yield(value=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='chain', ctx=Load()), args=[Name(id='window', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='fillvalue', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='size', ctx=Load()))], keywords=[])], keywords=[])], keywords=[])))], orelse=[If(test=Compare(left=Constant(value=0), ops=[Lt(), Lt()], comparators=[Name(id='i', ctx=Load()), Call(func=Name(id='min', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='n', ctx=Load())], keywords=[])]), body=[AugAssign(target=Name(id='window', ctx=Store()), op=Add(), value=BinOp(left=Tuple(elts=[Name(id='fillvalue', ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='i', ctx=Load()))), Expr(value=Yield(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='window', ctx=Load())], keywords=[])))], orelse=[])])], decorator_list=[]), FunctionDef(name='substrings', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield all of the substrings of *iterable*.\n\n        >>> [''.join(s) for s in substrings('more')]\n        ['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']\n\n    Note that non-string iterables can also be subdivided.\n\n        >>> list(substrings([0, 1, 2]))\n        [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]\n\n    ")), Assign(targets=[Name(id='seq', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='item', ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='seq', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), Expr(value=Yield(value=Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())))], orelse=[]), Assign(targets=[Name(id='seq', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[])), Assign(targets=[Name(id='item_count', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[])), For(target=Name(id='n', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=2), BinOp(left=Name(id='item_count', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), body=[For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='item_count', ctx=Load()), op=Sub(), right=Name(id='n', ctx=Load())), op=Add(), right=Constant(value=1))], keywords=[]), body=[Expr(value=Yield(value=Subscript(value=Name(id='seq', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load()), upper=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Name(id='n', ctx=Load()))), ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='substrings_indexes', args=arguments(posonlyargs=[], args=[arg(arg='seq'), arg(arg='reverse')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value="Yield all substrings and their positions in *seq*\n\n    The items yielded will be a tuple of the form ``(substr, i, j)``, where\n    ``substr == seq[i:j]``.\n\n    This function only works for iterables that support slicing, such as\n    ``str`` objects.\n\n    >>> for item in substrings_indexes('more'):\n    ...    print(item)\n    ('m', 0, 1)\n    ('o', 1, 2)\n    ('r', 2, 3)\n    ('e', 3, 4)\n    ('mo', 0, 2)\n    ('or', 1, 3)\n    ('re', 2, 4)\n    ('mor', 0, 3)\n    ('ore', 1, 4)\n    ('more', 0, 4)\n\n    Set *reverse* to ``True`` to yield the same items in the opposite order.\n\n\n    ")), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=1), BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))], keywords=[])), If(test=Name(id='reverse', ctx=Load()), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]))], orelse=[]), Return(value=GeneratorExp(elt=Tuple(elts=[Subscript(value=Name(id='seq', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load()), upper=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Name(id='L', ctx=Load()))), ctx=Load()), Name(id='i', ctx=Load()), BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Name(id='L', ctx=Load()))], ctx=Load()), generators=[comprehension(target=Name(id='L', ctx=Store()), iter=Name(id='r', ctx=Load()), ifs=[], is_async=0), comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[]), op=Sub(), right=Name(id='L', ctx=Load())), op=Add(), right=Constant(value=1))], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[]), ClassDef(name='bucket', bases=[], keywords=[], body=[Expr(value=Constant(value="Wrap *iterable* and return an object that buckets it iterable into\n    child iterables based on a *key* function.\n\n        >>> iterable = ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'b3']\n        >>> s = bucket(iterable, key=lambda x: x[0])  # Bucket by 1st character\n        >>> sorted(list(s))  # Get the keys\n        ['a', 'b', 'c']\n        >>> a_iterable = s['a']\n        >>> next(a_iterable)\n        'a1'\n        >>> next(a_iterable)\n        'a2'\n        >>> list(s['b'])\n        ['b1', 'b2', 'b3']\n\n    The original iterable will be advanced and its items will be cached until\n    they are used by the child iterables. This may require significant storage.\n\n    By default, attempting to select a bucket to which no items belong  will\n    exhaust the iterable and cache all values.\n    If you specify a *validator* function, selected buckets will instead be\n    checked against it.\n\n        >>> from itertools import count\n        >>> it = count(1, 2)  # Infinite sequence of odd numbers\n        >>> key = lambda x: x % 10  # Bucket by last digit\n        >>> validator = lambda x: x in {1, 3, 5, 7, 9}  # Odd digits only\n        >>> s = bucket(it, key=key, validator=validator)\n        >>> 2 in s\n        False\n        >>> list(s[2])\n        []\n\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterable'), arg(arg='key'), arg(arg='validator')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_key', ctx=Store())], value=Name(id='key', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Store())], value=Call(func=Name(id='defaultdict', ctx=Load()), args=[Name(id='deque', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_validator', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='validator', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=True))]))], decorator_list=[]), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validator', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[]), Try(body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Subscript(value=Name(id='self', ctx=Load()), slice=Name(id='value', ctx=Load()), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), slice=Name(id='value', ctx=Load()), ctx=Load()), attr='appendleft', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], finalbody=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='_get_values', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Helper to yield items from the parent iterator that match *value*.\n        Items that don't match are stored in the local cache as they\n        are encountered.\n        ")), While(test=Constant(value=True), body=[If(test=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), slice=Name(id='value', ctx=Load()), ctx=Load()), body=[Expr(value=Yield(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), slice=Name(id='value', ctx=Load()), ctx=Load()), attr='popleft', ctx=Load()), args=[], keywords=[])))], orelse=[While(test=Constant(value=True), body=[Try(body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return()])], orelse=[], finalbody=[]), Assign(targets=[Name(id='item_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_key', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='item_value', ctx=Load()), ops=[Eq()], comparators=[Name(id='value', ctx=Load())]), body=[Expr(value=Yield(value=Name(id='item', ctx=Load()))), Break()], orelse=[If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validator', ctx=Load()), args=[Name(id='item_value', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), slice=Name(id='item_value', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[])])], orelse=[])])], orelse=[])], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='item', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Load()), body=[Assign(targets=[Name(id='item_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_key', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validator', ctx=Load()), args=[Name(id='item_value', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), slice=Name(id='item_value', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=YieldFrom(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validator', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Tuple(elts=[], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_values', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='spy', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1)]), body=[Expr(value=Constant(value='Return a 2-tuple with a list containing the first *n* elements of\n    *iterable*, and an iterator with the same items as *iterable*.\n    This allows you to "look ahead" at the items in the iterable without\n    advancing it.\n\n    There is one item in the list by default:\n\n        >>> iterable = \'abcdefg\'\n        >>> head, iterable = spy(iterable)\n        >>> head\n        [\'a\']\n        >>> list(iterable)\n        [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\']\n\n    You may use unpacking to retrieve items instead of lists:\n\n        >>> (head,), iterable = spy(\'abcdefg\')\n        >>> head\n        \'a\'\n        >>> (first, second), iterable = spy(\'abcdefg\', 2)\n        >>> first\n        \'a\'\n        >>> second\n        \'b\'\n\n    The number of items requested can be larger than the number of items in\n    the iterable:\n\n        >>> iterable = [1, 2, 3, 4, 5]\n        >>> head, iterable = spy(iterable, 10)\n        >>> head\n        [1, 2, 3, 4, 5]\n        >>> list(iterable)\n        [1, 2, 3, 4, 5]\n\n    ')), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='head', ctx=Store())], value=Call(func=Name(id='take', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='it', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Call(func=Attribute(value=Name(id='head', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='chain', ctx=Load()), args=[Name(id='head', ctx=Load()), Name(id='it', ctx=Load())], keywords=[])], ctx=Load()))], decorator_list=[]), FunctionDef(name='interleave', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='iterables'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return a new iterable yielding from each iterable in turn,\n    until the shortest is exhausted.\n\n        >>> list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7]\n\n    For a version that doesn't terminate after the shortest iterable is\n    exhausted, see :func:`interleave_longest`.\n\n    ")), Return(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Name(id='iterables', ctx=Load()), ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='interleave_longest', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='iterables'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a new iterable yielding from each iterable in turn,\n    skipping any that are exhausted.\n\n        >>> list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7, 3, 8]\n\n    This function produces the same output as :func:`roundrobin`, but may\n    perform better for some inputs (in particular when the number of iterables\n    is large).\n\n    ')), Assign(targets=[Name(id='i', ctx=Store())], value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Call(func=Name(id='zip_longest', ctx=Load()), args=[Starred(value=Name(id='iterables', ctx=Load()), ctx=Load())], keywords=[keyword(arg='fillvalue', value=Name(id='_marker', ctx=Load()))])], keywords=[])), Return(value=GeneratorExp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='i', ctx=Load()), ifs=[Compare(left=Name(id='x', ctx=Load()), ops=[IsNot()], comparators=[Name(id='_marker', ctx=Load())])], is_async=0)]))], decorator_list=[]), FunctionDef(name='collapse', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='base_type'), arg(arg='levels')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Flatten an iterable with multiple levels of nesting (e.g., a list of\n    lists of tuples) into non-iterable types.\n\n        >>> iterable = [(1, 2), ([3, 4], [[5], [6]])]\n        >>> list(collapse(iterable))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and\n    will not be collapsed.\n\n    To avoid collapsing other types, specify *base_type*:\n\n        >>> iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]\n        >>> list(collapse(iterable, base_type=tuple))\n        ['ab', ('cd', 'ef'), 'gh', 'ij']\n\n    Specify *levels* to stop flattening after a certain level:\n\n    >>> iterable = [('a', ['b']), ('c', ['d'])]\n    >>> list(collapse(iterable))  # Fully flattened\n    ['a', 'b', 'c', 'd']\n    >>> list(collapse(iterable, levels=1))  # Only one level flattened\n    ['a', ['b'], 'c', ['d']]\n\n    ")), FunctionDef(name='walk', args=arguments(posonlyargs=[], args=[arg(arg='node'), arg(arg='level')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Compare(left=Name(id='levels', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='level', ctx=Load()), ops=[Gt()], comparators=[Name(id='levels', ctx=Load())])]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bytes', ctx=Load())], ctx=Load())], keywords=[]), BoolOp(op=And(), values=[Compare(left=Name(id='base_type', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Name(id='base_type', ctx=Load())], keywords=[])])]), body=[Expr(value=Yield(value=Name(id='node', ctx=Load()))), Return()], orelse=[]), Try(body=[Assign(targets=[Name(id='tree', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Expr(value=Yield(value=Name(id='node', ctx=Load()))), Return()])], orelse=[For(target=Name(id='child', ctx=Store()), iter=Name(id='tree', ctx=Load()), body=[Expr(value=YieldFrom(value=Call(func=Name(id='walk', ctx=Load()), args=[Name(id='child', ctx=Load()), BinOp(left=Name(id='level', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[])))], orelse=[])], finalbody=[])], decorator_list=[]), Expr(value=YieldFrom(value=Call(func=Name(id='walk', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Constant(value=0)], keywords=[])))], decorator_list=[]), FunctionDef(name='side_effect', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='iterable'), arg(arg='chunk_size'), arg(arg='before'), arg(arg='after')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Invoke *func* on each item in *iterable* (or on each *chunk_size* group\n    of items) before yielding the item.\n\n    `func` must be a function that takes a single argument. Its return value\n    will be discarded.\n\n    *before* and *after* are optional functions that take no arguments. They\n    will be executed before iteration starts and after it ends, respectively.\n\n    `side_effect` can be used for logging, updating progress bars, or anything\n    that is not functionally "pure."\n\n    Emitting a status message:\n\n        >>> from more_itertools import consume\n        >>> func = lambda item: print(\'Received {}\'.format(item))\n        >>> consume(side_effect(func, range(2)))\n        Received 0\n        Received 1\n\n    Operating on chunks of items:\n\n        >>> pair_sums = []\n        >>> func = lambda chunk: pair_sums.append(sum(chunk))\n        >>> list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))\n        [0, 1, 2, 3, 4, 5]\n        >>> list(pair_sums)\n        [1, 5, 9]\n\n    Writing to a file-like object:\n\n        >>> from io import StringIO\n        >>> from more_itertools import consume\n        >>> f = StringIO()\n        >>> func = lambda x: print(x, file=f)\n        >>> before = lambda: print(u\'HEADER\', file=f)\n        >>> after = f.close\n        >>> it = [u\'a\', u\'b\', u\'c\']\n        >>> consume(side_effect(func, it, before=before, after=after))\n        >>> f.closed\n        True\n\n    ')), Try(body=[If(test=Compare(left=Name(id='before', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='before', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='chunk_size', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[For(target=Name(id='item', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[Expr(value=Call(func=Name(id='func', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), Expr(value=Yield(value=Name(id='item', ctx=Load())))], orelse=[])], orelse=[For(target=Name(id='chunk', ctx=Store()), iter=Call(func=Name(id='chunked', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='chunk_size', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='func', ctx=Load()), args=[Name(id='chunk', ctx=Load())], keywords=[])), Expr(value=YieldFrom(value=Name(id='chunk', ctx=Load())))], orelse=[])])], handlers=[], orelse=[], finalbody=[If(test=Compare(left=Name(id='after', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='after', ctx=Load()), args=[], keywords=[]))], orelse=[])])], decorator_list=[]), FunctionDef(name='sliced', args=arguments(posonlyargs=[], args=[arg(arg='seq'), arg(arg='n'), arg(arg='strict')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Yield slices of length *n* from the sequence *seq*.\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6), 3))\n    [(1, 2, 3), (4, 5, 6)]\n\n    By the default, the last yielded slice will have fewer than *n* elements\n    if the length of *seq* is not divisible by *n*:\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))\n    [(1, 2, 3), (4, 5, 6), (7, 8)]\n\n    If the length of *seq* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    slice is yielded.\n\n    This function will only work for iterables that support slicing.\n    For non-sliceable iterables, see :func:`chunked`.\n\n    ')), Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='takewhile', ctx=Load()), args=[Name(id='len', ctx=Load()), GeneratorExp(elt=Subscript(value=Name(id='seq', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load()), upper=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Name(id='n', ctx=Load()))), ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='count', ctx=Load()), args=[Constant(value=0), Name(id='n', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), If(test=Name(id='strict', ctx=Load()), body=[FunctionDef(name='ret', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='_slice', ctx=Store()), iter=Name(id='iterator', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='_slice', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='n', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='seq is not divisible by n.')], keywords=[]))], orelse=[]), Expr(value=Yield(value=Name(id='_slice', ctx=Load())))], orelse=[])], decorator_list=[]), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Name(id='ret', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[Return(value=Name(id='iterator', ctx=Load()))])], decorator_list=[]), FunctionDef(name='split_at', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred'), arg(arg='maxsplit'), arg(arg='keep_separator')], kwonlyargs=[], kw_defaults=[], defaults=[UnaryOp(op=USub(), operand=Constant(value=1)), Constant(value=False)]), body=[Expr(value=Constant(value="Yield lists of items from *iterable*, where each list is delimited by\n    an item where callable *pred* returns ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b'))\n        [['a'], ['c', 'd', 'c'], ['a']]\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1))\n        [[0], [2], [4], [6], [8], []]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2))\n        [[0], [2], [4, 5, 6, 7, 8, 9]]\n\n    By default, the delimiting items are not included in the output.\n    The include them, set *keep_separator* to ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b', keep_separator=True))\n        [['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]\n\n    ")), If(test=Compare(left=Name(id='maxsplit', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Yield(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]))), Return()], orelse=[]), Assign(targets=[Name(id='buf', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), For(target=Name(id='item', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[If(test=Call(func=Name(id='pred', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='buf', ctx=Load()))), If(test=Name(id='keep_separator', ctx=Load()), body=[Expr(value=Yield(value=List(elts=[Name(id='item', ctx=Load())], ctx=Load())))], orelse=[]), If(test=Compare(left=Name(id='maxsplit', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Expr(value=Yield(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]))), Return()], orelse=[]), Assign(targets=[Name(id='buf', ctx=Store())], value=List(elts=[], ctx=Load())), AugAssign(target=Name(id='maxsplit', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))])], orelse=[]), Expr(value=Yield(value=Name(id='buf', ctx=Load())))], decorator_list=[]), FunctionDef(name='split_before', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred'), arg(arg='maxsplit')], kwonlyargs=[], kw_defaults=[], defaults=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Expr(value=Constant(value="Yield lists of items from *iterable*, where each list ends just before\n    an item for which callable *pred* returns ``True``:\n\n        >>> list(split_before('OneTwo', lambda s: s.isupper()))\n        [['O', 'n', 'e'], ['T', 'w', 'o']]\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]\n    ")), If(test=Compare(left=Name(id='maxsplit', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Yield(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]))), Return()], orelse=[]), Assign(targets=[Name(id='buf', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), For(target=Name(id='item', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='pred', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), Name(id='buf', ctx=Load())]), body=[Expr(value=Yield(value=Name(id='buf', ctx=Load()))), If(test=Compare(left=Name(id='maxsplit', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Expr(value=Yield(value=BinOp(left=List(elts=[Name(id='item', ctx=Load())], ctx=Load()), op=Add(), right=Call(func=Name(id='list', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[])))), Return()], orelse=[]), Assign(targets=[Name(id='buf', ctx=Store())], value=List(elts=[], ctx=Load())), AugAssign(target=Name(id='maxsplit', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='buf', ctx=Load()), body=[Expr(value=Yield(value=Name(id='buf', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='split_after', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred'), arg(arg='maxsplit')], kwonlyargs=[], kw_defaults=[], defaults=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Expr(value=Constant(value="Yield lists of items from *iterable*, where each list ends with an\n    item where callable *pred* returns ``True``:\n\n        >>> list(split_after('one1two2', lambda s: s.isdigit()))\n        [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0))\n        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]\n\n    ")), If(test=Compare(left=Name(id='maxsplit', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Yield(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]))), Return()], orelse=[]), Assign(targets=[Name(id='buf', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), For(target=Name(id='item', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='pred', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), Name(id='buf', ctx=Load())]), body=[Expr(value=Yield(value=Name(id='buf', ctx=Load()))), If(test=Compare(left=Name(id='maxsplit', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Expr(value=Yield(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]))), Return()], orelse=[]), Assign(targets=[Name(id='buf', ctx=Store())], value=List(elts=[], ctx=Load())), AugAssign(target=Name(id='maxsplit', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[])], orelse=[]), If(test=Name(id='buf', ctx=Load()), body=[Expr(value=Yield(value=Name(id='buf', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='split_when', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred'), arg(arg='maxsplit')], kwonlyargs=[], kw_defaults=[], defaults=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Expr(value=Constant(value='Split *iterable* into pieces based on the output of *pred*.\n    *pred* should be a function that takes successive pairs of items and\n    returns ``True`` if the iterable should be split in between them.\n\n    For example, to find runs of increasing numbers, split the iterable when\n    element ``i`` is larger than element ``i + 1``:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x > y))\n        [[1, 2, 3, 3], [2, 5], [2, 4], [2]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],\n        ...                 lambda x, y: x > y, maxsplit=2))\n        [[1, 2, 3, 3], [2, 5], [2, 4, 2]]\n\n    ')), If(test=Compare(left=Name(id='maxsplit', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Yield(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]))), Return()], orelse=[]), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='cur_item', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return()])], orelse=[], finalbody=[]), Assign(targets=[Name(id='buf', ctx=Store())], value=List(elts=[Name(id='cur_item', ctx=Load())], ctx=Load())), For(target=Name(id='next_item', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[If(test=Call(func=Name(id='pred', ctx=Load()), args=[Name(id='cur_item', ctx=Load()), Name(id='next_item', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='buf', ctx=Load()))), If(test=Compare(left=Name(id='maxsplit', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Expr(value=Yield(value=BinOp(left=List(elts=[Name(id='next_item', ctx=Load())], ctx=Load()), op=Add(), right=Call(func=Name(id='list', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[])))), Return()], orelse=[]), Assign(targets=[Name(id='buf', ctx=Store())], value=List(elts=[], ctx=Load())), AugAssign(target=Name(id='maxsplit', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='next_item', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cur_item', ctx=Store())], value=Name(id='next_item', ctx=Load()))], orelse=[]), Expr(value=Yield(value=Name(id='buf', ctx=Load())))], decorator_list=[]), FunctionDef(name='split_into', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='sizes')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield a list of sequential items from *iterable* of length 'n' for each\n    integer 'n' in *sizes*.\n\n        >>> list(split_into([1,2,3,4,5,6], [1,2,3]))\n        [[1], [2, 3], [4, 5, 6]]\n\n    If the sum of *sizes* is smaller than the length of *iterable*, then the\n    remaining items of *iterable* will not be returned.\n\n        >>> list(split_into([1,2,3,4,5,6], [2,3]))\n        [[1, 2], [3, 4, 5]]\n\n    If the sum of *sizes* is larger than the length of *iterable*, fewer items\n    will be returned in the iteration that overruns *iterable* and further\n    lists will be empty:\n\n        >>> list(split_into([1,2,3,4], [1,2,3,4]))\n        [[1], [2, 3], [4], []]\n\n    When a ``None`` object is encountered in *sizes*, the returned list will\n    contain items up to the end of *iterable* the same way that itertools.slice\n    does:\n\n        >>> list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))\n        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]\n\n    :func:`split_into` can be useful for grouping a series of items where the\n    sizes of the groups are not uniform. An example would be where in a row\n    from a table, multiple columns represent elements of the same feature\n    (e.g. a point represented by x,y,z) but, the format is not the same for\n    all columns.\n    ")), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), For(target=Name(id='size', ctx=Store()), iter=Name(id='sizes', ctx=Load()), body=[If(test=Compare(left=Name(id='size', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]))), Return()], orelse=[Expr(value=Yield(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='size', ctx=Load())], keywords=[])], keywords=[])))])], orelse=[])], decorator_list=[]), FunctionDef(name='padded', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='fillvalue'), arg(arg='n'), arg(arg='next_multiple')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Yield the elements from *iterable*, followed by *fillvalue*, such that\n    at least *n* items are emitted.\n\n        >>> list(padded([1, 2, 3], '?', 5))\n        [1, 2, 3, '?', '?']\n\n    If *next_multiple* is ``True``, *fillvalue* will be emitted until the\n    number of items emitted is a multiple of *n*::\n\n        >>> list(padded([1, 2, 3, 4], n=3, next_multiple=True))\n        [1, 2, 3, 4, None, None]\n\n    If *n* is ``None``, *fillvalue* will be emitted indefinitely.\n\n    ")), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=YieldFrom(value=Call(func=Name(id='chain', ctx=Load()), args=[Name(id='it', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='fillvalue', ctx=Load())], keywords=[])], keywords=[])))], orelse=[If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='n must be at least 1')], keywords=[]))], orelse=[Assign(targets=[Name(id='item_count', ctx=Store())], value=Constant(value=0)), For(target=Name(id='item', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[Expr(value=Yield(value=Name(id='item', ctx=Load()))), AugAssign(target=Name(id='item_count', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Assign(targets=[Name(id='remaining', ctx=Store())], value=IfExp(test=Name(id='next_multiple', ctx=Load()), body=BinOp(left=BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='item_count', ctx=Load())), op=Mod(), right=Name(id='n', ctx=Load())), orelse=BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='item_count', ctx=Load())))), For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='remaining', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='fillvalue', ctx=Load())))], orelse=[])])])], decorator_list=[]), FunctionDef(name='repeat_last', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='After the *iterable* is exhausted, keep yielding its last element.\n\n        >>> list(islice(repeat_last(range(3)), 5))\n        [0, 1, 2, 2, 2]\n\n    If the iterable is empty, yield *default* forever::\n\n        >>> list(islice(repeat_last(range(0), 42), 5))\n        [42, 42, 42, 42, 42]\n\n    ')), Assign(targets=[Name(id='item', ctx=Store())], value=Name(id='_marker', ctx=Load())), For(target=Name(id='item', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[Expr(value=Yield(value=Name(id='item', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='final', ctx=Store())], value=IfExp(test=Compare(left=Name(id='item', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=Name(id='default', ctx=Load()), orelse=Name(id='item', ctx=Load()))), Expr(value=YieldFrom(value=Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='final', ctx=Load())], keywords=[])))], decorator_list=[]), FunctionDef(name='distribute', args=arguments(posonlyargs=[], args=[arg(arg='n'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Distribute the items from *iterable* among *n* smaller iterables.\n\n        >>> group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 3, 5]\n        >>> list(group_2)\n        [2, 4, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = distribute(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 4, 7], [2, 5], [3, 6]]\n\n    If the length of *iterable* is smaller than *n*, then the last returned\n    iterables will be empty:\n\n        >>> children = distribute(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function uses :func:`itertools.tee` and may require significant\n    storage. If you need the order items in the smaller iterables to match the\n    original iterable, see :func:`divide`.\n\n    ')), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='n must be at least 1')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='children', ctx=Store())], value=Call(func=Name(id='tee', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='n', ctx=Load())], keywords=[])), Return(value=ListComp(elt=Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='index', ctx=Load()), Constant(value=None), Name(id='n', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='it', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='children', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[]), FunctionDef(name='stagger', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='offsets'), arg(arg='longest'), arg(arg='fillvalue')], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[UnaryOp(op=USub(), operand=Constant(value=1)), Constant(value=0), Constant(value=1)], ctx=Load()), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='Yield tuples whose elements are offset from *iterable*.\n    The amount by which the `i`-th item in each tuple is offset is given by\n    the `i`-th item in *offsets*.\n\n        >>> list(stagger([0, 1, 2, 3]))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3)]\n        >>> list(stagger(range(8), offsets=(0, 2, 4)))\n        [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]\n\n    By default, the sequence will end when the final element of a tuple is the\n    last item in the iterable. To continue until the first element of a tuple\n    is the last item in the iterable, set *longest* to ``True``::\n\n        >>> list(stagger([0, 1, 2, 3], longest=True))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    ')), Assign(targets=[Name(id='children', ctx=Store())], value=Call(func=Name(id='tee', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='offsets', ctx=Load())], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='zip_offset', ctx=Load()), args=[Starred(value=Name(id='children', ctx=Load()), ctx=Load())], keywords=[keyword(arg='offsets', value=Name(id='offsets', ctx=Load())), keyword(arg='longest', value=Name(id='longest', ctx=Load())), keyword(arg='fillvalue', value=Name(id='fillvalue', ctx=Load()))]))], decorator_list=[]), ClassDef(name='UnequalIterablesError', bases=[Name(id='ValueError', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='details')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Iterables have different lengths')), If(test=Compare(left=Name(id='details', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Constant(value=': index 0 has length {}; index {} has length {}'), attr='format', ctx=Load()), args=[Starred(value=Name(id='details', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='_zip_equal_generator', args=arguments(posonlyargs=[], args=[arg(arg='iterables')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='combo', ctx=Store()), iter=Call(func=Name(id='zip_longest', ctx=Load()), args=[Starred(value=Name(id='iterables', ctx=Load()), ctx=Load())], keywords=[keyword(arg='fillvalue', value=Name(id='_marker', ctx=Load()))]), body=[For(target=Name(id='val', ctx=Store()), iter=Name(id='combo', ctx=Load()), body=[If(test=Compare(left=Name(id='val', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='UnequalIterablesError', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Yield(value=Name(id='combo', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='zip_equal', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='iterables'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="``zip`` the input *iterables* together, but raise\n    ``UnequalIterablesError`` if they aren't all the same length.\n\n        >>> it_1 = range(3)\n        >>> it_2 = iter('abc')\n        >>> list(zip_equal(it_1, it_2))\n        [(0, 'a'), (1, 'b'), (2, 'c')]\n\n        >>> it_1 = range(3)\n        >>> it_2 = iter('abcd')\n        >>> list(zip_equal(it_1, it_2)) # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        more_itertools.more.UnequalIterablesError: Iterables have different\n        lengths\n\n    ")), If(test=Compare(left=Name(id='hexversion', ctx=Load()), ops=[GtE()], comparators=[Constant(value=50987174)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='zip_equal will be removed in a future version of more-itertools. Use the builtin zip function with strict=True instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Name(id='first_size', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='iterables', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='it', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Subscript(value=Name(id='iterables', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), Constant(value=1)], keywords=[]), body=[Assign(targets=[Name(id='size', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='size', ctx=Load()), ops=[NotEq()], comparators=[Name(id='first_size', ctx=Load())]), body=[Break()], orelse=[])], orelse=[Return(value=Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Name(id='iterables', ctx=Load()), ctx=Load())], keywords=[]))]), Raise(exc=Call(func=Name(id='UnequalIterablesError', ctx=Load()), args=[], keywords=[keyword(arg='details', value=Tuple(elts=[Name(id='first_size', ctx=Load()), Name(id='i', ctx=Load()), Name(id='size', ctx=Load())], ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Return(value=Call(func=Name(id='_zip_equal_generator', ctx=Load()), args=[Name(id='iterables', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='zip_offset', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='iterables'), kwonlyargs=[arg(arg='offsets'), arg(arg='longest'), arg(arg='fillvalue')], kw_defaults=[None, Constant(value=False), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value="``zip`` the input *iterables* together, but offset the `i`-th iterable\n    by the `i`-th item in *offsets*.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1)))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]\n\n    This can be used as a lightweight alternative to SciPy or pandas to analyze\n    data sets in which some series have a lead or lag relationship.\n\n    By default, the sequence will end when the shortest iterable is exhausted.\n    To continue until the longest iterable is exhausted, set *longest* to\n    ``True``.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    ")), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='iterables', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='offsets', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Number of iterables and offsets didn't match")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='staggered', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='it', ctx=Store()), Name(id='n', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='iterables', ctx=Load()), Name(id='offsets', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='staggered', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='chain', ctx=Load()), args=[Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='fillvalue', ctx=Load()), UnaryOp(op=USub(), operand=Name(id='n', ctx=Load()))], keywords=[]), Name(id='it', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='staggered', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='n', ctx=Load()), Constant(value=None)], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='staggered', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]))])])], orelse=[]), If(test=Name(id='longest', ctx=Load()), body=[Return(value=Call(func=Name(id='zip_longest', ctx=Load()), args=[Starred(value=Name(id='staggered', ctx=Load()), ctx=Load())], keywords=[keyword(arg='fillvalue', value=Name(id='fillvalue', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Name(id='staggered', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='sort_together', args=arguments(posonlyargs=[], args=[arg(arg='iterables'), arg(arg='key_list'), arg(arg='key'), arg(arg='reverse')], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[Constant(value=0)], ctx=Load()), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Return the input iterables sorted together, with *key_list* as the\n    priority for sorting. All iterables are trimmed to the length of the\n    shortest one.\n\n    This can be used like the sorting function in a spreadsheet. If each\n    iterable represents a column of data, the key list determines which\n    columns are used for sorting.\n\n    By default, all iterables are sorted using the ``0``-th iterable::\n\n        >>> iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]\n        >>> sort_together(iterables)\n        [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]\n\n    Set a different key list to sort according to another iterable.\n    Specifying multiple keys dictates how ties are broken::\n\n        >>> iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]\n        >>> sort_together(iterables, key_list=(1, 2))\n        [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]\n\n    To sort by a function of the elements of the iterable, pass a *key*\n    function. Its arguments are the elements of the iterables corresponding to\n    the key list::\n\n        >>> names = ('a', 'b', 'c')\n        >>> lengths = (1, 2, 3)\n        >>> widths = (5, 2, 1)\n        >>> def area(length, width):\n        ...     return length * width\n        >>> sort_together([names, lengths, widths], key_list=(1, 2), key=area)\n        [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]\n\n    Set *reverse* to ``True`` to sort in descending order.\n\n        >>> sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True)\n        [(3, 2, 1), ('a', 'b', 'c')]\n\n    ")), If(test=Compare(left=Name(id='key', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='key_argument', ctx=Store())], value=Call(func=Name(id='itemgetter', ctx=Load()), args=[Starred(value=Name(id='key_list', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='key_list', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='key_list', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='key_list', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='key_offset', ctx=Store())], value=Subscript(value=Name(id='key_list', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='key_argument', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='zipped_items')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='key', ctx=Load()), args=[Subscript(value=Name(id='zipped_items', ctx=Load()), slice=Name(id='key_offset', ctx=Load()), ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='get_key_items', ctx=Store())], value=Call(func=Name(id='itemgetter', ctx=Load()), args=[Starred(value=Name(id='key_list', ctx=Load()), ctx=Load())], keywords=[])), Assign(targets=[Name(id='key_argument', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='zipped_items')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='key', ctx=Load()), args=[Starred(value=Call(func=Name(id='get_key_items', ctx=Load()), args=[Name(id='zipped_items', ctx=Load())], keywords=[]), ctx=Load())], keywords=[])))])]), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Name(id='iterables', ctx=Load()), ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Name(id='key_argument', ctx=Load())), keyword(arg='reverse', value=Name(id='reverse', ctx=Load()))]), ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='unzip', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="The inverse of :func:`zip`, this function disaggregates the elements\n    of the zipped *iterable*.\n\n    The ``i``-th iterable contains the ``i``-th element from each element\n    of the zipped iterable. The first element is used to to determine the\n    length of the remaining elements.\n\n        >>> iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> letters, numbers = unzip(iterable)\n        >>> list(letters)\n        ['a', 'b', 'c', 'd']\n        >>> list(numbers)\n        [1, 2, 3, 4]\n\n    This is similar to using ``zip(*iterable)``, but it avoids reading\n    *iterable* into memory. Note, however, that this function uses\n    :func:`itertools.tee` and thus may require significant storage.\n\n    ")), Assign(targets=[Tuple(elts=[Name(id='head', ctx=Store()), Name(id='iterable', ctx=Store())], ctx=Store())], value=Call(func=Name(id='spy', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='head', ctx=Load())), body=[Return(value=Tuple(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='head', ctx=Store())], value=Subscript(value=Name(id='head', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='iterables', ctx=Store())], value=Call(func=Name(id='tee', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='head', ctx=Load())], keywords=[])], keywords=[])), FunctionDef(name='itemgetter', args=arguments(posonlyargs=[], args=[arg(arg='i')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='getter', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Subscript(value=Name(id='obj', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[Raise(exc=Name(id='StopIteration', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), Return(value=Name(id='getter', ctx=Load()))], decorator_list=[]), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='map', ctx=Load()), args=[Call(func=Name(id='itemgetter', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), Name(id='it', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='it', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='iterables', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='divide', args=arguments(posonlyargs=[], args=[arg(arg='n'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Divide the elements from *iterable* into *n* parts, maintaining\n    order.\n\n        >>> group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 2, 3]\n        >>> list(group_2)\n        [4, 5, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = divide(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 2, 3], [4, 5], [6, 7]]\n\n    If the length of the iterable is smaller than n, then the last returned\n    iterables will be empty:\n\n        >>> children = divide(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function will exhaust the iterable before returning and may require\n    significant storage. If order is not important, see :func:`distribute`,\n    which does not first pull the iterable into memory.\n\n    ')), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='n must be at least 1')], keywords=[]))], orelse=[]), Try(body=[Expr(value=Subscript(value=Name(id='iterable', ctx=Load()), slice=Slice(upper=Constant(value=0)), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Assign(targets=[Name(id='seq', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]))])], orelse=[Assign(targets=[Name(id='seq', ctx=Store())], value=Name(id='iterable', ctx=Load()))], finalbody=[]), Assign(targets=[Tuple(elts=[Name(id='q', ctx=Store()), Name(id='r', ctx=Store())], ctx=Store())], value=Call(func=Name(id='divmod', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[]), Name(id='n', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ret', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='stop', ctx=Store())], value=Constant(value=0)), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=1), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=Name(id='stop', ctx=Load())), AugAssign(target=Name(id='stop', ctx=Store()), op=Add(), value=IfExp(test=Compare(left=Name(id='i', ctx=Load()), ops=[LtE()], comparators=[Name(id='r', ctx=Load())]), body=BinOp(left=Name(id='q', ctx=Load()), op=Add(), right=Constant(value=1)), orelse=Name(id='q', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Subscript(value=Name(id='seq', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='stop', ctx=Load())), ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[]), FunctionDef(name='always_iterable', args=arguments(posonlyargs=[], args=[arg(arg='obj'), arg(arg='base_type')], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bytes', ctx=Load())], ctx=Load())]), body=[Expr(value=Constant(value="If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    ")), If(test=Compare(left=Name(id='obj', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Tuple(elts=[], ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='base_type', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='base_type', ctx=Load())], keywords=[])]), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Tuple(elts=[Name(id='obj', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Try(body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Tuple(elts=[Name(id='obj', ctx=Load())], ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='adjacent', args=arguments(posonlyargs=[], args=[arg(arg='predicate'), arg(arg='iterable'), arg(arg='distance')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1)]), body=[Expr(value=Constant(value='Return an iterable over `(bool, item)` tuples where the `item` is\n    drawn from *iterable* and the `bool` indicates whether\n    that item satisfies the *predicate* or is adjacent to an item that does.\n\n    For example, to find whether items are adjacent to a ``3``::\n\n        >>> list(adjacent(lambda x: x == 3, range(6)))\n        [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]\n\n    Set *distance* to change what counts as adjacent. For example, to find\n    whether items are two places away from a ``3``:\n\n        >>> list(adjacent(lambda x: x == 3, range(6), distance=2))\n        [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]\n\n    This is useful for contextualizing the results of a search function.\n    For example, a code comparison tool might want to identify lines that\n    have changed, but also surrounding lines to give the viewer of the diff\n    context.\n\n    The predicate function will only be called once for each item in the\n    iterable.\n\n    See also :func:`groupby_transform`, which can be used with this function\n    to group ranges of items with the same `bool` value.\n\n    ')), If(test=Compare(left=Name(id='distance', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='distance must be at least 0')], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='i1', ctx=Store()), Name(id='i2', ctx=Store())], ctx=Store())], value=Call(func=Name(id='tee', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='padding', ctx=Store())], value=BinOp(left=List(elts=[Constant(value=False)], ctx=Load()), op=Mult(), right=Name(id='distance', ctx=Load()))), Assign(targets=[Name(id='selected', ctx=Store())], value=Call(func=Name(id='chain', ctx=Load()), args=[Name(id='padding', ctx=Load()), Call(func=Name(id='map', ctx=Load()), args=[Name(id='predicate', ctx=Load()), Name(id='i1', ctx=Load())], keywords=[]), Name(id='padding', ctx=Load())], keywords=[])), Assign(targets=[Name(id='adjacent_to_selected', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='any', ctx=Load()), Call(func=Name(id='windowed', ctx=Load()), args=[Name(id='selected', ctx=Load()), BinOp(left=BinOp(left=Constant(value=2), op=Mult(), right=Name(id='distance', ctx=Load())), op=Add(), right=Constant(value=1))], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='adjacent_to_selected', ctx=Load()), Name(id='i2', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='groupby_transform', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='keyfunc'), arg(arg='valuefunc'), arg(arg='reducefunc')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="An extension of :func:`itertools.groupby` that can apply transformations\n    to the grouped data.\n\n    * *keyfunc* is a function computing a key value for each item in *iterable*\n    * *valuefunc* is a function that transforms the individual items from\n      *iterable* after grouping\n    * *reducefunc* is a function that transforms each group of items\n\n    >>> iterable = 'aAAbBBcCC'\n    >>> keyfunc = lambda k: k.upper()\n    >>> valuefunc = lambda v: v.lower()\n    >>> reducefunc = lambda g: ''.join(g)\n    >>> list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))\n    [('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')]\n\n    Each optional argument defaults to an identity function if not specified.\n\n    :func:`groupby_transform` is useful when grouping elements of an iterable\n    using a separate iterable as the key. To do this, :func:`zip` the iterables\n    and pass a *keyfunc* that extracts the first element and a *valuefunc*\n    that extracts the second element::\n\n        >>> from operator import itemgetter\n        >>> keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]\n        >>> values = 'abcdefghi'\n        >>> iterable = zip(keys, values)\n        >>> grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))\n        >>> [(k, ''.join(g)) for k, g in grouper]\n        [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]\n\n    Note that the order of items in the iterable is significant.\n    Only adjacent items are grouped together, so if you don't want any\n    duplicate groups, you should sort the iterable by the key function.\n\n    ")), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='groupby', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='keyfunc', ctx=Load())], keywords=[])), If(test=Name(id='valuefunc', ctx=Load()), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=GeneratorExp(elt=Tuple(elts=[Name(id='k', ctx=Load()), Call(func=Name(id='map', ctx=Load()), args=[Name(id='valuefunc', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='g', ctx=Store())], ctx=Store()), iter=Name(id='ret', ctx=Load()), ifs=[], is_async=0)]))], orelse=[]), If(test=Name(id='reducefunc', ctx=Load()), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=GeneratorExp(elt=Tuple(elts=[Name(id='k', ctx=Load()), Call(func=Name(id='reducefunc', ctx=Load()), args=[Name(id='g', ctx=Load())], keywords=[])], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='g', ctx=Store())], ctx=Store()), iter=Name(id='ret', ctx=Load()), ifs=[], is_async=0)]))], orelse=[]), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[]), ClassDef(name='numeric_range', bases=[Attribute(value=Name(id='abc', ctx=Load()), attr='Sequence', ctx=Load()), Attribute(value=Name(id='abc', ctx=Load()), attr='Hashable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="An extension of the built-in ``range()`` function whose arguments can\n    be any orderable numeric type.\n\n    With only *stop* specified, *start* defaults to ``0`` and *step*\n    defaults to ``1``. The output items will match the type of *stop*:\n\n        >>> list(numeric_range(3.5))\n        [0.0, 1.0, 2.0, 3.0]\n\n    With only *start* and *stop* specified, *step* defaults to ``1``. The\n    output items will match the type of *start*:\n\n        >>> from decimal import Decimal\n        >>> start = Decimal('2.1')\n        >>> stop = Decimal('5.1')\n        >>> list(numeric_range(start, stop))\n        [Decimal('2.1'), Decimal('3.1'), Decimal('4.1')]\n\n    With *start*, *stop*, and *step*  specified the output items will match\n    the type of ``start + step``:\n\n        >>> from fractions import Fraction\n        >>> start = Fraction(1, 2)  # Start at 1/2\n        >>> stop = Fraction(5, 2)  # End at 5/2\n        >>> step = Fraction(1, 2)  # Count by 1/2\n        >>> list(numeric_range(start, stop, step))\n        [Fraction(1, 2), Fraction(1, 1), Fraction(3, 2), Fraction(2, 1)]\n\n    If *step* is zero, ``ValueError`` is raised. Negative steps are supported:\n\n        >>> list(numeric_range(3, -1, -1.0))\n        [3.0, 2.0, 1.0, 0.0]\n\n    Be aware of the limitations of floating point numbers; the representation\n    of the yielded numbers may be surprising.\n\n    ``datetime.datetime`` objects can be used for *start* and *stop*, if *step*\n    is a ``datetime.timedelta`` object:\n\n        >>> import datetime\n        >>> start = datetime.datetime(2019, 1, 1)\n        >>> stop = datetime.datetime(2019, 1, 3)\n        >>> step = datetime.timedelta(days=1)\n        >>> items = iter(numeric_range(start, stop, step))\n        >>> next(items)\n        datetime.datetime(2019, 1, 1, 0, 0)\n        >>> next(items)\n        datetime.datetime(2019, 1, 2, 0, 0)\n\n    ")), Assign(targets=[Name(id='_EMPTY_HASH', ctx=Store())], value=Call(func=Name(id='hash', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Constant(value=0), Constant(value=0)], keywords=[])], keywords=[])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='argc', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='argc', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Store())], ctx=Store())], value=Name(id='args', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Store())], value=Call(func=Call(func=Name(id='type', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())], keywords=[]), args=[Constant(value=0)], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Store())], value=Call(func=Call(func=Name(id='type', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()))], keywords=[]), args=[Constant(value=1)], keywords=[]))], orelse=[If(test=Compare(left=Name(id='argc', ctx=Load()), ops=[Eq()], comparators=[Constant(value=2)]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Store())], ctx=Store())], value=Name(id='args', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Store())], value=Call(func=Call(func=Name(id='type', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()))], keywords=[]), args=[Constant(value=1)], keywords=[]))], orelse=[If(test=Compare(left=Name(id='argc', ctx=Load()), ops=[Eq()], comparators=[Constant(value=3)]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Store())], ctx=Store())], value=Name(id='args', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='argc', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='numeric_range expected at least 1 argument, got {}'), attr='format', ctx=Load()), args=[Name(id='argc', ctx=Load())], keywords=[])], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='numeric_range expected at most 3 arguments, got {}'), attr='format', ctx=Load()), args=[Name(id='argc', ctx=Load())], keywords=[])], keywords=[]))])])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_zero', ctx=Store())], value=Call(func=Call(func=Name(id='type', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load())], keywords=[]), args=[Constant(value=0)], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_zero', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='numeric_range() arg 3 must not be zero')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_growing', ctx=Store())], value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_zero', ctx=Load())])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_init_len', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_growing', ctx=Load()), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())]))], orelse=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())]))])], decorator_list=[]), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='elem')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_growing', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), ops=[LtE(), Lt()], comparators=[Name(id='elem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())]), body=[Return(value=Compare(left=BinOp(left=BinOp(left=Name(id='elem', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load())), op=Mod(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load())), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_zero', ctx=Load())]))], orelse=[])], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), ops=[GtE(), Gt()], comparators=[Name(id='elem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())]), body=[Return(value=Compare(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), op=Sub(), right=Name(id='elem', ctx=Load())), op=Mod(), right=UnaryOp(op=USub(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()))), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_zero', ctx=Load())]))], orelse=[])]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='numeric_range', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='empty_self', ctx=Store())], value=UnaryOp(op=Not(), operand=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='empty_other', ctx=Store())], value=UnaryOp(op=Not(), operand=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))), If(test=BoolOp(op=Or(), values=[Name(id='empty_self', ctx=Load()), Name(id='empty_other', ctx=Load())]), body=[Return(value=BoolOp(op=And(), values=[Name(id='empty_self', ctx=Load()), Name(id='empty_other', ctx=Load())]))], orelse=[Return(value=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='_start', ctx=Load())]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='_step', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_by_index', ctx=Load()), args=[UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), ops=[Eq()], comparators=[Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='_get_by_index', ctx=Load()), args=[UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[])])]))])], orelse=[Return(value=Constant(value=False))])], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_by_index', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='slice', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='step', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='key', ctx=Load()), attr='step', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()), orelse=BinOp(left=Attribute(value=Name(id='key', ctx=Load()), attr='step', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load())))), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='key', ctx=Load()), attr='start', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='key', ctx=Load()), attr='start', ctx=Load()), ops=[LtE()], comparators=[UnaryOp(op=USub(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_len', ctx=Load()))])]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()))], orelse=[If(test=Compare(left=Attribute(value=Name(id='key', ctx=Load()), attr='start', ctx=Load()), ops=[GtE()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_len', ctx=Load())]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load()))], orelse=[Assign(targets=[Name(id='start', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_by_index', ctx=Load()), args=[Attribute(value=Name(id='key', ctx=Load()), attr='start', ctx=Load())], keywords=[]))])]), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='key', ctx=Load()), attr='stop', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='key', ctx=Load()), attr='stop', ctx=Load()), ops=[GtE()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_len', ctx=Load())])]), body=[Assign(targets=[Name(id='stop', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load()))], orelse=[If(test=Compare(left=Attribute(value=Name(id='key', ctx=Load()), attr='stop', ctx=Load()), ops=[LtE()], comparators=[UnaryOp(op=USub(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_len', ctx=Load()))]), body=[Assign(targets=[Name(id='stop', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()))], orelse=[Assign(targets=[Name(id='stop', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_by_index', ctx=Load()), args=[Attribute(value=Name(id='key', ctx=Load()), attr='stop', ctx=Load())], keywords=[]))])]), Return(value=Call(func=Name(id='numeric_range', ctx=Load()), args=[Name(id='start', ctx=Load()), Name(id='stop', ctx=Load()), Name(id='step', ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='numeric range indices must be integers or slices, not {}'), attr='format', ctx=Load()), args=[Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]), attr='__name__', ctx=Load())], keywords=[])], keywords=[]))])])], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Name(id='self', ctx=Load()), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_by_index', ctx=Load()), args=[UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_EMPTY_HASH', ctx=Load()))])], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='values', ctx=Store())], value=GeneratorExp(elt=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), op=Add(), right=BinOp(left=Name(id='n', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()))), generators=[comprehension(target=Name(id='n', ctx=Store()), iter=Call(func=Name(id='count', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_growing', ctx=Load()), body=[Return(value=Call(func=Name(id='takewhile', ctx=Load()), args=[Call(func=Name(id='partial', ctx=Load()), args=[Name(id='gt', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())], keywords=[]), Name(id='values', ctx=Load())], keywords=[]))], orelse=[Return(value=Call(func=Name(id='takewhile', ctx=Load()), args=[Call(func=Name(id='partial', ctx=Load()), args=[Name(id='lt', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())], keywords=[]), Name(id='values', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='__len__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_len', ctx=Load()))], decorator_list=[]), FunctionDef(name='_init_len', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_growing', ctx=Load()), body=[Assign(targets=[Name(id='start', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load())), Assign(targets=[Name(id='stop', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())), Assign(targets=[Name(id='step', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()))], orelse=[Assign(targets=[Name(id='start', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())), Assign(targets=[Name(id='stop', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load())), Assign(targets=[Name(id='step', ctx=Store())], value=UnaryOp(op=USub(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load())))]), Assign(targets=[Name(id='distance', ctx=Store())], value=BinOp(left=Name(id='stop', ctx=Load()), op=Sub(), right=Name(id='start', ctx=Load()))), If(test=Compare(left=Name(id='distance', ctx=Load()), ops=[LtE()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_zero', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_len', ctx=Store())], value=Constant(value=0))], orelse=[Assign(targets=[Tuple(elts=[Name(id='q', ctx=Store()), Name(id='r', ctx=Store())], ctx=Store())], value=Call(func=Name(id='divmod', ctx=Load()), args=[Name(id='distance', ctx=Load()), Name(id='step', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_len', ctx=Store())], value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='int', ctx=Load()), args=[Compare(left=Name(id='r', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_zero', ctx=Load())])], keywords=[])))])], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Name(id='numeric_range', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load())], ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Call(func=Attribute(value=Constant(value='numeric_range({}, {})'), attr='format', ctx=Load()), args=[Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load())], keywords=[]), Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())], keywords=[])], keywords=[]))], orelse=[Return(value=Call(func=Attribute(value=Constant(value='numeric_range({}, {}, {})'), attr='format', ctx=Load()), args=[Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load())], keywords=[]), Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())], keywords=[]), Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load())], keywords=[])], keywords=[]))])], decorator_list=[]), FunctionDef(name='__reversed__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Name(id='numeric_range', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_by_index', ctx=Load()), args=[UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load())), UnaryOp(op=USub(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()))], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='count', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='int', ctx=Load()), args=[Compare(left=Name(id='value', ctx=Load()), ops=[In()], comparators=[Name(id='self', ctx=Load())])], keywords=[]))], decorator_list=[]), FunctionDef(name='index', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_growing', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), ops=[LtE(), Lt()], comparators=[Name(id='value', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='q', ctx=Store()), Name(id='r', ctx=Store())], ctx=Store())], value=Call(func=Name(id='divmod', ctx=Load()), args=[BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load())), Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='r', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_zero', ctx=Load())]), body=[Return(value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), ops=[GtE(), Gt()], comparators=[Name(id='value', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_stop', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='q', ctx=Store()), Name(id='r', ctx=Store())], ctx=Store())], value=Call(func=Name(id='divmod', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), op=Sub(), right=Name(id='value', ctx=Load())), UnaryOp(op=USub(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()))], keywords=[])), If(test=Compare(left=Name(id='r', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_zero', ctx=Load())]), body=[Return(value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])]), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{} is not in numeric range'), attr='format', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_get_by_index', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='i')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Attribute(value=Name(id='self', ctx=Load()), attr='_len', ctx=Load()))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), Compare(left=Name(id='i', ctx=Load()), ops=[GtE()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_len', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='IndexError', ctx=Load()), args=[Constant(value='numeric range object index out of range')], keywords=[]))], orelse=[]), Return(value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_start', ctx=Load()), op=Add(), right=BinOp(left=Name(id='i', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_step', ctx=Load()))))], decorator_list=[])], decorator_list=[]), FunctionDef(name='count_cycle', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Cycle through the items from *iterable* up to *n* times, yielding\n    the number of completed cycles along with each item. If *n* is omitted the\n    process repeats indefinitely.\n\n    >>> list(count_cycle('AB', 3))\n    [(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]\n\n    ")), Assign(targets=[Name(id='iterable', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='iterable', ctx=Load())), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Tuple(elts=[], ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='counter', ctx=Store())], value=IfExp(test=Compare(left=Name(id='n', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Call(func=Name(id='count', ctx=Load()), args=[], keywords=[]), orelse=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]))), Return(value=GeneratorExp(elt=Tuple(elts=[Name(id='i', ctx=Load()), Name(id='item', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Name(id='counter', ctx=Load()), ifs=[], is_async=0), comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='iterable', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[]), FunctionDef(name='mark_ends', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield 3-tuples of the form ``(is_first, is_last, item)``.\n\n    >>> list(mark_ends('ABC'))\n    [(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]\n\n    Use this when looping over an iterable to take special action on its first\n    and/or last items:\n\n    >>> iterable = ['Header', 100, 200, 'Footer']\n    >>> total = 0\n    >>> for is_first, is_last, item in mark_ends(iterable):\n    ...     if is_first:\n    ...         continue  # Skip the header\n    ...     if is_last:\n    ...         continue  # Skip the footer\n    ...     total += item\n    >>> print(total)\n    300\n    ")), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return()])], orelse=[], finalbody=[]), Try(body=[For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='count', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='a', ctx=Store())], value=Name(id='b', ctx=Load())), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[])), Expr(value=Yield(value=Tuple(elts=[Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), Constant(value=False), Name(id='a', ctx=Load())], ctx=Load())))], orelse=[])], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Expr(value=Yield(value=Tuple(elts=[Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), Constant(value=True), Name(id='a', ctx=Load())], ctx=Load())))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='locate', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred'), arg(arg='window_size')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='bool', ctx=Load()), Constant(value=None)]), body=[Expr(value=Constant(value="Yield the index of each item in *iterable* for which *pred* returns\n    ``True``.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(locate([0, 1, 1, 0, 1, 0, 0]))\n        [1, 2, 4]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item.\n\n        >>> list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))\n        [1, 3]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(locate(iterable, pred=pred, window_size=3))\n        [1, 5, 9]\n\n    Use with :func:`seekable` to find indexes and then retrieve the associated\n    items:\n\n        >>> from itertools import count\n        >>> from more_itertools import seekable\n        >>> source = (3 * n + 1 if (n % 2) else n // 2 for n in count())\n        >>> it = seekable(source)\n        >>> pred = lambda x: x > 100\n        >>> indexes = locate(it, pred=pred)\n        >>> i = next(indexes)\n        >>> it.seek(i)\n        >>> next(it)\n        106\n\n    ")), If(test=Compare(left=Name(id='window_size', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='compress', ctx=Load()), args=[Call(func=Name(id='count', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='map', ctx=Load()), args=[Name(id='pred', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='window_size', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='window size must be at least 1')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='windowed', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='window_size', ctx=Load())], keywords=[keyword(arg='fillvalue', value=Name(id='_marker', ctx=Load()))])), Return(value=Call(func=Name(id='compress', ctx=Load()), args=[Call(func=Name(id='count', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='starmap', ctx=Load()), args=[Name(id='pred', ctx=Load()), Name(id='it', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='lstrip', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield the items from *iterable*, but strip any from the beginning\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the start of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(lstrip(iterable, pred))\n        [1, 2, None, 3, False, None]\n\n    This function is analogous to to :func:`str.lstrip`, and is essentially\n    an wrapper for :func:`itertools.dropwhile`.\n\n    ")), Return(value=Call(func=Name(id='dropwhile', ctx=Load()), args=[Name(id='pred', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='rstrip', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield the items from *iterable*, but strip any from the end\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the end of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(rstrip(iterable, pred))\n        [None, False, None, 1, 2, None, 3]\n\n    This function is analogous to :func:`str.rstrip`.\n\n    ")), Assign(targets=[Name(id='cache', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='cache_append', ctx=Store())], value=Attribute(value=Name(id='cache', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='cache_clear', ctx=Store())], value=Attribute(value=Name(id='cache', ctx=Load()), attr='clear', ctx=Load())), For(target=Name(id='x', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[If(test=Call(func=Name(id='pred', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='cache_append', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]))], orelse=[Expr(value=YieldFrom(value=Name(id='cache', ctx=Load()))), Expr(value=Call(func=Name(id='cache_clear', ctx=Load()), args=[], keywords=[])), Expr(value=Yield(value=Name(id='x', ctx=Load())))])], orelse=[])], decorator_list=[]), FunctionDef(name='strip', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield the items from *iterable*, but strip any from the\n    beginning and end for which *pred* returns ``True``.\n\n    For example, to remove a set of items from both ends of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(strip(iterable, pred))\n        [1, 2, None, 3]\n\n    This function is analogous to :func:`str.strip`.\n\n    ")), Return(value=Call(func=Name(id='rstrip', ctx=Load()), args=[Call(func=Name(id='lstrip', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='pred', ctx=Load())], keywords=[]), Name(id='pred', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='islice_extended', bases=[], keywords=[], body=[Expr(value=Constant(value="An extension of :func:`itertools.islice` that supports negative values\n    for *stop*, *start*, and *step*.\n\n        >>> iterable = iter('abcdefgh')\n        >>> list(islice_extended(iterable, -4, -1))\n        ['e', 'f', 'g']\n\n    Slices with negative values require some caching of *iterable*, but this\n    function takes care to minimize the amount of memory required.\n\n    For example, you can use a negative step with an infinite iterator:\n\n        >>> from itertools import count\n        >>> list(islice_extended(count(), 110, 99, -2))\n        [110, 108, 106, 104, 102, 100]\n\n    You can also use slice notation directly:\n\n        >>> iterable = map(str, count())\n        >>> it = islice_extended(iterable)[10:20:2]\n        >>> list(it)\n        ['10', '12', '14', '16', '18']\n\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterable')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), If(test=Name(id='args', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterable', ctx=Store())], value=Call(func=Name(id='_islice_helper', ctx=Load()), args=[Name(id='it', ctx=Load()), Call(func=Name(id='slice', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterable', ctx=Store())], value=Name(id='it', ctx=Load()))])], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__next__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterable', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='slice', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='islice_extended', ctx=Load()), args=[Call(func=Name(id='_islice_helper', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterable', ctx=Load()), Name(id='key', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='islice_extended.__getitem__ argument must be a slice')], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='_islice_helper', args=arguments(posonlyargs=[], args=[arg(arg='it'), arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=Attribute(value=Name(id='s', ctx=Load()), attr='start', ctx=Load())), Assign(targets=[Name(id='stop', ctx=Store())], value=Attribute(value=Name(id='s', ctx=Load()), attr='stop', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='s', ctx=Load()), attr='step', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='step argument must be a non-zero integer or None.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='step', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='s', ctx=Load()), attr='step', ctx=Load()), Constant(value=1)])), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=IfExp(test=Compare(left=Name(id='start', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Constant(value=0), orelse=Name(id='start', ctx=Load()))), If(test=Compare(left=Name(id='start', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='cache', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='it', ctx=Load()), Constant(value=1)], keywords=[])], keywords=[keyword(arg='maxlen', value=UnaryOp(op=USub(), operand=Name(id='start', ctx=Load())))])), Assign(targets=[Name(id='len_iter', ctx=Store())], value=IfExp(test=Name(id='cache', ctx=Load()), body=Subscript(value=Subscript(value=Name(id='cache', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), slice=Constant(value=0), ctx=Load()), orelse=Constant(value=0))), Assign(targets=[Name(id='i', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='len_iter', ctx=Load()), op=Add(), right=Name(id='start', ctx=Load())), Constant(value=0)], keywords=[])), If(test=Compare(left=Name(id='stop', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=Name(id='len_iter', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='stop', ctx=Load()), ops=[GtE()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='stop', ctx=Load()), Name(id='len_iter', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='j', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='len_iter', ctx=Load()), op=Add(), right=Name(id='stop', ctx=Load())), Constant(value=0)], keywords=[]))])]), Assign(targets=[Name(id='n', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Sub(), right=Name(id='i', ctx=Load()))), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)]), body=[Return()], orelse=[]), For(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='islice', ctx=Load()), args=[Name(id='cache', ctx=Load()), Constant(value=0), Name(id='n', ctx=Load()), Name(id='step', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='item', ctx=Load())))], orelse=[])], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='stop', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='stop', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)])]), body=[Expr(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='start', ctx=Load()), Name(id='start', ctx=Load())], keywords=[]), Constant(value=None)], keywords=[])), Assign(targets=[Name(id='cache', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), UnaryOp(op=USub(), operand=Name(id='stop', ctx=Load()))], keywords=[])], keywords=[keyword(arg='maxlen', value=UnaryOp(op=USub(), operand=Name(id='stop', ctx=Load())))])), For(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='cached_item', ctx=Store())], value=Call(func=Attribute(value=Name(id='cache', ctx=Load()), attr='popleft', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=BinOp(left=Name(id='index', ctx=Load()), op=Mod(), right=Name(id='step', ctx=Load())), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Yield(value=Name(id='cached_item', ctx=Load())))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='cache', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Expr(value=YieldFrom(value=Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='start', ctx=Load()), Name(id='stop', ctx=Load()), Name(id='step', ctx=Load())], keywords=[])))])])], orelse=[Assign(targets=[Name(id='start', ctx=Store())], value=IfExp(test=Compare(left=Name(id='start', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=UnaryOp(op=USub(), operand=Constant(value=1)), orelse=Name(id='start', ctx=Load()))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='stop', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='stop', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)])]), body=[Assign(targets=[Name(id='n', ctx=Store())], value=BinOp(left=UnaryOp(op=USub(), operand=Name(id='stop', ctx=Load())), op=Sub(), right=Constant(value=1))), Assign(targets=[Name(id='cache', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='it', ctx=Load()), Constant(value=1)], keywords=[])], keywords=[keyword(arg='maxlen', value=Name(id='n', ctx=Load()))])), Assign(targets=[Name(id='len_iter', ctx=Store())], value=IfExp(test=Name(id='cache', ctx=Load()), body=Subscript(value=Subscript(value=Name(id='cache', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), slice=Constant(value=0), ctx=Load()), orelse=Constant(value=0))), If(test=Compare(left=Name(id='start', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Tuple(elts=[Name(id='i', ctx=Store()), Name(id='j', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='start', ctx=Load()), Name(id='stop', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='i', ctx=Store()), Name(id='j', ctx=Store())], ctx=Store())], value=Tuple(elts=[Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=Name(id='start', ctx=Load()), op=Sub(), right=Name(id='len_iter', ctx=Load())), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), Constant(value=None)], ctx=Load()))]), For(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='item', ctx=Store())], ctx=Store()), iter=Subscript(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='cache', ctx=Load())], keywords=[]), slice=Slice(lower=Name(id='i', ctx=Load()), upper=Name(id='j', ctx=Load()), step=Name(id='step', ctx=Load())), ctx=Load()), body=[Expr(value=Yield(value=Name(id='item', ctx=Load())))], orelse=[])], orelse=[If(test=Compare(left=Name(id='stop', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='m', ctx=Store())], value=BinOp(left=Name(id='stop', ctx=Load()), op=Add(), right=Constant(value=1))), Expr(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='m', ctx=Load()), Name(id='m', ctx=Load())], keywords=[]), Constant(value=None)], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='start', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='i', ctx=Store())], value=Name(id='start', ctx=Load())), Assign(targets=[Name(id='n', ctx=Store())], value=Constant(value=None))], orelse=[If(test=Compare(left=Name(id='stop', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='i', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='n', ctx=Store())], value=BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Constant(value=1)))], orelse=[Assign(targets=[Name(id='i', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='n', ctx=Store())], value=BinOp(left=Name(id='start', ctx=Load()), op=Sub(), right=Name(id='stop', ctx=Load()))), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)]), body=[Return()], orelse=[])])]), Assign(targets=[Name(id='cache', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='n', ctx=Load())], keywords=[])], keywords=[])), Expr(value=YieldFrom(value=Subscript(value=Name(id='cache', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load()), step=Name(id='step', ctx=Load())), ctx=Load())))])])], decorator_list=[]), FunctionDef(name='always_reversible', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='An extension of :func:`reversed` that supports all iterables, not\n    just those which implement the ``Reversible`` or ``Sequence`` protocols.\n\n        >>> print(*always_reversible(x for x in range(3)))\n        2 1 0\n\n    If the iterable is already reversible, this function returns the\n    result of :func:`reversed()`. If the iterable is not reversible,\n    this function will cache the remaining items in the iterable and\n    yield them in reverse order, which may require significant storage.\n    ')), Try(body=[Return(value=Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Return(value=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='consecutive_groups', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='ordering')], kwonlyargs=[], kw_defaults=[], defaults=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='x', ctx=Load()))]), body=[Expr(value=Constant(value="Yield groups of consecutive items using :func:`itertools.groupby`.\n    The *ordering* function determines whether two items are adjacent by\n    returning their position.\n\n    By default, the ordering function is the identity function. This is\n    suitable for finding runs of numbers:\n\n        >>> iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]\n        >>> for group in consecutive_groups(iterable):\n        ...     print(list(group))\n        [1]\n        [10, 11, 12]\n        [20]\n        [30, 31, 32, 33]\n        [40]\n\n    For finding runs of adjacent letters, try using the :meth:`index` method\n    of a string of letters:\n\n        >>> from string import ascii_lowercase\n        >>> iterable = 'abcdfgilmnop'\n        >>> ordering = ascii_lowercase.index\n        >>> for group in consecutive_groups(iterable, ordering):\n        ...     print(list(group))\n        ['a', 'b', 'c', 'd']\n        ['f', 'g']\n        ['i']\n        ['l', 'm', 'n', 'o', 'p']\n\n    Each group of consecutive items is an iterator that shares it source with\n    *iterable*. When an an output group is advanced, the previous group is\n    no longer available unless its elements are copied (e.g., into a ``list``).\n\n        >>> iterable = [1, 2, 11, 12, 21, 22]\n        >>> saved_groups = []\n        >>> for group in consecutive_groups(iterable):\n        ...     saved_groups.append(list(group))  # Copy group elements\n        >>> saved_groups\n        [[1, 2], [11, 12], [21, 22]]\n\n    ")), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='g', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='groupby', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=BinOp(left=Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=0), ctx=Load()), op=Sub(), right=Call(func=Name(id='ordering', ctx=Load()), args=[Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[]))))]), body=[Expr(value=Yield(value=Call(func=Name(id='map', ctx=Load()), args=[Call(func=Name(id='itemgetter', ctx=Load()), args=[Constant(value=1)], keywords=[]), Name(id='g', ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[]), FunctionDef(name='difference', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='func')], kwonlyargs=[arg(arg='initial')], kw_defaults=[Constant(value=None)], defaults=[Name(id='sub', ctx=Load())]), body=[Expr(value=Constant(value='This function is the inverse of :func:`itertools.accumulate`. By default\n    it will compute the first difference of *iterable* using\n    :func:`operator.sub`:\n\n        >>> from itertools import accumulate\n        >>> iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10\n        >>> list(difference(iterable))\n        [0, 1, 2, 3, 4]\n\n    *func* defaults to :func:`operator.sub`, but other functions can be\n    specified. They will be applied as follows::\n\n        A, B, C, D, ... --> A, func(B, A), func(C, B), func(D, C), ...\n\n    For example, to do progressive division:\n\n        >>> iterable = [1, 2, 6, 24, 120]\n        >>> func = lambda x, y: x // y\n        >>> list(difference(iterable, func))\n        [1, 2, 3, 4, 5]\n\n    If the *initial* keyword is set, the first element will be skipped when\n    computing successive differences.\n\n        >>> it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10)\n        >>> list(difference(it, initial=10))\n        [1, 2, 3]\n\n    ')), Assign(targets=[Tuple(elts=[Name(id='a', ctx=Store()), Name(id='b', ctx=Store())], ctx=Store())], value=Call(func=Name(id='tee', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='first', ctx=Store())], value=List(elts=[Call(func=Name(id='next', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], ctx=Load()))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[]))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='initial', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='first', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='chain', ctx=Load()), args=[Name(id='first', ctx=Load()), Call(func=Name(id='starmap', ctx=Load()), args=[Name(id='func', ctx=Load()), Call(func=Name(id='zip', ctx=Load()), args=[Name(id='b', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[]), ClassDef(name='SequenceView', bases=[Name(id='Sequence', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Return a read-only view of the sequence object *target*.\n\n    :class:`SequenceView` objects are analogous to Python\'s built-in\n    "dictionary view" types. They provide a dynamic view of a sequence\'s items,\n    meaning that when the sequence updates, so does the view.\n\n        >>> seq = [\'0\', \'1\', \'2\']\n        >>> view = SequenceView(seq)\n        >>> view\n        SequenceView([\'0\', \'1\', \'2\'])\n        >>> seq.append(\'3\')\n        >>> view\n        SequenceView([\'0\', \'1\', \'2\', \'3\'])\n\n    Sequence views support indexing, slicing, and length queries. They act\n    like the underlying sequence, except they don\'t allow assignment:\n\n        >>> view[1]\n        \'1\'\n        >>> view[1:-1]\n        [\'1\', \'2\']\n        >>> len(view)\n        4\n\n    Sequence views are useful as an alternative to copying, as they don\'t\n    require (much) extra storage.\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='target')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='Sequence', ctx=Load())], keywords=[])), body=[Raise(exc=Name(id='TypeError', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_target', ctx=Store())], value=Name(id='target', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_target', ctx=Load()), slice=Name(id='index', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__len__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_target', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='{}({})'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_target', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='seekable', bases=[], keywords=[], body=[Expr(value=Constant(value='Wrap an iterator to allow for seeking backward and forward. This\n    progressively caches the items in the source iterable so they can be\n    re-visited.\n\n    Call :meth:`seek` with an index to seek to that position in the source\n    iterable.\n\n    To "reset" an iterator, seek to ``0``:\n\n        >>> from itertools import count\n        >>> it = seekable((str(n) for n in count()))\n        >>> next(it), next(it), next(it)\n        (\'0\', \'1\', \'2\')\n        >>> it.seek(0)\n        >>> next(it), next(it), next(it)\n        (\'0\', \'1\', \'2\')\n        >>> next(it)\n        \'3\'\n\n    You can also seek forward:\n\n        >>> it = seekable((str(n) for n in range(20)))\n        >>> it.seek(10)\n        >>> next(it)\n        \'10\'\n        >>> it.seek(20)  # Seeking past the end of the source isn\'t a problem\n        >>> list(it)\n        []\n        >>> it.seek(0)  # Resetting works even after hitting the end\n        >>> next(it), next(it), next(it)\n        (\'0\', \'1\', \'2\')\n\n    Call :meth:`peek` to look ahead one item without advancing the iterator:\n\n        >>> it = seekable(\'1234\')\n        >>> it.peek()\n        \'1\'\n        >>> list(it)\n        [\'1\', \'2\', \'3\', \'4\']\n        >>> it.peek(default=\'empty\')\n        \'empty\'\n\n    Before the iterator is at its end, calling :func:`bool` on it will return\n    ``True``. After it will return ``False``:\n\n        >>> it = seekable(\'5678\')\n        >>> bool(it)\n        True\n        >>> list(it)\n        [\'5\', \'6\', \'7\', \'8\']\n        >>> bool(it)\n        False\n\n    You may view the contents of the cache with the :meth:`elements` method.\n    That returns a :class:`SequenceView`, a view that updates automatically:\n\n        >>> it = seekable((str(n) for n in range(10)))\n        >>> next(it), next(it), next(it)\n        (\'0\', \'1\', \'2\')\n        >>> elements = it.elements()\n        >>> elements\n        SequenceView([\'0\', \'1\', \'2\'])\n        >>> next(it)\n        \'3\'\n        >>> elements\n        SequenceView([\'0\', \'1\', \'2\', \'3\'])\n\n    By default, the cache grows as the source iterable progresses, so beware of\n    wrapping very large or infinite iterables. Supply *maxlen* to limit the\n    size of the cache (this of course limits how far back you can seek).\n\n        >>> from itertools import count\n        >>> it = seekable((str(n) for n in count()), maxlen=2)\n        >>> next(it), next(it), next(it), next(it)\n        (\'0\', \'1\', \'2\', \'3\')\n        >>> list(it.elements())\n        [\'2\', \'3\']\n        >>> it.seek(0)\n        >>> next(it), next(it), next(it), next(it)\n        (\'2\', \'3\', \'4\', \'5\')\n        >>> next(it)\n        \'6\'\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterable'), arg(arg='maxlen')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_source', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='maxlen', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[List(elts=[], ctx=Load()), Name(id='maxlen', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__next__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Try(body=[Assign(targets=[Name(id='item', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Store())], value=Constant(value=None))])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Store()), op=Add(), value=Constant(value=1)), Return(value=Name(id='item', ctx=Load()))], finalbody=[])], orelse=[]), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_source', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), Return(value=Name(id='item', ctx=Load()))], decorator_list=[]), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='peek', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='peek', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='_marker', ctx=Load())]), body=[Try(body=[Assign(targets=[Name(id='peeked', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[If(test=Compare(left=Name(id='default', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[Raise()], orelse=[]), Return(value=Name(id='default', ctx=Load()))])], orelse=[], finalbody=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Store()), op=Sub(), value=Constant(value=1)), Return(value=Name(id='peeked', ctx=Load()))], decorator_list=[]), FunctionDef(name='elements', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='SequenceView', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='seek', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_index', ctx=Store())], value=Name(id='index', ctx=Load())), Assign(targets=[Name(id='remainder', ctx=Store())], value=BinOp(left=Name(id='index', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_cache', ctx=Load())], keywords=[]))), If(test=Compare(left=Name(id='remainder', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Name(id='consume', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='remainder', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='run_length', bases=[], keywords=[], body=[Expr(value=Constant(value="\n    :func:`run_length.encode` compresses an iterable with run-length encoding.\n    It yields groups of repeated items with the count of how many times they\n    were repeated:\n\n        >>> uncompressed = 'abbcccdddd'\n        >>> list(run_length.encode(uncompressed))\n        [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n\n    :func:`run_length.decode` decompresses an iterable that was previously\n    compressed with run-length encoding. It yields the items of the\n    decompressed iterable:\n\n        >>> compressed = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> list(run_length.decode(compressed))\n        ['a', 'b', 'b', 'c', 'c', 'c', 'd', 'd', 'd', 'd']\n\n    ")), FunctionDef(name='encode', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=GeneratorExp(elt=Tuple(elts=[Name(id='k', ctx=Load()), Call(func=Name(id='ilen', ctx=Load()), args=[Name(id='g', ctx=Load())], keywords=[])], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='g', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='groupby', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='decode', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='k', ctx=Load()), Name(id='n', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='n', ctx=Store())], ctx=Store()), iter=Name(id='iterable', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())])], decorator_list=[]), FunctionDef(name='exactly_n', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n'), arg(arg='predicate')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='bool', ctx=Load())]), body=[Expr(value=Constant(value='Return ``True`` if exactly ``n`` items in the iterable are ``True``\n    according to the *predicate* function.\n\n        >>> exactly_n([True, True, False], 2)\n        True\n        >>> exactly_n([True, True, False], 1)\n        False\n        >>> exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x < 3)\n        True\n\n    The iterable will be advanced until ``n + 1`` truthy items are encountered,\n    so avoid calling it on infinite iterables.\n\n    ')), Return(value=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='take', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Constant(value=1)), Call(func=Name(id='filter', ctx=Load()), args=[Name(id='predicate', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[])], keywords=[])], keywords=[]), ops=[Eq()], comparators=[Name(id='n', ctx=Load())]))], decorator_list=[]), FunctionDef(name='circular_shifts', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a list of circular shifts of *iterable*.\n\n    >>> circular_shifts(range(4))\n    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n    ')), Assign(targets=[Name(id='lst', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='take', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='lst', ctx=Load())], keywords=[]), Call(func=Name(id='windowed', ctx=Load()), args=[Call(func=Name(id='cycle', ctx=Load()), args=[Name(id='lst', ctx=Load())], keywords=[]), Call(func=Name(id='len', ctx=Load()), args=[Name(id='lst', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='make_decorator', args=arguments(posonlyargs=[], args=[arg(arg='wrapping_func'), arg(arg='result_index')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Return a decorator version of *wrapping_func*, which is a function that\n    modifies an iterable. *result_index* is the position in that function\'s\n    signature where the iterable goes.\n\n    This lets you use itertools on the "production end," i.e. at function\n    definition. This can augment what the function returns without changing the\n    function\'s code.\n\n    For example, to produce a decorator version of :func:`chunked`:\n\n        >>> from more_itertools import chunked\n        >>> chunker = make_decorator(chunked, result_index=0)\n        >>> @chunker(3)\n        ... def iter_range(n):\n        ...     return iter(range(n))\n        ...\n        >>> list(iter_range(9))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n    To only allow truthy items to be returned:\n\n        >>> truth_serum = make_decorator(filter, result_index=1)\n        >>> @truth_serum(bool)\n        ... def boolean_test():\n        ...     return [0, 1, \'\', \' \', False, True]\n        ...\n        >>> list(boolean_test())\n        [1, \' \', True]\n\n    The :func:`peekable` and :func:`seekable` wrappers make for practical\n    decorators:\n\n        >>> from more_itertools import peekable\n        >>> peekable_function = make_decorator(peekable)\n        >>> @peekable_function()\n        ... def str_range(*args):\n        ...     return (str(x) for x in range(*args))\n        ...\n        >>> it = str_range(1, 20, 2)\n        >>> next(it), next(it), next(it)\n        (\'1\', \'3\', \'5\')\n        >>> it.peek()\n        \'7\'\n        >>> next(it)\n        \'7\'\n\n    ')), FunctionDef(name='decorator', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='wrapping_args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='wrapping_kwargs'), defaults=[]), body=[FunctionDef(name='outer_wrapper', args=arguments(posonlyargs=[], args=[arg(arg='f')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='inner_wrapper', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='f', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Name(id='wrapping_args_', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='wrapping_args', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='wrapping_args_', ctx=Load()), attr='insert', ctx=Load()), args=[Name(id='result_index', ctx=Load()), Name(id='result', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='wrapping_func', ctx=Load()), args=[Starred(value=Name(id='wrapping_args_', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='wrapping_kwargs', ctx=Load()))]))], decorator_list=[]), Return(value=Name(id='inner_wrapper', ctx=Load()))], decorator_list=[]), Return(value=Name(id='outer_wrapper', ctx=Load()))], decorator_list=[]), Return(value=Name(id='decorator', ctx=Load()))], decorator_list=[]), FunctionDef(name='map_reduce', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='keyfunc'), arg(arg='valuefunc'), arg(arg='reducefunc')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Return a dictionary that maps the items in *iterable* to categories\n    defined by *keyfunc*, transforms them with *valuefunc*, and\n    then summarizes them by category with *reducefunc*.\n\n    *valuefunc* defaults to the identity function if it is unspecified.\n    If *reducefunc* is unspecified, no summarization takes place:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> result = map_reduce('abbccc', keyfunc)\n        >>> sorted(result.items())\n        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    Specifying *valuefunc* transforms the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n        >>> sorted(result.items())\n        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    Specifying *reducefunc* summarizes the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> reducefunc = sum\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n        >>> sorted(result.items())\n        [('A', 1), ('B', 2), ('C', 3)]\n\n    You may want to filter the input iterable before applying the map/reduce\n    procedure:\n\n        >>> all_items = range(30)\n        >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n        >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n        >>> categories = map_reduce(items, keyfunc=keyfunc)\n        >>> sorted(categories.items())\n        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n        >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n        >>> sorted(summaries.items())\n        [(0, 90), (1, 75)]\n\n    Note that all items in the iterable are gathered into a list before the\n    summarization step, which may require significant storage.\n\n    The returned object is a :obj:`collections.defaultdict` with the\n    ``default_factory`` set to ``None``, such that it behaves like a normal\n    dictionary.\n\n    ")), Assign(targets=[Name(id='valuefunc', ctx=Store())], value=IfExp(test=Compare(left=Name(id='valuefunc', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='x', ctx=Load())), orelse=Name(id='valuefunc', ctx=Load()))), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='defaultdict', ctx=Load()), args=[Name(id='list', ctx=Load())], keywords=[])), For(target=Name(id='item', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[Assign(targets=[Name(id='key', ctx=Store())], value=Call(func=Name(id='keyfunc', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='valuefunc', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='ret', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='reducefunc', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value_list', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='ret', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Call(func=Name(id='reducefunc', ctx=Load()), args=[Name(id='value_list', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='ret', ctx=Load()), attr='default_factory', ctx=Store())], value=Constant(value=None)), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[]), FunctionDef(name='rlocate', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred'), arg(arg='window_size')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='bool', ctx=Load()), Constant(value=None)]), body=[Expr(value=Constant(value="Yield the index of each item in *iterable* for which *pred* returns\n    ``True``, starting from the right and moving left.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4\n        [4, 2, 1]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item:\n\n        >>> iterable = iter('abcb')\n        >>> pred = lambda x: x == 'b'\n        >>> list(rlocate(iterable, pred))\n        [3, 1]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(rlocate(iterable, pred=pred, window_size=3))\n        [9, 5, 1]\n\n    Beware, this function won't return anything for infinite iterables.\n    If *iterable* is reversible, ``rlocate`` will reverse it and search from\n    the right. Otherwise, it will search from the left and return the results\n    in reverse order.\n\n    See :func:`locate` to for other example applications.\n\n    ")), If(test=Compare(left=Name(id='window_size', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Try(body=[Assign(targets=[Name(id='len_iter', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Return(value=GeneratorExp(elt=BinOp(left=BinOp(left=Name(id='len_iter', ctx=Load()), op=Sub(), right=Name(id='i', ctx=Load())), op=Sub(), right=Constant(value=1)), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='locate', ctx=Load()), args=[Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]), Name(id='pred', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Return(value=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='locate', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='pred', ctx=Load()), Name(id='window_size', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='replace', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred'), arg(arg='substitutes'), arg(arg='count'), arg(arg='window_size')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=1)]), body=[Expr(value=Constant(value='Yield the items from *iterable*, replacing the items for which *pred*\n    returns ``True`` with the items from the iterable *substitutes*.\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = (2, 3)\n        >>> list(replace(iterable, pred, substitutes))\n        [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]\n\n    If *count* is given, the number of replacements will be limited:\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = [None]\n        >>> list(replace(iterable, pred, substitutes, count=2))\n        [1, 1, None, 1, 1, None, 1, 1, 0]\n\n    Use *window_size* to control the number of items passed as arguments to\n    *pred*. This allows for locating and replacing subsequences.\n\n        >>> iterable = [0, 1, 2, 5, 0, 1, 2, 5]\n        >>> window_size = 3\n        >>> pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred\n        >>> substitutes = [3, 4] # Splice in these items\n        >>> list(replace(iterable, pred, substitutes, window_size=window_size))\n        [3, 4, 5, 3, 4, 5]\n\n    ')), If(test=Compare(left=Name(id='window_size', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='window_size must be at least 1')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='substitutes', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='substitutes', ctx=Load())], keywords=[])), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='chain', ctx=Load()), args=[Name(id='iterable', ctx=Load()), BinOp(left=List(elts=[Name(id='_marker', ctx=Load())], ctx=Load()), op=Mult(), right=BinOp(left=Name(id='window_size', ctx=Load()), op=Sub(), right=Constant(value=1)))], keywords=[])), Assign(targets=[Name(id='windows', ctx=Store())], value=Call(func=Name(id='windowed', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='window_size', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Constant(value=0)), For(target=Name(id='w', ctx=Store()), iter=Name(id='windows', ctx=Load()), body=[If(test=Call(func=Name(id='pred', ctx=Load()), args=[Starred(value=Name(id='w', ctx=Load()), ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='count', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='n', ctx=Load()), ops=[Lt()], comparators=[Name(id='count', ctx=Load())])]), body=[AugAssign(target=Name(id='n', ctx=Store()), op=Add(), value=Constant(value=1)), Expr(value=YieldFrom(value=Name(id='substitutes', ctx=Load()))), Expr(value=Call(func=Name(id='consume', ctx=Load()), args=[Name(id='windows', ctx=Load()), BinOp(left=Name(id='window_size', ctx=Load()), op=Sub(), right=Constant(value=1))], keywords=[])), Continue()], orelse=[])], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='w', ctx=Load()), Compare(left=Subscript(value=Name(id='w', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[IsNot()], comparators=[Name(id='_marker', ctx=Load())])]), body=[Expr(value=Yield(value=Subscript(value=Name(id='w', ctx=Load()), slice=Constant(value=0), ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='partitions', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield all possible order-preserving partitions of *iterable*.\n\n    >>> iterable = 'abc'\n    >>> for part in partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['a', 'b', 'c']\n\n    This is unrelated to :func:`partition`.\n\n    ")), Assign(targets=[Name(id='sequence', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sequence', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='powerset', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Constant(value=1), Name(id='n', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Yield(value=ListComp(elt=Subscript(value=Name(id='sequence', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load()), upper=Name(id='j', ctx=Load())), ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='j', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[BinOp(left=Tuple(elts=[Constant(value=0)], ctx=Load()), op=Add(), right=Name(id='i', ctx=Load())), BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Tuple(elts=[Name(id='n', ctx=Load())], ctx=Load()))], keywords=[]), ifs=[], is_async=0)])))], orelse=[])], decorator_list=[]), FunctionDef(name='set_partitions', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='k')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n    Yield the set partitions of *iterable* into *k* parts. Set partitions are\n    not order-preserving.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable, 2):\n    ...     print([''.join(p) for p in part])\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n\n\n    If *k* is not given, every set partition is generated.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n    ['a', 'b', 'c']\n\n    ")), Assign(targets=[Name(id='L', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='L', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='k', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Can't partition in a negative or zero number of groups")], keywords=[]))], orelse=[If(test=Compare(left=Name(id='k', ctx=Load()), ops=[Gt()], comparators=[Name(id='n', ctx=Load())]), body=[Return()], orelse=[])])], orelse=[]), FunctionDef(name='set_partitions_helper', args=arguments(posonlyargs=[], args=[arg(arg='L'), arg(arg='k')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='L', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Expr(value=Yield(value=List(elts=[Name(id='L', ctx=Load())], ctx=Load())))], orelse=[If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Eq()], comparators=[Name(id='k', ctx=Load())]), body=[Expr(value=Yield(value=ListComp(elt=List(elts=[Name(id='s', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='s', ctx=Store()), iter=Name(id='L', ctx=Load()), ifs=[], is_async=0)])))], orelse=[Assign(targets=[Tuple(elts=[Name(id='e', ctx=Store()), Starred(value=Name(id='M', ctx=Store()), ctx=Store())], ctx=Store())], value=Name(id='L', ctx=Load())), For(target=Name(id='p', ctx=Store()), iter=Call(func=Name(id='set_partitions_helper', ctx=Load()), args=[Name(id='M', ctx=Load()), BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Constant(value=1))], keywords=[]), body=[Expr(value=Yield(value=List(elts=[List(elts=[Name(id='e', ctx=Load())], ctx=Load()), Starred(value=Name(id='p', ctx=Load()), ctx=Load())], ctx=Load())))], orelse=[]), For(target=Name(id='p', ctx=Store()), iter=Call(func=Name(id='set_partitions_helper', ctx=Load()), args=[Name(id='M', ctx=Load()), Name(id='k', ctx=Load())], keywords=[]), body=[For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Yield(value=BinOp(left=BinOp(left=Subscript(value=Name(id='p', ctx=Load()), slice=Slice(upper=Name(id='i', ctx=Load())), ctx=Load()), op=Add(), right=List(elts=[BinOp(left=List(elts=[Name(id='e', ctx=Load())], ctx=Load()), op=Add(), right=Subscript(value=Name(id='p', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()))], ctx=Load())), op=Add(), right=Subscript(value=Name(id='p', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load()))))], orelse=[])], orelse=[])])])], decorator_list=[]), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[For(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=1), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), body=[Expr(value=YieldFrom(value=Call(func=Name(id='set_partitions_helper', ctx=Load()), args=[Name(id='L', ctx=Load()), Name(id='k', ctx=Load())], keywords=[])))], orelse=[])], orelse=[Expr(value=YieldFrom(value=Call(func=Name(id='set_partitions_helper', ctx=Load()), args=[Name(id='L', ctx=Load()), Name(id='k', ctx=Load())], keywords=[])))])], decorator_list=[]), ClassDef(name='time_limited', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Yield items from *iterable* until *limit_seconds* have passed.\n    If the time limit expires before all items have been yielded, the\n    ``timed_out`` parameter will be set to ``True``.\n\n    >>> from time import sleep\n    >>> def generator():\n    ...     yield 1\n    ...     yield 2\n    ...     sleep(0.2)\n    ...     yield 3\n    >>> iterable = time_limited(0.1, generator())\n    >>> list(iterable)\n    [1, 2]\n    >>> iterable.timed_out\n    True\n\n    Note that the time is checked before each item is yielded, and iteration\n    stops if  the time elapsed is greater than *limit_seconds*. If your time\n    limit is 1 second, but it takes 2 seconds to generate the first item from\n    the iterable, the function will run for 2 seconds and not yield anything.\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='limit_seconds'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='limit_seconds', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='limit_seconds must be positive')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='limit_seconds', ctx=Store())], value=Name(id='limit_seconds', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterable', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_start_time', ctx=Store())], value=Call(func=Name(id='monotonic', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='timed_out', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__next__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterable', ctx=Load())], keywords=[])), If(test=Compare(left=BinOp(left=Call(func=Name(id='monotonic', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_start_time', ctx=Load())), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='limit_seconds', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='timed_out', ctx=Store())], value=Constant(value=True)), Raise(exc=Name(id='StopIteration', ctx=Load()))], orelse=[]), Return(value=Name(id='item', ctx=Load()))], decorator_list=[])], decorator_list=[]), FunctionDef(name='only', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='default'), arg(arg='too_long')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="If *iterable* has only one item, return it.\n    If it has zero items, return *default*.\n    If it has more than one item, raise the exception given by *too_long*,\n    which is ``ValueError`` by default.\n\n    >>> only([], default='missing')\n    'missing'\n    >>> only([1])\n    1\n    >>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: Expected exactly one item in iterable, but got 1, 2,\n     and perhaps more.'\n    >>> only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    TypeError\n\n    Note that :func:`only` attempts to advance *iterable* twice to ensure there\n    is only one item.  See :func:`spy` or :func:`peekable` to check\n    iterable contents less destructively.\n    ")), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='first_value', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='second_value', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Pass()])], orelse=[Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Constant(value='Expected exactly one item in iterable, but got {!r}, {!r}, and perhaps more.'), attr='format', ctx=Load()), args=[Name(id='first_value', ctx=Load()), Name(id='second_value', ctx=Load())], keywords=[])), Raise(exc=BoolOp(op=Or(), values=[Name(id='too_long', ctx=Load()), Call(func=Name(id='ValueError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[])]))], finalbody=[]), Return(value=Name(id='first_value', ctx=Load()))], decorator_list=[]), FunctionDef(name='ichunked', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Break *iterable* into sub-iterables with *n* elements each.\n    :func:`ichunked` is like :func:`chunked`, but it yields iterables\n    instead of lists.\n\n    If the sub-iterables are read in order, the elements of *iterable*\n    won't be stored in memory.\n    If they are read out of order, :func:`itertools.tee` is used to cache\n    elements as necessary.\n\n    >>> from itertools import count\n    >>> all_chunks = ichunked(count(), 4)\n    >>> c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)\n    >>> list(c_2)  # c_1's elements have been cached; c_3's haven't been\n    [4, 5, 6, 7]\n    >>> list(c_1)\n    [0, 1, 2, 3]\n    >>> list(c_3)\n    [8, 9, 10, 11]\n\n    ")), Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), While(test=Constant(value=True), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='_marker', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='item', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[Return()], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='source', ctx=Store()), Name(id='it', ctx=Store())], ctx=Store())], value=Call(func=Name(id='tee', ctx=Load()), args=[Call(func=Name(id='chain', ctx=Load()), args=[List(elts=[Name(id='item', ctx=Load())], ctx=Load()), Name(id='source', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Yield(value=Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='n', ctx=Load())], keywords=[]))), Expr(value=Call(func=Name(id='consume', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='n', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='distinct_combinations', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Yield the distinct combinations of *r* items taken from *iterable*.\n\n        >>> list(distinct_combinations([0, 0, 1], 2))\n        [(0, 0), (0, 1)]\n\n    Equivalent to ``set(combinations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    ')), If(test=Compare(left=Name(id='r', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='r must be non-negative')], keywords=[]))], orelse=[If(test=Compare(left=Name(id='r', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Yield(value=Tuple(elts=[], ctx=Load()))), Return()], orelse=[])]), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='generators', ctx=Store())], value=List(elts=[Call(func=Name(id='unique_everseen', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Name(id='itemgetter', ctx=Load()), args=[Constant(value=1)], keywords=[]))])], ctx=Load())), Assign(targets=[Name(id='current_combo', ctx=Store())], value=BinOp(left=List(elts=[Constant(value=None)], ctx=Load()), op=Mult(), right=Name(id='r', ctx=Load()))), Assign(targets=[Name(id='level', ctx=Store())], value=Constant(value=0)), While(test=Name(id='generators', ctx=Load()), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='cur_idx', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Subscript(value=Name(id='generators', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='generators', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='level', ctx=Store()), op=Sub(), value=Constant(value=1)), Continue()])], orelse=[], finalbody=[]), Assign(targets=[Subscript(value=Name(id='current_combo', ctx=Load()), slice=Name(id='level', ctx=Load()), ctx=Store())], value=Name(id='p', ctx=Load())), If(test=Compare(left=BinOp(left=Name(id='level', ctx=Load()), op=Add(), right=Constant(value=1)), ops=[Eq()], comparators=[Name(id='r', ctx=Load())]), body=[Expr(value=Yield(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='current_combo', ctx=Load())], keywords=[])))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='generators', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='unique_everseen', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Subscript(value=Name(id='pool', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='cur_idx', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load()), BinOp(left=Name(id='cur_idx', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Name(id='itemgetter', ctx=Load()), args=[Constant(value=1)], keywords=[]))])], keywords=[])), AugAssign(target=Name(id='level', ctx=Store()), op=Add(), value=Constant(value=1))])], orelse=[])], decorator_list=[]), FunctionDef(name='filter_except', args=arguments(posonlyargs=[], args=[arg(arg='validator'), arg(arg='iterable')], vararg=arg(arg='exceptions'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield the items from *iterable* for which the *validator* function does\n    not raise one of the specified *exceptions*.\n\n    *validator* is called for each item in *iterable*.\n    It should be a function that accepts one argument and raises an exception\n    if that item is not valid.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(filter_except(int, iterable, ValueError, TypeError))\n    ['1', '2', '4']\n\n    If an exception other than one given by *exceptions* is raised by\n    *validator*, it is raised like normal.\n    ")), For(target=Name(id='item', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[Try(body=[Expr(value=Call(func=Name(id='validator', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='exceptions', ctx=Load()), body=[Pass()])], orelse=[Expr(value=Yield(value=Name(id='item', ctx=Load())))], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='map_except', args=arguments(posonlyargs=[], args=[arg(arg='function'), arg(arg='iterable')], vararg=arg(arg='exceptions'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Transform each item from *iterable* with *function* and yield the\n    result, unless *function* raises one of the specified *exceptions*.\n\n    *function* is called to transform each item in *iterable*.\n    It should be a accept one argument.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(map_except(int, iterable, ValueError, TypeError))\n    [1, 2, 4]\n\n    If an exception other than one given by *exceptions* is raised by\n    *function*, it is raised like normal.\n    ")), For(target=Name(id='item', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[Try(body=[Expr(value=Yield(value=Call(func=Name(id='function', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])))], handlers=[ExceptHandler(type=Name(id='exceptions', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='_sample_unweighted', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='k')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='reservoir', ctx=Store())], value=Call(func=Name(id='take', ctx=Load()), args=[Name(id='k', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='W', ctx=Store())], value=Call(func=Name(id='exp', ctx=Load()), args=[BinOp(left=Call(func=Name(id='log', ctx=Load()), args=[Call(func=Name(id='random', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Div(), right=Name(id='k', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='next_index', ctx=Store())], value=BinOp(left=Name(id='k', ctx=Load()), op=Add(), right=Call(func=Name(id='floor', ctx=Load()), args=[BinOp(left=Call(func=Name(id='log', ctx=Load()), args=[Call(func=Name(id='random', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Div(), right=Call(func=Name(id='log', ctx=Load()), args=[BinOp(left=Constant(value=1), op=Sub(), right=Name(id='W', ctx=Load()))], keywords=[]))], keywords=[]))), For(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='element', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='k', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='index', ctx=Load()), ops=[Eq()], comparators=[Name(id='next_index', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='reservoir', ctx=Load()), slice=Call(func=Name(id='randrange', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), ctx=Store())], value=Name(id='element', ctx=Load())), AugAssign(target=Name(id='W', ctx=Store()), op=Mult(), value=Call(func=Name(id='exp', ctx=Load()), args=[BinOp(left=Call(func=Name(id='log', ctx=Load()), args=[Call(func=Name(id='random', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Div(), right=Name(id='k', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='next_index', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='floor', ctx=Load()), args=[BinOp(left=Call(func=Name(id='log', ctx=Load()), args=[Call(func=Name(id='random', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Div(), right=Call(func=Name(id='log', ctx=Load()), args=[BinOp(left=Constant(value=1), op=Sub(), right=Name(id='W', ctx=Load()))], keywords=[]))], keywords=[]), op=Add(), right=Constant(value=1)))], orelse=[])], orelse=[]), Return(value=Name(id='reservoir', ctx=Load()))], decorator_list=[]), FunctionDef(name='_sample_weighted', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='k'), arg(arg='weights')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='weight_keys', ctx=Store())], value=GeneratorExp(elt=BinOp(left=Call(func=Name(id='log', ctx=Load()), args=[Call(func=Name(id='random', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Div(), right=Name(id='weight', ctx=Load())), generators=[comprehension(target=Name(id='weight', ctx=Store()), iter=Name(id='weights', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='reservoir', ctx=Store())], value=Call(func=Name(id='take', ctx=Load()), args=[Name(id='k', ctx=Load()), Call(func=Name(id='zip', ctx=Load()), args=[Name(id='weight_keys', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='heapify', ctx=Load()), args=[Name(id='reservoir', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='smallest_weight_key', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='reservoir', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='weights_to_skip', ctx=Store())], value=BinOp(left=Call(func=Name(id='log', ctx=Load()), args=[Call(func=Name(id='random', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Div(), right=Name(id='smallest_weight_key', ctx=Load()))), For(target=Tuple(elts=[Name(id='weight', ctx=Store()), Name(id='element', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='weights', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='weight', ctx=Load()), ops=[GtE()], comparators=[Name(id='weights_to_skip', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='smallest_weight_key', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='reservoir', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='t_w', ctx=Store())], value=Call(func=Name(id='exp', ctx=Load()), args=[BinOp(left=Name(id='weight', ctx=Load()), op=Mult(), right=Name(id='smallest_weight_key', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='r_2', ctx=Store())], value=Call(func=Name(id='uniform', ctx=Load()), args=[Name(id='t_w', ctx=Load()), Constant(value=1)], keywords=[])), Assign(targets=[Name(id='weight_key', ctx=Store())], value=BinOp(left=Call(func=Name(id='log', ctx=Load()), args=[Name(id='r_2', ctx=Load())], keywords=[]), op=Div(), right=Name(id='weight', ctx=Load()))), Expr(value=Call(func=Name(id='heapreplace', ctx=Load()), args=[Name(id='reservoir', ctx=Load()), Tuple(elts=[Name(id='weight_key', ctx=Load()), Name(id='element', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='smallest_weight_key', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='reservoir', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='weights_to_skip', ctx=Store())], value=BinOp(left=Call(func=Name(id='log', ctx=Load()), args=[Call(func=Name(id='random', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Div(), right=Name(id='smallest_weight_key', ctx=Load())))], orelse=[AugAssign(target=Name(id='weights_to_skip', ctx=Store()), op=Sub(), value=Name(id='weight', ctx=Load()))])], orelse=[]), Return(value=ListComp(elt=Subscript(value=Call(func=Name(id='heappop', ctx=Load()), args=[Name(id='reservoir', ctx=Load())], keywords=[]), slice=Constant(value=1), ctx=Load()), generators=[comprehension(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[]), FunctionDef(name='sample', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='k'), arg(arg='weights')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return a *k*-length list of elements chosen (without replacement)\n    from the *iterable*. Like :func:`random.sample`, but works on iterables\n    of unknown length.\n\n    >>> iterable = range(100)\n    >>> sample(iterable, 5)  # doctest: +SKIP\n    [81, 60, 96, 16, 4]\n\n    An iterable with *weights* may also be given:\n\n    >>> iterable = range(100)\n    >>> weights = (i * i + 1 for i in range(100))\n    >>> sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP\n    [79, 67, 74, 66, 78]\n\n    The algorithm can also be used to generate weighted random permutations.\n    The relative weight of each item determines the probability that it\n    appears late in the permutation.\n\n    >>> data = "abcdefgh"\n    >>> weights = range(1, len(data) + 1)\n    >>> sample(data, k=len(data), weights=weights)  # doctest: +SKIP\n    [\'c\', \'a\', \'b\', \'e\', \'g\', \'d\', \'h\', \'f\']\n    ')), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='iterable', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='weights', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='_sample_unweighted', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='k', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='weights', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='weights', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='_sample_weighted', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='k', ctx=Load()), Name(id='weights', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='is_sorted', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='key'), arg(arg='reverse')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Returns ``True`` if the items of iterable are in sorted order, and\n    ``False`` otherwise. *key* and *reverse* have the same meaning that they do\n    in the built-in :func:`sorted` function.\n\n    >>> is_sorted(['1', '2', '3', '4', '5'], key=int)\n    True\n    >>> is_sorted([5, 4, 3, 1, 2], reverse=True)\n    False\n\n    The function returns ``False`` after encountering the first out-of-order\n    item. If there are no out-of-order items, the iterable is exhausted.\n    ")), Assign(targets=[Name(id='compare', ctx=Store())], value=IfExp(test=Name(id='reverse', ctx=Load()), body=Name(id='lt', ctx=Load()), orelse=Name(id='gt', ctx=Load()))), Assign(targets=[Name(id='it', ctx=Store())], value=IfExp(test=Compare(left=Name(id='key', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Name(id='iterable', ctx=Load()), orelse=Call(func=Name(id='map', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[]))), Return(value=UnaryOp(op=Not(), operand=Call(func=Name(id='any', ctx=Load()), args=[Call(func=Name(id='starmap', ctx=Load()), args=[Name(id='compare', ctx=Load()), Call(func=Name(id='pairwise', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[])], keywords=[])], keywords=[])))], decorator_list=[]), ClassDef(name='AbortThread', bases=[Name(id='BaseException', ctx=Load())], keywords=[], body=[Pass()], decorator_list=[]), ClassDef(name='callback_iter', bases=[], keywords=[], body=[Expr(value=Constant(value="Convert a function that uses callbacks to an iterator.\n\n    Let *func* be a function that takes a `callback` keyword argument.\n    For example:\n\n    >>> def func(callback=None):\n    ...     for i, c in [(1, 'a'), (2, 'b'), (3, 'c')]:\n    ...         if callback:\n    ...             callback(i, c)\n    ...     return 4\n\n\n    Use ``with callback_iter(func)`` to get an iterator over the parameters\n    that are delivered to the callback.\n\n    >>> with callback_iter(func) as it:\n    ...     for args, kwargs in it:\n    ...         print(args)\n    (1, 'a')\n    (2, 'b')\n    (3, 'c')\n\n    The function will be called in a background thread. The ``done`` property\n    indicates whether it has completed execution.\n\n    >>> it.done\n    True\n\n    If it completes successfully, its return value will be available\n    in the ``result`` property.\n\n    >>> it.result\n    4\n\n    Notes:\n\n    * If the function uses some keyword argument besides ``callback``, supply\n      *callback_kwd*.\n    * If it finished executing, but raised an exception, accessing the\n      ``result`` property will raise the same exception.\n    * If it hasn't finished executing, accessing the ``result``\n      property from within the ``with`` block will raise ``RuntimeError``.\n    * If it hasn't finished executing, accessing the ``result`` property from\n      outside the ``with`` block will raise a\n      ``more_itertools.AbortThread`` exception.\n    * Provide *wait_seconds* to adjust how frequently the it is polled for\n      output.\n\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='func'), arg(arg='callback_kwd'), arg(arg='wait_seconds')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='callback'), Constant(value=0.1)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_func', ctx=Store())], value=Name(id='func', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback_kwd', ctx=Store())], value=Name(id='callback_kwd', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_aborted', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_future', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_wait_seconds', ctx=Store())], value=Name(id='wait_seconds', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_executor', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Name(id='__import__', ctx=Load()), args=[Constant(value='concurrent.futures')], keywords=[]), attr='futures', ctx=Load()), attr='ThreadPoolExecutor', ctx=Load()), args=[], keywords=[keyword(arg='max_workers', value=Constant(value=1))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_reader', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exc_type'), arg(arg='exc_value'), arg(arg='traceback')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_aborted', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_executor', ctx=Load()), attr='shutdown', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__next__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterator', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='done', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_future', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_future', ctx=Load()), attr='done', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='result', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='done', ctx=Load())), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='Function has not yet completed')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_future', ctx=Load()), attr='result', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_reader', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='Queue', ctx=Load()), args=[], keywords=[])), FunctionDef(name='callback', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_aborted', ctx=Load()), body=[Raise(exc=Call(func=Name(id='AbortThread', ctx=Load()), args=[Constant(value='canceled by user')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='q', ctx=Load()), attr='put', ctx=Load()), args=[Tuple(elts=[Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_future', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_executor', ctx=Load()), attr='submit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_func', ctx=Load())], keywords=[keyword(value=Dict(keys=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback_kwd', ctx=Load())], values=[Name(id='callback', ctx=Load())]))])), While(test=Constant(value=True), body=[Try(body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='q', ctx=Load()), attr='get', ctx=Load()), args=[], keywords=[keyword(arg='timeout', value=Attribute(value=Name(id='self', ctx=Load()), attr='_wait_seconds', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='Empty', ctx=Load()), body=[Pass()])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='q', ctx=Load()), attr='task_done', ctx=Load()), args=[], keywords=[])), Expr(value=Yield(value=Name(id='item', ctx=Load())))], finalbody=[]), If(test=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_future', ctx=Load()), attr='done', ctx=Load()), args=[], keywords=[]), body=[Break()], orelse=[])], orelse=[]), Assign(targets=[Name(id='remaining', ctx=Store())], value=List(elts=[], ctx=Load())), While(test=Constant(value=True), body=[Try(body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='q', ctx=Load()), attr='get_nowait', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Empty', ctx=Load()), body=[Break()])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='q', ctx=Load()), attr='task_done', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='remaining', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], finalbody=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='q', ctx=Load()), attr='join', ctx=Load()), args=[], keywords=[])), Expr(value=YieldFrom(value=Name(id='remaining', ctx=Load())))], decorator_list=[])], decorator_list=[]), FunctionDef(name='windowed_complete', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Yield ``(beginning, middle, end)`` tuples, where:\n\n    * Each ``middle`` has *n* items from *iterable*\n    * Each ``beginning`` has the items before the ones in ``middle``\n    * Each ``end`` has the items after the ones in ``middle``\n\n    >>> iterable = range(7)\n    >>> n = 3\n    >>> for beginning, middle, end in windowed_complete(iterable, n):\n    ...     print(beginning, middle, end)\n    () (0, 1, 2) (3, 4, 5, 6)\n    (0,) (1, 2, 3) (4, 5, 6)\n    (0, 1) (2, 3, 4) (5, 6)\n    (0, 1, 2) (3, 4, 5) (6,)\n    (0, 1, 2, 3) (4, 5, 6) ()\n\n    Note that *n* must be at least 0 and most equal to the length of\n    *iterable*.\n\n    This function will exhaust the iterable and may require significant\n    storage.\n    ')), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='n must be >= 0')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='seq', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='size', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Gt()], comparators=[Name(id='size', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='n must be <= len(seq)')], keywords=[]))], orelse=[]), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='size', ctx=Load()), op=Sub(), right=Name(id='n', ctx=Load())), op=Add(), right=Constant(value=1))], keywords=[]), body=[Assign(targets=[Name(id='beginning', ctx=Store())], value=Subscript(value=Name(id='seq', ctx=Load()), slice=Slice(upper=Name(id='i', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='middle', ctx=Store())], value=Subscript(value=Name(id='seq', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load()), upper=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Name(id='n', ctx=Load()))), ctx=Load())), Assign(targets=[Name(id='end', ctx=Store())], value=Subscript(value=Name(id='seq', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Name(id='n', ctx=Load()))), ctx=Load())), Expr(value=Yield(value=Tuple(elts=[Name(id='beginning', ctx=Load()), Name(id='middle', ctx=Load()), Name(id='end', ctx=Load())], ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='all_unique', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n    Returns ``True`` if all the elements of *iterable* are unique (no two\n    elements are equal).\n\n        >>> all_unique('ABCB')\n        False\n\n    If a *key* function is specified, it will be used to make comparisons.\n\n        >>> all_unique('ABCb')\n        True\n        >>> all_unique('ABCb', str.lower)\n        False\n\n    The function returns as soon as the first non-unique element is\n    encountered. Iterables with a mix of hashable and unhashable items can\n    be used, but the function will be slower for unhashable items.\n    ")), Assign(targets=[Name(id='seenset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='seenset_add', ctx=Store())], value=Attribute(value=Name(id='seenset', ctx=Load()), attr='add', ctx=Load())), Assign(targets=[Name(id='seenlist', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='seenlist_add', ctx=Store())], value=Attribute(value=Name(id='seenlist', ctx=Load()), attr='append', ctx=Load())), For(target=Name(id='element', ctx=Store()), iter=IfExp(test=Name(id='key', ctx=Load()), body=Call(func=Name(id='map', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[]), orelse=Name(id='iterable', ctx=Load())), body=[Try(body=[If(test=Compare(left=Name(id='element', ctx=Load()), ops=[In()], comparators=[Name(id='seenset', ctx=Load())]), body=[Return(value=Constant(value=False))], orelse=[]), Expr(value=Call(func=Name(id='seenset_add', ctx=Load()), args=[Name(id='element', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[If(test=Compare(left=Name(id='element', ctx=Load()), ops=[In()], comparators=[Name(id='seenlist', ctx=Load())]), body=[Return(value=Constant(value=False))], orelse=[]), Expr(value=Call(func=Name(id='seenlist_add', ctx=Load()), args=[Name(id='element', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], orelse=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='nth_product', args=arguments(posonlyargs=[], args=[arg(arg='index')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Equivalent to ``list(product(*args))[index]``.\n\n    The products of *args* can be ordered lexicographically.\n    :func:`nth_product` computes the product at sort position *index* without\n    computing the previous products.\n\n        >>> nth_product(8, range(2), range(2), range(2), range(2))\n        (1, 0, 0, 0)\n\n    ``IndexError`` will be raised if the given *index* is invalid.\n    ')), Assign(targets=[Name(id='pools', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='tuple', ctx=Load()), Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='ns', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='len', ctx=Load()), Name(id='pools', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='reduce', ctx=Load()), args=[Name(id='mul', ctx=Load()), Name(id='ns', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='index', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[AugAssign(target=Name(id='index', ctx=Store()), op=Add(), value=Name(id='c', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Constant(value=0), ops=[LtE(), Lt()], comparators=[Name(id='index', ctx=Load()), Name(id='c', ctx=Load())])), body=[Raise(exc=Name(id='IndexError', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='pool', ctx=Store()), Name(id='n', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='pools', ctx=Load()), Name(id='ns', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='pool', ctx=Load()), slice=BinOp(left=Name(id='index', ctx=Load()), op=Mod(), right=Name(id='n', ctx=Load())), ctx=Load())], keywords=[])), AugAssign(target=Name(id='index', ctx=Store()), op=FloorDiv(), value=Name(id='n', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='nth_permutation', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r'), arg(arg='index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Equivalent to ``list(permutations(iterable, r))[index]```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`nth_permutation`\n    computes the subsequence at sort position *index* directly, without\n    computing the previous subsequences.\n\n        >>> nth_permutation('ghijk', 2, 5)\n        ('h', 'i')\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    ")), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='r', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='r', ctx=Load()), ops=[Eq()], comparators=[Name(id='n', ctx=Load())])]), body=[Assign(targets=[Tuple(elts=[Name(id='r', ctx=Store()), Name(id='c', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='n', ctx=Load()), Call(func=Name(id='factorial', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], ctx=Load()))], orelse=[If(test=UnaryOp(op=Not(), operand=Compare(left=Constant(value=0), ops=[LtE(), Lt()], comparators=[Name(id='r', ctx=Load()), Name(id='n', ctx=Load())])), body=[Raise(exc=Name(id='ValueError', ctx=Load()))], orelse=[Assign(targets=[Name(id='c', ctx=Store())], value=BinOp(left=Call(func=Name(id='factorial', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), op=FloorDiv(), right=Call(func=Name(id='factorial', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='r', ctx=Load()))], keywords=[])))])]), If(test=Compare(left=Name(id='index', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[AugAssign(target=Name(id='index', ctx=Store()), op=Add(), value=Name(id='c', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Constant(value=0), ops=[LtE(), Lt()], comparators=[Name(id='index', ctx=Load()), Name(id='c', ctx=Load())])), body=[Raise(exc=Name(id='IndexError', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='c', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=List(elts=[Constant(value=0)], ctx=Load()), op=Mult(), right=Name(id='r', ctx=Load()))), Assign(targets=[Name(id='q', ctx=Store())], value=IfExp(test=Compare(left=Name(id='r', ctx=Load()), ops=[Lt()], comparators=[Name(id='n', ctx=Load())]), body=BinOp(left=BinOp(left=Name(id='index', ctx=Load()), op=Mult(), right=Call(func=Name(id='factorial', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])), op=FloorDiv(), right=Name(id='c', ctx=Load())), orelse=Name(id='index', ctx=Load()))), For(target=Name(id='d', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=1), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='q', ctx=Store()), Name(id='i', ctx=Store())], ctx=Store())], value=Call(func=Name(id='divmod', ctx=Load()), args=[Name(id='q', ctx=Load()), Name(id='d', ctx=Load())], keywords=[])), If(test=Compare(left=Constant(value=0), ops=[LtE(), Lt()], comparators=[BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='d', ctx=Load())), Name(id='r', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='result', ctx=Load()), slice=BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='d', ctx=Load())), ctx=Store())], value=Name(id='i', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='q', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Break()], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='pool', ctx=Load()), attr='pop', ctx=Load()), Name(id='result', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='value_chain', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield all arguments passed to the function in the same order in which\n    they were passed. If an argument itself is iterable then iterate over its\n    values.\n\n        >>> list(value_chain(1, 2, 3, [4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and are emitted\n    as-is:\n\n        >>> list(value_chain('12', '34', ['56', '78']))\n        ['12', '34', '56', '78']\n\n\n    Multiple levels of nesting are not flattened.\n\n    ")), For(target=Name(id='value', ctx=Store()), iter=Name(id='args', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bytes', ctx=Load())], ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='value', ctx=Load()))), Continue()], orelse=[]), Try(body=[Expr(value=YieldFrom(value=Name(id='value', ctx=Load())))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Expr(value=Yield(value=Name(id='value', ctx=Load())))])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='product_index', args=arguments(posonlyargs=[], args=[arg(arg='element')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Equivalent to ``list(product(*args)).index(element)``\n\n    The products of *args* can be ordered lexicographically.\n    :func:`product_index` computes the first index of *element* without\n    computing the previous products.\n\n        >>> product_index([8, 2], range(10), range(5))\n        42\n\n    ``ValueError`` will be raised if the given *element* isn't in the product\n    of *args*.\n    ")), Assign(targets=[Name(id='index', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='x', ctx=Store()), Name(id='pool', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip_longest', ctx=Load()), args=[Name(id='element', ctx=Load()), Name(id='args', ctx=Load())], keywords=[keyword(arg='fillvalue', value=Name(id='_marker', ctx=Load()))]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='x', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), Compare(left=Name(id='pool', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='element is not a product of args')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[])), Assign(targets=[Name(id='index', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='index', ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[])), op=Add(), right=Call(func=Attribute(value=Name(id='pool', ctx=Load()), attr='index', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])))], orelse=[]), Return(value=Name(id='index', ctx=Load()))], decorator_list=[]), FunctionDef(name='combination_index', args=arguments(posonlyargs=[], args=[arg(arg='element'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Equivalent to ``list(combinations(iterable, r)).index(element)``\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`combination_index` computes the index of the\n    first *element*, without computing the previous combinations.\n\n        >>> combination_index('adf', 'abcdefg')\n        10\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations of *iterable*.\n    ")), Assign(targets=[Name(id='element', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='element', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='y', ctx=Store())], ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='element', ctx=Load()), Tuple(elts=[Constant(value=None), Constant(value=None)], ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=0))], orelse=[]), Assign(targets=[Name(id='indexes', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store()), iter=Name(id='pool', ctx=Load()), body=[If(test=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[Name(id='y', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='indexes', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='tmp', ctx=Store()), Name(id='y', ctx=Store())], ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='element', ctx=Load()), Tuple(elts=[Constant(value=None), Constant(value=None)], ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='tmp', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Break()], orelse=[Assign(targets=[Name(id='k', ctx=Store())], value=Name(id='tmp', ctx=Load()))])], orelse=[])], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='element is not a combination of iterable')], keywords=[]))]), Assign(targets=[Tuple(elts=[Name(id='n', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='last', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[keyword(arg='default', value=Tuple(elts=[Name(id='n', ctx=Load()), Constant(value=None)], ctx=Load()))])), Assign(targets=[Name(id='index', ctx=Store())], value=Constant(value=1)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='j', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='indexes', ctx=Load())], keywords=[])], keywords=[keyword(arg='start', value=Constant(value=1))]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[LtE()], comparators=[Name(id='j', ctx=Load())]), body=[AugAssign(target=Name(id='index', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='factorial', ctx=Load()), args=[Name(id='j', ctx=Load())], keywords=[]), op=FloorDiv(), right=BinOp(left=Call(func=Name(id='factorial', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='factorial', ctx=Load()), args=[BinOp(left=Name(id='j', ctx=Load()), op=Sub(), right=Name(id='i', ctx=Load()))], keywords=[]))))], orelse=[])], orelse=[]), Return(value=BinOp(left=BinOp(left=Call(func=Name(id='factorial', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), op=FloorDiv(), right=BinOp(left=Call(func=Name(id='factorial', ctx=Load()), args=[BinOp(left=Name(id='k', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), op=Mult(), right=Call(func=Name(id='factorial', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='k', ctx=Load()))], keywords=[]))), op=Sub(), right=Name(id='index', ctx=Load())))], decorator_list=[]), FunctionDef(name='permutation_index', args=arguments(posonlyargs=[], args=[arg(arg='element'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Equivalent to ``list(permutations(iterable, r)).index(element)```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`permutation_index`\n    computes the index of the first *element* directly, without computing\n    the previous permutations.\n\n        >>> permutation_index([1, 3, 2], range(5))\n        19\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    permutations of *iterable*.\n    ")), Assign(targets=[Name(id='index', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[]), UnaryOp(op=USub(), operand=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), Name(id='element', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='pool', ctx=Load()), attr='index', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Assign(targets=[Name(id='index', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='index', ctx=Load()), op=Mult(), right=Name(id='i', ctx=Load())), op=Add(), right=Name(id='r', ctx=Load()))), Delete(targets=[Subscript(value=Name(id='pool', ctx=Load()), slice=Name(id='r', ctx=Load()), ctx=Del())])], orelse=[]), Return(value=Name(id='index', ctx=Load()))], decorator_list=[]), ClassDef(name='countable', bases=[], keywords=[], body=[Expr(value=Constant(value="Wrap *iterable* and keep a count of how many items have been consumed.\n\n    The ``items_seen`` attribute starts at ``0`` and increments as the iterable\n    is consumed:\n\n        >>> iterable = map(str, range(10))\n        >>> it = countable(iterable)\n        >>> it.items_seen\n        0\n        >>> next(it), next(it)\n        ('0', '1')\n        >>> list(it)\n        ['2', '3', '4', '5', '6', '7', '8', '9']\n        >>> it.items_seen\n        10\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='items_seen', ctx=Store())], value=Constant(value=0))], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__next__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_it', ctx=Load())], keywords=[])), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='items_seen', ctx=Store()), op=Add(), value=Constant(value=1)), Return(value=Name(id='item', ctx=Load()))], decorator_list=[])], decorator_list=[])], type_ignores=[])