Module(body=[Expr(value=Constant(value='Imported from the recipes section of the itertools documentation.\n\nAll functions taken from the recipes section of the itertools library docs\n[1]_.\nSome backward-compatible usability improvements have been made.\n\n.. [1] http://docs.python.org/library/itertools.html#recipes\n\n')), Import(names=[alias(name='warnings')]), ImportFrom(module='collections', names=[alias(name='deque')], level=0), ImportFrom(module='itertools', names=[alias(name='chain'), alias(name='combinations'), alias(name='count'), alias(name='cycle'), alias(name='groupby'), alias(name='islice'), alias(name='repeat'), alias(name='starmap'), alias(name='tee'), alias(name='zip_longest')], level=0), Import(names=[alias(name='operator')]), ImportFrom(module='random', names=[alias(name='randrange'), alias(name='sample'), alias(name='choice')], level=0), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='all_equal'), Constant(value='consume'), Constant(value='convolve'), Constant(value='dotproduct'), Constant(value='first_true'), Constant(value='flatten'), Constant(value='grouper'), Constant(value='iter_except'), Constant(value='ncycles'), Constant(value='nth'), Constant(value='nth_combination'), Constant(value='padnone'), Constant(value='pad_none'), Constant(value='pairwise'), Constant(value='partition'), Constant(value='powerset'), Constant(value='prepend'), Constant(value='quantify'), Constant(value='random_combination_with_replacement'), Constant(value='random_combination'), Constant(value='random_permutation'), Constant(value='random_product'), Constant(value='repeatfunc'), Constant(value='roundrobin'), Constant(value='tabulate'), Constant(value='tail'), Constant(value='take'), Constant(value='unique_everseen'), Constant(value='unique_justseen')], ctx=Load())), FunctionDef(name='take', args=arguments(posonlyargs=[], args=[arg(arg='n'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return first *n* items of the iterable as a list.\n\n        >>> take(3, range(10))\n        [0, 1, 2]\n\n    If there are fewer than *n* items in the iterable, all of them are\n    returned.\n\n        >>> take(10, range(3))\n        [0, 1, 2]\n\n    ')), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='n', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='tabulate', args=arguments(posonlyargs=[], args=[arg(arg='function'), arg(arg='start')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Return an iterator over the results of ``func(start)``,\n    ``func(start + 1)``, ``func(start + 2)``...\n\n    *func* should be a function that accepts one integer argument.\n\n    If *start* is not specified it defaults to 0. It will be incremented each\n    time the iterator is advanced.\n\n        >>> square = lambda x: x ** 2\n        >>> iterator = tabulate(square, -3)\n        >>> take(4, iterator)\n        [9, 4, 1, 0]\n\n    ')), Return(value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='function', ctx=Load()), Call(func=Name(id='count', ctx=Load()), args=[Name(id='start', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='tail', args=arguments(posonlyargs=[], args=[arg(arg='n'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return an iterator over the last *n* items of *iterable*.\n\n    >>> t = tail(3, 'ABCDEFG')\n    >>> list(t)\n    ['E', 'F', 'G']\n\n    ")), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Name(id='deque', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[keyword(arg='maxlen', value=Name(id='n', ctx=Load()))])], keywords=[]))], decorator_list=[]), FunctionDef(name='consume', args=arguments(posonlyargs=[], args=[arg(arg='iterator'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Advance *iterable* by *n* steps. If *n* is ``None``, consume it\n    entirely.\n\n    Efficiently exhausts an iterator without returning values. Defaults to\n    consuming the whole iterator, but an optional second argument may be\n    provided to limit consumption.\n\n        >>> i = (x for x in range(10))\n        >>> next(i)\n        0\n        >>> consume(i, 3)\n        >>> next(i)\n        4\n        >>> consume(i)\n        >>> next(i)\n        Traceback (most recent call last):\n          File "<stdin>", line 1, in <module>\n        StopIteration\n\n    If the iterator has fewer items remaining than the provided limit, the\n    whole iterator will be consumed.\n\n        >>> i = (x for x in range(3))\n        >>> consume(i, 5)\n        >>> next(i)\n        Traceback (most recent call last):\n          File "<stdin>", line 1, in <module>\n        StopIteration\n\n    ')), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='deque', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[keyword(arg='maxlen', value=Constant(value=0))]))], orelse=[Expr(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='iterator', ctx=Load()), Name(id='n', ctx=Load()), Name(id='n', ctx=Load())], keywords=[]), Constant(value=None)], keywords=[]))])], decorator_list=[]), FunctionDef(name='nth', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Returns the nth item or a default value.\n\n    >>> l = range(10)\n    >>> nth(l, 3)\n    3\n    >>> nth(l, 20, "zebra")\n    \'zebra\'\n\n    ')), Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='n', ctx=Load()), Constant(value=None)], keywords=[]), Name(id='default', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='all_equal', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Returns ``True`` if all the elements are equal to each other.\n\n        >>> all_equal('aaaa')\n        True\n        >>> all_equal('aaab')\n        False\n\n    ")), Assign(targets=[Name(id='g', ctx=Store())], value=Call(func=Name(id='groupby', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Return(value=BoolOp(op=And(), values=[Call(func=Name(id='next', ctx=Load()), args=[Name(id='g', ctx=Load()), Constant(value=True)], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='next', ctx=Load()), args=[Name(id='g', ctx=Load()), Constant(value=False)], keywords=[]))]))], decorator_list=[]), FunctionDef(name='quantify', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='bool', ctx=Load())]), body=[Expr(value=Constant(value='Return the how many times the predicate is true.\n\n    >>> quantify([True, False, True])\n    2\n\n    ')), Return(value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='pred', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='pad_none', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns the sequence of elements and then returns ``None`` indefinitely.\n\n        >>> take(5, pad_none(range(3)))\n        [0, 1, 2, None, None]\n\n    Useful for emulating the behavior of the built-in :func:`map` function.\n\n    See also :func:`padded`.\n\n    ')), Return(value=Call(func=Name(id='chain', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Constant(value=None)], keywords=[])], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='padnone', ctx=Store())], value=Name(id='pad_none', ctx=Load())), FunctionDef(name='ncycles', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns the sequence elements *n* times\n\n    >>> list(ncycles(["a", "b"], 3))\n    [\'a\', \'b\', \'a\', \'b\', \'a\', \'b\']\n\n    ')), Return(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Call(func=Name(id='repeat', ctx=Load()), args=[Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]), Name(id='n', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='dotproduct', args=arguments(posonlyargs=[], args=[arg(arg='vec1'), arg(arg='vec2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns the dot product of the two iterables.\n\n    >>> dotproduct([10, 10], [20, 20])\n    400\n\n    ')), Return(value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='mul', ctx=Load()), Name(id='vec1', ctx=Load()), Name(id='vec2', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='flatten', args=arguments(posonlyargs=[], args=[arg(arg='listOfLists')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return an iterator flattening one level of nesting in a list of lists.\n\n        >>> list(flatten([[0, 1], [2, 3]]))\n        [0, 1, 2, 3]\n\n    See also :func:`collapse`, which can flatten multiple levels of nesting.\n\n    ')), Return(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Name(id='listOfLists', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='repeatfunc', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='times')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Call *func* with *args* repeatedly, returning an iterable over the\n    results.\n\n    If *times* is specified, the iterable will terminate after that many\n    repetitions:\n\n        >>> from operator import add\n        >>> times = 4\n        >>> args = 3, 5\n        >>> list(repeatfunc(add, times, *args))\n        [8, 8, 8, 8]\n\n    If *times* is ``None`` the iterable will not terminate:\n\n        >>> from random import randrange\n        >>> times = None\n        >>> args = 1, 11\n        >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP\n        [2, 4, 8, 1, 8, 4]\n\n    ')), If(test=Compare(left=Name(id='times', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='starmap', ctx=Load()), args=[Name(id='func', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='starmap', ctx=Load()), args=[Name(id='func', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='args', ctx=Load()), Name(id='times', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_pairwise', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns an iterator of paired items, overlapping, from the original\n\n    >>> take(4, pairwise(count()))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n\n    On Python 3.10 and above, this is an alias for :func:`itertools.pairwise`.\n\n    ')), Assign(targets=[Tuple(elts=[Name(id='a', ctx=Store()), Name(id='b', ctx=Store())], ctx=Store())], value=Call(func=Name(id='tee', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='b', ctx=Load()), Constant(value=None)], keywords=[])), Expr(value=YieldFrom(value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[])))], decorator_list=[]), Try(body=[ImportFrom(module='itertools', names=[alias(name='pairwise', asname='itertools_pairwise')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='pairwise', ctx=Store())], value=Name(id='_pairwise', ctx=Load()))])], orelse=[FunctionDef(name='pairwise', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=YieldFrom(value=Call(func=Name(id='itertools_pairwise', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='pairwise', ctx=Load()), attr='__doc__', ctx=Store())], value=Attribute(value=Name(id='_pairwise', ctx=Load()), attr='__doc__', ctx=Load()))], finalbody=[]), FunctionDef(name='grouper', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n'), arg(arg='fillvalue')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Collect data into fixed-length chunks or blocks.\n\n    >>> list(grouper('ABCDEFG', 3, 'x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]\n\n    ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='grouper expects iterable as first parameter'), Name(id='DeprecationWarning', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='n', ctx=Store()), Name(id='iterable', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='iterable', ctx=Load()), Name(id='n', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='args', ctx=Store())], value=BinOp(left=List(elts=[Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])], ctx=Load()), op=Mult(), right=Name(id='n', ctx=Load()))), Return(value=Call(func=Name(id='zip_longest', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(arg='fillvalue', value=Name(id='fillvalue', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='roundrobin', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='iterables'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yields an item from each iterable, alternating between them.\n\n        >>> list(roundrobin('ABC', 'D', 'EF'))\n        ['A', 'D', 'E', 'B', 'F', 'C']\n\n    This function produces the same output as :func:`interleave_longest`, but\n    may perform better for some inputs (in particular when the number of\n    iterables is small).\n\n    ")), Assign(targets=[Name(id='pending', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='iterables', ctx=Load())], keywords=[])), Assign(targets=[Name(id='nexts', ctx=Store())], value=Call(func=Name(id='cycle', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]), attr='__next__', ctx=Load()), generators=[comprehension(target=Name(id='it', ctx=Store()), iter=Name(id='iterables', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), While(test=Name(id='pending', ctx=Load()), body=[Try(body=[For(target=Name(id='next', ctx=Store()), iter=Name(id='nexts', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Name(id='next', ctx=Load()), args=[], keywords=[])))], orelse=[])], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[AugAssign(target=Name(id='pending', ctx=Store()), op=Sub(), value=Constant(value=1)), Assign(targets=[Name(id='nexts', ctx=Store())], value=Call(func=Name(id='cycle', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='nexts', ctx=Load()), Name(id='pending', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='partition', args=arguments(posonlyargs=[], args=[arg(arg='pred'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Returns a 2-tuple of iterables derived from the input iterable.\n    The first yields the items that have ``pred(item) == False``.\n    The second yields the items that have ``pred(item) == True``.\n\n        >>> is_odd = lambda x: x % 2 != 0\n        >>> iterable = range(10)\n        >>> even_items, odd_items = partition(is_odd, iterable)\n        >>> list(even_items), list(odd_items)\n        ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9])\n\n    If *pred* is None, :func:`bool` is used.\n\n        >>> iterable = [0, 1, False, True, '', ' ']\n        >>> false_items, true_items = partition(None, iterable)\n        >>> list(false_items), list(true_items)\n        ([0, False, ''], [1, True, ' '])\n\n    ")), If(test=Compare(left=Name(id='pred', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='pred', ctx=Store())], value=Name(id='bool', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='evaluations', ctx=Store())], value=GeneratorExp(elt=Tuple(elts=[Call(func=Name(id='pred', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), Name(id='x', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='iterable', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Tuple(elts=[Name(id='t1', ctx=Store()), Name(id='t2', ctx=Store())], ctx=Store())], value=Call(func=Name(id='tee', ctx=Load()), args=[Name(id='evaluations', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[GeneratorExp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='cond', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store()), iter=Name(id='t1', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Name(id='cond', ctx=Load()))], is_async=0)]), GeneratorExp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='cond', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store()), iter=Name(id='t2', ctx=Load()), ifs=[Name(id='cond', ctx=Load())], is_async=0)])], ctx=Load()))], decorator_list=[]), FunctionDef(name='powerset', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yields all possible subsets of the iterable.\n\n        >>> list(powerset([1, 2, 3]))\n        [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n\n    :func:`powerset` will operate on iterables that aren't :class:`set`\n    instances, so repeated elements in the input will produce repeated elements\n    in the output. Use :func:`unique_everseen` on the input to avoid generating\n    duplicates:\n\n        >>> seq = [1, 1, 0]\n        >>> list(powerset(seq))\n        [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]\n        >>> from more_itertools import unique_everseen\n        >>> list(powerset(unique_everseen(seq)))\n        [(), (1,), (0,), (1, 0)]\n\n    ")), Assign(targets=[Name(id='s', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='combinations', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='r', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='r', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='unique_everseen', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n    Yield unique elements, preserving order.\n\n        >>> list(unique_everseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D']\n        >>> list(unique_everseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'D']\n\n    Sequences with a mix of hashable and unhashable items can be used.\n    The function will be slower (i.e., `O(n^2)`) for unhashable items.\n\n    Remember that ``list`` objects are unhashable - you can use the *key*\n    parameter to transform the list to a tuple (which is hashable) to\n    avoid a slowdown.\n\n        >>> iterable = ([1, 2], [2, 3], [1, 2])\n        >>> list(unique_everseen(iterable))  # Slow\n        [[1, 2], [2, 3]]\n        >>> list(unique_everseen(iterable, key=tuple))  # Faster\n        [[1, 2], [2, 3]]\n\n    Similary, you may want to convert unhashable ``set`` objects with\n    ``key=frozenset``. For ``dict`` objects,\n    ``key=lambda x: frozenset(x.items())`` can be used.\n\n    ")), Assign(targets=[Name(id='seenset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='seenset_add', ctx=Store())], value=Attribute(value=Name(id='seenset', ctx=Load()), attr='add', ctx=Load())), Assign(targets=[Name(id='seenlist', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='seenlist_add', ctx=Store())], value=Attribute(value=Name(id='seenlist', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='use_key', ctx=Store())], value=Compare(left=Name(id='key', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), For(target=Name(id='element', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[Assign(targets=[Name(id='k', ctx=Store())], value=IfExp(test=Name(id='use_key', ctx=Load()), body=Call(func=Name(id='key', ctx=Load()), args=[Name(id='element', ctx=Load())], keywords=[]), orelse=Name(id='element', ctx=Load()))), Try(body=[If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotIn()], comparators=[Name(id='seenset', ctx=Load())]), body=[Expr(value=Call(func=Name(id='seenset_add', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Yield(value=Name(id='element', ctx=Load())))], orelse=[])], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotIn()], comparators=[Name(id='seenlist', ctx=Load())]), body=[Expr(value=Call(func=Name(id='seenlist_add', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Yield(value=Name(id='element', ctx=Load())))], orelse=[])])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='unique_justseen', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Yields elements in order, ignoring serial duplicates\n\n    >>> list(unique_justseen('AAAABBBCCDAABBB'))\n    ['A', 'B', 'C', 'D', 'A', 'B']\n    >>> list(unique_justseen('ABBCcAD', str.lower))\n    ['A', 'B', 'C', 'A', 'D']\n\n    ")), Return(value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='next', ctx=Load()), Call(func=Name(id='map', ctx=Load()), args=[Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Constant(value=1)], keywords=[]), Call(func=Name(id='groupby', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='key', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='iter_except', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='exception'), arg(arg='first')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Yields results from a function repeatedly until an exception is raised.\n\n    Converts a call-until-exception interface to an iterator interface.\n    Like ``iter(func, sentinel)``, but uses an exception instead of a sentinel\n    to end the loop.\n\n        >>> l = [0, 1, 2]\n        >>> list(iter_except(l.pop, IndexError))\n        [2, 1, 0]\n\n    ')), Try(body=[If(test=Compare(left=Name(id='first', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Call(func=Name(id='first', ctx=Load()), args=[], keywords=[])))], orelse=[]), While(test=Constant(value=1), body=[Expr(value=Yield(value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[])))], orelse=[])], handlers=[ExceptHandler(type=Name(id='exception', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='first_true', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='default'), arg(arg='pred')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="\n    Returns the first true value in the iterable.\n\n    If no true value is found, returns *default*\n\n    If *pred* is not None, returns the first item for which\n    ``pred(item) == True`` .\n\n        >>> first_true(range(10))\n        1\n        >>> first_true(range(10), pred=lambda x: x > 5)\n        6\n        >>> first_true(range(10), default='missing', pred=lambda x: x > 9)\n        'missing'\n\n    ")), Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='filter', ctx=Load()), args=[Name(id='pred', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[]), Name(id='default', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='random_product', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[arg(arg='repeat')], kw_defaults=[Constant(value=1)], defaults=[]), body=[Expr(value=Constant(value="Draw an item at random from each of the input iterables.\n\n        >>> random_product('abc', range(4), 'XYZ')  # doctest:+SKIP\n        ('c', 3, 'Z')\n\n    If *repeat* is provided as a keyword argument, that many items will be\n    drawn from each iterable.\n\n        >>> random_product('abcd', range(4), repeat=2)  # doctest:+SKIP\n        ('a', 2, 'd', 3)\n\n    This equivalent to taking a random selection from\n    ``itertools.product(*args, **kwarg)``.\n\n    ")), Assign(targets=[Name(id='pools', ctx=Store())], value=BinOp(left=ListComp(elt=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='pool', ctx=Store()), iter=Name(id='args', ctx=Load()), ifs=[], is_async=0)]), op=Mult(), right=Name(id='repeat', ctx=Load()))), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='choice', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='pool', ctx=Store()), iter=Name(id='pools', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='random_permutation', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return a random *r* length permutation of the elements in *iterable*.\n\n    If *r* is not specified or is ``None``, then *r* defaults to the length of\n    *iterable*.\n\n        >>> random_permutation(range(5))  # doctest:+SKIP\n        (3, 4, 0, 1, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.permutations(iterable, r)``.\n\n    ')), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=IfExp(test=Compare(left=Name(id='r', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[]), orelse=Name(id='r', ctx=Load()))), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='sample', ctx=Load()), args=[Name(id='pool', ctx=Load()), Name(id='r', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='random_combination', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a random *r* length subsequence of the elements in *iterable*.\n\n        >>> random_combination(range(5), 3)  # doctest:+SKIP\n        (2, 3, 4)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations(iterable, r)``.\n\n    ')), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[])), Assign(targets=[Name(id='indices', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Name(id='sample', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), Name(id='r', ctx=Load())], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='pool', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Name(id='indices', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='random_combination_with_replacement', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a random *r* length subsequence of elements in *iterable*,\n    allowing individual elements to be repeated.\n\n        >>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP\n        (0, 0, 1, 2, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations_with_replacement(iterable, r)``.\n\n    ')), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[])), Assign(targets=[Name(id='indices', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='randrange', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='pool', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Name(id='indices', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='nth_combination', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r'), arg(arg='index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Equivalent to ``list(combinations(iterable, r))[index]``.\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`nth_combination` computes the subsequence at\n    sort position *index* directly, without computing the previous\n    subsequences.\n\n        >>> nth_combination(range(5), 3, 5)\n        (0, 3, 4)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    ')), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='r', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), Compare(left=Name(id='r', ctx=Load()), ops=[Gt()], comparators=[Name(id='n', ctx=Load())])]), body=[Raise(exc=Name(id='ValueError', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='c', ctx=Store())], value=Constant(value=1)), Assign(targets=[Name(id='k', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='r', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='r', ctx=Load()))], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=1), BinOp(left=Name(id='k', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), body=[Assign(targets=[Name(id='c', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='c', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='k', ctx=Load())), op=Add(), right=Name(id='i', ctx=Load()))), op=FloorDiv(), right=Name(id='i', ctx=Load())))], orelse=[]), If(test=Compare(left=Name(id='index', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[AugAssign(target=Name(id='index', ctx=Store()), op=Add(), value=Name(id='c', ctx=Load()))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='index', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), Compare(left=Name(id='index', ctx=Load()), ops=[GtE()], comparators=[Name(id='c', ctx=Load())])]), body=[Raise(exc=Name(id='IndexError', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=List(elts=[], ctx=Load())), While(test=Name(id='r', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='c', ctx=Store()), Name(id='n', ctx=Store()), Name(id='r', ctx=Store())], ctx=Store())], value=Tuple(elts=[BinOp(left=BinOp(left=Name(id='c', ctx=Load()), op=Mult(), right=Name(id='r', ctx=Load())), op=FloorDiv(), right=Name(id='n', ctx=Load())), BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Constant(value=1)), BinOp(left=Name(id='r', ctx=Load()), op=Sub(), right=Constant(value=1))], ctx=Load())), While(test=Compare(left=Name(id='index', ctx=Load()), ops=[GtE()], comparators=[Name(id='c', ctx=Load())]), body=[AugAssign(target=Name(id='index', ctx=Store()), op=Sub(), value=Name(id='c', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='c', ctx=Store()), Name(id='n', ctx=Store())], ctx=Store())], value=Tuple(elts=[BinOp(left=BinOp(left=Name(id='c', ctx=Load()), op=Mult(), right=BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='r', ctx=Load()))), op=FloorDiv(), right=Name(id='n', ctx=Load())), BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Constant(value=1))], ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='pool', ctx=Load()), slice=BinOp(left=UnaryOp(op=USub(), operand=Constant(value=1)), op=Sub(), right=Name(id='n', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='prepend', args=arguments(posonlyargs=[], args=[arg(arg='value'), arg(arg='iterator')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield *value*, followed by the elements in *iterator*.\n\n        >>> value = '0'\n        >>> iterator = ['1', '2', '3']\n        >>> list(prepend(value, iterator))\n        ['0', '1', '2', '3']\n\n    To prepend multiple values, see :func:`itertools.chain`\n    or :func:`value_chain`.\n\n    ")), Return(value=Call(func=Name(id='chain', ctx=Load()), args=[List(elts=[Name(id='value', ctx=Load())], ctx=Load()), Name(id='iterator', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='convolve', args=arguments(posonlyargs=[], args=[arg(arg='signal'), arg(arg='kernel')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Convolve the iterable *signal* with the iterable *kernel*.\n\n        >>> signal = (1, 2, 3, 4, 5)\n        >>> kernel = [3, 2, 1]\n        >>> list(convolve(signal, kernel))\n        [3, 8, 14, 20, 26, 14, 5]\n\n    Note: the input arguments are not interchangeable, as the *kernel*\n    is immediately consumed and stored.\n\n    ')), Assign(targets=[Name(id='kernel', ctx=Store())], value=Subscript(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='kernel', ctx=Load())], keywords=[]), slice=Slice(step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='kernel', ctx=Load())], keywords=[])), Assign(targets=[Name(id='window', ctx=Store())], value=BinOp(left=Call(func=Name(id='deque', ctx=Load()), args=[List(elts=[Constant(value=0)], ctx=Load())], keywords=[keyword(arg='maxlen', value=Name(id='n', ctx=Load()))]), op=Mult(), right=Name(id='n', ctx=Load()))), For(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='chain', ctx=Load()), args=[Name(id='signal', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Constant(value=0), BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Constant(value=1))], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='window', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Expr(value=Yield(value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='mul', ctx=Load()), Name(id='kernel', ctx=Load()), Name(id='window', ctx=Load())], keywords=[])], keywords=[])))], orelse=[])], decorator_list=[])], type_ignores=[])