Module(body=[Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Distribution')], ctx=Load())), Import(names=[alias(name='io')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='numbers')]), Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), Import(names=[alias(name='sys')]), ImportFrom(module='contextlib', names=[alias(name='suppress')], level=0), ImportFrom(module='glob', names=[alias(name='iglob')], level=0), ImportFrom(module='pathlib', names=[alias(name='Path')], level=0), ImportFrom(module='typing', names=[alias(name='List'), alias(name='Optional'), alias(name='Set')], level=0), Import(names=[alias(name='distutils.cmd')]), Import(names=[alias(name='distutils.command')]), Import(names=[alias(name='distutils.core')]), Import(names=[alias(name='distutils.dist')]), Import(names=[alias(name='distutils.log')]), ImportFrom(module='distutils.debug', names=[alias(name='DEBUG')], level=0), ImportFrom(module='distutils.errors', names=[alias(name='DistutilsOptionError'), alias(name='DistutilsSetupError')], level=0), ImportFrom(module='distutils.fancy_getopt', names=[alias(name='translate_longopt')], level=0), ImportFrom(module='distutils.util', names=[alias(name='strtobool')], level=0), ImportFrom(module='extern.more_itertools', names=[alias(name='partition'), alias(name='unique_everseen')], level=1), ImportFrom(module='extern.ordered_set', names=[alias(name='OrderedSet')], level=1), ImportFrom(module='extern.packaging.markers', names=[alias(name='InvalidMarker'), alias(name='Marker')], level=1), ImportFrom(module='extern.packaging.specifiers', names=[alias(name='InvalidSpecifier'), alias(name='SpecifierSet')], level=1), ImportFrom(module='extern.packaging.version', names=[alias(name='InvalidVersion'), alias(name='Version')], level=1), ImportFrom(names=[alias(name='_entry_points')], level=1), ImportFrom(names=[alias(name='_normalization')], level=1), ImportFrom(names=[alias(name='_reqs')], level=1), ImportFrom(names=[alias(name='command', asname='_')], level=1), ImportFrom(module='_importlib', names=[alias(name='metadata')], level=1), ImportFrom(module='config', names=[alias(name='setupcfg'), alias(name='pyprojecttoml')], level=1), ImportFrom(module='discovery', names=[alias(name='ConfigDiscovery')], level=1), ImportFrom(module='monkey', names=[alias(name='get_unpatched')], level=1), ImportFrom(module='warnings', names=[alias(name='InformationOnly'), alias(name='SetuptoolsDeprecationWarning')], level=1), Assign(targets=[Name(id='sequence', ctx=Store())], value=Tuple(elts=[Name(id='tuple', ctx=Load()), Name(id='list', ctx=Load())], ctx=Load())), FunctionDef(name='check_importable', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='ep', ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='EntryPoint', ctx=Load()), args=[], keywords=[keyword(arg='value', value=Name(id='value', ctx=Load())), keyword(arg='name', value=Constant(value=None)), keyword(arg='group', value=Constant(value=None))])), Assert(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='ep', ctx=Load()), attr='extras', ctx=Load())))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TypeError', ctx=Load()), Name(id='ValueError', ctx=Load()), Name(id='AttributeError', ctx=Load()), Name(id='AssertionError', ctx=Load())], ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[BinOp(left=Constant(value="%r must be importable 'module:attrs' string (got %r)"), op=Mod(), right=Tuple(elts=[Name(id='attr', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load()))], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='assert_string_list', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Verify that value is a string list')), Try(body=[Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), Assert(test=Compare(left=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='value', ctx=Load())]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TypeError', ctx=Load()), Name(id='ValueError', ctx=Load()), Name(id='AttributeError', ctx=Load()), Name(id='AssertionError', ctx=Load())], ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[BinOp(left=Constant(value='%r must be a list of strings (got %r)'), op=Mod(), right=Tuple(elts=[Name(id='attr', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load()))], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='check_nsp', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Verify that namespace packages are valid')), Assign(targets=[Name(id='ns_packages', ctx=Store())], value=Name(id='value', ctx=Load())), Expr(value=Call(func=Name(id='assert_string_list', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='attr', ctx=Load()), Name(id='ns_packages', ctx=Load())], keywords=[])), For(target=Name(id='nsp', ctx=Store()), iter=Name(id='ns_packages', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='has_contents_for', ctx=Load()), args=[Name(id='nsp', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[BinOp(left=Constant(value='Distribution contains no modules or packages for '), op=Add(), right=BinOp(left=Constant(value='namespace package %r'), op=Mod(), right=Name(id='nsp', ctx=Load())))], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='parent', ctx=Store()), Name(id='sep', ctx=Store()), Name(id='child', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='nsp', ctx=Load()), attr='rpartition', ctx=Load()), args=[Constant(value='.')], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='parent', ctx=Load()), Compare(left=Name(id='parent', ctx=Load()), ops=[NotIn()], comparators=[Name(id='ns_packages', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='log', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='WARNING: %r is declared as a package namespace, but %r is not: please correct this in setup.py'), Name(id='nsp', ctx=Load()), Name(id='parent', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='SetuptoolsDeprecationWarning', ctx=Load()), attr='emit', ctx=Load()), args=[Constant(value='The namespace_packages parameter is deprecated.'), Constant(value='Please replace its usage with implicit namespaces (PEP 420).')], keywords=[keyword(arg='see_docs', value=Constant(value='references/keywords.html#keyword-namespace-packages'))]))], orelse=[])], decorator_list=[]), FunctionDef(name='check_extras', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Verify that extras_require mapping is valid')), Try(body=[Expr(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='starmap', ctx=Load()), args=[Name(id='_check_extra', ctx=Load()), Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TypeError', ctx=Load()), Name(id='ValueError', ctx=Load()), Name(id='AttributeError', ctx=Load())], ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[Constant(value="'extras_require' must be a dictionary whose values are strings or lists of strings containing valid project/version requirement specifiers.")], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='_check_extra', args=arguments(posonlyargs=[], args=[arg(arg='extra'), arg(arg='reqs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='sep', ctx=Store()), Name(id='marker', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='extra', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value=':')], keywords=[])), Try(body=[Expr(value=Call(func=Name(id='_check_marker', ctx=Load()), args=[Name(id='marker', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='InvalidMarker', ctx=Load()), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='Invalid environment marker: '), FormattedValue(value=Name(id='marker', ctx=Load()), conversion=-1), Constant(value=' ('), FormattedValue(value=Name(id='extra', ctx=Load()), conversion=114), Constant(value=')')])), Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]), cause=Constant(value=None))])], orelse=[], finalbody=[]), Expr(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='_reqs', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='reqs', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_check_marker', args=arguments(posonlyargs=[], args=[arg(arg='marker')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='marker', ctx=Load())), body=[Return()], orelse=[]), Assign(targets=[Name(id='m', ctx=Store())], value=Call(func=Name(id='Marker', ctx=Load()), args=[Name(id='marker', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='m', ctx=Load()), attr='evaluate', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='assert_bool', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Verify that value is True, False, 0, or 1')), If(test=Compare(left=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='value', ctx=Load())]), body=[Assign(targets=[Name(id='tmpl', ctx=Store())], value=Constant(value='{attr!r} must be a boolean value (got {value!r})')), Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[Call(func=Attribute(value=Name(id='tmpl', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='attr', value=Name(id='attr', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load()))])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='invalid_unless_false', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='value', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='DistDeprecationWarning', ctx=Load()), attr='emit', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='attr', ctx=Load()), conversion=-1), Constant(value=' is ignored.')])], keywords=[])), Return()], orelse=[]), Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='attr', ctx=Load()), conversion=-1), Constant(value=' is invalid.')])], keywords=[]))], decorator_list=[]), FunctionDef(name='check_requirements', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Verify that install_requires is a valid requirements list')), Try(body=[Expr(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='_reqs', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Tuple(elts=[Name(id='dict', ctx=Load()), Name(id='set', ctx=Load())], ctx=Load())], keywords=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Unordered types are not allowed')], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TypeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), name='error', body=[Assign(targets=[Name(id='tmpl', ctx=Store())], value=Constant(value='{attr!r} must be a string or list of strings containing valid project/version requirement specifiers; {error}')), Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[Call(func=Attribute(value=Name(id='tmpl', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='attr', value=Name(id='attr', ctx=Load())), keyword(arg='error', value=Name(id='error', ctx=Load()))])], keywords=[]), cause=Name(id='error', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='check_specifier', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Verify that value is a valid version specifier')), Try(body=[Expr(value=Call(func=Name(id='SpecifierSet', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='InvalidSpecifier', ctx=Load()), Name(id='AttributeError', ctx=Load())], ctx=Load()), name='error', body=[Assign(targets=[Name(id='tmpl', ctx=Store())], value=Constant(value='{attr!r} must be a string containing valid version specifiers; {error}')), Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[Call(func=Attribute(value=Name(id='tmpl', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='attr', value=Name(id='attr', ctx=Load())), keyword(arg='error', value=Name(id='error', ctx=Load()))])], keywords=[]), cause=Name(id='error', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='check_entry_points', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Verify that entry_points map is parseable')), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='_entry_points', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='check_test_suite', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[Constant(value='test_suite must be a string')], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='check_package_data', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Verify that value is a dictionary of package names to glob lists')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{!r} must be a dictionary mapping package names to lists of string wildcard patterns'), attr='format', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='k', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='keys of {!r} dict must be strings (got {!r})'), attr='format', ctx=Load()), args=[Name(id='attr', ctx=Load()), Name(id='k', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='assert_string_list', ctx=Load()), args=[Name(id='dist', ctx=Load()), Call(func=Attribute(value=Constant(value='values of {!r} dict'), attr='format', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[]), Name(id='v', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='check_packages', args=arguments(posonlyargs=[], args=[arg(arg='dist'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='pkgname', ctx=Store()), iter=Name(id='value', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Constant(value='\\w+(\\.\\w+)*'), Name(id='pkgname', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='log', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='WARNING: %r not a valid package name; please use only .-separated package names in setup.py'), Name(id='pkgname', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='_Distribution', ctx=Store())], value=Call(func=Name(id='get_unpatched', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='core', ctx=Load()), attr='Distribution', ctx=Load())], keywords=[])), ClassDef(name='Distribution', bases=[Name(id='_Distribution', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Distribution with support for tests and package data\n\n    This is an enhanced version of \'distutils.dist.Distribution\' that\n    effectively adds the following new optional keyword arguments to \'setup()\':\n\n     \'install_requires\' -- a string or sequence of strings specifying project\n        versions that the distribution requires when installed, in the format\n        used by \'pkg_resources.require()\'.  They will be installed\n        automatically when the package is installed.  If you wish to use\n        packages that are not available in PyPI, or want to give your users an\n        alternate download location, you can add a \'find_links\' option to the\n        \'[easy_install]\' section of your project\'s \'setup.cfg\' file, and then\n        setuptools will scan the listed web pages for links that satisfy the\n        requirements.\n\n     \'extras_require\' -- a dictionary mapping names of optional "extras" to the\n        additional requirement(s) that using those extras incurs. For example,\n        this::\n\n            extras_require = dict(reST = ["docutils>=0.3", "reSTedit"])\n\n        indicates that the distribution can optionally provide an extra\n        capability called "reST", but it can only be used if docutils and\n        reSTedit are installed.  If the user installs your package using\n        EasyInstall and requests one of your extras, the corresponding\n        additional requirements will be installed if needed.\n\n     \'test_suite\' -- the name of a test suite to run for the \'test\' command.\n        If the user runs \'python setup.py test\', the package will be installed,\n        and the named test suite will be run.  The format is the same as\n        would be used on a \'unittest.py\' command line.  That is, it is the\n        dotted name of an object to import and call to generate a test suite.\n\n     \'package_data\' -- a dictionary mapping package names to lists of filenames\n        or globs to use to find data files contained in the named packages.\n        If the dictionary has filenames or globs listed under \'""\' (the empty\n        string), those names will be searched for in every package, in addition\n        to any names for the specific package.  Data files found using these\n        names/globs will be installed along with the package, in the same\n        location as the package.  Note that globs are allowed to reference\n        the contents of non-package subdirectories, as long as you use \'/\' as\n        a path separator.  (Globs are automatically converted to\n        platform-specific paths at runtime.)\n\n    In addition to these new keywords, this class also has several new methods\n    for manipulating the distribution\'s contents.  For example, the \'include()\'\n    and \'exclude()\' methods can be thought of as in-place add and subtract\n    commands that add or remove packages, modules, extensions, and so on from\n    the distribution.\n    ')), Assign(targets=[Name(id='_DISTUTILS_UNSUPPORTED_METADATA', ctx=Store())], value=Dict(keys=[Constant(value='long_description_content_type'), Constant(value='project_urls'), Constant(value='provides_extras'), Constant(value='license_file'), Constant(value='license_files'), Constant(value='install_requires'), Constant(value='extras_require')], values=[Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=None)), Name(id='dict', ctx=Load()), Name(id='OrderedSet', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=None)), Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Constant(value=None)), Name(id='list', ctx=Load()), Name(id='dict', ctx=Load())])), Assign(targets=[Name(id='_patched_dist', ctx=Store())], value=Constant(value=None)), FunctionDef(name='patch_missing_pkg_info', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='attrs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='attrs', ctx=Load())), Compare(left=Constant(value='name'), ops=[NotIn()], comparators=[Name(id='attrs', ctx=Load())]), Compare(left=Constant(value='version'), ops=[NotIn()], comparators=[Name(id='attrs', ctx=Load())])]), body=[Return()], orelse=[]), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='_normalization', ctx=Load()), attr='safe_name', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='attrs', ctx=Load()), slice=Constant(value='name'), ctx=Load())], keywords=[])], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='suppress', ctx=Load()), args=[Attribute(value=Name(id='metadata', ctx=Load()), attr='PackageNotFoundError', ctx=Load())], keywords=[]))], body=[Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='distribution', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='dist', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='read_text', ctx=Load()), args=[Constant(value='PKG-INFO')], keywords=[]))]), body=[Assign(targets=[Attribute(value=Name(id='dist', ctx=Load()), attr='_version', ctx=Store())], value=Call(func=Attribute(value=Name(id='_normalization', ctx=Load()), attr='safe_version', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='attrs', ctx=Load()), slice=Constant(value='version'), ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_patched_dist', ctx=Store())], value=Name(id='dist', ctx=Load()))], orelse=[])])], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='attrs')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='have_package_data', ctx=Store())], value=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='package_data')], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='have_package_data', ctx=Load())), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='package_data', ctx=Store())], value=Dict(keys=[], values=[]))], orelse=[]), Assign(targets=[Name(id='attrs', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='attrs', ctx=Load()), Dict(keys=[], values=[])])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist_files', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='src_root', ctx=Store())], value=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='src_root'), Constant(value=None)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='patch_missing_pkg_info', ctx=Load()), args=[Name(id='attrs', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dependency_links', ctx=Store())], value=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='dependency_links'), List(elts=[], ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='setup_requires', ctx=Store())], value=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='setup_requires'), List(elts=[], ctx=Load())], keywords=[])), For(target=Name(id='ep', ctx=Store()), iter=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='entry_points', ctx=Load()), args=[], keywords=[keyword(arg='group', value=Constant(value='distutils.setup_keywords'))]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='setdefault', ctx=Load()), args=[Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), Constant(value=None)], keywords=[]))], orelse=[]), Assign(targets=[Name(id='metadata_only', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_DISTUTILS_UNSUPPORTED_METADATA', ctx=Load())], keywords=[])), AugAssign(target=Name(id='metadata_only', ctx=Store()), op=Sub(), value=Set(elts=[Constant(value='install_requires'), Constant(value='extras_require')])), Assign(targets=[Name(id='dist_attrs', ctx=Store())], value=DictComp(key=Name(id='k', ctx=Load()), value=Name(id='v', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Compare(left=Name(id='k', ctx=Load()), ops=[NotIn()], comparators=[Name(id='metadata_only', ctx=Load())])], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='_Distribution', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='dist_attrs', ctx=Load())], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_referenced_files', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='set_defaults', ctx=Store())], value=Call(func=Name(id='ConfigDiscovery', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_set_metadata_defaults', ctx=Load()), args=[Name(id='attrs', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='version', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_normalize_version', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_version', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='version', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_finalize_requires', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_validate_metadata', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='required', ctx=Store())], value=Set(elts=[Constant(value='name')])), Assign(targets=[Name(id='provided', ctx=Store())], value=SetComp(elt=Name(id='key', ctx=Load()), generators=[comprehension(target=Name(id='key', ctx=Store()), iter=Call(func=Name(id='vars', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load())], keywords=[]), ifs=[Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), Name(id='key', ctx=Load()), Constant(value=None)], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)])], is_async=0)])), Assign(targets=[Name(id='missing', ctx=Store())], value=BinOp(left=Name(id='required', ctx=Load()), op=Sub(), right=Name(id='provided', ctx=Load()))), If(test=Name(id='missing', ctx=Load()), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='Required package metadata is missing: '), FormattedValue(value=Name(id='missing', ctx=Load()), conversion=-1)])), Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_set_metadata_defaults', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='attrs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Fill-in missing metadata fields not supported by distutils.\n        Some fields may have been set by other tools (e.g. pbr).\n        Those fields (vars(self.metadata)) take precedence to\n        supplied attrs.\n        ')), For(target=Tuple(elts=[Name(id='option', ctx=Store()), Name(id='default', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_DISTUTILS_UNSUPPORTED_METADATA', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load())], keywords=[]), attr='setdefault', ctx=Load()), args=[Name(id='option', ctx=Load()), Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='option', ctx=Load()), Call(func=Name(id='default', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_normalize_version', args=arguments(posonlyargs=[], args=[arg(arg='version')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(names=[alias(name='sic')], level=1), If(test=BoolOp(op=Or(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='version', ctx=Load()), Name(id='sic', ctx=Load())], keywords=[]), Compare(left=Name(id='version', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Return(value=Name(id='version', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='normalized', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='Version', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='version', ctx=Load()), ops=[NotEq()], comparators=[Name(id='normalized', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='InformationOnly', ctx=Load()), attr='emit', ctx=Load()), args=[JoinedStr(values=[Constant(value="Normalizing '"), FormattedValue(value=Name(id='version', ctx=Load()), conversion=-1), Constant(value="' to '"), FormattedValue(value=Name(id='normalized', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Return(value=Name(id='normalized', ctx=Load()))], orelse=[]), Return(value=Name(id='version', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_validate_version', args=arguments(posonlyargs=[], args=[arg(arg='version')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='version', ctx=Load()), Attribute(value=Name(id='numbers', ctx=Load()), attr='Number', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='version', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Try(body=[Expr(value=Call(func=Name(id='Version', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='InvalidVersion', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), body=[ImportFrom(names=[alias(name='sic')], level=1), Expr(value=Call(func=Attribute(value=Name(id='SetuptoolsDeprecationWarning', ctx=Load()), attr='emit', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid version: '), FormattedValue(value=Name(id='version', ctx=Load()), conversion=114), Constant(value='.')]), Constant(value='\n                    The version specified is not a valid version according to PEP 440.\n                    This may not work as expected with newer versions of\n                    setuptools, pip, and PyPI.\n                    ')], keywords=[keyword(arg='see_url', value=Constant(value='https://peps.python.org/pep-0440/')), keyword(arg='due_date', value=Tuple(elts=[Constant(value=2023), Constant(value=9), Constant(value=26)], ctx=Load()))])), Return(value=Call(func=Name(id='sic', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], orelse=[]), Return(value=Name(id='version', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_finalize_requires', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Set `metadata.python_requires` and fix environment markers\n        in `install_requires` and `extras_require`.\n        ')), If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='python_requires'), Constant(value=None)], keywords=[]), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='python_requires', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='python_requires', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_normalize_requires', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='install_requires', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='install_requires', ctx=Load())), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='extras_require', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='extras_require', ctx=Load())), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='extras_require', ctx=Load()), body=[For(target=Name(id='extra', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='extras_require', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='extra', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='extra', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':')], keywords=[]), slice=Constant(value=0), ctx=Load())), If(test=Name(id='extra', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='provides_extras', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='extra', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='_normalize_requires', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Make sure requirement-related attributes exist and are normalized')), Assign(targets=[Name(id='install_requires', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='install_requires'), Constant(value=None)], keywords=[]), List(elts=[], ctx=Load())])), Assign(targets=[Name(id='extras_require', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='extras_require'), Constant(value=None)], keywords=[]), Dict(keys=[], values=[])])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='install_requires', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Call(func=Attribute(value=Name(id='_reqs', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='install_requires', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='extras_require', ctx=Store())], value=DictComp(key=Name(id='k', ctx=Load()), value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Call(func=Attribute(value=Name(id='_reqs', ctx=Load()), attr='parse', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='v', ctx=Load()), List(elts=[], ctx=Load())])], keywords=[])], keywords=[])], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='extras_require', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[]), FunctionDef(name='_finalize_license_files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute names of all license files which should be included.')), AnnAssign(target=Name(id='license_files', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()), value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='license_files', ctx=Load()), simple=1), AnnAssign(target=Name(id='patterns', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=IfExp(test=Name(id='license_files', ctx=Load()), body=Name(id='license_files', ctx=Load()), orelse=List(elts=[], ctx=Load())), simple=1), AnnAssign(target=Name(id='license_file', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='license_file', ctx=Load()), simple=1), If(test=BoolOp(op=And(), values=[Name(id='license_file', ctx=Load()), Compare(left=Name(id='license_file', ctx=Load()), ops=[NotIn()], comparators=[Name(id='patterns', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='patterns', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='license_file', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='license_files', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='license_file', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Name(id='patterns', ctx=Store())], value=Tuple(elts=[Constant(value='LICEN[CS]E*'), Constant(value='COPYING*'), Constant(value='NOTICE*'), Constant(value='AUTHORS*')], ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), attr='license_files', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='unique_everseen', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_expand_patterns', ctx=Load()), args=[Name(id='patterns', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_expand_patterns', args=arguments(posonlyargs=[], args=[arg(arg='patterns')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        >>> list(Distribution._expand_patterns(['LICENSE']))\n        ['LICENSE']\n        >>> list(Distribution._expand_patterns(['setup.cfg', 'LIC*']))\n        ['setup.cfg', 'LICENSE']\n        ")), Return(value=GeneratorExp(elt=Name(id='path', ctx=Load()), generators=[comprehension(target=Name(id='pattern', ctx=Store()), iter=Name(id='patterns', ctx=Load()), ifs=[], is_async=0), comprehension(target=Name(id='path', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Name(id='iglob', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[])], keywords=[]), ifs=[BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='~')], keywords=[])), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])])], is_async=0)]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_parse_config_files', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='filenames')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Adapted from distutils.dist.Distribution.parse_config_files,\n        this method provides the same functionality in subtly-improved\n        ways.\n        ')), ImportFrom(module='configparser', names=[alias(name='ConfigParser')], level=0), Assign(targets=[Name(id='ignore_options', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='prefix', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='base_prefix', ctx=Load())]), body=List(elts=[], ctx=Load()), orelse=List(elts=[Constant(value='install-base'), Constant(value='install-platbase'), Constant(value='install-lib'), Constant(value='install-platlib'), Constant(value='install-purelib'), Constant(value='install-headers'), Constant(value='install-scripts'), Constant(value='install-data'), Constant(value='prefix'), Constant(value='exec-prefix'), Constant(value='home'), Constant(value='user'), Constant(value='root')], ctx=Load()))), Assign(targets=[Name(id='ignore_options', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='ignore_options', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='filenames', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='filenames', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='find_config_files', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Name(id='DEBUG', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='announce', ctx=Load()), args=[Constant(value='Distribution.parse_config_files():')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='parser', ctx=Store())], value=Call(func=Name(id='ConfigParser', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='parser', ctx=Load()), attr='optionxform', ctx=Store())], value=Name(id='str', ctx=Load())), For(target=Name(id='filename', ctx=Store()), iter=Name(id='filenames', ctx=Load()), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='io', ctx=Load()), attr='open', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='reader', ctx=Store()))], body=[If(test=Name(id='DEBUG', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='announce', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='  reading {filename}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='read_file', ctx=Load()), args=[Name(id='reader', ctx=Load())], keywords=[]))]), For(target=Name(id='section', ctx=Store()), iter=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='sections', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='options', ctx=Store())], value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='options', ctx=Load()), args=[Name(id='section', ctx=Load())], keywords=[])), Assign(targets=[Name(id='opt_dict', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_option_dict', ctx=Load()), args=[Name(id='section', ctx=Load())], keywords=[])), For(target=Name(id='opt', ctx=Store()), iter=Name(id='options', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='opt', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__name__')]), Compare(left=Name(id='opt', ctx=Load()), ops=[In()], comparators=[Name(id='ignore_options', ctx=Load())])]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='val', ctx=Store())], value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='section', ctx=Load()), Name(id='opt', ctx=Load())], keywords=[])), Assign(targets=[Name(id='opt', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='warn_dash_deprecation', ctx=Load()), args=[Name(id='opt', ctx=Load()), Name(id='section', ctx=Load())], keywords=[])), Assign(targets=[Name(id='opt', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_option_lowercase', ctx=Load()), args=[Name(id='opt', ctx=Load()), Name(id='section', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='opt_dict', ctx=Load()), slice=Name(id='opt', ctx=Load()), ctx=Store())], value=Tuple(elts=[Name(id='filename', ctx=Load()), Name(id='val', ctx=Load())], ctx=Load()))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='__init__', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='global'), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='command_options', ctx=Load())]), body=[Return()], orelse=[]), For(target=Tuple(elts=[Name(id='opt', ctx=Store()), Tuple(elts=[Name(id='src', ctx=Store()), Name(id='val', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='command_options', ctx=Load()), slice=Constant(value='global'), ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='alias', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='negative_opt', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='opt', ctx=Load())], keywords=[])), If(test=Name(id='alias', ctx=Load()), body=[Assign(targets=[Name(id='val', ctx=Store())], value=UnaryOp(op=Not(), operand=Call(func=Name(id='strtobool', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[])))], orelse=[If(test=Compare(left=Name(id='opt', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='verbose'), Constant(value='dry_run')], ctx=Load())]), body=[Assign(targets=[Name(id='val', ctx=Store())], value=Call(func=Name(id='strtobool', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[]))], orelse=[])]), Try(body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), BoolOp(op=Or(), values=[Name(id='alias', ctx=Load()), Name(id='opt', ctx=Load())]), Name(id='val', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='DistutilsOptionError', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='warn_dash_deprecation', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='opt'), arg(arg='section')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='section', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='options.extras_require'), Constant(value='options.data_files')], ctx=Load())]), body=[Return(value=Name(id='opt', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='underscore_opt', ctx=Store())], value=Call(func=Attribute(value=Name(id='opt', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='_')], keywords=[])), Assign(targets=[Name(id='commands', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='distutils', ctx=Load()), attr='command', ctx=Load()), attr='__all__', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_setuptools_commands', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='section', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='options')], keywords=[])), Compare(left=Name(id='section', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='metadata')]), Compare(left=Name(id='section', ctx=Load()), ops=[NotIn()], comparators=[Name(id='commands', ctx=Load())])]), body=[Return(value=Name(id='underscore_opt', ctx=Load()))], orelse=[]), If(test=Compare(left=Constant(value='-'), ops=[In()], comparators=[Name(id='opt', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='SetuptoolsDeprecationWarning', ctx=Load()), attr='emit', ctx=Load()), args=[Constant(value='Invalid dash-separated options'), JoinedStr(values=[Constant(value='\n                Usage of dash-separated '), FormattedValue(value=Name(id='opt', ctx=Load()), conversion=114), Constant(value=' will not be supported in future\n                versions. Please use the underscore name '), FormattedValue(value=Name(id='underscore_opt', ctx=Load()), conversion=114), Constant(value=' instead.\n                ')])], keywords=[keyword(arg='see_docs', value=Constant(value='userguide/declarative_config.html')), keyword(arg='due_date', value=Tuple(elts=[Constant(value=2023), Constant(value=9), Constant(value=26)], ctx=Load()))]))], orelse=[]), Return(value=Name(id='underscore_opt', ctx=Load()))], decorator_list=[]), FunctionDef(name='_setuptools_commands', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='distribution', ctx=Load()), args=[Constant(value='setuptools')], keywords=[]), attr='entry_points', ctx=Load()), attr='names', ctx=Load()))], handlers=[ExceptHandler(type=Attribute(value=Name(id='metadata', ctx=Load()), attr='PackageNotFoundError', ctx=Load()), body=[Return(value=List(elts=[], ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='make_option_lowercase', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='opt'), arg(arg='section')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='section', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='metadata')]), Call(func=Attribute(value=Name(id='opt', ctx=Load()), attr='islower', ctx=Load()), args=[], keywords=[])]), body=[Return(value=Name(id='opt', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='lowercase_opt', ctx=Store())], value=Call(func=Attribute(value=Name(id='opt', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='SetuptoolsDeprecationWarning', ctx=Load()), attr='emit', ctx=Load()), args=[Constant(value='Invalid uppercase configuration'), JoinedStr(values=[Constant(value='\n            Usage of uppercase key '), FormattedValue(value=Name(id='opt', ctx=Load()), conversion=114), Constant(value=' in '), FormattedValue(value=Name(id='section', ctx=Load()), conversion=114), Constant(value=' will not be supported in\n            future versions. Please use lowercase '), FormattedValue(value=Name(id='lowercase_opt', ctx=Load()), conversion=114), Constant(value=' instead.\n            ')])], keywords=[keyword(arg='see_docs', value=Constant(value='userguide/declarative_config.html')), keyword(arg='due_date', value=Tuple(elts=[Constant(value=2023), Constant(value=9), Constant(value=26)], ctx=Load()))])), Return(value=Name(id='lowercase_opt', ctx=Load()))], decorator_list=[]), FunctionDef(name='_set_command_options', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='command_obj'), arg(arg='option_dict')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n        Set the options for 'command_obj' from 'option_dict'.  Basically\n        this means copying elements of a dictionary ('option_dict') to\n        attributes of an instance ('command').\n\n        'command_obj' must be a Command instance.  If 'option_dict' is not\n        supplied, uses the standard option dictionary for this command\n        (from 'self.command_options').\n\n        (Adopted from distutils.dist.Distribution._set_command_options)\n        ")), Assign(targets=[Name(id='command_name', ctx=Store())], value=Call(func=Attribute(value=Name(id='command_obj', ctx=Load()), attr='get_command_name', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='option_dict', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='option_dict', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_option_dict', ctx=Load()), args=[Name(id='command_name', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='DEBUG', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='announce', ctx=Load()), args=[BinOp(left=Constant(value="  setting options for '%s' command:"), op=Mod(), right=Name(id='command_name', ctx=Load()))], keywords=[]))], orelse=[]), For(target=Tuple(elts=[Name(id='option', ctx=Store()), Tuple(elts=[Name(id='source', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='option_dict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Name(id='DEBUG', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='announce', ctx=Load()), args=[BinOp(left=Constant(value='    %s = %s (from %s)'), op=Mod(), right=Tuple(elts=[Name(id='option', ctx=Load()), Name(id='value', ctx=Load()), Name(id='source', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Name(id='bool_opts', ctx=Store())], value=ListComp(elt=Call(func=Name(id='translate_longopt', ctx=Load()), args=[Name(id='o', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='o', ctx=Store()), iter=Attribute(value=Name(id='command_obj', ctx=Load()), attr='boolean_options', ctx=Load()), ifs=[], is_async=0)]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Assign(targets=[Name(id='bool_opts', ctx=Store())], value=List(elts=[], ctx=Load()))])], orelse=[], finalbody=[]), Try(body=[Assign(targets=[Name(id='neg_opt', ctx=Store())], value=Attribute(value=Name(id='command_obj', ctx=Load()), attr='negative_opt', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Assign(targets=[Name(id='neg_opt', ctx=Store())], value=Dict(keys=[], values=[]))])], orelse=[], finalbody=[]), Try(body=[Assign(targets=[Name(id='is_string', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='option', ctx=Load()), ops=[In()], comparators=[Name(id='neg_opt', ctx=Load())]), Name(id='is_string', ctx=Load())]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='command_obj', ctx=Load()), Subscript(value=Name(id='neg_opt', ctx=Load()), slice=Name(id='option', ctx=Load()), ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Name(id='strtobool', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='option', ctx=Load()), ops=[In()], comparators=[Name(id='bool_opts', ctx=Load())]), Name(id='is_string', ctx=Load())]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='command_obj', ctx=Load()), Name(id='option', ctx=Load()), Call(func=Name(id='strtobool', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='command_obj', ctx=Load()), Name(id='option', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='command_obj', ctx=Load()), Name(id='option', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='DistutilsOptionError', ctx=Load()), args=[BinOp(left=Constant(value="error in %s: command '%s' has no such option '%s'"), op=Mod(), right=Tuple(elts=[Name(id='source', ctx=Load()), Name(id='command_name', ctx=Load()), Name(id='option', ctx=Load())], ctx=Load()))], keywords=[]))])])])], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='DistutilsOptionError', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='_get_project_config_files', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='filenames')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add default file and split between INI and TOML')), Assign(targets=[Name(id='tomlfiles', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='standard_project_metadata', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='src_root', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='curdir', ctx=Load())]), Constant(value='pyproject.toml')], keywords=[])), If(test=Compare(left=Name(id='filenames', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Name(id='partition', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='f')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]), attr='suffix', ctx=Load()), ops=[Eq()], comparators=[Constant(value='.toml')])), Name(id='filenames', ctx=Load())], keywords=[])), Assign(targets=[Name(id='filenames', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Subscript(value=Name(id='parts', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), Assign(targets=[Name(id='tomlfiles', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Subscript(value=Name(id='parts', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Attribute(value=Name(id='standard_project_metadata', ctx=Load()), attr='exists', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='tomlfiles', ctx=Store())], value=List(elts=[Name(id='standard_project_metadata', ctx=Load())], ctx=Load()))], orelse=[])]), Return(value=Tuple(elts=[Name(id='filenames', ctx=Load()), Name(id='tomlfiles', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='parse_config_files', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='filenames'), arg(arg='ignore_option_errors')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Parses configuration files from various levels\n        and loads configuration.\n        ')), Assign(targets=[Tuple(elts=[Name(id='inifiles', ctx=Store()), Name(id='tomlfiles', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_project_config_files', ctx=Load()), args=[Name(id='filenames', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_config_files', ctx=Load()), args=[], keywords=[keyword(arg='filenames', value=Name(id='inifiles', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='setupcfg', ctx=Load()), attr='parse_configuration', ctx=Load()), args=[Name(id='self', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='command_options', ctx=Load())], keywords=[keyword(arg='ignore_option_errors', value=Name(id='ignore_option_errors', ctx=Load()))])), For(target=Name(id='filename', ctx=Store()), iter=Name(id='tomlfiles', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='pyprojecttoml', ctx=Load()), attr='apply_configuration', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='filename', ctx=Load()), Name(id='ignore_option_errors', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_finalize_requires', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_finalize_license_files', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='fetch_build_eggs', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requires')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Resolve pre-setup requirements')), ImportFrom(module='installer', names=[alias(name='_fetch_build_eggs')], level=1), Return(value=Call(func=Name(id='_fetch_build_eggs', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='requires', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='finalize_options', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Allow plugins to apply arbitrary operations to the\n        distribution. Each hook may optionally define a 'order'\n        to influence the order of execution. Smaller numbers\n        go first and the default is 0.\n        ")), Assign(targets=[Name(id='group', ctx=Store())], value=Constant(value='setuptools.finalize_distribution_options')), FunctionDef(name='by_order', args=arguments(posonlyargs=[], args=[arg(arg='hook')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='hook', ctx=Load()), Constant(value='order'), Constant(value=0)], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='defined', ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='entry_points', ctx=Load()), args=[], keywords=[keyword(arg='group', value=Name(id='group', ctx=Load()))])), Assign(targets=[Name(id='filtered', ctx=Store())], value=Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='filterfalse', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_removed', ctx=Load()), Name(id='defined', ctx=Load())], keywords=[])), Assign(targets=[Name(id='loaded', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='e')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='load', ctx=Load()), args=[], keywords=[])), Name(id='filtered', ctx=Load())], keywords=[])), For(target=Name(id='ep', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='loaded', ctx=Load())], keywords=[keyword(arg='key', value=Name(id='by_order', ctx=Load()))]), body=[Expr(value=Call(func=Name(id='ep', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_removed', args=arguments(posonlyargs=[], args=[arg(arg='ep')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        When removing an entry point, if metadata is loaded\n        from an older version of Setuptools, that removed\n        entry point will attempt to be loaded and will fail.\n        See #2765 for more details.\n        ')), Assign(targets=[Name(id='removed', ctx=Store())], value=Set(elts=[Constant(value='2to3_doctests')])), Return(value=Compare(left=Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), ops=[In()], comparators=[Name(id='removed', ctx=Load())]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_finalize_setup_keywords', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='ep', ctx=Store()), iter=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='entry_points', ctx=Load()), args=[], keywords=[keyword(arg='group', value=Constant(value='distutils.setup_keywords'))]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), Constant(value=None)], keywords=[])), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Call(func=Attribute(value=Name(id='ep', ctx=Load()), attr='load', ctx=Load()), args=[], keywords=[]), args=[Name(id='self', ctx=Load()), Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='get_egg_cache_dir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(names=[alias(name='windows_support')], level=1), Assign(targets=[Name(id='egg_cache_dir', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='curdir', ctx=Load()), Constant(value='.eggs')], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='egg_cache_dir', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='mkdir', ctx=Load()), args=[Name(id='egg_cache_dir', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='windows_support', ctx=Load()), attr='hide_file', ctx=Load()), args=[Name(id='egg_cache_dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='readme_txt_filename', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='egg_cache_dir', ctx=Load()), Constant(value='README.txt')], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='readme_txt_filename', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='This directory contains eggs that were downloaded by setuptools to build, test, and run plug-ins.\n\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='This directory caches those eggs to prevent repeated downloads.\n\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='However, it is safe to delete this directory.\n\n')], keywords=[]))])], orelse=[]), Return(value=Name(id='egg_cache_dir', ctx=Load()))], decorator_list=[]), FunctionDef(name='fetch_build_egg', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Fetch an egg needed for building')), ImportFrom(module='installer', names=[alias(name='fetch_build_egg')], level=1), Return(value=Call(func=Name(id='fetch_build_egg', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='req', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_command_class', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='command')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Pluggable version of get_command_class()')), If(test=Compare(left=Name(id='command', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='cmdclass', ctx=Load())]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='cmdclass', ctx=Load()), slice=Name(id='command', ctx=Load()), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='eps', ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='entry_points', ctx=Load()), args=[], keywords=[keyword(arg='group', value=Constant(value='distutils.commands')), keyword(arg='name', value=Name(id='command', ctx=Load()))])), For(target=Name(id='ep', ctx=Store()), iter=Name(id='eps', ctx=Load()), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='cmdclass', ctx=Load()), slice=Name(id='command', ctx=Load()), ctx=Store()), Name(id='cmdclass', ctx=Store())], value=Call(func=Attribute(value=Name(id='ep', ctx=Load()), attr='load', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='cmdclass', ctx=Load()))], orelse=[Return(value=Call(func=Attribute(value=Name(id='_Distribution', ctx=Load()), attr='get_command_class', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='command', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='print_commands', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='ep', ctx=Store()), iter=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='entry_points', ctx=Load()), args=[], keywords=[keyword(arg='group', value=Constant(value='distutils.commands'))]), body=[If(test=Compare(left=Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='cmdclass', ctx=Load())]), body=[Assign(targets=[Name(id='cmdclass', ctx=Store())], value=Call(func=Attribute(value=Name(id='ep', ctx=Load()), attr='load', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='cmdclass', ctx=Load()), slice=Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Name(id='cmdclass', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='_Distribution', ctx=Load()), attr='print_commands', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_command_list', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='ep', ctx=Store()), iter=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='entry_points', ctx=Load()), args=[], keywords=[keyword(arg='group', value=Constant(value='distutils.commands'))]), body=[If(test=Compare(left=Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='cmdclass', ctx=Load())]), body=[Assign(targets=[Name(id='cmdclass', ctx=Store())], value=Call(func=Attribute(value=Name(id='ep', ctx=Load()), attr='load', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='cmdclass', ctx=Load()), slice=Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Name(id='cmdclass', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='_Distribution', ctx=Load()), attr='get_command_list', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='include', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='attrs'), defaults=[]), body=[Expr(value=Constant(value='Add items to distribution that are named in keyword arguments\n\n        For example, \'dist.include(py_modules=["x"])\' would add \'x\' to\n        the distribution\'s \'py_modules\' attribute, if it was not already\n        there.\n\n        Currently, this method only supports inclusion for attributes that are\n        lists or tuples.  If you need to add support for adding to other\n        attributes in this or a subclass, you can add an \'_include_X\' method,\n        where \'X\' is the name of the attribute.  The method will be called with\n        the value passed to \'include()\'.  So, \'dist.include(foo={"bar":"baz"})\'\n        will try to call \'dist._include_foo({"bar":"baz"})\', which can then\n        handle whatever special inclusion logic is needed.\n        ')), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='include', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), BinOp(left=Constant(value='_include_'), op=Add(), right=Name(id='k', ctx=Load())), Constant(value=None)], keywords=[])), If(test=Name(id='include', ctx=Load()), body=[Expr(value=Call(func=Name(id='include', ctx=Load()), args=[Name(id='v', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_include_misc', ctx=Load()), args=[Name(id='k', ctx=Load()), Name(id='v', ctx=Load())], keywords=[]))])], orelse=[])], decorator_list=[]), FunctionDef(name='exclude_package', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='package')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove packages, modules, and extensions in named package')), Assign(targets=[Name(id='pfx', ctx=Store())], value=BinOp(left=Name(id='package', ctx=Load()), op=Add(), right=Constant(value='.'))), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='packages', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='packages', ctx=Store())], value=ListComp(elt=Name(id='p', ctx=Load()), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='packages', ctx=Load()), ifs=[BoolOp(op=And(), values=[Compare(left=Name(id='p', ctx=Load()), ops=[NotEq()], comparators=[Name(id='package', ctx=Load())]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='pfx', ctx=Load())], keywords=[]))])], is_async=0)]))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='py_modules', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='py_modules', ctx=Store())], value=ListComp(elt=Name(id='p', ctx=Load()), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='py_modules', ctx=Load()), ifs=[BoolOp(op=And(), values=[Compare(left=Name(id='p', ctx=Load()), ops=[NotEq()], comparators=[Name(id='package', ctx=Load())]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='pfx', ctx=Load())], keywords=[]))])], is_async=0)]))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='ext_modules', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ext_modules', ctx=Store())], value=ListComp(elt=Name(id='p', ctx=Load()), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='ext_modules', ctx=Load()), ifs=[BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='p', ctx=Load()), attr='name', ctx=Load()), ops=[NotEq()], comparators=[Name(id='package', ctx=Load())]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='p', ctx=Load()), attr='name', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='pfx', ctx=Load())], keywords=[]))])], is_async=0)]))], orelse=[])], decorator_list=[]), FunctionDef(name='has_contents_for', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='package')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return true if 'exclude_package(package)' would do something")), Assign(targets=[Name(id='pfx', ctx=Store())], value=BinOp(left=Name(id='package', ctx=Load()), op=Add(), right=Constant(value='.'))), For(target=Name(id='p', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iter_distribution_names', ctx=Load()), args=[], keywords=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='p', ctx=Load()), ops=[Eq()], comparators=[Name(id='package', ctx=Load())]), Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='pfx', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='_exclude_misc', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Handle 'exclude()' for list/tuple attrs without a special handler")), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='sequence', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[BinOp(left=Constant(value='%s: setting must be a list or tuple (%r)'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Name(id='old', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[BinOp(left=Constant(value='%s: No such distribution setting'), op=Mod(), right=Name(id='name', ctx=Load()))], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='old', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='old', ctx=Load()), Name(id='sequence', ctx=Load())], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[BinOp(left=Name(id='name', ctx=Load()), op=Add(), right=Constant(value=': this setting cannot be changed via include/exclude'))], keywords=[]))], orelse=[If(test=Name(id='old', ctx=Load()), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load()), ListComp(elt=Name(id='item', ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='old', ctx=Load()), ifs=[Compare(left=Name(id='item', ctx=Load()), ops=[NotIn()], comparators=[Name(id='value', ctx=Load())])], is_async=0)])], keywords=[]))], orelse=[])])], decorator_list=[]), FunctionDef(name='_include_misc', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Handle 'include()' for list/tuple attrs without a special handler")), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='sequence', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[BinOp(left=Constant(value='%s: setting must be a list (%r)'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Name(id='old', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[BinOp(left=Constant(value='%s: No such distribution setting'), op=Mod(), right=Name(id='name', ctx=Load()))], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='old', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='old', ctx=Load()), Name(id='sequence', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[BinOp(left=Name(id='name', ctx=Load()), op=Add(), right=Constant(value=': this setting cannot be changed via include/exclude'))], keywords=[]))], orelse=[Assign(targets=[Name(id='new', ctx=Store())], value=ListComp(elt=Name(id='item', ctx=Load()), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='value', ctx=Load()), ifs=[Compare(left=Name(id='item', ctx=Load()), ops=[NotIn()], comparators=[Name(id='old', ctx=Load())])], is_async=0)])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load()), BinOp(left=Name(id='old', ctx=Load()), op=Add(), right=Name(id='new', ctx=Load()))], keywords=[]))])])], decorator_list=[]), FunctionDef(name='exclude', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='attrs'), defaults=[]), body=[Expr(value=Constant(value='Remove items from distribution that are named in keyword arguments\n\n        For example, \'dist.exclude(py_modules=["x"])\' would remove \'x\' from\n        the distribution\'s \'py_modules\' attribute.  Excluding packages uses\n        the \'exclude_package()\' method, so all of the package\'s contained\n        packages, modules, and extensions are also excluded.\n\n        Currently, this method only supports exclusion from attributes that are\n        lists or tuples.  If you need to add support for excluding from other\n        attributes in this or a subclass, you can add an \'_exclude_X\' method,\n        where \'X\' is the name of the attribute.  The method will be called with\n        the value passed to \'exclude()\'.  So, \'dist.exclude(foo={"bar":"baz"})\'\n        will try to call \'dist._exclude_foo({"bar":"baz"})\', which can then\n        handle whatever special exclusion logic is needed.\n        ')), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='exclude', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), BinOp(left=Constant(value='_exclude_'), op=Add(), right=Name(id='k', ctx=Load())), Constant(value=None)], keywords=[])), If(test=Name(id='exclude', ctx=Load()), body=[Expr(value=Call(func=Name(id='exclude', ctx=Load()), args=[Name(id='v', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_exclude_misc', ctx=Load()), args=[Name(id='k', ctx=Load()), Name(id='v', ctx=Load())], keywords=[]))])], orelse=[])], decorator_list=[]), FunctionDef(name='_exclude_packages', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='packages')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='packages', ctx=Load()), Name(id='sequence', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='DistutilsSetupError', ctx=Load()), args=[BinOp(left=Constant(value='packages: setting must be a list or tuple (%r)'), op=Mod(), right=Tuple(elts=[Name(id='packages', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='exclude_package', ctx=Load()), Name(id='packages', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_parse_command_opts', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parser'), arg(arg='args')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='global_options', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='global_options', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='negative_opt', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='negative_opt', ctx=Load())), Assign(targets=[Name(id='command', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='aliases', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_option_dict', ctx=Load()), args=[Constant(value='aliases')], keywords=[])), While(test=Compare(left=Name(id='command', ctx=Load()), ops=[In()], comparators=[Name(id='aliases', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='src', ctx=Store()), Name(id='alias', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='aliases', ctx=Load()), slice=Name(id='command', ctx=Load()), ctx=Load())), Delete(targets=[Subscript(value=Name(id='aliases', ctx=Load()), slice=Name(id='command', ctx=Load()), ctx=Del())]), Import(names=[alias(name='shlex')]), Assign(targets=[Subscript(value=Name(id='args', ctx=Load()), slice=Slice(upper=Constant(value=1)), ctx=Store())], value=Call(func=Attribute(value=Name(id='shlex', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='alias', ctx=Load()), Constant(value=True)], keywords=[])), Assign(targets=[Name(id='command', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='nargs', ctx=Store())], value=Call(func=Attribute(value=Name(id='_Distribution', ctx=Load()), attr='_parse_command_opts', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parser', ctx=Load()), Name(id='args', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cmd_class', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_command_class', ctx=Load()), args=[Name(id='command', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cmd_class', ctx=Load()), Constant(value='command_consumes_arguments'), Constant(value=None)], keywords=[]), body=[Assign(targets=[Subscript(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_option_dict', ctx=Load()), args=[Name(id='command', ctx=Load())], keywords=[]), slice=Constant(value='args'), ctx=Store())], value=Tuple(elts=[Constant(value='command line'), Name(id='nargs', ctx=Load())], ctx=Load())), If(test=Compare(left=Name(id='nargs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='nargs', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_cmdline_options', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return a '{cmd: {opt:val}}' map of all command-line options\n\n        Option names are all long, but do not include the leading '--', and\n        contain dashes rather than underscores.  If the option doesn't take\n        an argument (e.g. '--quiet'), the 'val' is 'None'.\n\n        Note that options provided by config files are intentionally excluded.\n        ")), Assign(targets=[Name(id='d', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='cmd', ctx=Store()), Name(id='opts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='command_options', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[For(target=Tuple(elts=[Name(id='opt', ctx=Store()), Tuple(elts=[Name(id='src', ctx=Store()), Name(id='val', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='opts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='src', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='command line')]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='opt', ctx=Store())], value=Call(func=Attribute(value=Name(id='opt', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='_'), Constant(value='-')], keywords=[])), If(test=Compare(left=Name(id='val', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='cmdobj', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_command_obj', ctx=Load()), args=[Name(id='cmd', ctx=Load())], keywords=[])), Assign(targets=[Name(id='neg_opt', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='negative_opt', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='neg_opt', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cmdobj', ctx=Load()), Constant(value='negative_opt'), Dict(keys=[], values=[])], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='neg', ctx=Store()), Name(id='pos', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='neg_opt', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='pos', ctx=Load()), ops=[Eq()], comparators=[Name(id='opt', ctx=Load())]), body=[Assign(targets=[Name(id='opt', ctx=Store())], value=Name(id='neg', ctx=Load())), Assign(targets=[Name(id='val', ctx=Store())], value=Constant(value=None)), Break()], orelse=[])], orelse=[Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Constant(value="Shouldn't be able to get here")], keywords=[]))])], orelse=[If(test=Compare(left=Name(id='val', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='val', ctx=Store())], value=Constant(value=None))], orelse=[])]), Assign(targets=[Subscript(value=Call(func=Attribute(value=Name(id='d', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='cmd', ctx=Load()), Dict(keys=[], values=[])], keywords=[]), slice=Name(id='opt', ctx=Load()), ctx=Store())], value=Name(id='val', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='d', ctx=Load()))], decorator_list=[]), FunctionDef(name='iter_distribution_names', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Yield all packages, modules, and extension names in distribution')), For(target=Name(id='pkg', ctx=Store()), iter=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='packages', ctx=Load()), Tuple(elts=[], ctx=Load())]), body=[Expr(value=Yield(value=Name(id='pkg', ctx=Load())))], orelse=[]), For(target=Name(id='module', ctx=Store()), iter=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='py_modules', ctx=Load()), Tuple(elts=[], ctx=Load())]), body=[Expr(value=Yield(value=Name(id='module', ctx=Load())))], orelse=[]), For(target=Name(id='ext', ctx=Store()), iter=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='ext_modules', ctx=Load()), Tuple(elts=[], ctx=Load())]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='ext', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='buildinfo', ctx=Store())], ctx=Store())], value=Name(id='ext', ctx=Load()))], orelse=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='ext', ctx=Load()), attr='name', ctx=Load()))]), If(test=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='module')], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Name(id='name', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=6))), ctx=Load()))], orelse=[]), Expr(value=Yield(value=Name(id='name', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='handle_display_options', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='option_order')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='If there were any non-global "display-only" options\n        (--help-commands or the metadata display options) on the command\n        line, display the requested info and return true; else return\n        false.\n        ')), Import(names=[alias(name='sys')]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='help_commands', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='_Distribution', ctx=Load()), attr='handle_display_options', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='option_order', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='sys', ctx=Load()), attr='stdout', ctx=Load()), Attribute(value=Name(id='io', ctx=Load()), attr='TextIOWrapper', ctx=Load())], keywords=[])), body=[Return(value=Call(func=Attribute(value=Name(id='_Distribution', ctx=Load()), attr='handle_display_options', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='option_order', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stdout', ctx=Load()), attr='encoding', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[Tuple(elts=[Constant(value='utf-8'), Constant(value='utf8')], ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Name(id='_Distribution', ctx=Load()), attr='handle_display_options', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='option_order', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='encoding', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stdout', ctx=Load()), attr='encoding', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stdout', ctx=Load()), attr='reconfigure', ctx=Load()), args=[], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))])), Try(body=[Return(value=Call(func=Attribute(value=Name(id='_Distribution', ctx=Load()), attr='handle_display_options', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='option_order', ctx=Load())], keywords=[]))], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stdout', ctx=Load()), attr='reconfigure', ctx=Load()), args=[], keywords=[keyword(arg='encoding', value=Name(id='encoding', ctx=Load()))]))])], decorator_list=[]), FunctionDef(name='run_command', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='command')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_defaults', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='run_command', ctx=Load()), args=[Name(id='command', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='DistDeprecationWarning', bases=[Name(id='SetuptoolsDeprecationWarning', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for warning about deprecations in dist in\n    setuptools. Not ignored by default, unlike DeprecationWarning.'))], decorator_list=[])], type_ignores=[])