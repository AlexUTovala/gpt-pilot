Module(body=[Expr(value=Constant(value='\nLoad setuptools configuration from ``setup.cfg`` files.\n\n**API will be made private in the future**\n\nTo read project metadata, consider using\n``build.util.project_wheel_metadata`` (https://pypi.org/project/build/).\nFor simple scenarios, you can also try parsing the file directly\nwith the help of ``configparser``.\n')), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='os')]), ImportFrom(module='collections', names=[alias(name='defaultdict')], level=0), ImportFrom(module='functools', names=[alias(name='partial')], level=0), ImportFrom(module='functools', names=[alias(name='wraps')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Callable'), alias(name='Any'), alias(name='Dict'), alias(name='Generic'), alias(name='Iterable'), alias(name='List'), alias(name='Optional'), alias(name='Set'), alias(name='Tuple'), alias(name='TypeVar'), alias(name='Union')], level=0), ImportFrom(module='errors', names=[alias(name='FileError'), alias(name='OptionError')], level=2), ImportFrom(module='extern.packaging.markers', names=[alias(name='default_environment', asname='marker_env')], level=2), ImportFrom(module='extern.packaging.requirements', names=[alias(name='InvalidRequirement'), alias(name='Requirement')], level=2), ImportFrom(module='extern.packaging.specifiers', names=[alias(name='SpecifierSet')], level=2), ImportFrom(module='extern.packaging.version', names=[alias(name='InvalidVersion'), alias(name='Version')], level=2), ImportFrom(module='warnings', names=[alias(name='SetuptoolsDeprecationWarning')], level=2), ImportFrom(names=[alias(name='expand')], level=1), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='distutils.dist', names=[alias(name='DistributionMetadata')], level=0), ImportFrom(module='setuptools.dist', names=[alias(name='Distribution')], level=0)], orelse=[]), Assign(targets=[Name(id='_Path', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='PathLike', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='SingleCommandOptions', ctx=Store())], value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Constant(value='str'), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Constant(value='str'), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), Expr(value=Constant(value='Dict that associate the name of the options of a particular command to a\ntuple. The first element of the tuple indicates the origin of the option value\n(e.g. the name of the configuration file where it was read from),\nwhile the second element of the tuple is the option value itself\n')), Assign(targets=[Name(id='AllCommandOptions', ctx=Store())], value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Constant(value='str'), Name(id='SingleCommandOptions', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='Target', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='Target')], keywords=[keyword(arg='bound', value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='Distribution'), Constant(value='DistributionMetadata')], ctx=Load()), ctx=Load()))])), FunctionDef(name='read_configuration', args=arguments(posonlyargs=[], args=[arg(arg='filepath', annotation=Name(id='_Path', ctx=Load())), arg(arg='find_others'), arg(arg='ignore_option_errors')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value='Read given configuration file and returns options from it as a dict.\n\n    :param str|unicode filepath: Path to configuration file\n        to get options from.\n\n    :param bool find_others: Whether to search for other configuration files\n        which could be on in various places.\n\n    :param bool ignore_option_errors: Whether to silently ignore\n        options, values of which could not be resolved (e.g. due to exceptions\n        in directives such as file:, attr:, etc.).\n        If False exceptions are propagated as expected.\n\n    :rtype: dict\n    ')), ImportFrom(module='setuptools.dist', names=[alias(name='Distribution')], level=0), Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Name(id='Distribution', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='filenames', ctx=Store())], value=IfExp(test=Name(id='find_others', ctx=Load()), body=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='find_config_files', ctx=Load()), args=[], keywords=[]), orelse=List(elts=[], ctx=Load()))), Assign(targets=[Name(id='handlers', ctx=Store())], value=Call(func=Name(id='_apply', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='filepath', ctx=Load()), Name(id='filenames', ctx=Load()), Name(id='ignore_option_errors', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='configuration_to_dict', ctx=Load()), args=[Name(id='handlers', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='dict', ctx=Load())), FunctionDef(name='apply_configuration', args=arguments(posonlyargs=[], args=[arg(arg='dist', annotation=Constant(value='Distribution')), arg(arg='filepath', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Apply the configuration from a ``setup.cfg`` file into an existing\n    distribution object.\n    ')), Expr(value=Call(func=Name(id='_apply', ctx=Load()), args=[Name(id='dist', ctx=Load()), Name(id='filepath', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='_finalize_requires', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='dist', ctx=Load()))], decorator_list=[], returns=Constant(value='Distribution')), FunctionDef(name='_apply', args=arguments(posonlyargs=[], args=[arg(arg='dist', annotation=Constant(value='Distribution')), arg(arg='filepath', annotation=Name(id='_Path', ctx=Load())), arg(arg='other_files', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load())), arg(arg='ignore_option_errors', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[], ctx=Load()), Constant(value=False)]), body=[Expr(value=Constant(value='Read configuration from ``filepath`` and applies to the ``dist`` object.')), ImportFrom(module='setuptools.dist', names=[alias(name='_Distribution')], level=0), Assign(targets=[Name(id='filepath', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Name(id='filepath', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='filepath', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='FileError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Configuration file '), FormattedValue(value=Name(id='filepath', ctx=Load()), conversion=-1), Constant(value=' does not exist.')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='current_directory', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='chdir', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='filepath', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='filenames', ctx=Store())], value=List(elts=[Starred(value=Name(id='other_files', ctx=Load()), ctx=Load()), Name(id='filepath', ctx=Load())], ctx=Load())), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='_Distribution', ctx=Load()), attr='parse_config_files', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[keyword(arg='filenames', value=Name(id='filenames', ctx=Load()))])), Assign(targets=[Name(id='handlers', ctx=Store())], value=Call(func=Name(id='parse_configuration', ctx=Load()), args=[Name(id='dist', ctx=Load()), Attribute(value=Name(id='dist', ctx=Load()), attr='command_options', ctx=Load())], keywords=[keyword(arg='ignore_option_errors', value=Name(id='ignore_option_errors', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='_finalize_license_files', ctx=Load()), args=[], keywords=[]))], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='chdir', ctx=Load()), args=[Name(id='current_directory', ctx=Load())], keywords=[]))]), Return(value=Name(id='handlers', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Constant(value='ConfigHandler'), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='_get_option', args=arguments(posonlyargs=[], args=[arg(arg='target_obj', annotation=Name(id='Target', ctx=Load())), arg(arg='key', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Given a target object and option key, get that option from\n    the target object, either through a get_{key} method or\n    from an attribute directly.\n    ')), Assign(targets=[Name(id='getter_name', ctx=Store())], value=JoinedStr(values=[Constant(value='get_'), FormattedValue(value=Name(id='key', ctx=Load()), conversion=-1)])), Assign(targets=[Name(id='by_attribute', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Name(id='getattr', ctx=Load()), Name(id='target_obj', ctx=Load()), Name(id='key', ctx=Load())], keywords=[])), Assign(targets=[Name(id='getter', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='target_obj', ctx=Load()), Name(id='getter_name', ctx=Load()), Name(id='by_attribute', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='getter', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='configuration_to_dict', args=arguments(posonlyargs=[], args=[arg(arg='handlers', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Constant(value='ConfigHandler'), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns configuration data gathered by given handlers as a dict.\n\n    :param list[ConfigHandler] handlers: Handlers list,\n        usually from parse_configuration()\n\n    :rtype: dict\n    ')), AnnAssign(target=Name(id='config_dict', ctx=Store()), annotation=Name(id='dict', ctx=Load()), value=Call(func=Name(id='defaultdict', ctx=Load()), args=[Name(id='dict', ctx=Load())], keywords=[]), simple=1), For(target=Name(id='handler', ctx=Store()), iter=Name(id='handlers', ctx=Load()), body=[For(target=Name(id='option', ctx=Store()), iter=Attribute(value=Name(id='handler', ctx=Load()), attr='set_options', ctx=Load()), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='_get_option', ctx=Load()), args=[Attribute(value=Name(id='handler', ctx=Load()), attr='target_obj', ctx=Load()), Name(id='option', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Subscript(value=Name(id='config_dict', ctx=Load()), slice=Attribute(value=Name(id='handler', ctx=Load()), attr='section_prefix', ctx=Load()), ctx=Load()), slice=Name(id='option', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='config_dict', ctx=Load()))], decorator_list=[], returns=Name(id='dict', ctx=Load())), FunctionDef(name='parse_configuration', args=arguments(posonlyargs=[], args=[arg(arg='distribution', annotation=Constant(value='Distribution')), arg(arg='command_options', annotation=Name(id='AllCommandOptions', ctx=Load())), arg(arg='ignore_option_errors')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Performs additional parsing of configuration options\n    for a distribution.\n\n    Returns a list of used option handlers.\n\n    :param Distribution distribution:\n    :param dict command_options:\n    :param bool ignore_option_errors: Whether to silently ignore\n        options, values of which could not be resolved (e.g. due to exceptions\n        in directives such as file:, attr:, etc.).\n        If False exceptions are propagated as expected.\n    :rtype: list\n    ')), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='expand', ctx=Load()), attr='EnsurePackagesDiscovered', ctx=Load()), args=[Name(id='distribution', ctx=Load())], keywords=[]), optional_vars=Name(id='ensure_discovered', ctx=Store()))], body=[Assign(targets=[Name(id='options', ctx=Store())], value=Call(func=Name(id='ConfigOptionsHandler', ctx=Load()), args=[Name(id='distribution', ctx=Load()), Name(id='command_options', ctx=Load()), Name(id='ignore_option_errors', ctx=Load()), Name(id='ensure_discovered', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='options', ctx=Load()), attr='parse', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='distribution', ctx=Load()), attr='package_dir', ctx=Load())), body=[Assign(targets=[Attribute(value=Name(id='distribution', ctx=Load()), attr='package_dir', ctx=Store())], value=Attribute(value=Name(id='options', ctx=Load()), attr='package_dir', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='meta', ctx=Store())], value=Call(func=Name(id='ConfigMetadataHandler', ctx=Load()), args=[Attribute(value=Name(id='distribution', ctx=Load()), attr='metadata', ctx=Load()), Name(id='command_options', ctx=Load()), Name(id='ignore_option_errors', ctx=Load()), Name(id='ensure_discovered', ctx=Load()), Attribute(value=Name(id='distribution', ctx=Load()), attr='package_dir', ctx=Load()), Attribute(value=Name(id='distribution', ctx=Load()), attr='src_root', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='meta', ctx=Load()), attr='parse', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='distribution', ctx=Load()), attr='_referenced_files', ctx=Load()), attr='update', ctx=Load()), args=[Attribute(value=Name(id='options', ctx=Load()), attr='_referenced_files', ctx=Load()), Attribute(value=Name(id='meta', ctx=Load()), attr='_referenced_files', ctx=Load())], keywords=[]))]), Return(value=Tuple(elts=[Name(id='meta', ctx=Load()), Name(id='options', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Constant(value='ConfigMetadataHandler'), Constant(value='ConfigOptionsHandler')], ctx=Load()), ctx=Load())), FunctionDef(name='_warn_accidental_env_marker_misconfig', args=arguments(posonlyargs=[], args=[arg(arg='label', annotation=Name(id='str', ctx=Load())), arg(arg='orig_value', annotation=Name(id='str', ctx=Load())), arg(arg='parsed', annotation=Name(id='list', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Because users sometimes misinterpret this configuration:\n\n    [options.extras_require]\n    foo = bar;python_version<"4"\n\n    It looks like one requirement with an environment marker\n    but because there is no newline, it\'s parsed as two requirements\n    with a semicolon as separator.\n\n    Therefore, if:\n        * input string does not contain a newline AND\n        * parsed result contains two requirements AND\n        * parsing of the two parts from the result ("<first>;<second>")\n        leads in a valid Requirement with a valid marker\n    a UserWarning is shown to inform the user about the possible problem.\n    ')), If(test=BoolOp(op=Or(), values=[Compare(left=Constant(value='\n'), ops=[In()], comparators=[Name(id='orig_value', ctx=Load())]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parsed', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=2)])]), body=[Return()], orelse=[]), Assign(targets=[Name(id='markers', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='marker_env', ctx=Load()), args=[], keywords=[]), attr='keys', ctx=Load()), args=[], keywords=[])), Try(body=[Assign(targets=[Name(id='req', ctx=Store())], value=Call(func=Name(id='Requirement', ctx=Load()), args=[Subscript(value=Name(id='parsed', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='req', ctx=Load()), attr='name', ctx=Load()), ops=[In()], comparators=[Name(id='markers', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='_AmbiguousMarker', ctx=Load()), attr='emit', ctx=Load()), args=[], keywords=[keyword(arg='field', value=Name(id='label', ctx=Load())), keyword(arg='req', value=Subscript(value=Name(id='parsed', ctx=Load()), slice=Constant(value=1), ctx=Load()))]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='InvalidRequirement', ctx=Load()), name='ex', body=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Subscript(value=Name(id='parsed', ctx=Load()), slice=Constant(value=1), ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='marker', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='marker', ctx=Store()), iter=Name(id='markers', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Name(id='_AmbiguousMarker', ctx=Load()), attr='message', ctx=Load()), args=[], keywords=[keyword(arg='field', value=Name(id='label', ctx=Load())), keyword(arg='req', value=Subscript(value=Name(id='parsed', ctx=Load()), slice=Constant(value=1), ctx=Load()))])), Raise(exc=Call(func=Name(id='InvalidRequirement', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]), cause=Name(id='ex', ctx=Load()))], orelse=[])])], orelse=[], finalbody=[])], decorator_list=[]), ClassDef(name='ConfigHandler', bases=[Subscript(value=Name(id='Generic', ctx=Load()), slice=Name(id='Target', ctx=Load()), ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Handles metadata supplied in configuration files.')), AnnAssign(target=Name(id='section_prefix', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), Expr(value=Constant(value='Prefix for config sections handled by this handler.\n    Must be provided by class heirs.\n\n    ')), AnnAssign(target=Name(id='aliases', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), Expr(value=Constant(value='Options aliases.\n    For compatibility with various packages. E.g.: d2to1 and pbr.\n    Note: `-` in keys is replaced with `_` by config parser.\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='target_obj', annotation=Name(id='Target', ctx=Load())), arg(arg='options', annotation=Name(id='AllCommandOptions', ctx=Load())), arg(arg='ignore_option_errors'), arg(arg='ensure_discovered', annotation=Attribute(value=Name(id='expand', ctx=Load()), attr='EnsurePackagesDiscovered', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ignore_option_errors', ctx=Store())], value=Name(id='ignore_option_errors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='target_obj', ctx=Store())], value=Name(id='target_obj', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='sections', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_section_options', ctx=Load()), args=[Name(id='options', ctx=Load())], keywords=[])], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='set_options', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ensure_discovered', ctx=Store())], value=Name(id='ensure_discovered', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_referenced_files', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=0), Expr(value=Constant(value='After parsing configurations, this property will enumerate\n        all files referenced by the "file:" directive. Private API for setuptools only.\n        '))], decorator_list=[]), FunctionDef(name='_section_options', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='options', annotation=Name(id='AllCommandOptions', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Tuple(elts=[Name(id='full_name', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='options', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='pre', ctx=Store()), Name(id='sep', ctx=Store()), Name(id='name', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='full_name', ctx=Load()), attr='partition', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='section_prefix', ctx=Load())], keywords=[])), If(test=Name(id='pre', ctx=Load()), body=[Continue()], orelse=[]), Expr(value=Yield(value=Tuple(elts=[Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='lstrip', ctx=Load()), args=[Constant(value='.')], keywords=[]), Name(id='value', ctx=Load())], ctx=Load())))], orelse=[])], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='parsers', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Metadata item name to parser function mapping.')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[BinOp(left=Constant(value='%s must provide .parsers property'), op=Mod(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()))], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='__setitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='option_name'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='target_obj', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='target_obj', ctx=Load())), Assign(targets=[Name(id='option_name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='aliases', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='option_name', ctx=Load()), Name(id='option_name', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='current_value', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='target_obj', ctx=Load()), Name(id='option_name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='KeyError', ctx=Load()), args=[Name(id='option_name', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[]), If(test=Name(id='current_value', ctx=Load()), body=[Return()], orelse=[]), Try(body=[Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parsers', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='option_name', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='x', ctx=Load()))], keywords=[]), args=[Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=BinOp(left=Tuple(elts=[Name(id='Exception', ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='ignore_option_errors', ctx=Load())), body=[Return()])], orelse=[], finalbody=[]), Assign(targets=[Name(id='simple_setter', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Attribute(value=Name(id='target_obj', ctx=Load()), attr='__setattr__', ctx=Load()), Name(id='option_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='setter', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='target_obj', ctx=Load()), BinOp(left=Constant(value='set_%s'), op=Mod(), right=Name(id='option_name', ctx=Load())), Name(id='simple_setter', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setter', ctx=Load()), args=[Name(id='parsed', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='set_options', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='option_name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_parse_list', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='value'), arg(arg='separator')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=',')]), body=[Expr(value=Constant(value='Represents value as a list.\n\n        Value is split either by separator (defaults to comma) or by lines.\n\n        :param value:\n        :param separator: List items separator character.\n        :rtype: list\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Return(value=Name(id='value', ctx=Load()))], orelse=[]), If(test=Compare(left=Constant(value='\n'), ops=[In()], comparators=[Name(id='value', ctx=Load())]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='separator', ctx=Load())], keywords=[]))]), Return(value=ListComp(elt=Call(func=Attribute(value=Name(id='chunk', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='chunk', ctx=Store()), iter=Name(id='value', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='chunk', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], is_async=0)]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_parse_dict', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Represents value as a dict.\n\n        :param value:\n        :rtype: dict\n        ')), Assign(targets=[Name(id='separator', ctx=Store())], value=Constant(value='=')), Assign(targets=[Name(id='result', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_parse_list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='sep', ctx=Store()), Name(id='val', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='partition', ctx=Load()), args=[Name(id='separator', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='sep', ctx=Load()), ops=[NotEq()], comparators=[Name(id='separator', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='OptionError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Unable to parse option value to dict: '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='result', ctx=Load()), slice=Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), ctx=Store())], value=Call(func=Attribute(value=Name(id='val', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_parse_bool', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Represents value as boolean.\n\n        :param value:\n        :rtype: bool\n        ')), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Return(value=Compare(left=Name(id='value', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='1'), Constant(value='true'), Constant(value='yes')], ctx=Load())]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_exclude_files_parser', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns a parser function to make sure field inputs\n        are not files.\n\n        Parses a value after getting the key so error messages are\n        more informative.\n\n        :param key:\n        :rtype: callable\n        ')), FunctionDef(name='parser', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='exclude_directive', ctx=Store())], value=Constant(value='file:')), If(test=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='exclude_directive', ctx=Load())], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Only strings are accepted for the {0} field, files are not accepted'), attr='format', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='value', ctx=Load()))], decorator_list=[]), Return(value=Name(id='parser', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_parse_file', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value'), arg(arg='root_dir', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Represents value as a string, allowing including text\n        from nearest files using `file:` directive.\n\n        Directive is sandboxed and won't reach anything outside\n        directory with setup.py.\n\n        Examples:\n            file: README.rst, CHANGELOG.md, src/file.txt\n\n        :param str value:\n        :rtype: str\n        ")), Assign(targets=[Name(id='include_directive', ctx=Store())], value=Constant(value='file:')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Return(value=Name(id='value', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='include_directive', ctx=Load())], keywords=[])), body=[Return(value=Name(id='value', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='spec', ctx=Store())], value=Subscript(value=Name(id='value', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='include_directive', ctx=Load())], keywords=[])), ctx=Load())), Assign(targets=[Name(id='filepaths', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='path', ctx=Store()), iter=Call(func=Attribute(value=Name(id='spec', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',')], keywords=[]), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_referenced_files', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='filepaths', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='expand', ctx=Load()), attr='read_files', ctx=Load()), args=[Name(id='filepaths', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_parse_attr', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value'), arg(arg='package_dir'), arg(arg='root_dir', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Represents value as a module attribute.\n\n        Examples:\n            attr: package.attr\n            attr: package.module.attr\n\n        :param str value:\n        :rtype: str\n        ')), Assign(targets=[Name(id='attr_directive', ctx=Store())], value=Constant(value='attr:')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='attr_directive', ctx=Load())], keywords=[])), body=[Return(value=Name(id='value', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='attr_desc', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='replace', ctx=Load()), args=[Name(id='attr_directive', ctx=Load()), Constant(value='')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='package_dir', ctx=Load()), attr='update', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ensure_discovered', ctx=Load()), attr='package_dir', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='expand', ctx=Load()), attr='read_attr', ctx=Load()), args=[Name(id='attr_desc', ctx=Load()), Name(id='package_dir', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_get_parser_compound', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='parse_methods'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns parser function to represents value as a list.\n\n        Parses a value applying given methods one after another.\n\n        :param parse_methods:\n        :rtype: callable\n        ')), FunctionDef(name='parse', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parsed', ctx=Store())], value=Name(id='value', ctx=Load())), For(target=Name(id='method', ctx=Store()), iter=Name(id='parse_methods', ctx=Load()), body=[Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Name(id='method', ctx=Load()), args=[Name(id='parsed', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='parsed', ctx=Load()))], decorator_list=[]), Return(value=Name(id='parse', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_parse_section_to_dict_with_key', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='section_options'), arg(arg='values_parser')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses section options into a dictionary.\n\n        Applies a given parser to each option in a section.\n\n        :param dict section_options:\n        :param callable values_parser: function with 2 args corresponding to key, value\n        :rtype: dict\n        ')), Assign(targets=[Name(id='value', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Tuple(elts=[Name(id='_', ctx=Store()), Name(id='val', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='section_options', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='value', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Call(func=Name(id='values_parser', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='val', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='value', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_parse_section_to_dict', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='section_options'), arg(arg='values_parser')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Parses section options into a dictionary.\n\n        Optionally applies a given parser to each value.\n\n        :param dict section_options:\n        :param callable values_parser: function with 1 arg corresponding to option value\n        :rtype: dict\n        ')), Assign(targets=[Name(id='parser', ctx=Store())], value=IfExp(test=Name(id='values_parser', ctx=Load()), body=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='_'), arg(arg='v')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='values_parser', ctx=Load()), args=[Name(id='v', ctx=Load())], keywords=[])), orelse=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='_'), arg(arg='v')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='v', ctx=Load())))), Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_parse_section_to_dict_with_key', ctx=Load()), args=[Name(id='section_options', ctx=Load()), Name(id='parser', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='parse_section', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='section_options')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses configuration file section.\n\n        :param dict section_options:\n        ')), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Tuple(elts=[Name(id='_', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='section_options', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='suppress', ctx=Load()), args=[Name(id='KeyError', ctx=Load())], keywords=[]))], body=[Assign(targets=[Subscript(value=Name(id='self', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load()))])], orelse=[])], decorator_list=[]), FunctionDef(name='parse', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses configuration file items from one\n        or more related sections.\n\n        ')), For(target=Tuple(elts=[Name(id='section_name', ctx=Store()), Name(id='section_options', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='sections', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='method_postfix', ctx=Store())], value=Constant(value='')), If(test=Name(id='section_name', ctx=Load()), body=[Assign(targets=[Name(id='method_postfix', ctx=Store())], value=BinOp(left=Constant(value='_%s'), op=Mod(), right=Name(id='section_name', ctx=Load())))], orelse=[]), AnnAssign(target=Name(id='section_parser_method', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Callable', ctx=Load()), ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Call(func=Attribute(value=BinOp(left=Constant(value='parse_section%s'), op=Mod(), right=Name(id='method_postfix', ctx=Load())), attr='replace', ctx=Load()), args=[Constant(value='.'), Constant(value='__')], keywords=[]), Constant(value=None)], keywords=[]), simple=1), If(test=Compare(left=Name(id='section_parser_method', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='OptionError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Unsupported distribution option section: ['), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='section_prefix', ctx=Load()), conversion=-1), Constant(value='.'), FormattedValue(value=Name(id='section_name', ctx=Load()), conversion=-1), Constant(value=']')])], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='section_parser_method', ctx=Load()), args=[Name(id='section_options', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_deprecated_config_handler', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='func'), arg(arg='msg')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Expr(value=Constant(value='this function will wrap around parameters that are deprecated\n\n        :param msg: deprecation message\n        :param func: function to be wrapped around\n        ')), FunctionDef(name='config_handler', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='kw', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='stacklevel'), Constant(value=2)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='_DeprecatedConfig', ctx=Load()), attr='emit', ctx=Load()), args=[Constant(value='Deprecated config in `setup.cfg`'), Name(id='msg', ctx=Load())], keywords=[keyword(value=Name(id='kw', ctx=Load()))])), Return(value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[Call(func=Name(id='wraps', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])]), Return(value=Name(id='config_handler', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='ConfigMetadataHandler', bases=[Subscript(value=Name(id='ConfigHandler', ctx=Load()), slice=Constant(value='DistributionMetadata'), ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='section_prefix', ctx=Store())], value=Constant(value='metadata')), Assign(targets=[Name(id='aliases', ctx=Store())], value=Dict(keys=[Constant(value='home_page'), Constant(value='summary'), Constant(value='classifier'), Constant(value='platform')], values=[Constant(value='url'), Constant(value='description'), Constant(value='classifiers'), Constant(value='platforms')])), Assign(targets=[Name(id='strict_mode', ctx=Store())], value=Constant(value=False)), Expr(value=Constant(value='We need to keep it loose, to be partially compatible with\n    `pbr` and `d2to1` packages which also uses `metadata` section.\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='target_obj', annotation=Constant(value='DistributionMetadata')), arg(arg='options', annotation=Name(id='AllCommandOptions', ctx=Load())), arg(arg='ignore_option_errors', annotation=Name(id='bool', ctx=Load())), arg(arg='ensure_discovered', annotation=Attribute(value=Name(id='expand', ctx=Load()), attr='EnsurePackagesDiscovered', ctx=Load())), arg(arg='package_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='dict', ctx=Load()), ctx=Load())), arg(arg='root_dir', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Attribute(value=Name(id='os', ctx=Load()), attr='curdir', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='target_obj', ctx=Load()), Name(id='options', ctx=Load()), Name(id='ignore_option_errors', ctx=Load()), Name(id='ensure_discovered', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='package_dir', ctx=Store())], value=Name(id='package_dir', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='root_dir', ctx=Store())], value=Name(id='root_dir', ctx=Load()))], decorator_list=[]), FunctionDef(name='parsers', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Metadata item name to parser function mapping.')), Assign(targets=[Name(id='parse_list', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_list', ctx=Load())), Assign(targets=[Name(id='parse_file', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_parse_file', ctx=Load())], keywords=[keyword(arg='root_dir', value=Attribute(value=Name(id='self', ctx=Load()), attr='root_dir', ctx=Load()))])), Assign(targets=[Name(id='parse_dict', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_dict', ctx=Load())), Assign(targets=[Name(id='exclude_files_parser', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_exclude_files_parser', ctx=Load())), Return(value=Dict(keys=[Constant(value='platforms'), Constant(value='keywords'), Constant(value='provides'), Constant(value='requires'), Constant(value='obsoletes'), Constant(value='classifiers'), Constant(value='license'), Constant(value='license_file'), Constant(value='license_files'), Constant(value='description'), Constant(value='long_description'), Constant(value='version'), Constant(value='project_urls')], values=[Name(id='parse_list', ctx=Load()), Name(id='parse_list', ctx=Load()), Name(id='parse_list', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_deprecated_config_handler', ctx=Load()), args=[Name(id='parse_list', ctx=Load()), Constant(value='The requires parameter is deprecated, please use install_requires for runtime dependencies.')], keywords=[keyword(arg='due_date', value=Tuple(elts=[Constant(value=2023), Constant(value=10), Constant(value=30)], ctx=Load()))]), Name(id='parse_list', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_parser_compound', ctx=Load()), args=[Name(id='parse_file', ctx=Load()), Name(id='parse_list', ctx=Load())], keywords=[]), Call(func=Name(id='exclude_files_parser', ctx=Load()), args=[Constant(value='license')], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_deprecated_config_handler', ctx=Load()), args=[Call(func=Name(id='exclude_files_parser', ctx=Load()), args=[Constant(value='license_file')], keywords=[]), Constant(value='The license_file parameter is deprecated, use license_files instead.')], keywords=[keyword(arg='due_date', value=Tuple(elts=[Constant(value=2023), Constant(value=10), Constant(value=30)], ctx=Load()))]), Name(id='parse_list', ctx=Load()), Name(id='parse_file', ctx=Load()), Name(id='parse_file', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_parse_version', ctx=Load()), Name(id='parse_dict', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_parse_version', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses `version` option value.\n\n        :param value:\n        :rtype: str\n\n        ')), Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_file', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='root_dir', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='version', ctx=Load()), ops=[NotEq()], comparators=[Name(id='value', ctx=Load())]), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Attribute(value=Name(id='version', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Try(body=[Expr(value=Call(func=Name(id='Version', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='InvalidVersion', ctx=Load()), body=[Raise(exc=Call(func=Name(id='OptionError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Version loaded from '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1), Constant(value=' does not comply with PEP 440: '), FormattedValue(value=Name(id='version', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Name(id='version', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='expand', ctx=Load()), attr='version', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_attr', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='package_dir', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='root_dir', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='ConfigOptionsHandler', bases=[Subscript(value=Name(id='ConfigHandler', ctx=Load()), slice=Constant(value='Distribution'), ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='section_prefix', ctx=Store())], value=Constant(value='options')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='target_obj', annotation=Constant(value='Distribution')), arg(arg='options', annotation=Name(id='AllCommandOptions', ctx=Load())), arg(arg='ignore_option_errors', annotation=Name(id='bool', ctx=Load())), arg(arg='ensure_discovered', annotation=Attribute(value=Name(id='expand', ctx=Load()), attr='EnsurePackagesDiscovered', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='target_obj', ctx=Load()), Name(id='options', ctx=Load()), Name(id='ignore_option_errors', ctx=Load()), Name(id='ensure_discovered', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='root_dir', ctx=Store())], value=Attribute(value=Name(id='target_obj', ctx=Load()), attr='src_root', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='package_dir', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0)], decorator_list=[]), FunctionDef(name='_parse_list_semicolon', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_parse_list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[keyword(arg='separator', value=Constant(value=';'))]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_parse_file_in_root', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_file', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[keyword(arg='root_dir', value=Attribute(value=Name(id='self', ctx=Load()), attr='root_dir', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_parse_requirements_list', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='label', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_list_semicolon', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_file_in_root', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='_warn_accidental_env_marker_misconfig', ctx=Load()), args=[Name(id='label', ctx=Load()), Name(id='value', ctx=Load()), Name(id='parsed', ctx=Load())], keywords=[])), Return(value=ListComp(elt=Name(id='line', ctx=Load()), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Name(id='parsed', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='#')], keywords=[]))], is_async=0)]))], decorator_list=[]), FunctionDef(name='parsers', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Metadata item name to parser function mapping.')), Assign(targets=[Name(id='parse_list', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_list', ctx=Load())), Assign(targets=[Name(id='parse_bool', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_bool', ctx=Load())), Assign(targets=[Name(id='parse_dict', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_dict', ctx=Load())), Assign(targets=[Name(id='parse_cmdclass', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_cmdclass', ctx=Load())), Return(value=Dict(keys=[Constant(value='zip_safe'), Constant(value='include_package_data'), Constant(value='package_dir'), Constant(value='scripts'), Constant(value='eager_resources'), Constant(value='dependency_links'), Constant(value='namespace_packages'), Constant(value='install_requires'), Constant(value='setup_requires'), Constant(value='tests_require'), Constant(value='packages'), Constant(value='entry_points'), Constant(value='py_modules'), Constant(value='python_requires'), Constant(value='cmdclass')], values=[Name(id='parse_bool', ctx=Load()), Name(id='parse_bool', ctx=Load()), Name(id='parse_dict', ctx=Load()), Name(id='parse_list', ctx=Load()), Name(id='parse_list', ctx=Load()), Name(id='parse_list', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_deprecated_config_handler', ctx=Load()), args=[Name(id='parse_list', ctx=Load()), Constant(value='The namespace_packages parameter is deprecated, consider using implicit namespaces instead (PEP 420).')], keywords=[]), Call(func=Name(id='partial', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_parse_requirements_list', ctx=Load()), Constant(value='install_requires')], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='_parse_list_semicolon', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_parse_list_semicolon', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_parse_packages', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_parse_file_in_root', ctx=Load()), Name(id='parse_list', ctx=Load()), Name(id='SpecifierSet', ctx=Load()), Name(id='parse_cmdclass', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_parse_cmdclass', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='package_dir', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ensure_discovered', ctx=Load()), attr='package_dir', ctx=Load())), Return(value=Call(func=Attribute(value=Name(id='expand', ctx=Load()), attr='cmdclass', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_dict', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), Name(id='package_dir', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='root_dir', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_parse_packages', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses `packages` option value.\n\n        :param value:\n        :rtype: list\n        ')), Assign(targets=[Name(id='find_directives', ctx=Store())], value=List(elts=[Constant(value='find:'), Constant(value='find_namespace:')], ctx=Load())), Assign(targets=[Name(id='trimmed_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='trimmed_value', ctx=Load()), ops=[NotIn()], comparators=[Name(id='find_directives', ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='find_kwargs', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parse_section_packages__find', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='sections', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='packages.find'), Dict(keys=[], values=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='find_kwargs', ctx=Load()), attr='update', ctx=Load()), args=[], keywords=[keyword(arg='namespaces', value=Compare(left=Name(id='trimmed_value', ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='find_directives', ctx=Load()), slice=Constant(value=1), ctx=Load())])), keyword(arg='root_dir', value=Attribute(value=Name(id='self', ctx=Load()), attr='root_dir', ctx=Load())), keyword(arg='fill_package_dir', value=Attribute(value=Name(id='self', ctx=Load()), attr='package_dir', ctx=Load()))])), Return(value=Call(func=Attribute(value=Name(id='expand', ctx=Load()), attr='find_packages', ctx=Load()), args=[], keywords=[keyword(value=Name(id='find_kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='parse_section_packages__find', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='section_options')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses `packages.find` configuration file section.\n\n        To be used in conjunction with _parse_packages().\n\n        :param dict section_options:\n        ')), Assign(targets=[Name(id='section_data', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_section_to_dict', ctx=Load()), args=[Name(id='section_options', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_parse_list', ctx=Load())], keywords=[])), Assign(targets=[Name(id='valid_keys', ctx=Store())], value=List(elts=[Constant(value='where'), Constant(value='include'), Constant(value='exclude')], ctx=Load())), Assign(targets=[Name(id='find_kwargs', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[ListComp(elt=Tuple(elts=[Name(id='k', ctx=Load()), Name(id='v', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='section_data', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[BoolOp(op=And(), values=[Compare(left=Name(id='k', ctx=Load()), ops=[In()], comparators=[Name(id='valid_keys', ctx=Load())]), Name(id='v', ctx=Load())])], is_async=0)])], keywords=[])), Assign(targets=[Name(id='where', ctx=Store())], value=Call(func=Attribute(value=Name(id='find_kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='where')], keywords=[])), If(test=Compare(left=Name(id='where', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='find_kwargs', ctx=Load()), slice=Constant(value='where'), ctx=Store())], value=Subscript(value=Name(id='where', ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[]), Return(value=Name(id='find_kwargs', ctx=Load()))], decorator_list=[]), FunctionDef(name='parse_section_entry_points', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='section_options')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses `entry_points` configuration file section.\n\n        :param dict section_options:\n        ')), Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_section_to_dict', ctx=Load()), args=[Name(id='section_options', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_parse_list', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='self', ctx=Load()), slice=Constant(value='entry_points'), ctx=Store())], value=Name(id='parsed', ctx=Load()))], decorator_list=[]), FunctionDef(name='_parse_package_data', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='section_options')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='package_data', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_section_to_dict', ctx=Load()), args=[Name(id='section_options', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_parse_list', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='expand', ctx=Load()), attr='canonic_package_data', ctx=Load()), args=[Name(id='package_data', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='parse_section_package_data', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='section_options')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses `package_data` configuration file section.\n\n        :param dict section_options:\n        ')), Assign(targets=[Subscript(value=Name(id='self', ctx=Load()), slice=Constant(value='package_data'), ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_package_data', ctx=Load()), args=[Name(id='section_options', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='parse_section_exclude_package_data', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='section_options')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses `exclude_package_data` configuration file section.\n\n        :param dict section_options:\n        ')), Assign(targets=[Subscript(value=Name(id='self', ctx=Load()), slice=Constant(value='exclude_package_data'), ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_package_data', ctx=Load()), args=[Name(id='section_options', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='parse_section_extras_require', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='section_options')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses `extras_require` configuration file section.\n\n        :param dict section_options:\n        ')), Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_section_to_dict_with_key', ctx=Load()), args=[Name(id='section_options', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='k'), arg(arg='v')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_requirements_list', ctx=Load()), args=[JoinedStr(values=[Constant(value='extras_require['), FormattedValue(value=Name(id='k', ctx=Load()), conversion=-1), Constant(value=']')]), Name(id='v', ctx=Load())], keywords=[]))], keywords=[])), Assign(targets=[Subscript(value=Name(id='self', ctx=Load()), slice=Constant(value='extras_require'), ctx=Store())], value=Name(id='parsed', ctx=Load()))], decorator_list=[]), FunctionDef(name='parse_section_data_files', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='section_options')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parses `data_files` configuration file section.\n\n        :param dict section_options:\n        ')), Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse_section_to_dict', ctx=Load()), args=[Name(id='section_options', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_parse_list', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='self', ctx=Load()), slice=Constant(value='data_files'), ctx=Store())], value=Call(func=Attribute(value=Name(id='expand', ctx=Load()), attr='canonic_data_files', ctx=Load()), args=[Name(id='parsed', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='root_dir', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='_AmbiguousMarker', bases=[Name(id='SetuptoolsDeprecationWarning', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='_SUMMARY', ctx=Store())], value=Constant(value='Ambiguous requirement marker.')), Assign(targets=[Name(id='_DETAILS', ctx=Store())], value=Constant(value='\n    One of the parsed requirements in `{field}` looks like a valid environment marker:\n\n        {req!r}\n\n    Please make sure that the configuration file is correct.\n    You can use dangling lines to avoid this problem.\n    ')), Assign(targets=[Name(id='_SEE_DOCS', ctx=Store())], value=Constant(value='userguide/declarative_config.html#opt-2')), FunctionDef(name='message', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Assign(targets=[Name(id='docs', ctx=Store())], value=JoinedStr(values=[Constant(value='https://setuptools.pypa.io/en/latest/'), FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='_SEE_DOCS', ctx=Load()), conversion=-1)])), Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_format', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='_SUMMARY', ctx=Load()), Attribute(value=Name(id='cls', ctx=Load()), attr='_DETAILS', ctx=Load())], keywords=[keyword(arg='see_url', value=Name(id='docs', ctx=Load())), keyword(arg='format_args', value=Name(id='kw', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())])], decorator_list=[]), ClassDef(name='_DeprecatedConfig', bases=[Name(id='SetuptoolsDeprecationWarning', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='_SEE_DOCS', ctx=Store())], value=Constant(value='userguide/declarative_config.html'))], decorator_list=[])], type_ignores=[])