Module(body=[Assign(targets=[Name(id='VERSION', ctx=Store())], value=Constant(value='2.16.3')), Import(names=[alias(name='re')]), ImportFrom(module='fastjsonschema_exceptions', names=[alias(name='JsonSchemaValueException')], level=1), Assign(targets=[Name(id='REGEX_PATTERNS', ctx=Store())], value=Dict(keys=[Constant(value='^.*$'), Constant(value='.+'), Constant(value='^.+$'), Constant(value='idn-email_re_pattern')], values=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^.*$')], keywords=[]), Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='.+')], keywords=[]), Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^.+$')], keywords=[]), Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^[^@]+@[^@]+\\.[^@]+\\Z')], keywords=[])])), Assign(targets=[Name(id='NoneType', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Constant(value=None)], keywords=[])), FunctionDef(name='validate', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[Expr(value=Call(func=Name(id='validate_https___packaging_python_org_en_latest_specifications_declaring_build_dependencies', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value=''))], keywords=[])), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___packaging_python_org_en_latest_specifications_declaring_build_dependencies', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be object'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='project')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://packaging.python.org/en/latest/specifications/declaring-build-dependencies/'), Constant(value='Data structure for ``pyproject.toml`` files'), List(elts=[Constant(value='File format containing build-time configurations for the Python ecosystem. '), Constant(value=':pep:`517` initially defined a build-system independent format for source trees'), Constant(value='which was complemented by :pep:`518` to provide a way of specifying dependencies '), Constant(value='for building Python projects.'), Constant(value='Please notice the ``project`` table (as initially defined in  :pep:`621`) is not included'), Constant(value='in this schema and should be considered separately.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='build-system'), Constant(value='project'), Constant(value='tool')], values=[Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='object'), Constant(value='Table used to store build-related data'), Constant(value=False), Dict(keys=[Constant(value='requires'), Constant(value='build-backend'), Constant(value='backend-path')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of dependencies in the :pep:`508` format required to execute the build'), Constant(value='system. Please notice that the resulting dependency graph'), Constant(value='**MUST NOT contain cycles**')], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='Python object that will be used to perform the build according to :pep:`517`'), Constant(value='pep517-backend-reference')]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of directories to be prepended to ``sys.path`` when loading the'), Constant(value='back-end, and running its hooks')], ctx=Load()), Dict(keys=[Constant(value='type'), Constant(value='$comment')], values=[Constant(value='string'), Constant(value='Should be a path (TODO: enforce it with format?)')])])]), List(elts=[Constant(value='requires')], ctx=Load())]), Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='required'), Constant(value='additionalProperties'), Constant(value='if'), Constant(value='then'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://packaging.python.org/en/latest/specifications/declaring-project-metadata/'), Constant(value='Package metadata stored in the ``project`` table'), List(elts=[Constant(value='Data structure for the **project** table inside ``pyproject.toml``'), Constant(value='(as initially defined in :pep:`621`)')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='name'), Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The name (primary identifier) of the project. MUST be statically defined.'), Constant(value='pep508-identifier')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The version of the project as supported by :pep:`440`.'), Constant(value='pep440')]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The `summary description of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#summary>`_')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='`Full/detailed description of the project in the form of a README'), Constant(value='<https://peps.python.org/pep-0621/#readme>`_'), Constant(value="with meaning similar to the one defined in `core metadata's Description"), Constant(value='<https://packaging.python.org/specifications/core-metadata/#description>`_')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file (UTF-8) containing the full description'), Constant(value='of the project. If the file path ends in case-insensitive ``.md`` or'), Constant(value='``.rst`` suffixes, then the content-type is respectively'), Constant(value='``text/markdown`` or ``text/x-rst``')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='allOf')], values=[Constant(value='object'), List(elts=[Dict(keys=[Constant(value='anyOf')], values=[List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])]), List(elts=[Constant(value='content-type')], ctx=Load())])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='$$description')], values=[Constant(value='string'), Constant(value='pep508-versionspec'), List(elts=[Constant(value='`The Python version requirements of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.')], ctx=Load())]), Dict(keys=[Constant(value='description'), Constant(value='oneOf')], values=[Constant(value='`Project license <https://peps.python.org/pep-0621/#license>`_.'), List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to the file (UTF-8) which contains the license for the'), Constant(value='project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The license of the project whose meaning is that of the'), Constant(value='`License field from the core metadata'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#license>`_.')], ctx=Load())])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/author')]), List(elts=[Constant(value="The people or organizations considered to be the 'authors' of the project."), Constant(value='The exact meaning is open to interpretation (e.g. original or primary authors,'), Constant(value='current maintainers, or owners of the package).')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/author')]), List(elts=[Constant(value="The people or organizations considered to be the 'maintainers' of the project."), Constant(value='Similarly to ``authors``, the exact meaning is open to interpretation.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='List of keywords to assist searching for the distribution in a larger catalog.')]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='trove-classifier'), Constant(value='`PyPI classifier <https://pypi.org/classifiers/>`_.')]), List(elts=[Constant(value='`Trove classifiers <https://pypi.org/classifiers/>`_'), Constant(value='which apply to the project.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='URLs associated with the project in the form ``label => value``.'), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])])]), Dict(keys=[Constant(value='$ref'), Constant(value='$$description')], values=[Constant(value='#/definitions/entry-point-group'), List(elts=[Constant(value='Instruct the installer to create command-line wrappers for the given'), Constant(value='`entry points <https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load())]), Dict(keys=[Constant(value='$ref'), Constant(value='$$description')], values=[Constant(value='#/definitions/entry-point-group'), List(elts=[Constant(value='Instruct the installer to create GUI wrappers for the given'), Constant(value='`entry points <https://packaging.python.org/specifications/entry-points/>`_.'), Constant(value='The difference between ``scripts`` and ``gui-scripts`` is only relevant in'), Constant(value='Windows.')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Instruct the installer to expose the given modules/functions via'), Constant(value='``entry-point`` discovery mechanism (useful for plugins).'), Constant(value='More information available in the `Python packaging guide'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-group')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/entry-point-group')])])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='items')], values=[Constant(value='array'), Constant(value='Project (mandatory) dependencies.'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/dependency')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='Optional dependency for the project'), Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/dependency')])])])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Specifies which fields are intentionally unspecified and expected to be'), Constant(value='dynamically provided by build tools')], ctx=Load()), Dict(keys=[Constant(value='enum')], values=[List(elts=[Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies')], ctx=Load())])])]), List(elts=[Constant(value='name')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='not'), Constant(value='$$comment')], values=[Dict(keys=[Constant(value='required'), Constant(value='properties')], values=[List(elts=[Constant(value='dynamic')], ctx=Load()), Dict(keys=[Constant(value='dynamic')], values=[Dict(keys=[Constant(value='contains'), Constant(value='$$description')], values=[Dict(keys=[Constant(value='const')], values=[Constant(value='version')]), List(elts=[Constant(value='version is listed in ``dynamic``')], ctx=Load())])])]), List(elts=[Constant(value='According to :pep:`621`:'), Constant(value='    If the core metadata specification lists a field as "Required", then'), Constant(value='    the metadata MUST specify the field statically or list it in dynamic'), Constant(value='In turn, `core metadata`_ defines:'), Constant(value='    The required fields are: Metadata-Version, Name, Version.'), Constant(value='    All the other fields are optional.'), Constant(value='Since ``Metadata-Version`` is defined by the build back-end, ``name`` and'), Constant(value='``version`` are the only mandatory information in ``pyproject.toml``.'), Constant(value='.. _core metadata: https://packaging.python.org/specifications/core-metadata/')], ctx=Load())]), Dict(keys=[Constant(value='required'), Constant(value='$$description')], values=[List(elts=[Constant(value='version')], ctx=Load()), List(elts=[Constant(value='version should be statically defined in the ``version`` field')], ctx=Load())]), Dict(keys=[Constant(value='author'), Constant(value='entry-point-group'), Constant(value='dependency')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])]), Dict(keys=[Constant(value='type'), Constant(value='properties')], values=[Constant(value='object'), Dict(keys=[Constant(value='distutils'), Constant(value='setuptools')], values=[Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='patternProperties'), Constant(value='$comment')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://docs.python.org/3/install/'), Constant(value='``tool.distutils`` table'), List(elts=[Constant(value='Originally, ``distutils`` allowed developers to configure arguments for'), Constant(value='``setup.py`` scripts via `distutils configuration files'), Constant(value='<https://docs.python.org/3/install/#distutils-configuration-files>`_.'), Constant(value='``tool.distutils`` subtables could be used with the same purpose'), Constant(value='(NOT CURRENTLY IMPLEMENTED).')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='global')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='object'), Constant(value='Global options applied to all ``distutils`` commands')])]), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='object')])]), Constant(value='TODO: Is there a practical way of making this schema more specific?')]), Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://setuptools.pypa.io/en/latest/references/keywords.html'), Constant(value='``tool.setuptools`` table'), List(elts=[Constant(value='Please notice for the time being the ``setuptools`` project does not specify'), Constant(value='a way of configuring builds via ``pyproject.toml``.'), Constant(value='Therefore this schema should be taken just as a *"thought experiment"* on how'), Constant(value='this *might be done*, by following the principles established in'), Constant(value='`ini2toml <https://ini2toml.readthedocs.io/en/latest/setuptools_pep621.html>`_.'), Constant(value='It considers only ``setuptools`` `parameters'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/declarative_config.html>`_'), Constant(value='that can currently be configured via ``setup.cfg`` and are not covered by :pep:`621`'), Constant(value='but intentionally excludes ``dependency_links`` and ``setup_requires``.'), Constant(value='NOTE: ``scripts`` was renamed to ``script-files`` to avoid confusion with'), Constant(value='entry-point based scripts (defined in :pep:`621`).')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='platforms'), Constant(value='provides'), Constant(value='obsoletes'), Constant(value='zip-safe'), Constant(value='script-files'), Constant(value='eager-resources'), Constant(value='packages'), Constant(value='package-dir'), Constant(value='package-data'), Constant(value='include-package-data'), Constant(value='exclude-package-data'), Constant(value='namespace-packages'), Constant(value='py-modules'), Constant(value='data-files'), Constant(value='cmdclass'), Constant(value='license-files'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Package and virtual package names contained within this package'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Packages which this package renders obsolete'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])]), Dict(keys=[Constant(value='description'), Constant(value='type')], values=[Constant(value='Whether the project can be safely installed and run from a zip file.'), Constant(value='boolean')]), Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Legacy way of defining scripts (entry-points are preferred).'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='TODO: is this field deprecated/should be removed?')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Resources that should be extracted together, if any of them is needed,'), Constant(value='or if any C extensions included in the project are imported.')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='Packages that should be included in the distribution.'), Constant(value='It can be given either as a list of package identifiers'), Constant(value='or as a ``dict``-like structure with a single key ``find``'), Constant(value='which corresponds to a dynamic call to'), Constant(value='``setuptools.config.expand.find_packages`` function.'), Constant(value='The ``find`` key is associated with a nested ``dict``-like structure that can'), Constant(value='contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,'), Constant(value='mimicking the keyword arguments of the associated function.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Array of Python package identifiers'), Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/package-name')])]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/find-directive')])], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value=':class:`dict`-like structure mapping from package names to directories where their'), Constant(value='code can be found.'), Constant(value='The empty string (as key) means that all packages are contained inside'), Constant(value='the given directory will be included in the distribution.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='const')], values=[Constant(value='')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/package-name')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns.'), Constant(value='Usually this option is not needed when using ``include-package-data = true``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type')], values=[List(elts=[Constant(value='Automatically include any data files inside the package directories'), Constant(value='that are specified by ``MANIFEST.in``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='boolean')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns that should be excluded'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='https://setuptools.pypa.io/en/latest/userguide/package_discovery.html')]), Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Modules that setuptools will manipulate'), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='TODO: clarify the relationship with ``packages``')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='**DEPRECATED**: dict-like structure where each key represents a directory and'), Constant(value='the value is a list of glob patterns that should be installed in them.'), Constant(value="Please notice this don't work with wheels. See `data files support"), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping of distutils-style command names to ``setuptools.Command`` subclasses'), Constant(value='which in turn should be represented by strings with a qualified class name'), Constant(value='(i.e., "dotted" form with module), e.g.::\n\n'), Constant(value='    cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n'), Constant(value='The command class should be a directly defined at the top-level of the'), Constant(value='containing module (no class nesting).')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-qualified-identifier')])])]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), List(elts=[Constant(value='PROVISIONAL: List of glob patterns for all license files being distributed.'), Constant(value='(might become standard with PEP 639).'), Constant(value="By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``")], ctx=Load()), Constant(value='TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), Constant(value='Instructions for loading :pep:`621`-related metadata dynamically'), Constant(value=False), Dict(keys=[Constant(value='version'), Constant(value='classifiers'), Constant(value='description'), Constant(value='dependencies'), Constant(value='entry-points'), Constant(value='optional-dependencies'), Constant(value='readme')], values=[Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='A version dynamically loaded via either the ``attr:`` or ``file:``'), Constant(value='directives. Please make sure the given file or attribute respects :pep:`440`.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/attr-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')])], ctx=Load())]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='type'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')]), Constant(value=False), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')])])]), Dict(keys=[Constant(value='anyOf'), Constant(value='required')], values=[List(elts=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='properties')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])], ctx=Load()), List(elts=[Constant(value='file')], ctx=Load())])])])]), Dict(keys=[Constant(value='package-name'), Constant(value='file-directive'), Constant(value='attr-directive'), Constant(value='find-directive')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/find-directive'), Constant(value="'find:' directive"), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='find')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])])])])])])])]), Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='required'), Constant(value='additionalProperties'), Constant(value='if'), Constant(value='then'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://packaging.python.org/en/latest/specifications/declaring-project-metadata/'), Constant(value='Package metadata stored in the ``project`` table'), List(elts=[Constant(value='Data structure for the **project** table inside ``pyproject.toml``'), Constant(value='(as initially defined in :pep:`621`)')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='name'), Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The name (primary identifier) of the project. MUST be statically defined.'), Constant(value='pep508-identifier')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The version of the project as supported by :pep:`440`.'), Constant(value='pep440')]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The `summary description of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#summary>`_')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='`Full/detailed description of the project in the form of a README'), Constant(value='<https://peps.python.org/pep-0621/#readme>`_'), Constant(value="with meaning similar to the one defined in `core metadata's Description"), Constant(value='<https://packaging.python.org/specifications/core-metadata/#description>`_')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file (UTF-8) containing the full description'), Constant(value='of the project. If the file path ends in case-insensitive ``.md`` or'), Constant(value='``.rst`` suffixes, then the content-type is respectively'), Constant(value='``text/markdown`` or ``text/x-rst``')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='allOf')], values=[Constant(value='object'), List(elts=[Dict(keys=[Constant(value='anyOf')], values=[List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])]), List(elts=[Constant(value='content-type')], ctx=Load())])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='$$description')], values=[Constant(value='string'), Constant(value='pep508-versionspec'), List(elts=[Constant(value='`The Python version requirements of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.')], ctx=Load())]), Dict(keys=[Constant(value='description'), Constant(value='oneOf')], values=[Constant(value='`Project license <https://peps.python.org/pep-0621/#license>`_.'), List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to the file (UTF-8) which contains the license for the'), Constant(value='project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The license of the project whose meaning is that of the'), Constant(value='`License field from the core metadata'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#license>`_.')], ctx=Load())])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/author')]), List(elts=[Constant(value="The people or organizations considered to be the 'authors' of the project."), Constant(value='The exact meaning is open to interpretation (e.g. original or primary authors,'), Constant(value='current maintainers, or owners of the package).')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/author')]), List(elts=[Constant(value="The people or organizations considered to be the 'maintainers' of the project."), Constant(value='Similarly to ``authors``, the exact meaning is open to interpretation.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='List of keywords to assist searching for the distribution in a larger catalog.')]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='trove-classifier'), Constant(value='`PyPI classifier <https://pypi.org/classifiers/>`_.')]), List(elts=[Constant(value='`Trove classifiers <https://pypi.org/classifiers/>`_'), Constant(value='which apply to the project.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='URLs associated with the project in the form ``label => value``.'), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])])]), Dict(keys=[Constant(value='$ref'), Constant(value='$$description')], values=[Constant(value='#/definitions/entry-point-group'), List(elts=[Constant(value='Instruct the installer to create command-line wrappers for the given'), Constant(value='`entry points <https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load())]), Dict(keys=[Constant(value='$ref'), Constant(value='$$description')], values=[Constant(value='#/definitions/entry-point-group'), List(elts=[Constant(value='Instruct the installer to create GUI wrappers for the given'), Constant(value='`entry points <https://packaging.python.org/specifications/entry-points/>`_.'), Constant(value='The difference between ``scripts`` and ``gui-scripts`` is only relevant in'), Constant(value='Windows.')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Instruct the installer to expose the given modules/functions via'), Constant(value='``entry-point`` discovery mechanism (useful for plugins).'), Constant(value='More information available in the `Python packaging guide'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-group')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/entry-point-group')])])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='items')], values=[Constant(value='array'), Constant(value='Project (mandatory) dependencies.'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/dependency')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='Optional dependency for the project'), Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/dependency')])])])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Specifies which fields are intentionally unspecified and expected to be'), Constant(value='dynamically provided by build tools')], ctx=Load()), Dict(keys=[Constant(value='enum')], values=[List(elts=[Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies')], ctx=Load())])])]), List(elts=[Constant(value='name')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='not'), Constant(value='$$comment')], values=[Dict(keys=[Constant(value='required'), Constant(value='properties')], values=[List(elts=[Constant(value='dynamic')], ctx=Load()), Dict(keys=[Constant(value='dynamic')], values=[Dict(keys=[Constant(value='contains'), Constant(value='$$description')], values=[Dict(keys=[Constant(value='const')], values=[Constant(value='version')]), List(elts=[Constant(value='version is listed in ``dynamic``')], ctx=Load())])])]), List(elts=[Constant(value='According to :pep:`621`:'), Constant(value='    If the core metadata specification lists a field as "Required", then'), Constant(value='    the metadata MUST specify the field statically or list it in dynamic'), Constant(value='In turn, `core metadata`_ defines:'), Constant(value='    The required fields are: Metadata-Version, Name, Version.'), Constant(value='    All the other fields are optional.'), Constant(value='Since ``Metadata-Version`` is defined by the build back-end, ``name`` and'), Constant(value='``version`` are the only mandatory information in ``pyproject.toml``.'), Constant(value='.. _core metadata: https://packaging.python.org/specifications/core-metadata/')], ctx=Load())]), Dict(keys=[Constant(value='required'), Constant(value='$$description')], values=[List(elts=[Constant(value='version')], ctx=Load()), List(elts=[Constant(value='version should be statically defined in the ``version`` field')], ctx=Load())]), Dict(keys=[Constant(value='author'), Constant(value='entry-point-group'), Constant(value='dependency')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='build-system'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='build-system')], keywords=[])), Assign(targets=[Name(id='data__buildsystem', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='build-system'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__buildsystem', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system must be object'))], keywords=[keyword(arg='value', value=Name(id='data__buildsystem', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='object'), Constant(value='Table used to store build-related data'), Constant(value=False), Dict(keys=[Constant(value='requires'), Constant(value='build-backend'), Constant(value='backend-path')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of dependencies in the :pep:`508` format required to execute the build'), Constant(value='system. Please notice that the resulting dependency graph'), Constant(value='**MUST NOT contain cycles**')], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='Python object that will be used to perform the build according to :pep:`517`'), Constant(value='pep517-backend-reference')]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of directories to be prepended to ``sys.path`` when loading the'), Constant(value='back-end, and running its hooks')], ctx=Load()), Dict(keys=[Constant(value='type'), Constant(value='$comment')], values=[Constant(value='string'), Constant(value='Should be a path (TODO: enforce it with format?)')])])]), List(elts=[Constant(value='requires')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__buildsystem_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__buildsystem', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__buildsystem_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__buildsystem_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__buildsystem', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data__buildsystem', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='requires')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=".build-system must contain ['requires'] properties"))], keywords=[keyword(arg='value', value=Name(id='data__buildsystem', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='object'), Constant(value='Table used to store build-related data'), Constant(value=False), Dict(keys=[Constant(value='requires'), Constant(value='build-backend'), Constant(value='backend-path')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of dependencies in the :pep:`508` format required to execute the build'), Constant(value='system. Please notice that the resulting dependency graph'), Constant(value='**MUST NOT contain cycles**')], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='Python object that will be used to perform the build according to :pep:`517`'), Constant(value='pep517-backend-reference')]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of directories to be prepended to ``sys.path`` when loading the'), Constant(value='back-end, and running its hooks')], ctx=Load()), Dict(keys=[Constant(value='type'), Constant(value='$comment')], values=[Constant(value='string'), Constant(value='Should be a path (TODO: enforce it with format?)')])])]), List(elts=[Constant(value='requires')], ctx=Load())])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[]), Assign(targets=[Name(id='data__buildsystem_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__buildsystem', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='requires'), ops=[In()], comparators=[Name(id='data__buildsystem_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__buildsystem_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='requires')], keywords=[])), Assign(targets=[Name(id='data__buildsystem__requires', ctx=Store())], value=Subscript(value=Name(id='data__buildsystem', ctx=Load()), slice=Constant(value='requires'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__buildsystem__requires', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system.requires must be array'))], keywords=[keyword(arg='value', value=Name(id='data__buildsystem__requires', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system.requires'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of dependencies in the :pep:`508` format required to execute the build'), Constant(value='system. Please notice that the resulting dependency graph'), Constant(value='**MUST NOT contain cycles**')], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__buildsystem__requires_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__buildsystem__requires', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__buildsystem__requires_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__buildsystem__requires_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__buildsystem__requires', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__buildsystem__requires_x', ctx=Store()), Name(id='data__buildsystem__requires_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__buildsystem__requires', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__buildsystem__requires_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.build-system.requires[{data__buildsystem__requires_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__buildsystem__requires_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.build-system.requires[{data__buildsystem__requires_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='build-backend'), ops=[In()], comparators=[Name(id='data__buildsystem_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__buildsystem_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='build-backend')], keywords=[])), Assign(targets=[Name(id='data__buildsystem__buildbackend', ctx=Store())], value=Subscript(value=Name(id='data__buildsystem', ctx=Load()), slice=Constant(value='build-backend'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__buildsystem__buildbackend', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system.build-backend must be string'))], keywords=[keyword(arg='value', value=Name(id='data__buildsystem__buildbackend', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system.build-backend'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='Python object that will be used to perform the build according to :pep:`517`'), Constant(value='pep517-backend-reference')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__buildsystem__buildbackend', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='pep517-backend-reference'), ctx=Load()), args=[Name(id='data__buildsystem__buildbackend', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system.build-backend must be pep517-backend-reference'))], keywords=[keyword(arg='value', value=Name(id='data__buildsystem__buildbackend', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system.build-backend'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='Python object that will be used to perform the build according to :pep:`517`'), Constant(value='pep517-backend-reference')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='backend-path'), ops=[In()], comparators=[Name(id='data__buildsystem_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__buildsystem_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='backend-path')], keywords=[])), Assign(targets=[Name(id='data__buildsystem__backendpath', ctx=Store())], value=Subscript(value=Name(id='data__buildsystem', ctx=Load()), slice=Constant(value='backend-path'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__buildsystem__backendpath', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system.backend-path must be array'))], keywords=[keyword(arg='value', value=Name(id='data__buildsystem__backendpath', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system.backend-path'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of directories to be prepended to ``sys.path`` when loading the'), Constant(value='back-end, and running its hooks')], ctx=Load()), Dict(keys=[Constant(value='type'), Constant(value='$comment')], values=[Constant(value='string'), Constant(value='Should be a path (TODO: enforce it with format?)')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__buildsystem__backendpath_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__buildsystem__backendpath', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__buildsystem__backendpath_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__buildsystem__backendpath_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__buildsystem__backendpath', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__buildsystem__backendpath_x', ctx=Store()), Name(id='data__buildsystem__backendpath_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__buildsystem__backendpath', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__buildsystem__backendpath_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.build-system.backend-path[{data__buildsystem__backendpath_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__buildsystem__backendpath_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.build-system.backend-path[{data__buildsystem__backendpath_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$comment')], values=[Constant(value='string'), Constant(value='Should be a path (TODO: enforce it with format?)')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data__buildsystem_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__buildsystem_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data__buildsystem', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.build-system'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='object'), Constant(value='Table used to store build-related data'), Constant(value=False), Dict(keys=[Constant(value='requires'), Constant(value='build-backend'), Constant(value='backend-path')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of dependencies in the :pep:`508` format required to execute the build'), Constant(value='system. Please notice that the resulting dependency graph'), Constant(value='**MUST NOT contain cycles**')], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='Python object that will be used to perform the build according to :pep:`517`'), Constant(value='pep517-backend-reference')]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of directories to be prepended to ``sys.path`` when loading the'), Constant(value='back-end, and running its hooks')], ctx=Load()), Dict(keys=[Constant(value='type'), Constant(value='$comment')], values=[Constant(value='string'), Constant(value='Should be a path (TODO: enforce it with format?)')])])]), List(elts=[Constant(value='requires')], ctx=Load())])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='project'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='project')], keywords=[])), Assign(targets=[Name(id='data__project', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='project'), ctx=Load())), Expr(value=Call(func=Name(id='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata', ctx=Load()), args=[Name(id='data__project', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.project'))], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='tool'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='tool')], keywords=[])), Assign(targets=[Name(id='data__tool', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='tool'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__tool', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.tool must be object'))], keywords=[keyword(arg='value', value=Name(id='data__tool', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.tool'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='properties')], values=[Constant(value='object'), Dict(keys=[Constant(value='distutils'), Constant(value='setuptools')], values=[Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='patternProperties'), Constant(value='$comment')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://docs.python.org/3/install/'), Constant(value='``tool.distutils`` table'), List(elts=[Constant(value='Originally, ``distutils`` allowed developers to configure arguments for'), Constant(value='``setup.py`` scripts via `distutils configuration files'), Constant(value='<https://docs.python.org/3/install/#distutils-configuration-files>`_.'), Constant(value='``tool.distutils`` subtables could be used with the same purpose'), Constant(value='(NOT CURRENTLY IMPLEMENTED).')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='global')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='object'), Constant(value='Global options applied to all ``distutils`` commands')])]), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='object')])]), Constant(value='TODO: Is there a practical way of making this schema more specific?')]), Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://setuptools.pypa.io/en/latest/references/keywords.html'), Constant(value='``tool.setuptools`` table'), List(elts=[Constant(value='Please notice for the time being the ``setuptools`` project does not specify'), Constant(value='a way of configuring builds via ``pyproject.toml``.'), Constant(value='Therefore this schema should be taken just as a *"thought experiment"* on how'), Constant(value='this *might be done*, by following the principles established in'), Constant(value='`ini2toml <https://ini2toml.readthedocs.io/en/latest/setuptools_pep621.html>`_.'), Constant(value='It considers only ``setuptools`` `parameters'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/declarative_config.html>`_'), Constant(value='that can currently be configured via ``setup.cfg`` and are not covered by :pep:`621`'), Constant(value='but intentionally excludes ``dependency_links`` and ``setup_requires``.'), Constant(value='NOTE: ``scripts`` was renamed to ``script-files`` to avoid confusion with'), Constant(value='entry-point based scripts (defined in :pep:`621`).')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='platforms'), Constant(value='provides'), Constant(value='obsoletes'), Constant(value='zip-safe'), Constant(value='script-files'), Constant(value='eager-resources'), Constant(value='packages'), Constant(value='package-dir'), Constant(value='package-data'), Constant(value='include-package-data'), Constant(value='exclude-package-data'), Constant(value='namespace-packages'), Constant(value='py-modules'), Constant(value='data-files'), Constant(value='cmdclass'), Constant(value='license-files'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Package and virtual package names contained within this package'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Packages which this package renders obsolete'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])]), Dict(keys=[Constant(value='description'), Constant(value='type')], values=[Constant(value='Whether the project can be safely installed and run from a zip file.'), Constant(value='boolean')]), Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Legacy way of defining scripts (entry-points are preferred).'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='TODO: is this field deprecated/should be removed?')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Resources that should be extracted together, if any of them is needed,'), Constant(value='or if any C extensions included in the project are imported.')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='Packages that should be included in the distribution.'), Constant(value='It can be given either as a list of package identifiers'), Constant(value='or as a ``dict``-like structure with a single key ``find``'), Constant(value='which corresponds to a dynamic call to'), Constant(value='``setuptools.config.expand.find_packages`` function.'), Constant(value='The ``find`` key is associated with a nested ``dict``-like structure that can'), Constant(value='contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,'), Constant(value='mimicking the keyword arguments of the associated function.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Array of Python package identifiers'), Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/package-name')])]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/find-directive')])], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value=':class:`dict`-like structure mapping from package names to directories where their'), Constant(value='code can be found.'), Constant(value='The empty string (as key) means that all packages are contained inside'), Constant(value='the given directory will be included in the distribution.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='const')], values=[Constant(value='')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/package-name')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns.'), Constant(value='Usually this option is not needed when using ``include-package-data = true``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type')], values=[List(elts=[Constant(value='Automatically include any data files inside the package directories'), Constant(value='that are specified by ``MANIFEST.in``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='boolean')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns that should be excluded'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='https://setuptools.pypa.io/en/latest/userguide/package_discovery.html')]), Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Modules that setuptools will manipulate'), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='TODO: clarify the relationship with ``packages``')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='**DEPRECATED**: dict-like structure where each key represents a directory and'), Constant(value='the value is a list of glob patterns that should be installed in them.'), Constant(value="Please notice this don't work with wheels. See `data files support"), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping of distutils-style command names to ``setuptools.Command`` subclasses'), Constant(value='which in turn should be represented by strings with a qualified class name'), Constant(value='(i.e., "dotted" form with module), e.g.::\n\n'), Constant(value='    cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n'), Constant(value='The command class should be a directly defined at the top-level of the'), Constant(value='containing module (no class nesting).')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-qualified-identifier')])])]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), List(elts=[Constant(value='PROVISIONAL: List of glob patterns for all license files being distributed.'), Constant(value='(might become standard with PEP 639).'), Constant(value="By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``")], ctx=Load()), Constant(value='TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), Constant(value='Instructions for loading :pep:`621`-related metadata dynamically'), Constant(value=False), Dict(keys=[Constant(value='version'), Constant(value='classifiers'), Constant(value='description'), Constant(value='dependencies'), Constant(value='entry-points'), Constant(value='optional-dependencies'), Constant(value='readme')], values=[Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='A version dynamically loaded via either the ``attr:`` or ``file:``'), Constant(value='directives. Please make sure the given file or attribute respects :pep:`440`.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/attr-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')])], ctx=Load())]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='type'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')]), Constant(value=False), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')])])]), Dict(keys=[Constant(value='anyOf'), Constant(value='required')], values=[List(elts=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='properties')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])], ctx=Load()), List(elts=[Constant(value='file')], ctx=Load())])])])]), Dict(keys=[Constant(value='package-name'), Constant(value='file-directive'), Constant(value='attr-directive'), Constant(value='find-directive')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/find-directive'), Constant(value="'find:' directive"), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='find')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])])])])])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__tool_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__tool', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__tool_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__tool_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__tool', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='distutils'), ops=[In()], comparators=[Name(id='data__tool_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__tool_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='distutils')], keywords=[])), Assign(targets=[Name(id='data__tool__distutils', ctx=Store())], value=Subscript(value=Name(id='data__tool', ctx=Load()), slice=Constant(value='distutils'), ctx=Load())), Expr(value=Call(func=Name(id='validate_https___docs_python_org_3_install', ctx=Load()), args=[Name(id='data__tool__distutils', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.tool.distutils'))], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='setuptools'), ops=[In()], comparators=[Name(id='data__tool_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__tool_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='setuptools')], keywords=[])), Assign(targets=[Name(id='data__tool__setuptools', ctx=Store())], value=Subscript(value=Name(id='data__tool', ctx=Load()), slice=Constant(value='setuptools'), ctx=Load())), Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html', ctx=Load()), args=[Name(id='data__tool__setuptools', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.tool.setuptools'))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='project')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://packaging.python.org/en/latest/specifications/declaring-build-dependencies/'), Constant(value='Data structure for ``pyproject.toml`` files'), List(elts=[Constant(value='File format containing build-time configurations for the Python ecosystem. '), Constant(value=':pep:`517` initially defined a build-system independent format for source trees'), Constant(value='which was complemented by :pep:`518` to provide a way of specifying dependencies '), Constant(value='for building Python projects.'), Constant(value='Please notice the ``project`` table (as initially defined in  :pep:`621`) is not included'), Constant(value='in this schema and should be considered separately.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='build-system'), Constant(value='project'), Constant(value='tool')], values=[Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='object'), Constant(value='Table used to store build-related data'), Constant(value=False), Dict(keys=[Constant(value='requires'), Constant(value='build-backend'), Constant(value='backend-path')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of dependencies in the :pep:`508` format required to execute the build'), Constant(value='system. Please notice that the resulting dependency graph'), Constant(value='**MUST NOT contain cycles**')], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='Python object that will be used to perform the build according to :pep:`517`'), Constant(value='pep517-backend-reference')]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='List of directories to be prepended to ``sys.path`` when loading the'), Constant(value='back-end, and running its hooks')], ctx=Load()), Dict(keys=[Constant(value='type'), Constant(value='$comment')], values=[Constant(value='string'), Constant(value='Should be a path (TODO: enforce it with format?)')])])]), List(elts=[Constant(value='requires')], ctx=Load())]), Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='required'), Constant(value='additionalProperties'), Constant(value='if'), Constant(value='then'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://packaging.python.org/en/latest/specifications/declaring-project-metadata/'), Constant(value='Package metadata stored in the ``project`` table'), List(elts=[Constant(value='Data structure for the **project** table inside ``pyproject.toml``'), Constant(value='(as initially defined in :pep:`621`)')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='name'), Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The name (primary identifier) of the project. MUST be statically defined.'), Constant(value='pep508-identifier')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The version of the project as supported by :pep:`440`.'), Constant(value='pep440')]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The `summary description of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#summary>`_')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='`Full/detailed description of the project in the form of a README'), Constant(value='<https://peps.python.org/pep-0621/#readme>`_'), Constant(value="with meaning similar to the one defined in `core metadata's Description"), Constant(value='<https://packaging.python.org/specifications/core-metadata/#description>`_')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file (UTF-8) containing the full description'), Constant(value='of the project. If the file path ends in case-insensitive ``.md`` or'), Constant(value='``.rst`` suffixes, then the content-type is respectively'), Constant(value='``text/markdown`` or ``text/x-rst``')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='allOf')], values=[Constant(value='object'), List(elts=[Dict(keys=[Constant(value='anyOf')], values=[List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])]), List(elts=[Constant(value='content-type')], ctx=Load())])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='$$description')], values=[Constant(value='string'), Constant(value='pep508-versionspec'), List(elts=[Constant(value='`The Python version requirements of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.')], ctx=Load())]), Dict(keys=[Constant(value='description'), Constant(value='oneOf')], values=[Constant(value='`Project license <https://peps.python.org/pep-0621/#license>`_.'), List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to the file (UTF-8) which contains the license for the'), Constant(value='project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The license of the project whose meaning is that of the'), Constant(value='`License field from the core metadata'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#license>`_.')], ctx=Load())])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/author')]), List(elts=[Constant(value="The people or organizations considered to be the 'authors' of the project."), Constant(value='The exact meaning is open to interpretation (e.g. original or primary authors,'), Constant(value='current maintainers, or owners of the package).')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/author')]), List(elts=[Constant(value="The people or organizations considered to be the 'maintainers' of the project."), Constant(value='Similarly to ``authors``, the exact meaning is open to interpretation.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='List of keywords to assist searching for the distribution in a larger catalog.')]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='trove-classifier'), Constant(value='`PyPI classifier <https://pypi.org/classifiers/>`_.')]), List(elts=[Constant(value='`Trove classifiers <https://pypi.org/classifiers/>`_'), Constant(value='which apply to the project.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='URLs associated with the project in the form ``label => value``.'), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])])]), Dict(keys=[Constant(value='$ref'), Constant(value='$$description')], values=[Constant(value='#/definitions/entry-point-group'), List(elts=[Constant(value='Instruct the installer to create command-line wrappers for the given'), Constant(value='`entry points <https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load())]), Dict(keys=[Constant(value='$ref'), Constant(value='$$description')], values=[Constant(value='#/definitions/entry-point-group'), List(elts=[Constant(value='Instruct the installer to create GUI wrappers for the given'), Constant(value='`entry points <https://packaging.python.org/specifications/entry-points/>`_.'), Constant(value='The difference between ``scripts`` and ``gui-scripts`` is only relevant in'), Constant(value='Windows.')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Instruct the installer to expose the given modules/functions via'), Constant(value='``entry-point`` discovery mechanism (useful for plugins).'), Constant(value='More information available in the `Python packaging guide'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-group')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/entry-point-group')])])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='items')], values=[Constant(value='array'), Constant(value='Project (mandatory) dependencies.'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/dependency')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='Optional dependency for the project'), Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/dependency')])])])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Specifies which fields are intentionally unspecified and expected to be'), Constant(value='dynamically provided by build tools')], ctx=Load()), Dict(keys=[Constant(value='enum')], values=[List(elts=[Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies')], ctx=Load())])])]), List(elts=[Constant(value='name')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='not'), Constant(value='$$comment')], values=[Dict(keys=[Constant(value='required'), Constant(value='properties')], values=[List(elts=[Constant(value='dynamic')], ctx=Load()), Dict(keys=[Constant(value='dynamic')], values=[Dict(keys=[Constant(value='contains'), Constant(value='$$description')], values=[Dict(keys=[Constant(value='const')], values=[Constant(value='version')]), List(elts=[Constant(value='version is listed in ``dynamic``')], ctx=Load())])])]), List(elts=[Constant(value='According to :pep:`621`:'), Constant(value='    If the core metadata specification lists a field as "Required", then'), Constant(value='    the metadata MUST specify the field statically or list it in dynamic'), Constant(value='In turn, `core metadata`_ defines:'), Constant(value='    The required fields are: Metadata-Version, Name, Version.'), Constant(value='    All the other fields are optional.'), Constant(value='Since ``Metadata-Version`` is defined by the build back-end, ``name`` and'), Constant(value='``version`` are the only mandatory information in ``pyproject.toml``.'), Constant(value='.. _core metadata: https://packaging.python.org/specifications/core-metadata/')], ctx=Load())]), Dict(keys=[Constant(value='required'), Constant(value='$$description')], values=[List(elts=[Constant(value='version')], ctx=Load()), List(elts=[Constant(value='version should be statically defined in the ``version`` field')], ctx=Load())]), Dict(keys=[Constant(value='author'), Constant(value='entry-point-group'), Constant(value='dependency')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])]), Dict(keys=[Constant(value='type'), Constant(value='properties')], values=[Constant(value='object'), Dict(keys=[Constant(value='distutils'), Constant(value='setuptools')], values=[Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='patternProperties'), Constant(value='$comment')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://docs.python.org/3/install/'), Constant(value='``tool.distutils`` table'), List(elts=[Constant(value='Originally, ``distutils`` allowed developers to configure arguments for'), Constant(value='``setup.py`` scripts via `distutils configuration files'), Constant(value='<https://docs.python.org/3/install/#distutils-configuration-files>`_.'), Constant(value='``tool.distutils`` subtables could be used with the same purpose'), Constant(value='(NOT CURRENTLY IMPLEMENTED).')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='global')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='object'), Constant(value='Global options applied to all ``distutils`` commands')])]), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='object')])]), Constant(value='TODO: Is there a practical way of making this schema more specific?')]), Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://setuptools.pypa.io/en/latest/references/keywords.html'), Constant(value='``tool.setuptools`` table'), List(elts=[Constant(value='Please notice for the time being the ``setuptools`` project does not specify'), Constant(value='a way of configuring builds via ``pyproject.toml``.'), Constant(value='Therefore this schema should be taken just as a *"thought experiment"* on how'), Constant(value='this *might be done*, by following the principles established in'), Constant(value='`ini2toml <https://ini2toml.readthedocs.io/en/latest/setuptools_pep621.html>`_.'), Constant(value='It considers only ``setuptools`` `parameters'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/declarative_config.html>`_'), Constant(value='that can currently be configured via ``setup.cfg`` and are not covered by :pep:`621`'), Constant(value='but intentionally excludes ``dependency_links`` and ``setup_requires``.'), Constant(value='NOTE: ``scripts`` was renamed to ``script-files`` to avoid confusion with'), Constant(value='entry-point based scripts (defined in :pep:`621`).')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='platforms'), Constant(value='provides'), Constant(value='obsoletes'), Constant(value='zip-safe'), Constant(value='script-files'), Constant(value='eager-resources'), Constant(value='packages'), Constant(value='package-dir'), Constant(value='package-data'), Constant(value='include-package-data'), Constant(value='exclude-package-data'), Constant(value='namespace-packages'), Constant(value='py-modules'), Constant(value='data-files'), Constant(value='cmdclass'), Constant(value='license-files'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Package and virtual package names contained within this package'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Packages which this package renders obsolete'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])]), Dict(keys=[Constant(value='description'), Constant(value='type')], values=[Constant(value='Whether the project can be safely installed and run from a zip file.'), Constant(value='boolean')]), Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Legacy way of defining scripts (entry-points are preferred).'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='TODO: is this field deprecated/should be removed?')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Resources that should be extracted together, if any of them is needed,'), Constant(value='or if any C extensions included in the project are imported.')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='Packages that should be included in the distribution.'), Constant(value='It can be given either as a list of package identifiers'), Constant(value='or as a ``dict``-like structure with a single key ``find``'), Constant(value='which corresponds to a dynamic call to'), Constant(value='``setuptools.config.expand.find_packages`` function.'), Constant(value='The ``find`` key is associated with a nested ``dict``-like structure that can'), Constant(value='contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,'), Constant(value='mimicking the keyword arguments of the associated function.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Array of Python package identifiers'), Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/package-name')])]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/find-directive')])], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value=':class:`dict`-like structure mapping from package names to directories where their'), Constant(value='code can be found.'), Constant(value='The empty string (as key) means that all packages are contained inside'), Constant(value='the given directory will be included in the distribution.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='const')], values=[Constant(value='')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/package-name')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns.'), Constant(value='Usually this option is not needed when using ``include-package-data = true``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type')], values=[List(elts=[Constant(value='Automatically include any data files inside the package directories'), Constant(value='that are specified by ``MANIFEST.in``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='boolean')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns that should be excluded'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='https://setuptools.pypa.io/en/latest/userguide/package_discovery.html')]), Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Modules that setuptools will manipulate'), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='TODO: clarify the relationship with ``packages``')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='**DEPRECATED**: dict-like structure where each key represents a directory and'), Constant(value='the value is a list of glob patterns that should be installed in them.'), Constant(value="Please notice this don't work with wheels. See `data files support"), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping of distutils-style command names to ``setuptools.Command`` subclasses'), Constant(value='which in turn should be represented by strings with a qualified class name'), Constant(value='(i.e., "dotted" form with module), e.g.::\n\n'), Constant(value='    cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n'), Constant(value='The command class should be a directly defined at the top-level of the'), Constant(value='containing module (no class nesting).')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-qualified-identifier')])])]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), List(elts=[Constant(value='PROVISIONAL: List of glob patterns for all license files being distributed.'), Constant(value='(might become standard with PEP 639).'), Constant(value="By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``")], ctx=Load()), Constant(value='TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), Constant(value='Instructions for loading :pep:`621`-related metadata dynamically'), Constant(value=False), Dict(keys=[Constant(value='version'), Constant(value='classifiers'), Constant(value='description'), Constant(value='dependencies'), Constant(value='entry-points'), Constant(value='optional-dependencies'), Constant(value='readme')], values=[Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='A version dynamically loaded via either the ``attr:`` or ``file:``'), Constant(value='directives. Please make sure the given file or attribute respects :pep:`440`.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/attr-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')])], ctx=Load())]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='type'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')]), Constant(value=False), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')])])]), Dict(keys=[Constant(value='anyOf'), Constant(value='required')], values=[List(elts=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/file-directive')]), Dict(keys=[Constant(value='properties')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])], ctx=Load()), List(elts=[Constant(value='file')], ctx=Load())])])])]), Dict(keys=[Constant(value='package-name'), Constant(value='file-directive'), Constant(value='attr-directive'), Constant(value='find-directive')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/find-directive'), Constant(value="'find:' directive"), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='find')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])])])])])])])]), Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='required'), Constant(value='additionalProperties'), Constant(value='if'), Constant(value='then'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://packaging.python.org/en/latest/specifications/declaring-project-metadata/'), Constant(value='Package metadata stored in the ``project`` table'), List(elts=[Constant(value='Data structure for the **project** table inside ``pyproject.toml``'), Constant(value='(as initially defined in :pep:`621`)')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='name'), Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The name (primary identifier) of the project. MUST be statically defined.'), Constant(value='pep508-identifier')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The version of the project as supported by :pep:`440`.'), Constant(value='pep440')]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The `summary description of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#summary>`_')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='`Full/detailed description of the project in the form of a README'), Constant(value='<https://peps.python.org/pep-0621/#readme>`_'), Constant(value="with meaning similar to the one defined in `core metadata's Description"), Constant(value='<https://packaging.python.org/specifications/core-metadata/#description>`_')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file (UTF-8) containing the full description'), Constant(value='of the project. If the file path ends in case-insensitive ``.md`` or'), Constant(value='``.rst`` suffixes, then the content-type is respectively'), Constant(value='``text/markdown`` or ``text/x-rst``')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='allOf')], values=[Constant(value='object'), List(elts=[Dict(keys=[Constant(value='anyOf')], values=[List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])]), List(elts=[Constant(value='content-type')], ctx=Load())])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='$$description')], values=[Constant(value='string'), Constant(value='pep508-versionspec'), List(elts=[Constant(value='`The Python version requirements of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.')], ctx=Load())]), Dict(keys=[Constant(value='description'), Constant(value='oneOf')], values=[Constant(value='`Project license <https://peps.python.org/pep-0621/#license>`_.'), List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to the file (UTF-8) which contains the license for the'), Constant(value='project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The license of the project whose meaning is that of the'), Constant(value='`License field from the core metadata'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#license>`_.')], ctx=Load())])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/author')]), List(elts=[Constant(value="The people or organizations considered to be the 'authors' of the project."), Constant(value='The exact meaning is open to interpretation (e.g. original or primary authors,'), Constant(value='current maintainers, or owners of the package).')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/author')]), List(elts=[Constant(value="The people or organizations considered to be the 'maintainers' of the project."), Constant(value='Similarly to ``authors``, the exact meaning is open to interpretation.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='List of keywords to assist searching for the distribution in a larger catalog.')]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='trove-classifier'), Constant(value='`PyPI classifier <https://pypi.org/classifiers/>`_.')]), List(elts=[Constant(value='`Trove classifiers <https://pypi.org/classifiers/>`_'), Constant(value='which apply to the project.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='URLs associated with the project in the form ``label => value``.'), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])])]), Dict(keys=[Constant(value='$ref'), Constant(value='$$description')], values=[Constant(value='#/definitions/entry-point-group'), List(elts=[Constant(value='Instruct the installer to create command-line wrappers for the given'), Constant(value='`entry points <https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load())]), Dict(keys=[Constant(value='$ref'), Constant(value='$$description')], values=[Constant(value='#/definitions/entry-point-group'), List(elts=[Constant(value='Instruct the installer to create GUI wrappers for the given'), Constant(value='`entry points <https://packaging.python.org/specifications/entry-points/>`_.'), Constant(value='The difference between ``scripts`` and ``gui-scripts`` is only relevant in'), Constant(value='Windows.')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Instruct the installer to expose the given modules/functions via'), Constant(value='``entry-point`` discovery mechanism (useful for plugins).'), Constant(value='More information available in the `Python packaging guide'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-group')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/entry-point-group')])])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='items')], values=[Constant(value='array'), Constant(value='Project (mandatory) dependencies.'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/dependency')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='Optional dependency for the project'), Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$ref')], values=[Constant(value='#/definitions/dependency')])])])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Specifies which fields are intentionally unspecified and expected to be'), Constant(value='dynamically provided by build tools')], ctx=Load()), Dict(keys=[Constant(value='enum')], values=[List(elts=[Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies')], ctx=Load())])])]), List(elts=[Constant(value='name')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='not'), Constant(value='$$comment')], values=[Dict(keys=[Constant(value='required'), Constant(value='properties')], values=[List(elts=[Constant(value='dynamic')], ctx=Load()), Dict(keys=[Constant(value='dynamic')], values=[Dict(keys=[Constant(value='contains'), Constant(value='$$description')], values=[Dict(keys=[Constant(value='const')], values=[Constant(value='version')]), List(elts=[Constant(value='version is listed in ``dynamic``')], ctx=Load())])])]), List(elts=[Constant(value='According to :pep:`621`:'), Constant(value='    If the core metadata specification lists a field as "Required", then'), Constant(value='    the metadata MUST specify the field statically or list it in dynamic'), Constant(value='In turn, `core metadata`_ defines:'), Constant(value='    The required fields are: Metadata-Version, Name, Version.'), Constant(value='    All the other fields are optional.'), Constant(value='Since ``Metadata-Version`` is defined by the build back-end, ``name`` and'), Constant(value='``version`` are the only mandatory information in ``pyproject.toml``.'), Constant(value='.. _core metadata: https://packaging.python.org/specifications/core-metadata/')], ctx=Load())]), Dict(keys=[Constant(value='required'), Constant(value='$$description')], values=[List(elts=[Constant(value='version')], ctx=Load()), List(elts=[Constant(value='version should be statically defined in the ``version`` field')], ctx=Load())]), Dict(keys=[Constant(value='author'), Constant(value='entry-point-group'), Constant(value='dependency')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___setuptools_pypa_io_en_latest_references_keywords_html', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be object'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://setuptools.pypa.io/en/latest/references/keywords.html'), Constant(value='``tool.setuptools`` table'), List(elts=[Constant(value='Please notice for the time being the ``setuptools`` project does not specify'), Constant(value='a way of configuring builds via ``pyproject.toml``.'), Constant(value='Therefore this schema should be taken just as a *"thought experiment"* on how'), Constant(value='this *might be done*, by following the principles established in'), Constant(value='`ini2toml <https://ini2toml.readthedocs.io/en/latest/setuptools_pep621.html>`_.'), Constant(value='It considers only ``setuptools`` `parameters'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/declarative_config.html>`_'), Constant(value='that can currently be configured via ``setup.cfg`` and are not covered by :pep:`621`'), Constant(value='but intentionally excludes ``dependency_links`` and ``setup_requires``.'), Constant(value='NOTE: ``scripts`` was renamed to ``script-files`` to avoid confusion with'), Constant(value='entry-point based scripts (defined in :pep:`621`).')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='platforms'), Constant(value='provides'), Constant(value='obsoletes'), Constant(value='zip-safe'), Constant(value='script-files'), Constant(value='eager-resources'), Constant(value='packages'), Constant(value='package-dir'), Constant(value='package-data'), Constant(value='include-package-data'), Constant(value='exclude-package-data'), Constant(value='namespace-packages'), Constant(value='py-modules'), Constant(value='data-files'), Constant(value='cmdclass'), Constant(value='license-files'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Package and virtual package names contained within this package'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Packages which this package renders obsolete'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])]), Dict(keys=[Constant(value='description'), Constant(value='type')], values=[Constant(value='Whether the project can be safely installed and run from a zip file.'), Constant(value='boolean')]), Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Legacy way of defining scripts (entry-points are preferred).'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='TODO: is this field deprecated/should be removed?')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Resources that should be extracted together, if any of them is needed,'), Constant(value='or if any C extensions included in the project are imported.')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='Packages that should be included in the distribution.'), Constant(value='It can be given either as a list of package identifiers'), Constant(value='or as a ``dict``-like structure with a single key ``find``'), Constant(value='which corresponds to a dynamic call to'), Constant(value='``setuptools.config.expand.find_packages`` function.'), Constant(value='The ``find`` key is associated with a nested ``dict``-like structure that can'), Constant(value='contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,'), Constant(value='mimicking the keyword arguments of the associated function.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Array of Python package identifiers'), Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/find-directive'), Constant(value="'find:' directive"), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='find')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])])])], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value=':class:`dict`-like structure mapping from package names to directories where their'), Constant(value='code can be found.'), Constant(value='The empty string (as key) means that all packages are contained inside'), Constant(value='the given directory will be included in the distribution.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='const')], values=[Constant(value='')]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns.'), Constant(value='Usually this option is not needed when using ``include-package-data = true``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type')], values=[List(elts=[Constant(value='Automatically include any data files inside the package directories'), Constant(value='that are specified by ``MANIFEST.in``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='boolean')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns that should be excluded'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='https://setuptools.pypa.io/en/latest/userguide/package_discovery.html')]), Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Modules that setuptools will manipulate'), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='TODO: clarify the relationship with ``packages``')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='**DEPRECATED**: dict-like structure where each key represents a directory and'), Constant(value='the value is a list of glob patterns that should be installed in them.'), Constant(value="Please notice this don't work with wheels. See `data files support"), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping of distutils-style command names to ``setuptools.Command`` subclasses'), Constant(value='which in turn should be represented by strings with a qualified class name'), Constant(value='(i.e., "dotted" form with module), e.g.::\n\n'), Constant(value='    cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n'), Constant(value='The command class should be a directly defined at the top-level of the'), Constant(value='containing module (no class nesting).')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-qualified-identifier')])])]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), List(elts=[Constant(value='PROVISIONAL: List of glob patterns for all license files being distributed.'), Constant(value='(might become standard with PEP 639).'), Constant(value="By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``")], ctx=Load()), Constant(value='TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), Constant(value='Instructions for loading :pep:`621`-related metadata dynamically'), Constant(value=False), Dict(keys=[Constant(value='version'), Constant(value='classifiers'), Constant(value='description'), Constant(value='dependencies'), Constant(value='entry-points'), Constant(value='optional-dependencies'), Constant(value='readme')], values=[Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='A version dynamically loaded via either the ``attr:`` or ``file:``'), Constant(value='directives. Please make sure the given file or attribute respects :pep:`440`.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')]), Constant(value=False), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])])]), Dict(keys=[Constant(value='anyOf'), Constant(value='required')], values=[List(elts=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])], ctx=Load()), List(elts=[Constant(value='file')], ctx=Load())])])])]), Dict(keys=[Constant(value='package-name'), Constant(value='file-directive'), Constant(value='attr-directive'), Constant(value='find-directive')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/find-directive'), Constant(value="'find:' directive"), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='find')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])])])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='platforms'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='platforms')], keywords=[])), Assign(targets=[Name(id='data__platforms', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='platforms'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__platforms', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.platforms must be array'))], keywords=[keyword(arg='value', value=Name(id='data__platforms', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.platforms'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__platforms_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__platforms', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__platforms_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__platforms_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__platforms', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__platforms_x', ctx=Store()), Name(id='data__platforms_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__platforms', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__platforms_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.platforms[{data__platforms_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__platforms_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.platforms[{data__platforms_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='provides'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='provides')], keywords=[])), Assign(targets=[Name(id='data__provides', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='provides'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__provides', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.provides must be array'))], keywords=[keyword(arg='value', value=Name(id='data__provides', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.provides'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Package and virtual package names contained within this package'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__provides_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__provides', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__provides_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__provides_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__provides', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__provides_x', ctx=Store()), Name(id='data__provides_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__provides', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__provides_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.provides[{data__provides_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__provides_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.provides[{data__provides_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__provides_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='pep508-identifier'), ctx=Load()), args=[Name(id='data__provides_item', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.provides[{data__provides_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be pep508-identifier'))], keywords=[keyword(arg='value', value=Name(id='data__provides_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.provides[{data__provides_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='obsoletes'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='obsoletes')], keywords=[])), Assign(targets=[Name(id='data__obsoletes', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='obsoletes'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__obsoletes', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.obsoletes must be array'))], keywords=[keyword(arg='value', value=Name(id='data__obsoletes', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.obsoletes'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Packages which this package renders obsolete'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__obsoletes_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__obsoletes', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__obsoletes_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__obsoletes_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__obsoletes', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__obsoletes_x', ctx=Store()), Name(id='data__obsoletes_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__obsoletes', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__obsoletes_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.obsoletes[{data__obsoletes_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__obsoletes_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.obsoletes[{data__obsoletes_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__obsoletes_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='pep508-identifier'), ctx=Load()), args=[Name(id='data__obsoletes_item', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.obsoletes[{data__obsoletes_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be pep508-identifier'))], keywords=[keyword(arg='value', value=Name(id='data__obsoletes_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.obsoletes[{data__obsoletes_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='zip-safe'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='zip-safe')], keywords=[])), Assign(targets=[Name(id='data__zipsafe', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='zip-safe'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__zipsafe', ctx=Load()), Name(id='bool', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.zip-safe must be boolean'))], keywords=[keyword(arg='value', value=Name(id='data__zipsafe', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.zip-safe'))), keyword(arg='definition', value=Dict(keys=[Constant(value='description'), Constant(value='type')], values=[Constant(value='Whether the project can be safely installed and run from a zip file.'), Constant(value='boolean')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='script-files'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='script-files')], keywords=[])), Assign(targets=[Name(id='data__scriptfiles', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='script-files'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__scriptfiles', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.script-files must be array'))], keywords=[keyword(arg='value', value=Name(id='data__scriptfiles', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.script-files'))), keyword(arg='definition', value=Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Legacy way of defining scripts (entry-points are preferred).'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='TODO: is this field deprecated/should be removed?')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__scriptfiles_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__scriptfiles', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__scriptfiles_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__scriptfiles_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__scriptfiles', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__scriptfiles_x', ctx=Store()), Name(id='data__scriptfiles_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__scriptfiles', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__scriptfiles_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.script-files[{data__scriptfiles_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__scriptfiles_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.script-files[{data__scriptfiles_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='eager-resources'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='eager-resources')], keywords=[])), Assign(targets=[Name(id='data__eagerresources', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='eager-resources'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__eagerresources', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.eager-resources must be array'))], keywords=[keyword(arg='value', value=Name(id='data__eagerresources', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.eager-resources'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Resources that should be extracted together, if any of them is needed,'), Constant(value='or if any C extensions included in the project are imported.')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__eagerresources_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__eagerresources', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__eagerresources_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__eagerresources_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__eagerresources', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__eagerresources_x', ctx=Store()), Name(id='data__eagerresources_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__eagerresources', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__eagerresources_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.eager-resources[{data__eagerresources_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__eagerresources_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.eager-resources[{data__eagerresources_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='packages'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='packages')], keywords=[])), Assign(targets=[Name(id='data__packages', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='packages'), ctx=Load())), Assign(targets=[Name(id='data__packages_one_of_count1', ctx=Store())], value=Constant(value=0)), If(test=Compare(left=Name(id='data__packages_one_of_count1', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packages', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.packages must be array'))], keywords=[keyword(arg='value', value=Name(id='data__packages', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.packages'))), keyword(arg='definition', value=Dict(keys=[Constant(value='title'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Array of Python package identifiers'), Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__packages_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packages', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__packages_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__packages_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__packages', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__packages_x', ctx=Store()), Name(id='data__packages_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__packages', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_package_name', ctx=Load()), args=[Name(id='data__packages_item', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Call(func=Attribute(value=Constant(value='.packages[{data__packages_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))]))], keywords=[]))], orelse=[])], orelse=[]), AugAssign(target=Name(id='data__packages_one_of_count1', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__packages_one_of_count1', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_find_directive', ctx=Load()), args=[Name(id='data__packages', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.packages'))], keywords=[])), AugAssign(target=Name(id='data__packages_one_of_count1', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__packages_one_of_count1', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.packages must be valid exactly by one definition')), op=Add(), right=BinOp(left=BinOp(left=Constant(value=' ('), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__packages_one_of_count1', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' matches found)')))], keywords=[keyword(arg='value', value=Name(id='data__packages', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.packages'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='Packages that should be included in the distribution.'), Constant(value='It can be given either as a list of package identifiers'), Constant(value='or as a ``dict``-like structure with a single key ``find``'), Constant(value='which corresponds to a dynamic call to'), Constant(value='``setuptools.config.expand.find_packages`` function.'), Constant(value='The ``find`` key is associated with a nested ``dict``-like structure that can'), Constant(value='contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,'), Constant(value='mimicking the keyword arguments of the associated function.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Array of Python package identifiers'), Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/find-directive'), Constant(value="'find:' directive"), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='find')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])])])], ctx=Load())])), keyword(arg='rule', value=Constant(value='oneOf'))]))], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='package-dir'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='package-dir')], keywords=[])), Assign(targets=[Name(id='data__packagedir', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='package-dir'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packagedir', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-dir must be object'))], keywords=[keyword(arg='value', value=Name(id='data__packagedir', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-dir'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value=':class:`dict`-like structure mapping from package names to directories where their'), Constant(value='code can be found.'), Constant(value='The empty string (as key) means that all packages are contained inside'), Constant(value='the given directory will be included in the distribution.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='const')], values=[Constant(value='')]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__packagedir_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packagedir', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__packagedir_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__packagedir_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__packagedir', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='data__packagedir_key', ctx=Store()), Name(id='data__packagedir_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data__packagedir', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='^.*$'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data__packagedir_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data__packagedir_key', ctx=Load()), ops=[In()], comparators=[Name(id='data__packagedir_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__packagedir_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data__packagedir_key', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packagedir_val', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.package-dir.{data__packagedir_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__packagedir_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.package-dir.{data__packagedir_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data__packagedir_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-dir must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__packagedir_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data__packagedir', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-dir'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value=':class:`dict`-like structure mapping from package names to directories where their'), Constant(value='code can be found.'), Constant(value='The empty string (as key) means that all packages are contained inside'), Constant(value='the given directory will be included in the distribution.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='const')], values=[Constant(value='')]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[]), Assign(targets=[Name(id='data__packagedir_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__packagedir', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='data__packagedir_len', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='data__packagedir_property_names', ctx=Store())], value=Constant(value=True)), For(target=Name(id='data__packagedir_key', ctx=Store()), iter=Name(id='data__packagedir', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='data__packagedir_key_one_of_count2', ctx=Store())], value=Constant(value=0)), If(test=Compare(left=Name(id='data__packagedir_key_one_of_count2', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[If(test=Compare(left=Name(id='data__packagedir_key', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='')]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-dir must be same as const definition: '))], keywords=[keyword(arg='value', value=Name(id='data__packagedir_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-dir'))), keyword(arg='definition', value=Dict(keys=[Constant(value='const')], values=[Constant(value='')])), keyword(arg='rule', value=Constant(value='const'))]))], orelse=[]), AugAssign(target=Name(id='data__packagedir_key_one_of_count2', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__packagedir_key_one_of_count2', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_package_name', ctx=Load()), args=[Name(id='data__packagedir_key', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.package-dir'))], keywords=[])), AugAssign(target=Name(id='data__packagedir_key_one_of_count2', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__packagedir_key_one_of_count2', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-dir must be valid exactly by one definition')), op=Add(), right=BinOp(left=BinOp(left=Constant(value=' ('), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__packagedir_key_one_of_count2', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' matches found)')))], keywords=[keyword(arg='value', value=Name(id='data__packagedir_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-dir'))), keyword(arg='definition', value=Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='const')], values=[Constant(value='')]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])], ctx=Load())])), keyword(arg='rule', value=Constant(value='oneOf'))]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Assign(targets=[Name(id='data__packagedir_property_names', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__packagedir_property_names', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-dir must be named by propertyName definition'))], keywords=[keyword(arg='value', value=Name(id='data__packagedir', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-dir'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value=':class:`dict`-like structure mapping from package names to directories where their'), Constant(value='code can be found.'), Constant(value='The empty string (as key) means that all packages are contained inside'), Constant(value='the given directory will be included in the distribution.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='const')], values=[Constant(value='')]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])), keyword(arg='rule', value=Constant(value='propertyNames'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='package-data'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='package-data')], keywords=[])), Assign(targets=[Name(id='data__packagedata', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='package-data'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packagedata', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data must be object'))], keywords=[keyword(arg='value', value=Name(id='data__packagedata', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns.'), Constant(value='Usually this option is not needed when using ``include-package-data = true``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__packagedata_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packagedata', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__packagedata_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__packagedata_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__packagedata', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='data__packagedata_key', ctx=Store()), Name(id='data__packagedata_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data__packagedata', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='^.*$'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data__packagedata_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data__packagedata_key', ctx=Load()), ops=[In()], comparators=[Name(id='data__packagedata_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__packagedata_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data__packagedata_key', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packagedata_val', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.package-data.{data__packagedata_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be array'))], keywords=[keyword(arg='value', value=Name(id='data__packagedata_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.package-data.{data__packagedata_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__packagedata_val_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packagedata_val', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__packagedata_val_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__packagedata_val_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__packagedata_val', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__packagedata_val_x', ctx=Store()), Name(id='data__packagedata_val_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__packagedata_val', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packagedata_val_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.package-data.{data__packagedata_key}[{data__packagedata_val_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__packagedata_val_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.package-data.{data__packagedata_key}[{data__packagedata_val_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data__packagedata_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__packagedata_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data__packagedata', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns.'), Constant(value='Usually this option is not needed when using ``include-package-data = true``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[]), Assign(targets=[Name(id='data__packagedata_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__packagedata', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='data__packagedata_len', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='data__packagedata_property_names', ctx=Store())], value=Constant(value=True)), For(target=Name(id='data__packagedata_key', ctx=Store()), iter=Name(id='data__packagedata', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='data__packagedata_key_one_of_count3', ctx=Store())], value=Constant(value=0)), If(test=Compare(left=Name(id='data__packagedata_key_one_of_count3', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__packagedata_key', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='python-module-name'), ctx=Load()), args=[Name(id='data__packagedata_key', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data must be python-module-name'))], keywords=[keyword(arg='value', value=Name(id='data__packagedata_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[]), AugAssign(target=Name(id='data__packagedata_key_one_of_count3', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__packagedata_key_one_of_count3', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[If(test=Compare(left=Name(id='data__packagedata_key', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='*')]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data must be same as const definition: *'))], keywords=[keyword(arg='value', value=Name(id='data__packagedata_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='const')], values=[Constant(value='*')])), keyword(arg='rule', value=Constant(value='const'))]))], orelse=[]), AugAssign(target=Name(id='data__packagedata_key_one_of_count3', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__packagedata_key_one_of_count3', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data must be valid exactly by one definition')), op=Add(), right=BinOp(left=BinOp(left=Constant(value=' ('), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__packagedata_key_one_of_count3', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' matches found)')))], keywords=[keyword(arg='value', value=Name(id='data__packagedata_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())])), keyword(arg='rule', value=Constant(value='oneOf'))]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Assign(targets=[Name(id='data__packagedata_property_names', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__packagedata_property_names', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data must be named by propertyName definition'))], keywords=[keyword(arg='value', value=Name(id='data__packagedata', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns.'), Constant(value='Usually this option is not needed when using ``include-package-data = true``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])])), keyword(arg='rule', value=Constant(value='propertyNames'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='include-package-data'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='include-package-data')], keywords=[])), Assign(targets=[Name(id='data__includepackagedata', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='include-package-data'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__includepackagedata', ctx=Load()), Name(id='bool', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.include-package-data must be boolean'))], keywords=[keyword(arg='value', value=Name(id='data__includepackagedata', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.include-package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type')], values=[List(elts=[Constant(value='Automatically include any data files inside the package directories'), Constant(value='that are specified by ``MANIFEST.in``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='boolean')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='exclude-package-data'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='exclude-package-data')], keywords=[])), Assign(targets=[Name(id='data__excludepackagedata', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='exclude-package-data'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__excludepackagedata', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data must be object'))], keywords=[keyword(arg='value', value=Name(id='data__excludepackagedata', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns that should be excluded'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__excludepackagedata_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__excludepackagedata', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__excludepackagedata_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__excludepackagedata_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__excludepackagedata', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='data__excludepackagedata_key', ctx=Store()), Name(id='data__excludepackagedata_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data__excludepackagedata', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='^.*$'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data__excludepackagedata_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data__excludepackagedata_key', ctx=Load()), ops=[In()], comparators=[Name(id='data__excludepackagedata_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__excludepackagedata_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data__excludepackagedata_key', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__excludepackagedata_val', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.exclude-package-data.{data__excludepackagedata_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be array'))], keywords=[keyword(arg='value', value=Name(id='data__excludepackagedata_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.exclude-package-data.{data__excludepackagedata_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__excludepackagedata_val_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__excludepackagedata_val', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__excludepackagedata_val_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__excludepackagedata_val_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__excludepackagedata_val', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__excludepackagedata_val_x', ctx=Store()), Name(id='data__excludepackagedata_val_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__excludepackagedata_val', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__excludepackagedata_val_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.exclude-package-data.{data__excludepackagedata_key}[{data__excludepackagedata_val_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__excludepackagedata_val_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.exclude-package-data.{data__excludepackagedata_key}[{data__excludepackagedata_val_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data__excludepackagedata_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__excludepackagedata_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data__excludepackagedata', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns that should be excluded'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[]), Assign(targets=[Name(id='data__excludepackagedata_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__excludepackagedata', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='data__excludepackagedata_len', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='data__excludepackagedata_property_names', ctx=Store())], value=Constant(value=True)), For(target=Name(id='data__excludepackagedata_key', ctx=Store()), iter=Name(id='data__excludepackagedata', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='data__excludepackagedata_key_one_of_count4', ctx=Store())], value=Constant(value=0)), If(test=Compare(left=Name(id='data__excludepackagedata_key_one_of_count4', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__excludepackagedata_key', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='python-module-name'), ctx=Load()), args=[Name(id='data__excludepackagedata_key', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data must be python-module-name'))], keywords=[keyword(arg='value', value=Name(id='data__excludepackagedata_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[]), AugAssign(target=Name(id='data__excludepackagedata_key_one_of_count4', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__excludepackagedata_key_one_of_count4', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[If(test=Compare(left=Name(id='data__excludepackagedata_key', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='*')]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data must be same as const definition: *'))], keywords=[keyword(arg='value', value=Name(id='data__excludepackagedata_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='const')], values=[Constant(value='*')])), keyword(arg='rule', value=Constant(value='const'))]))], orelse=[]), AugAssign(target=Name(id='data__excludepackagedata_key_one_of_count4', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__excludepackagedata_key_one_of_count4', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data must be valid exactly by one definition')), op=Add(), right=BinOp(left=BinOp(left=Constant(value=' ('), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__excludepackagedata_key_one_of_count4', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' matches found)')))], keywords=[keyword(arg='value', value=Name(id='data__excludepackagedata_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())])), keyword(arg='rule', value=Constant(value='oneOf'))]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Assign(targets=[Name(id='data__excludepackagedata_property_names', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__excludepackagedata_property_names', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data must be named by propertyName definition'))], keywords=[keyword(arg='value', value=Name(id='data__excludepackagedata', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.exclude-package-data'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns that should be excluded'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])])), keyword(arg='rule', value=Constant(value='propertyNames'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='namespace-packages'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='namespace-packages')], keywords=[])), Assign(targets=[Name(id='data__namespacepackages', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='namespace-packages'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__namespacepackages', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.namespace-packages must be array'))], keywords=[keyword(arg='value', value=Name(id='data__namespacepackages', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.namespace-packages'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='https://setuptools.pypa.io/en/latest/userguide/package_discovery.html')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__namespacepackages_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__namespacepackages', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__namespacepackages_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__namespacepackages_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__namespacepackages', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__namespacepackages_x', ctx=Store()), Name(id='data__namespacepackages_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__namespacepackages', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__namespacepackages_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.namespace-packages[{data__namespacepackages_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__namespacepackages_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.namespace-packages[{data__namespacepackages_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__namespacepackages_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='python-module-name'), ctx=Load()), args=[Name(id='data__namespacepackages_item', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.namespace-packages[{data__namespacepackages_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be python-module-name'))], keywords=[keyword(arg='value', value=Name(id='data__namespacepackages_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.namespace-packages[{data__namespacepackages_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='py-modules'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='py-modules')], keywords=[])), Assign(targets=[Name(id='data__pymodules', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='py-modules'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__pymodules', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.py-modules must be array'))], keywords=[keyword(arg='value', value=Name(id='data__pymodules', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.py-modules'))), keyword(arg='definition', value=Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Modules that setuptools will manipulate'), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='TODO: clarify the relationship with ``packages``')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__pymodules_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__pymodules', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__pymodules_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__pymodules_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__pymodules', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__pymodules_x', ctx=Store()), Name(id='data__pymodules_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__pymodules', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__pymodules_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.py-modules[{data__pymodules_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__pymodules_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.py-modules[{data__pymodules_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__pymodules_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='python-module-name'), ctx=Load()), args=[Name(id='data__pymodules_item', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.py-modules[{data__pymodules_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be python-module-name'))], keywords=[keyword(arg='value', value=Name(id='data__pymodules_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.py-modules[{data__pymodules_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='data-files'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='data-files')], keywords=[])), Assign(targets=[Name(id='data__datafiles', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='data-files'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__datafiles', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.data-files must be object'))], keywords=[keyword(arg='value', value=Name(id='data__datafiles', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.data-files'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='**DEPRECATED**: dict-like structure where each key represents a directory and'), Constant(value='the value is a list of glob patterns that should be installed in them.'), Constant(value="Please notice this don't work with wheels. See `data files support"), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__datafiles_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__datafiles', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__datafiles_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__datafiles_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__datafiles', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='data__datafiles_key', ctx=Store()), Name(id='data__datafiles_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data__datafiles', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='^.*$'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data__datafiles_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data__datafiles_key', ctx=Load()), ops=[In()], comparators=[Name(id='data__datafiles_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__datafiles_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data__datafiles_key', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__datafiles_val', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.data-files.{data__datafiles_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be array'))], keywords=[keyword(arg='value', value=Name(id='data__datafiles_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.data-files.{data__datafiles_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__datafiles_val_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__datafiles_val', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__datafiles_val_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__datafiles_val_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__datafiles_val', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__datafiles_val_x', ctx=Store()), Name(id='data__datafiles_val_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__datafiles_val', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__datafiles_val_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.data-files.{data__datafiles_key}[{data__datafiles_val_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__datafiles_val_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.data-files.{data__datafiles_key}[{data__datafiles_val_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='cmdclass'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='cmdclass')], keywords=[])), Assign(targets=[Name(id='data__cmdclass', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='cmdclass'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__cmdclass', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.cmdclass must be object'))], keywords=[keyword(arg='value', value=Name(id='data__cmdclass', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.cmdclass'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping of distutils-style command names to ``setuptools.Command`` subclasses'), Constant(value='which in turn should be represented by strings with a qualified class name'), Constant(value='(i.e., "dotted" form with module), e.g.::\n\n'), Constant(value='    cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n'), Constant(value='The command class should be a directly defined at the top-level of the'), Constant(value='containing module (no class nesting).')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-qualified-identifier')])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__cmdclass_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__cmdclass', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__cmdclass_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__cmdclass_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__cmdclass', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='data__cmdclass_key', ctx=Store()), Name(id='data__cmdclass_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data__cmdclass', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='^.*$'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data__cmdclass_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data__cmdclass_key', ctx=Load()), ops=[In()], comparators=[Name(id='data__cmdclass_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__cmdclass_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data__cmdclass_key', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__cmdclass_val', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.cmdclass.{data__cmdclass_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__cmdclass_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.cmdclass.{data__cmdclass_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-qualified-identifier')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__cmdclass_val', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='python-qualified-identifier'), ctx=Load()), args=[Name(id='data__cmdclass_val', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.cmdclass.{data__cmdclass_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be python-qualified-identifier'))], keywords=[keyword(arg='value', value=Name(id='data__cmdclass_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.cmdclass.{data__cmdclass_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-qualified-identifier')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='license-files'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='license-files')], keywords=[])), Assign(targets=[Name(id='data__licensefiles', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='license-files'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__licensefiles', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.license-files must be array'))], keywords=[keyword(arg='value', value=Name(id='data__licensefiles', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.license-files'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), List(elts=[Constant(value='PROVISIONAL: List of glob patterns for all license files being distributed.'), Constant(value='(might become standard with PEP 639).'), Constant(value="By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``")], ctx=Load()), Constant(value='TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__licensefiles_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__licensefiles', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__licensefiles_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__licensefiles_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__licensefiles', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__licensefiles_x', ctx=Store()), Name(id='data__licensefiles_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__licensefiles', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__licensefiles_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.license-files[{data__licensefiles_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__licensefiles_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.license-files[{data__licensefiles_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='dynamic'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='dynamic')], keywords=[])), Assign(targets=[Name(id='data__dynamic', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='dynamic'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic must be object'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), Constant(value='Instructions for loading :pep:`621`-related metadata dynamically'), Constant(value=False), Dict(keys=[Constant(value='version'), Constant(value='classifiers'), Constant(value='description'), Constant(value='dependencies'), Constant(value='entry-points'), Constant(value='optional-dependencies'), Constant(value='readme')], values=[Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='A version dynamically loaded via either the ``attr:`` or ``file:``'), Constant(value='directives. Please make sure the given file or attribute respects :pep:`440`.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')]), Constant(value=False), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])])]), Dict(keys=[Constant(value='anyOf'), Constant(value='required')], values=[List(elts=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])], ctx=Load()), List(elts=[Constant(value='file')], ctx=Load())])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__dynamic_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__dynamic_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__dynamic_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__dynamic', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='version'), ops=[In()], comparators=[Name(id='data__dynamic_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__dynamic_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='version')], keywords=[])), Assign(targets=[Name(id='data__dynamic__version', ctx=Store())], value=Subscript(value=Name(id='data__dynamic', ctx=Load()), slice=Constant(value='version'), ctx=Load())), Assign(targets=[Name(id='data__dynamic__version_one_of_count5', ctx=Store())], value=Constant(value=0)), If(test=Compare(left=Name(id='data__dynamic__version_one_of_count5', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_attr_directive', ctx=Load()), args=[Name(id='data__dynamic__version', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.dynamic.version'))], keywords=[])), AugAssign(target=Name(id='data__dynamic__version_one_of_count5', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__dynamic__version_one_of_count5', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive', ctx=Load()), args=[Name(id='data__dynamic__version', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.dynamic.version'))], keywords=[])), AugAssign(target=Name(id='data__dynamic__version_one_of_count5', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__dynamic__version_one_of_count5', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.version must be valid exactly by one definition')), op=Add(), right=BinOp(left=BinOp(left=Constant(value=' ('), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__dynamic__version_one_of_count5', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' matches found)')))], keywords=[keyword(arg='value', value=Name(id='data__dynamic__version', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.version'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='A version dynamically loaded via either the ``attr:`` or ``file:``'), Constant(value='directives. Please make sure the given file or attribute respects :pep:`440`.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])], ctx=Load())])), keyword(arg='rule', value=Constant(value='oneOf'))]))], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='classifiers'), ops=[In()], comparators=[Name(id='data__dynamic_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__dynamic_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='classifiers')], keywords=[])), Assign(targets=[Name(id='data__dynamic__classifiers', ctx=Store())], value=Subscript(value=Name(id='data__dynamic', ctx=Load()), slice=Constant(value='classifiers'), ctx=Load())), Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive', ctx=Load()), args=[Name(id='data__dynamic__classifiers', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.dynamic.classifiers'))], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='description'), ops=[In()], comparators=[Name(id='data__dynamic_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__dynamic_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='description')], keywords=[])), Assign(targets=[Name(id='data__dynamic__description', ctx=Store())], value=Subscript(value=Name(id='data__dynamic', ctx=Load()), slice=Constant(value='description'), ctx=Load())), Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive', ctx=Load()), args=[Name(id='data__dynamic__description', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.dynamic.description'))], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='dependencies'), ops=[In()], comparators=[Name(id='data__dynamic_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__dynamic_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='dependencies')], keywords=[])), Assign(targets=[Name(id='data__dynamic__dependencies', ctx=Store())], value=Subscript(value=Name(id='data__dynamic', ctx=Load()), slice=Constant(value='dependencies'), ctx=Load())), Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive', ctx=Load()), args=[Name(id='data__dynamic__dependencies', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.dynamic.dependencies'))], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='entry-points'), ops=[In()], comparators=[Name(id='data__dynamic_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__dynamic_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='entry-points')], keywords=[])), Assign(targets=[Name(id='data__dynamic__entrypoints', ctx=Store())], value=Subscript(value=Name(id='data__dynamic', ctx=Load()), slice=Constant(value='entry-points'), ctx=Load())), Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive', ctx=Load()), args=[Name(id='data__dynamic__entrypoints', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.dynamic.entry-points'))], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='optional-dependencies'), ops=[In()], comparators=[Name(id='data__dynamic_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__dynamic_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='optional-dependencies')], keywords=[])), Assign(targets=[Name(id='data__dynamic__optionaldependencies', ctx=Store())], value=Subscript(value=Name(id='data__dynamic', ctx=Load()), slice=Constant(value='optional-dependencies'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic__optionaldependencies', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.optional-dependencies must be object'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic__optionaldependencies', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.optional-dependencies'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')]), Constant(value=False), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__dynamic__optionaldependencies_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic__optionaldependencies', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__dynamic__optionaldependencies_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__dynamic__optionaldependencies_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__dynamic__optionaldependencies', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='data__dynamic__optionaldependencies_key', ctx=Store()), Name(id='data__dynamic__optionaldependencies_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data__dynamic__optionaldependencies', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='.+'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data__dynamic__optionaldependencies_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data__dynamic__optionaldependencies_key', ctx=Load()), ops=[In()], comparators=[Name(id='data__dynamic__optionaldependencies_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__dynamic__optionaldependencies_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data__dynamic__optionaldependencies_key', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive', ctx=Load()), args=[Name(id='data__dynamic__optionaldependencies_val', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Call(func=Attribute(value=Constant(value='.dynamic.optional-dependencies.{data__dynamic__optionaldependencies_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))]))], keywords=[]))], orelse=[])], orelse=[]), If(test=Name(id='data__dynamic__optionaldependencies_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.optional-dependencies must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__dynamic__optionaldependencies_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic__optionaldependencies', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.optional-dependencies'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')]), Constant(value=False), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[]), Assign(targets=[Name(id='data__dynamic__optionaldependencies_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__dynamic__optionaldependencies', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='data__dynamic__optionaldependencies_len', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='data__dynamic__optionaldependencies_property_names', ctx=Store())], value=Constant(value=True)), For(target=Name(id='data__dynamic__optionaldependencies_key', ctx=Store()), iter=Name(id='data__dynamic__optionaldependencies', ctx=Load()), body=[Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic__optionaldependencies_key', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='python-identifier'), ctx=Load()), args=[Name(id='data__dynamic__optionaldependencies_key', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.optional-dependencies must be python-identifier'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic__optionaldependencies_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.optional-dependencies'))), keyword(arg='definition', value=Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Assign(targets=[Name(id='data__dynamic__optionaldependencies_property_names', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__dynamic__optionaldependencies_property_names', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.optional-dependencies must be named by propertyName definition'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic__optionaldependencies', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.optional-dependencies'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')]), Constant(value=False), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])])])), keyword(arg='rule', value=Constant(value='propertyNames'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='readme'), ops=[In()], comparators=[Name(id='data__dynamic_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__dynamic_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='readme')], keywords=[])), Assign(targets=[Name(id='data__dynamic__readme', ctx=Store())], value=Subscript(value=Name(id='data__dynamic', ctx=Load()), slice=Constant(value='readme'), ctx=Load())), Assign(targets=[Name(id='data__dynamic__readme_any_of_count6', ctx=Store())], value=Constant(value=0)), If(test=UnaryOp(op=Not(), operand=Name(id='data__dynamic__readme_any_of_count6', ctx=Load())), body=[Try(body=[Expr(value=Call(func=Name(id='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive', ctx=Load()), args=[Name(id='data__dynamic__readme', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.dynamic.readme'))], keywords=[])), AugAssign(target=Name(id='data__dynamic__readme_any_of_count6', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__dynamic__readme_any_of_count6', ctx=Load())), body=[Try(body=[Assign(targets=[Name(id='data__dynamic__readme_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic__readme', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__dynamic__readme_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__dynamic__readme_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__dynamic__readme', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='content-type'), ops=[In()], comparators=[Name(id='data__dynamic__readme_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__dynamic__readme_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='content-type')], keywords=[])), Assign(targets=[Name(id='data__dynamic__readme__contenttype', ctx=Store())], value=Subscript(value=Name(id='data__dynamic__readme', ctx=Load()), slice=Constant(value='content-type'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic__readme__contenttype', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.readme.content-type must be string'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic__readme__contenttype', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.readme.content-type'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[]), AugAssign(target=Name(id='data__dynamic__readme_any_of_count6', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__dynamic__readme_any_of_count6', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.readme cannot be validated by any definition'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic__readme', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.readme'))), keyword(arg='definition', value=Dict(keys=[Constant(value='anyOf'), Constant(value='required')], values=[List(elts=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])], ctx=Load()), List(elts=[Constant(value='file')], ctx=Load())])), keyword(arg='rule', value=Constant(value='anyOf'))]))], orelse=[]), Assign(targets=[Name(id='data__dynamic__readme_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic__readme', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__dynamic__readme_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__dynamic__readme_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__dynamic__readme', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data__dynamic__readme', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='file')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=".dynamic.readme must contain ['file'] properties"))], keywords=[keyword(arg='value', value=Name(id='data__dynamic__readme', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic.readme'))), keyword(arg='definition', value=Dict(keys=[Constant(value='anyOf'), Constant(value='required')], values=[List(elts=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])], ctx=Load()), List(elts=[Constant(value='file')], ctx=Load())])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data__dynamic_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__dynamic_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), Constant(value='Instructions for loading :pep:`621`-related metadata dynamically'), Constant(value=False), Dict(keys=[Constant(value='version'), Constant(value='classifiers'), Constant(value='description'), Constant(value='dependencies'), Constant(value='entry-points'), Constant(value='optional-dependencies'), Constant(value='readme')], values=[Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='A version dynamically loaded via either the ``attr:`` or ``file:``'), Constant(value='directives. Please make sure the given file or attribute respects :pep:`440`.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')]), Constant(value=False), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])])]), Dict(keys=[Constant(value='anyOf'), Constant(value='required')], values=[List(elts=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])], ctx=Load()), List(elts=[Constant(value='file')], ctx=Load())])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://setuptools.pypa.io/en/latest/references/keywords.html'), Constant(value='``tool.setuptools`` table'), List(elts=[Constant(value='Please notice for the time being the ``setuptools`` project does not specify'), Constant(value='a way of configuring builds via ``pyproject.toml``.'), Constant(value='Therefore this schema should be taken just as a *"thought experiment"* on how'), Constant(value='this *might be done*, by following the principles established in'), Constant(value='`ini2toml <https://ini2toml.readthedocs.io/en/latest/setuptools_pep621.html>`_.'), Constant(value='It considers only ``setuptools`` `parameters'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/declarative_config.html>`_'), Constant(value='that can currently be configured via ``setup.cfg`` and are not covered by :pep:`621`'), Constant(value='but intentionally excludes ``dependency_links`` and ``setup_requires``.'), Constant(value='NOTE: ``scripts`` was renamed to ``script-files`` to avoid confusion with'), Constant(value='entry-point based scripts (defined in :pep:`621`).')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='platforms'), Constant(value='provides'), Constant(value='obsoletes'), Constant(value='zip-safe'), Constant(value='script-files'), Constant(value='eager-resources'), Constant(value='packages'), Constant(value='package-dir'), Constant(value='package-data'), Constant(value='include-package-data'), Constant(value='exclude-package-data'), Constant(value='namespace-packages'), Constant(value='py-modules'), Constant(value='data-files'), Constant(value='cmdclass'), Constant(value='license-files'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Package and virtual package names contained within this package'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Packages which this package renders obsolete'), Constant(value='**(not supported by pip)**')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='pep508-identifier')])]), Dict(keys=[Constant(value='description'), Constant(value='type')], values=[Constant(value='Whether the project can be safely installed and run from a zip file.'), Constant(value='boolean')]), Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Legacy way of defining scripts (entry-points are preferred).'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='TODO: is this field deprecated/should be removed?')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='items')], values=[List(elts=[Constant(value='Resources that should be extracted together, if any of them is needed,'), Constant(value='or if any C extensions included in the project are imported.')], ctx=Load()), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='Packages that should be included in the distribution.'), Constant(value='It can be given either as a list of package identifiers'), Constant(value='or as a ``dict``-like structure with a single key ``find``'), Constant(value='which corresponds to a dynamic call to'), Constant(value='``setuptools.config.expand.find_packages`` function.'), Constant(value='The ``find`` key is associated with a nested ``dict``-like structure that can'), Constant(value='contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,'), Constant(value='mimicking the keyword arguments of the associated function.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Array of Python package identifiers'), Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/find-directive'), Constant(value="'find:' directive"), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='find')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])])])], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value=':class:`dict`-like structure mapping from package names to directories where their'), Constant(value='code can be found.'), Constant(value='The empty string (as key) means that all packages are contained inside'), Constant(value='the given directory will be included in the distribution.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='const')], values=[Constant(value='')]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns.'), Constant(value='Usually this option is not needed when using ``include-package-data = true``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type')], values=[List(elts=[Constant(value='Automatically include any data files inside the package directories'), Constant(value='that are specified by ``MANIFEST.in``'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='boolean')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='propertyNames'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping from package names to lists of glob patterns that should be excluded'), Constant(value='For more information on how to include data files, check ``setuptools`` `docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='const')], values=[Constant(value='*')])], ctx=Load())]), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='https://setuptools.pypa.io/en/latest/userguide/package_discovery.html')]), Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items'), Constant(value='$comment')], values=[Constant(value='Modules that setuptools will manipulate'), Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-module-name')]), Constant(value='TODO: clarify the relationship with ``packages``')]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='**DEPRECATED**: dict-like structure where each key represents a directory and'), Constant(value='the value is a list of glob patterns that should be installed in them.'), Constant(value="Please notice this don't work with wheels. See `data files support"), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])]), Dict(keys=[Constant(value='$$description'), Constant(value='type'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Mapping of distutils-style command names to ``setuptools.Command`` subclasses'), Constant(value='which in turn should be represented by strings with a qualified class name'), Constant(value='(i.e., "dotted" form with module), e.g.::\n\n'), Constant(value='    cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n'), Constant(value='The command class should be a directly defined at the top-level of the'), Constant(value='containing module (no class nesting).')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='^.*$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='python-qualified-identifier')])])]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), List(elts=[Constant(value='PROVISIONAL: List of glob patterns for all license files being distributed.'), Constant(value='(might become standard with PEP 639).'), Constant(value="By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``")], ctx=Load()), Constant(value='TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), Constant(value='Instructions for loading :pep:`621`-related metadata dynamically'), Constant(value=False), Dict(keys=[Constant(value='version'), Constant(value='classifiers'), Constant(value='description'), Constant(value='dependencies'), Constant(value='entry-points'), Constant(value='optional-dependencies'), Constant(value='readme')], values=[Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='A version dynamically loaded via either the ``attr:`` or ``file:``'), Constant(value='directives. Please make sure the given file or attribute respects :pep:`440`.')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Dict(keys=[Constant(value='format')], values=[Constant(value='python-identifier')]), Constant(value=False), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])])]), Dict(keys=[Constant(value='anyOf'), Constant(value='required')], values=[List(elts=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])])], ctx=Load()), List(elts=[Constant(value='file')], ctx=Load())])])])]), Dict(keys=[Constant(value='package-name'), Constant(value='file-directive'), Constant(value='attr-directive'), Constant(value='find-directive')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/find-directive'), Constant(value="'find:' directive"), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='find')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])])])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be object'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='file')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=" must contain ['file'] properties"))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[]), Assign(targets=[Name(id='data_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='file'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='file')], keywords=[])), Assign(targets=[Name(id='data__file', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='file'), ctx=Load())), Assign(targets=[Name(id='data__file_one_of_count7', ctx=Store())], value=Constant(value=0)), If(test=Compare(left=Name(id='data__file_one_of_count7', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__file', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.file must be string'))], keywords=[keyword(arg='value', value=Name(id='data__file', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.file'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), AugAssign(target=Name(id='data__file_one_of_count7', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__file_one_of_count7', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__file', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.file must be array'))], keywords=[keyword(arg='value', value=Name(id='data__file', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.file'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__file_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__file', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__file_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__file_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__file', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__file_x', ctx=Store()), Name(id='data__file_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__file', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__file_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.file[{data__file_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__file_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.file[{data__file_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[]), AugAssign(target=Name(id='data__file_one_of_count7', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__file_one_of_count7', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.file must be valid exactly by one definition')), op=Add(), right=BinOp(left=BinOp(left=Constant(value=' ('), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__file_one_of_count7', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' matches found)')))], keywords=[keyword(arg='value', value=Name(id='data__file', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.file'))), keyword(arg='definition', value=Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])), keyword(arg='rule', value=Constant(value='oneOf'))]))], orelse=[])], orelse=[]), If(test=Name(id='data_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='#/definitions/file-directive'), Constant(value="'file:' directive"), Constant(value='Value is read from a file (or list of files and then concatenated)'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='oneOf')], values=[List(elts=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_attr_directive', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be object'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='attr')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=" must contain ['attr'] properties"))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[]), Assign(targets=[Name(id='data_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='attr'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='attr')], keywords=[])), Assign(targets=[Name(id='data__attr', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='attr'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__attr', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.attr must be string'))], keywords=[keyword(arg='value', value=Name(id='data__attr', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.attr'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[]), If(test=Name(id='data_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='title'), Constant(value='$id'), Constant(value='$$description'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties'), Constant(value='required')], values=[Constant(value="'attr:' directive"), Constant(value='#/definitions/attr-directive'), List(elts=[Constant(value='Value is read from a module attribute. Supports callables and iterables;'), Constant(value='unsupported types are cast via ``str()``')], ctx=Load()), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='attr')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), List(elts=[Constant(value='attr')], ctx=Load())])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_find_directive', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be object'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/find-directive'), Constant(value="'find:' directive"), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='find')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='find'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='find')], keywords=[])), Assign(targets=[Name(id='data__find', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='find'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find must be object'))], keywords=[keyword(arg='value', value=Name(id='data__find', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__find_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__find_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__find_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__find', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='where'), ops=[In()], comparators=[Name(id='data__find_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__find_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='where')], keywords=[])), Assign(targets=[Name(id='data__find__where', ctx=Store())], value=Subscript(value=Name(id='data__find', ctx=Load()), slice=Constant(value='where'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find__where', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find.where must be array'))], keywords=[keyword(arg='value', value=Name(id='data__find__where', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find.where'))), keyword(arg='definition', value=Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__find__where_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find__where', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__find__where_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__find__where_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__find__where', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__find__where_x', ctx=Store()), Name(id='data__find__where_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__find__where', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find__where_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.find.where[{data__find__where_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__find__where_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.find.where[{data__find__where_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='exclude'), ops=[In()], comparators=[Name(id='data__find_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__find_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='exclude')], keywords=[])), Assign(targets=[Name(id='data__find__exclude', ctx=Store())], value=Subscript(value=Name(id='data__find', ctx=Load()), slice=Constant(value='exclude'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find__exclude', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find.exclude must be array'))], keywords=[keyword(arg='value', value=Name(id='data__find__exclude', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find.exclude'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__find__exclude_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find__exclude', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__find__exclude_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__find__exclude_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__find__exclude', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__find__exclude_x', ctx=Store()), Name(id='data__find__exclude_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__find__exclude', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find__exclude_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.find.exclude[{data__find__exclude_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__find__exclude_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.find.exclude[{data__find__exclude_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='include'), ops=[In()], comparators=[Name(id='data__find_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__find_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='include')], keywords=[])), Assign(targets=[Name(id='data__find__include', ctx=Store())], value=Subscript(value=Name(id='data__find', ctx=Load()), slice=Constant(value='include'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find__include', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find.include must be array'))], keywords=[keyword(arg='value', value=Name(id='data__find__include', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find.include'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__find__include_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find__include', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__find__include_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__find__include_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__find__include', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__find__include_x', ctx=Store()), Name(id='data__find__include_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__find__include', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find__include_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.find.include[{data__find__include_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__find__include_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.find.include[{data__find__include_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='namespaces'), ops=[In()], comparators=[Name(id='data__find_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__find_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='namespaces')], keywords=[])), Assign(targets=[Name(id='data__find__namespaces', ctx=Store())], value=Subscript(value=Name(id='data__find', ctx=Load()), slice=Constant(value='namespaces'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__find__namespaces', ctx=Load()), Name(id='bool', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find.namespaces must be boolean'))], keywords=[keyword(arg='value', value=Name(id='data__find__namespaces', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find.namespaces'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[]), If(test=Name(id='data__find_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__find_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data__find', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.find'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/find-directive'), Constant(value="'find:' directive"), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='find')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='object'), List(elts=[Constant(value='Dynamic `package discovery'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='where'), Constant(value='exclude'), Constant(value='include'), Constant(value='namespaces')], values=[Dict(keys=[Constant(value='description'), Constant(value='type'), Constant(value='items')], values=[Constant(value='Directories to be searched for packages (Unix-style relative path)'), Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Exclude packages that match the values listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Restrict the found packages to just the ones listed in this field.'), Constant(value="Can container shell-style wildcards (e.g. ``'pkg.*'``)")], ctx=Load()), Dict(keys=[Constant(value='type')], values=[Constant(value='string')])]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='boolean'), List(elts=[Constant(value='When ``True``, directories without a ``__init__.py`` file will also'), Constant(value='be scanned for :pep:`420`-style implicit namespaces')], ctx=Load())])])])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_package_name', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data_any_of_count8', ctx=Store())], value=Constant(value=0)), If(test=UnaryOp(op=Not(), operand=Name(id='data_any_of_count8', ctx=Load())), body=[Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='python-module-name'), ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be python-module-name'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[]), AugAssign(target=Name(id='data_any_of_count8', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data_any_of_count8', ctx=Load())), body=[Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='pep561-stub-name'), ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be pep561-stub-name'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[]), AugAssign(target=Name(id='data_any_of_count8', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data_any_of_count8', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' cannot be validated by any definition'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='description'), Constant(value='type'), Constant(value='anyOf')], values=[Constant(value='#/definitions/package-name'), Constant(value='Valid package name'), Constant(value='Valid package name (importable or PEP 561).'), Constant(value='string'), List(elts=[Dict(keys=[Constant(value='format')], values=[Constant(value='python-module-name')]), Dict(keys=[Constant(value='format')], values=[Constant(value='pep561-stub-name')])], ctx=Load())])), keyword(arg='rule', value=Constant(value='anyOf'))]))], orelse=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___docs_python_org_3_install', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be object'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='patternProperties'), Constant(value='$comment')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://docs.python.org/3/install/'), Constant(value='``tool.distutils`` table'), List(elts=[Constant(value='Originally, ``distutils`` allowed developers to configure arguments for'), Constant(value='``setup.py`` scripts via `distutils configuration files'), Constant(value='<https://docs.python.org/3/install/#distutils-configuration-files>`_.'), Constant(value='``tool.distutils`` subtables could be used with the same purpose'), Constant(value='(NOT CURRENTLY IMPLEMENTED).')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='global')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='object'), Constant(value='Global options applied to all ``distutils`` commands')])]), Dict(keys=[Constant(value='.+')], values=[Dict(keys=[Constant(value='type')], values=[Constant(value='object')])]), Constant(value='TODO: Is there a practical way of making this schema more specific?')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='global'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='global')], keywords=[])), Assign(targets=[Name(id='data__global', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='global'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__global', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.global must be object'))], keywords=[keyword(arg='value', value=Name(id='data__global', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.global'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='object'), Constant(value='Global options applied to all ``distutils`` commands')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[]), For(target=Tuple(elts=[Name(id='data_key', ctx=Store()), Name(id='data_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='.+'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data_key', ctx=Load()), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data_key', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data_val', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.{data_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be object'))], keywords=[keyword(arg='value', value=Name(id='data_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.{data_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='object')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be object'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='required'), Constant(value='additionalProperties'), Constant(value='if'), Constant(value='then'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://packaging.python.org/en/latest/specifications/declaring-project-metadata/'), Constant(value='Package metadata stored in the ``project`` table'), List(elts=[Constant(value='Data structure for the **project** table inside ``pyproject.toml``'), Constant(value='(as initially defined in :pep:`621`)')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='name'), Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The name (primary identifier) of the project. MUST be statically defined.'), Constant(value='pep508-identifier')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The version of the project as supported by :pep:`440`.'), Constant(value='pep440')]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The `summary description of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#summary>`_')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='`Full/detailed description of the project in the form of a README'), Constant(value='<https://peps.python.org/pep-0621/#readme>`_'), Constant(value="with meaning similar to the one defined in `core metadata's Description"), Constant(value='<https://packaging.python.org/specifications/core-metadata/#description>`_')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file (UTF-8) containing the full description'), Constant(value='of the project. If the file path ends in case-insensitive ``.md`` or'), Constant(value='``.rst`` suffixes, then the content-type is respectively'), Constant(value='``text/markdown`` or ``text/x-rst``')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='allOf')], values=[Constant(value='object'), List(elts=[Dict(keys=[Constant(value='anyOf')], values=[List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])]), List(elts=[Constant(value='content-type')], ctx=Load())])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='$$description')], values=[Constant(value='string'), Constant(value='pep508-versionspec'), List(elts=[Constant(value='`The Python version requirements of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.')], ctx=Load())]), Dict(keys=[Constant(value='description'), Constant(value='oneOf')], values=[Constant(value='`Project license <https://peps.python.org/pep-0621/#license>`_.'), List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to the file (UTF-8) which contains the license for the'), Constant(value='project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The license of the project whose meaning is that of the'), Constant(value='`License field from the core metadata'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#license>`_.')], ctx=Load())])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), List(elts=[Constant(value="The people or organizations considered to be the 'authors' of the project."), Constant(value='The exact meaning is open to interpretation (e.g. original or primary authors,'), Constant(value='current maintainers, or owners of the package).')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), List(elts=[Constant(value="The people or organizations considered to be the 'maintainers' of the project."), Constant(value='Similarly to ``authors``, the exact meaning is open to interpretation.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='List of keywords to assist searching for the distribution in a larger catalog.')]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='trove-classifier'), Constant(value='`PyPI classifier <https://pypi.org/classifiers/>`_.')]), List(elts=[Constant(value='`Trove classifiers <https://pypi.org/classifiers/>`_'), Constant(value='which apply to the project.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='URLs associated with the project in the form ``label => value``.'), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Instruct the installer to expose the given modules/functions via'), Constant(value='``entry-point`` discovery mechanism (useful for plugins).'), Constant(value='More information available in the `Python packaging guide'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-group')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])])])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='items')], values=[Constant(value='array'), Constant(value='Project (mandatory) dependencies.'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='Optional dependency for the project'), Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Specifies which fields are intentionally unspecified and expected to be'), Constant(value='dynamically provided by build tools')], ctx=Load()), Dict(keys=[Constant(value='enum')], values=[List(elts=[Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies')], ctx=Load())])])]), List(elts=[Constant(value='name')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='not'), Constant(value='$$comment')], values=[Dict(keys=[Constant(value='required'), Constant(value='properties')], values=[List(elts=[Constant(value='dynamic')], ctx=Load()), Dict(keys=[Constant(value='dynamic')], values=[Dict(keys=[Constant(value='contains'), Constant(value='$$description')], values=[Dict(keys=[Constant(value='const')], values=[Constant(value='version')]), List(elts=[Constant(value='version is listed in ``dynamic``')], ctx=Load())])])]), List(elts=[Constant(value='According to :pep:`621`:'), Constant(value='    If the core metadata specification lists a field as "Required", then'), Constant(value='    the metadata MUST specify the field statically or list it in dynamic'), Constant(value='In turn, `core metadata`_ defines:'), Constant(value='    The required fields are: Metadata-Version, Name, Version.'), Constant(value='    All the other fields are optional.'), Constant(value='Since ``Metadata-Version`` is defined by the build back-end, ``name`` and'), Constant(value='``version`` are the only mandatory information in ``pyproject.toml``.'), Constant(value='.. _core metadata: https://packaging.python.org/specifications/core-metadata/')], ctx=Load())]), Dict(keys=[Constant(value='required'), Constant(value='$$description')], values=[List(elts=[Constant(value='version')], ctx=Load()), List(elts=[Constant(value='version should be statically defined in the ``version`` field')], ctx=Load())]), Dict(keys=[Constant(value='author'), Constant(value='entry-point-group'), Constant(value='dependency')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='name')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=" must contain ['name'] properties"))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='required'), Constant(value='additionalProperties'), Constant(value='if'), Constant(value='then'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://packaging.python.org/en/latest/specifications/declaring-project-metadata/'), Constant(value='Package metadata stored in the ``project`` table'), List(elts=[Constant(value='Data structure for the **project** table inside ``pyproject.toml``'), Constant(value='(as initially defined in :pep:`621`)')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='name'), Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The name (primary identifier) of the project. MUST be statically defined.'), Constant(value='pep508-identifier')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The version of the project as supported by :pep:`440`.'), Constant(value='pep440')]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The `summary description of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#summary>`_')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='`Full/detailed description of the project in the form of a README'), Constant(value='<https://peps.python.org/pep-0621/#readme>`_'), Constant(value="with meaning similar to the one defined in `core metadata's Description"), Constant(value='<https://packaging.python.org/specifications/core-metadata/#description>`_')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file (UTF-8) containing the full description'), Constant(value='of the project. If the file path ends in case-insensitive ``.md`` or'), Constant(value='``.rst`` suffixes, then the content-type is respectively'), Constant(value='``text/markdown`` or ``text/x-rst``')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='allOf')], values=[Constant(value='object'), List(elts=[Dict(keys=[Constant(value='anyOf')], values=[List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])]), List(elts=[Constant(value='content-type')], ctx=Load())])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='$$description')], values=[Constant(value='string'), Constant(value='pep508-versionspec'), List(elts=[Constant(value='`The Python version requirements of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.')], ctx=Load())]), Dict(keys=[Constant(value='description'), Constant(value='oneOf')], values=[Constant(value='`Project license <https://peps.python.org/pep-0621/#license>`_.'), List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to the file (UTF-8) which contains the license for the'), Constant(value='project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The license of the project whose meaning is that of the'), Constant(value='`License field from the core metadata'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#license>`_.')], ctx=Load())])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), List(elts=[Constant(value="The people or organizations considered to be the 'authors' of the project."), Constant(value='The exact meaning is open to interpretation (e.g. original or primary authors,'), Constant(value='current maintainers, or owners of the package).')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), List(elts=[Constant(value="The people or organizations considered to be the 'maintainers' of the project."), Constant(value='Similarly to ``authors``, the exact meaning is open to interpretation.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='List of keywords to assist searching for the distribution in a larger catalog.')]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='trove-classifier'), Constant(value='`PyPI classifier <https://pypi.org/classifiers/>`_.')]), List(elts=[Constant(value='`Trove classifiers <https://pypi.org/classifiers/>`_'), Constant(value='which apply to the project.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='URLs associated with the project in the form ``label => value``.'), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Instruct the installer to expose the given modules/functions via'), Constant(value='``entry-point`` discovery mechanism (useful for plugins).'), Constant(value='More information available in the `Python packaging guide'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-group')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])])])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='items')], values=[Constant(value='array'), Constant(value='Project (mandatory) dependencies.'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='Optional dependency for the project'), Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Specifies which fields are intentionally unspecified and expected to be'), Constant(value='dynamically provided by build tools')], ctx=Load()), Dict(keys=[Constant(value='enum')], values=[List(elts=[Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies')], ctx=Load())])])]), List(elts=[Constant(value='name')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='not'), Constant(value='$$comment')], values=[Dict(keys=[Constant(value='required'), Constant(value='properties')], values=[List(elts=[Constant(value='dynamic')], ctx=Load()), Dict(keys=[Constant(value='dynamic')], values=[Dict(keys=[Constant(value='contains'), Constant(value='$$description')], values=[Dict(keys=[Constant(value='const')], values=[Constant(value='version')]), List(elts=[Constant(value='version is listed in ``dynamic``')], ctx=Load())])])]), List(elts=[Constant(value='According to :pep:`621`:'), Constant(value='    If the core metadata specification lists a field as "Required", then'), Constant(value='    the metadata MUST specify the field statically or list it in dynamic'), Constant(value='In turn, `core metadata`_ defines:'), Constant(value='    The required fields are: Metadata-Version, Name, Version.'), Constant(value='    All the other fields are optional.'), Constant(value='Since ``Metadata-Version`` is defined by the build back-end, ``name`` and'), Constant(value='``version`` are the only mandatory information in ``pyproject.toml``.'), Constant(value='.. _core metadata: https://packaging.python.org/specifications/core-metadata/')], ctx=Load())]), Dict(keys=[Constant(value='required'), Constant(value='$$description')], values=[List(elts=[Constant(value='version')], ctx=Load()), List(elts=[Constant(value='version should be statically defined in the ``version`` field')], ctx=Load())]), Dict(keys=[Constant(value='author'), Constant(value='entry-point-group'), Constant(value='dependency')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[]), Assign(targets=[Name(id='data_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='name'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='name')], keywords=[])), Assign(targets=[Name(id='data__name', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='name'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__name', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.name must be string'))], keywords=[keyword(arg='value', value=Name(id='data__name', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.name'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The name (primary identifier) of the project. MUST be statically defined.'), Constant(value='pep508-identifier')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__name', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='pep508-identifier'), ctx=Load()), args=[Name(id='data__name', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.name must be pep508-identifier'))], keywords=[keyword(arg='value', value=Name(id='data__name', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.name'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The name (primary identifier) of the project. MUST be statically defined.'), Constant(value='pep508-identifier')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='version'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='version')], keywords=[])), Assign(targets=[Name(id='data__version', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='version'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__version', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.version must be string'))], keywords=[keyword(arg='value', value=Name(id='data__version', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.version'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The version of the project as supported by :pep:`440`.'), Constant(value='pep440')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__version', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='pep440'), ctx=Load()), args=[Name(id='data__version', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.version must be pep440'))], keywords=[keyword(arg='value', value=Name(id='data__version', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.version'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The version of the project as supported by :pep:`440`.'), Constant(value='pep440')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='description'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='description')], keywords=[])), Assign(targets=[Name(id='data__description', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='description'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__description', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.description must be string'))], keywords=[keyword(arg='value', value=Name(id='data__description', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.description'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The `summary description of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#summary>`_')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='readme'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='readme')], keywords=[])), Assign(targets=[Name(id='data__readme', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='readme'), ctx=Load())), Assign(targets=[Name(id='data__readme_one_of_count9', ctx=Store())], value=Constant(value=0)), If(test=Compare(left=Name(id='data__readme_one_of_count9', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__readme', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme must be string'))], keywords=[keyword(arg='value', value=Name(id='data__readme', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file (UTF-8) containing the full description'), Constant(value='of the project. If the file path ends in case-insensitive ``.md`` or'), Constant(value='``.rst`` suffixes, then the content-type is respectively'), Constant(value='``text/markdown`` or ``text/x-rst``')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), AugAssign(target=Name(id='data__readme_one_of_count9', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__readme_one_of_count9', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__readme', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme must be object'))], keywords=[keyword(arg='value', value=Name(id='data__readme', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='allOf')], values=[Constant(value='object'), List(elts=[Dict(keys=[Constant(value='anyOf')], values=[List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])]), List(elts=[Constant(value='content-type')], ctx=Load())])], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__readme_any_of_count10', ctx=Store())], value=Constant(value=0)), If(test=UnaryOp(op=Not(), operand=Name(id='data__readme_any_of_count10', ctx=Load())), body=[Try(body=[Assign(targets=[Name(id='data__readme_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__readme', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__readme_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__readme_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__readme', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data__readme', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='file')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=".readme must contain ['file'] properties"))], keywords=[keyword(arg='value', value=Name(id='data__readme', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme'))), keyword(arg='definition', value=Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[]), Assign(targets=[Name(id='data__readme_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__readme', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='file'), ops=[In()], comparators=[Name(id='data__readme_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__readme_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='file')], keywords=[])), Assign(targets=[Name(id='data__readme__file', ctx=Store())], value=Subscript(value=Name(id='data__readme', ctx=Load()), slice=Constant(value='file'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__readme__file', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme.file must be string'))], keywords=[keyword(arg='value', value=Name(id='data__readme__file', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme.file'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[]), AugAssign(target=Name(id='data__readme_any_of_count10', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__readme_any_of_count10', ctx=Load())), body=[Try(body=[Assign(targets=[Name(id='data__readme_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__readme', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__readme_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__readme_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__readme', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data__readme', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='text')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=".readme must contain ['text'] properties"))], keywords=[keyword(arg='value', value=Name(id='data__readme', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme'))), keyword(arg='definition', value=Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[]), Assign(targets=[Name(id='data__readme_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__readme', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='text'), ops=[In()], comparators=[Name(id='data__readme_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__readme_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='text')], keywords=[])), Assign(targets=[Name(id='data__readme__text', ctx=Store())], value=Subscript(value=Name(id='data__readme', ctx=Load()), slice=Constant(value='text'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__readme__text', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme.text must be string'))], keywords=[keyword(arg='value', value=Name(id='data__readme__text', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme.text'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[]), AugAssign(target=Name(id='data__readme_any_of_count10', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__readme_any_of_count10', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme cannot be validated by any definition'))], keywords=[keyword(arg='value', value=Name(id='data__readme', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme'))), keyword(arg='definition', value=Dict(keys=[Constant(value='anyOf')], values=[List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())])), keyword(arg='rule', value=Constant(value='anyOf'))]))], orelse=[]), Assign(targets=[Name(id='data__readme_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__readme', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__readme_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__readme_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__readme', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data__readme', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='content-type')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=".readme must contain ['content-type'] properties"))], keywords=[keyword(arg='value', value=Name(id='data__readme', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme'))), keyword(arg='definition', value=Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])]), List(elts=[Constant(value='content-type')], ctx=Load())])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[]), Assign(targets=[Name(id='data__readme_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__readme', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='content-type'), ops=[In()], comparators=[Name(id='data__readme_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__readme_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='content-type')], keywords=[])), Assign(targets=[Name(id='data__readme__contenttype', ctx=Store())], value=Subscript(value=Name(id='data__readme', ctx=Load()), slice=Constant(value='content-type'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__readme__contenttype', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme.content-type must be string'))], keywords=[keyword(arg='value', value=Name(id='data__readme__contenttype', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme.content-type'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[]), AugAssign(target=Name(id='data__readme_one_of_count9', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__readme_one_of_count9', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme must be valid exactly by one definition')), op=Add(), right=BinOp(left=BinOp(left=Constant(value=' ('), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__readme_one_of_count9', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' matches found)')))], keywords=[keyword(arg='value', value=Name(id='data__readme', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.readme'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='`Full/detailed description of the project in the form of a README'), Constant(value='<https://peps.python.org/pep-0621/#readme>`_'), Constant(value="with meaning similar to the one defined in `core metadata's Description"), Constant(value='<https://packaging.python.org/specifications/core-metadata/#description>`_')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file (UTF-8) containing the full description'), Constant(value='of the project. If the file path ends in case-insensitive ``.md`` or'), Constant(value='``.rst`` suffixes, then the content-type is respectively'), Constant(value='``text/markdown`` or ``text/x-rst``')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='allOf')], values=[Constant(value='object'), List(elts=[Dict(keys=[Constant(value='anyOf')], values=[List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])]), List(elts=[Constant(value='content-type')], ctx=Load())])], ctx=Load())])], ctx=Load())])), keyword(arg='rule', value=Constant(value='oneOf'))]))], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='requires-python'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='requires-python')], keywords=[])), Assign(targets=[Name(id='data__requirespython', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='requires-python'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__requirespython', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.requires-python must be string'))], keywords=[keyword(arg='value', value=Name(id='data__requirespython', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.requires-python'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='$$description')], values=[Constant(value='string'), Constant(value='pep508-versionspec'), List(elts=[Constant(value='`The Python version requirements of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__requirespython', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='pep508-versionspec'), ctx=Load()), args=[Name(id='data__requirespython', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.requires-python must be pep508-versionspec'))], keywords=[keyword(arg='value', value=Name(id='data__requirespython', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.requires-python'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='$$description')], values=[Constant(value='string'), Constant(value='pep508-versionspec'), List(elts=[Constant(value='`The Python version requirements of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.')], ctx=Load())])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='license'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='license')], keywords=[])), Assign(targets=[Name(id='data__license', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='license'), ctx=Load())), Assign(targets=[Name(id='data__license_one_of_count11', ctx=Store())], value=Constant(value=0)), If(test=Compare(left=Name(id='data__license_one_of_count11', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[Assign(targets=[Name(id='data__license_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__license', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__license_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__license_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__license', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data__license', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='file')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=".license must contain ['file'] properties"))], keywords=[keyword(arg='value', value=Name(id='data__license', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.license'))), keyword(arg='definition', value=Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to the file (UTF-8) which contains the license for the'), Constant(value='project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[]), Assign(targets=[Name(id='data__license_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__license', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='file'), ops=[In()], comparators=[Name(id='data__license_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__license_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='file')], keywords=[])), Assign(targets=[Name(id='data__license__file', ctx=Store())], value=Subscript(value=Name(id='data__license', ctx=Load()), slice=Constant(value='file'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__license__file', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.license.file must be string'))], keywords=[keyword(arg='value', value=Name(id='data__license__file', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.license.file'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to the file (UTF-8) which contains the license for the'), Constant(value='project.')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[]), AugAssign(target=Name(id='data__license_one_of_count11', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__license_one_of_count11', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), body=[Try(body=[Assign(targets=[Name(id='data__license_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__license', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__license_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__license_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__license', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data__license', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='text')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=".license must contain ['text'] properties"))], keywords=[keyword(arg='value', value=Name(id='data__license', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.license'))), keyword(arg='definition', value=Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The license of the project whose meaning is that of the'), Constant(value='`License field from the core metadata'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#license>`_.')], ctx=Load())])]), List(elts=[Constant(value='text')], ctx=Load())])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[]), Assign(targets=[Name(id='data__license_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__license', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='text'), ops=[In()], comparators=[Name(id='data__license_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__license_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='text')], keywords=[])), Assign(targets=[Name(id='data__license__text', ctx=Store())], value=Subscript(value=Name(id='data__license', ctx=Load()), slice=Constant(value='text'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__license__text', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.license.text must be string'))], keywords=[keyword(arg='value', value=Name(id='data__license__text', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.license.text'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The license of the project whose meaning is that of the'), Constant(value='`License field from the core metadata'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#license>`_.')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[]), AugAssign(target=Name(id='data__license_one_of_count11', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='data__license_one_of_count11', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.license must be valid exactly by one definition')), op=Add(), right=BinOp(left=BinOp(left=Constant(value=' ('), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__license_one_of_count11', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' matches found)')))], keywords=[keyword(arg='value', value=Name(id='data__license', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.license'))), keyword(arg='definition', value=Dict(keys=[Constant(value='description'), Constant(value='oneOf')], values=[Constant(value='`Project license <https://peps.python.org/pep-0621/#license>`_.'), List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to the file (UTF-8) which contains the license for the'), Constant(value='project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The license of the project whose meaning is that of the'), Constant(value='`License field from the core metadata'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#license>`_.')], ctx=Load())])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())])), keyword(arg='rule', value=Constant(value='oneOf'))]))], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='authors'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='authors')], keywords=[])), Assign(targets=[Name(id='data__authors', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='authors'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__authors', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.authors must be array'))], keywords=[keyword(arg='value', value=Name(id='data__authors', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.authors'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), List(elts=[Constant(value="The people or organizations considered to be the 'authors' of the project."), Constant(value='The exact meaning is open to interpretation (e.g. original or primary authors,'), Constant(value='current maintainers, or owners of the package).')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__authors_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__authors', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__authors_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__authors_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__authors', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__authors_x', ctx=Store()), Name(id='data__authors_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__authors', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_author', ctx=Load()), args=[Name(id='data__authors_item', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Call(func=Attribute(value=Constant(value='.authors[{data__authors_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))]))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='maintainers'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='maintainers')], keywords=[])), Assign(targets=[Name(id='data__maintainers', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='maintainers'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__maintainers', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.maintainers must be array'))], keywords=[keyword(arg='value', value=Name(id='data__maintainers', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.maintainers'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), List(elts=[Constant(value="The people or organizations considered to be the 'maintainers' of the project."), Constant(value='Similarly to ``authors``, the exact meaning is open to interpretation.')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__maintainers_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__maintainers', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__maintainers_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__maintainers_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__maintainers', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__maintainers_x', ctx=Store()), Name(id='data__maintainers_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__maintainers', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_author', ctx=Load()), args=[Name(id='data__maintainers_item', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Call(func=Attribute(value=Constant(value='.maintainers[{data__maintainers_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))]))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='keywords'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='keywords')], keywords=[])), Assign(targets=[Name(id='data__keywords', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='keywords'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__keywords', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.keywords must be array'))], keywords=[keyword(arg='value', value=Name(id='data__keywords', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.keywords'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='List of keywords to assist searching for the distribution in a larger catalog.')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__keywords_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__keywords', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__keywords_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__keywords_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__keywords', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__keywords_x', ctx=Store()), Name(id='data__keywords_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__keywords', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__keywords_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.keywords[{data__keywords_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__keywords_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.keywords[{data__keywords_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type')], values=[Constant(value='string')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='classifiers'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='classifiers')], keywords=[])), Assign(targets=[Name(id='data__classifiers', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='classifiers'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__classifiers', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.classifiers must be array'))], keywords=[keyword(arg='value', value=Name(id='data__classifiers', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.classifiers'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='trove-classifier'), Constant(value='`PyPI classifier <https://pypi.org/classifiers/>`_.')]), List(elts=[Constant(value='`Trove classifiers <https://pypi.org/classifiers/>`_'), Constant(value='which apply to the project.')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__classifiers_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__classifiers', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__classifiers_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__classifiers_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__classifiers', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__classifiers_x', ctx=Store()), Name(id='data__classifiers_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__classifiers', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__classifiers_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.classifiers[{data__classifiers_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__classifiers_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.classifiers[{data__classifiers_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='trove-classifier'), Constant(value='`PyPI classifier <https://pypi.org/classifiers/>`_.')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__classifiers_item', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='trove-classifier'), ctx=Load()), args=[Name(id='data__classifiers_item', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.classifiers[{data__classifiers_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be trove-classifier'))], keywords=[keyword(arg='value', value=Name(id='data__classifiers_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.classifiers[{data__classifiers_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='trove-classifier'), Constant(value='`PyPI classifier <https://pypi.org/classifiers/>`_.')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='urls'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='urls')], keywords=[])), Assign(targets=[Name(id='data__urls', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='urls'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__urls', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.urls must be object'))], keywords=[keyword(arg='value', value=Name(id='data__urls', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.urls'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='URLs associated with the project in the form ``label => value``.'), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__urls_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__urls', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__urls_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__urls_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__urls', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='data__urls_key', ctx=Store()), Name(id='data__urls_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data__urls', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='^.+$'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data__urls_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data__urls_key', ctx=Load()), ops=[In()], comparators=[Name(id='data__urls_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__urls_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data__urls_key', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__urls_val', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.urls.{data__urls_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data__urls_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.urls.{data__urls_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__urls_val', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='url'), ctx=Load()), args=[Name(id='data__urls_val', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.urls.{data__urls_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be url'))], keywords=[keyword(arg='value', value=Name(id='data__urls_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.urls.{data__urls_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data__urls_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.urls must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__urls_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data__urls', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.urls'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='URLs associated with the project in the form ``label => value``.'), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='scripts'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='scripts')], keywords=[])), Assign(targets=[Name(id='data__scripts', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='scripts'), ctx=Load())), Expr(value=Call(func=Name(id='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_entry_point_group', ctx=Load()), args=[Name(id='data__scripts', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.scripts'))], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='gui-scripts'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='gui-scripts')], keywords=[])), Assign(targets=[Name(id='data__guiscripts', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='gui-scripts'), ctx=Load())), Expr(value=Call(func=Name(id='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_entry_point_group', ctx=Load()), args=[Name(id='data__guiscripts', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Constant(value='.gui-scripts'))], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='entry-points'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='entry-points')], keywords=[])), Assign(targets=[Name(id='data__entrypoints', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='entry-points'), ctx=Load())), Assign(targets=[Name(id='data__entrypoints_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__entrypoints', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__entrypoints_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__entrypoints_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__entrypoints', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='data__entrypoints_key', ctx=Store()), Name(id='data__entrypoints_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data__entrypoints', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='^.+$'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data__entrypoints_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data__entrypoints_key', ctx=Load()), ops=[In()], comparators=[Name(id='data__entrypoints_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__entrypoints_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data__entrypoints_key', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_entry_point_group', ctx=Load()), args=[Name(id='data__entrypoints_val', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Call(func=Attribute(value=Constant(value='.entry-points.{data__entrypoints_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))]))], keywords=[]))], orelse=[])], orelse=[]), If(test=Name(id='data__entrypoints_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.entry-points must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__entrypoints_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data__entrypoints', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.entry-points'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Instruct the installer to expose the given modules/functions via'), Constant(value='``entry-point`` discovery mechanism (useful for plugins).'), Constant(value='More information available in the `Python packaging guide'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-group')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[]), Assign(targets=[Name(id='data__entrypoints_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__entrypoints', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='data__entrypoints_len', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='data__entrypoints_property_names', ctx=Store())], value=Constant(value=True)), For(target=Name(id='data__entrypoints_key', ctx=Store()), iter=Name(id='data__entrypoints', ctx=Load()), body=[Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__entrypoints_key', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='python-entrypoint-group'), ctx=Load()), args=[Name(id='data__entrypoints_key', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.entry-points must be python-entrypoint-group'))], keywords=[keyword(arg='value', value=Name(id='data__entrypoints_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.entry-points'))), keyword(arg='definition', value=Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-group')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Assign(targets=[Name(id='data__entrypoints_property_names', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__entrypoints_property_names', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.entry-points must be named by propertyName definition'))], keywords=[keyword(arg='value', value=Name(id='data__entrypoints', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.entry-points'))), keyword(arg='definition', value=Dict(keys=[Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Instruct the installer to expose the given modules/functions via'), Constant(value='``entry-point`` discovery mechanism (useful for plugins).'), Constant(value='More information available in the `Python packaging guide'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-group')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])])])])), keyword(arg='rule', value=Constant(value='propertyNames'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='dependencies'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='dependencies')], keywords=[])), Assign(targets=[Name(id='data__dependencies', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='dependencies'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dependencies', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dependencies must be array'))], keywords=[keyword(arg='value', value=Name(id='data__dependencies', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dependencies'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='items')], values=[Constant(value='array'), Constant(value='Project (mandatory) dependencies.'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__dependencies_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dependencies', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__dependencies_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__dependencies_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__dependencies', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__dependencies_x', ctx=Store()), Name(id='data__dependencies_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__dependencies', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_dependency', ctx=Load()), args=[Name(id='data__dependencies_item', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Call(func=Attribute(value=Constant(value='.dependencies[{data__dependencies_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))]))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='optional-dependencies'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='optional-dependencies')], keywords=[])), Assign(targets=[Name(id='data__optionaldependencies', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='optional-dependencies'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__optionaldependencies', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.optional-dependencies must be object'))], keywords=[keyword(arg='value', value=Name(id='data__optionaldependencies', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.optional-dependencies'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='Optional dependency for the project'), Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__optionaldependencies_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__optionaldependencies', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data__optionaldependencies_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data__optionaldependencies_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data__optionaldependencies', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='data__optionaldependencies_key', ctx=Store()), Name(id='data__optionaldependencies_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data__optionaldependencies', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='^.+$'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data__optionaldependencies_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data__optionaldependencies_key', ctx=Load()), ops=[In()], comparators=[Name(id='data__optionaldependencies_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data__optionaldependencies_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data__optionaldependencies_key', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__optionaldependencies_val', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.optional-dependencies.{data__optionaldependencies_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be array'))], keywords=[keyword(arg='value', value=Name(id='data__optionaldependencies_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.optional-dependencies.{data__optionaldependencies_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__optionaldependencies_val_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__optionaldependencies_val', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__optionaldependencies_val_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__optionaldependencies_val_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__optionaldependencies_val', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__optionaldependencies_val_x', ctx=Store()), Name(id='data__optionaldependencies_val_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__optionaldependencies_val', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_dependency', ctx=Load()), args=[Name(id='data__optionaldependencies_val_item', ctx=Load()), Name(id='custom_formats', ctx=Load()), BinOp(left=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')]), op=Add(), right=Call(func=Attribute(value=Constant(value='.optional-dependencies.{data__optionaldependencies_key}[{data__optionaldependencies_val_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))]))], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data__optionaldependencies_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.optional-dependencies must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data__optionaldependencies_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data__optionaldependencies', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.optional-dependencies'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='Optional dependency for the project'), Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[]), Assign(targets=[Name(id='data__optionaldependencies_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__optionaldependencies', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='data__optionaldependencies_len', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='data__optionaldependencies_property_names', ctx=Store())], value=Constant(value=True)), For(target=Name(id='data__optionaldependencies_key', ctx=Store()), iter=Name(id='data__optionaldependencies', ctx=Load()), body=[Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__optionaldependencies_key', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='pep508-identifier'), ctx=Load()), args=[Name(id='data__optionaldependencies_key', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.optional-dependencies must be pep508-identifier'))], keywords=[keyword(arg='value', value=Name(id='data__optionaldependencies_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.optional-dependencies'))), keyword(arg='definition', value=Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Assign(targets=[Name(id='data__optionaldependencies_property_names', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__optionaldependencies_property_names', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.optional-dependencies must be named by propertyName definition'))], keywords=[keyword(arg='value', value=Name(id='data__optionaldependencies', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.optional-dependencies'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='Optional dependency for the project'), Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])])), keyword(arg='rule', value=Constant(value='propertyNames'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='dynamic'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='dynamic')], keywords=[])), Assign(targets=[Name(id='data__dynamic', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='dynamic'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic must be array'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Specifies which fields are intentionally unspecified and expected to be'), Constant(value='dynamically provided by build tools')], ctx=Load()), Dict(keys=[Constant(value='enum')], values=[List(elts=[Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies')], ctx=Load())])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data__dynamic_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__dynamic_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__dynamic_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data__dynamic', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='data__dynamic_x', ctx=Store()), Name(id='data__dynamic_item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='data__dynamic', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data__dynamic_item', ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies')], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.dynamic[{data__dynamic_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=" must be one of ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']"))], keywords=[keyword(arg='value', value=Name(id='data__dynamic_item', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.dynamic[{data__dynamic_x}]'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='enum')], values=[List(elts=[Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies')], ctx=Load())])), keyword(arg='rule', value=Constant(value='enum'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$schema'), Constant(value='$id'), Constant(value='title'), Constant(value='$$description'), Constant(value='type'), Constant(value='properties'), Constant(value='required'), Constant(value='additionalProperties'), Constant(value='if'), Constant(value='then'), Constant(value='definitions')], values=[Constant(value='http://json-schema.org/draft-07/schema'), Constant(value='https://packaging.python.org/en/latest/specifications/declaring-project-metadata/'), Constant(value='Package metadata stored in the ``project`` table'), List(elts=[Constant(value='Data structure for the **project** table inside ``pyproject.toml``'), Constant(value='(as initially defined in :pep:`621`)')], ctx=Load()), Constant(value='object'), Dict(keys=[Constant(value='name'), Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies'), Constant(value='dynamic')], values=[Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The name (primary identifier) of the project. MUST be statically defined.'), Constant(value='pep508-identifier')]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='string'), Constant(value='The version of the project as supported by :pep:`440`.'), Constant(value='pep440')]), Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The `summary description of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#summary>`_')], ctx=Load())]), Dict(keys=[Constant(value='$$description'), Constant(value='oneOf')], values=[List(elts=[Constant(value='`Full/detailed description of the project in the form of a README'), Constant(value='<https://peps.python.org/pep-0621/#readme>`_'), Constant(value="with meaning similar to the one defined in `core metadata's Description"), Constant(value='<https://packaging.python.org/specifications/core-metadata/#description>`_')], ctx=Load()), List(elts=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file (UTF-8) containing the full description'), Constant(value='of the project. If the file path ends in case-insensitive ``.md`` or'), Constant(value='``.rst`` suffixes, then the content-type is respectively'), Constant(value='``text/markdown`` or ``text/x-rst``')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='allOf')], values=[Constant(value='object'), List(elts=[Dict(keys=[Constant(value='anyOf')], values=[List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to a text file containing the full description'), Constant(value='of the project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='Full text describing the project.')])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='content-type')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Content-type (:rfc:`1341`) of the full description'), Constant(value='(e.g. ``text/markdown``). The ``charset`` parameter is assumed'), Constant(value='UTF-8 when not present.')], ctx=Load()), Constant(value='TODO: add regex pattern or format?')])]), List(elts=[Constant(value='content-type')], ctx=Load())])], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='$$description')], values=[Constant(value='string'), Constant(value='pep508-versionspec'), List(elts=[Constant(value='`The Python version requirements of the project'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.')], ctx=Load())]), Dict(keys=[Constant(value='description'), Constant(value='oneOf')], values=[Constant(value='`Project license <https://peps.python.org/pep-0621/#license>`_.'), List(elts=[Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='file')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='Relative path to the file (UTF-8) which contains the license for the'), Constant(value='project.')], ctx=Load())])]), List(elts=[Constant(value='file')], ctx=Load())]), Dict(keys=[Constant(value='properties'), Constant(value='required')], values=[Dict(keys=[Constant(value='text')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='The license of the project whose meaning is that of the'), Constant(value='`License field from the core metadata'), Constant(value='<https://packaging.python.org/specifications/core-metadata/#license>`_.')], ctx=Load())])]), List(elts=[Constant(value='text')], ctx=Load())])], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), List(elts=[Constant(value="The people or organizations considered to be the 'authors' of the project."), Constant(value='The exact meaning is open to interpretation (e.g. original or primary authors,'), Constant(value='current maintainers, or owners of the package).')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), List(elts=[Constant(value="The people or organizations considered to be the 'maintainers' of the project."), Constant(value='Similarly to ``authors``, the exact meaning is open to interpretation.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='List of keywords to assist searching for the distribution in a larger catalog.')]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='$$description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='trove-classifier'), Constant(value='`PyPI classifier <https://pypi.org/classifiers/>`_.')]), List(elts=[Constant(value='`Trove classifiers <https://pypi.org/classifiers/>`_'), Constant(value='which apply to the project.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='URLs associated with the project in the form ``label => value``.'), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='format')], values=[Constant(value='string'), Constant(value='url')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[List(elts=[Constant(value='Instruct the installer to expose the given modules/functions via'), Constant(value='``entry-point`` discovery mechanism (useful for plugins).'), Constant(value='More information available in the `Python packaging guide'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-group')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])])])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='items')], values=[Constant(value='array'), Constant(value='Project (mandatory) dependencies.'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])]), Dict(keys=[Constant(value='type'), Constant(value='description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='object'), Constant(value='Optional dependency for the project'), Dict(keys=[Constant(value='format')], values=[Constant(value='pep508-identifier')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='items')], values=[Constant(value='array'), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])]), Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='items')], values=[Constant(value='array'), List(elts=[Constant(value='Specifies which fields are intentionally unspecified and expected to be'), Constant(value='dynamically provided by build tools')], ctx=Load()), Dict(keys=[Constant(value='enum')], values=[List(elts=[Constant(value='version'), Constant(value='description'), Constant(value='readme'), Constant(value='requires-python'), Constant(value='license'), Constant(value='authors'), Constant(value='maintainers'), Constant(value='keywords'), Constant(value='classifiers'), Constant(value='urls'), Constant(value='scripts'), Constant(value='gui-scripts'), Constant(value='entry-points'), Constant(value='dependencies'), Constant(value='optional-dependencies')], ctx=Load())])])]), List(elts=[Constant(value='name')], ctx=Load()), Constant(value=False), Dict(keys=[Constant(value='not'), Constant(value='$$comment')], values=[Dict(keys=[Constant(value='required'), Constant(value='properties')], values=[List(elts=[Constant(value='dynamic')], ctx=Load()), Dict(keys=[Constant(value='dynamic')], values=[Dict(keys=[Constant(value='contains'), Constant(value='$$description')], values=[Dict(keys=[Constant(value='const')], values=[Constant(value='version')]), List(elts=[Constant(value='version is listed in ``dynamic``')], ctx=Load())])])]), List(elts=[Constant(value='According to :pep:`621`:'), Constant(value='    If the core metadata specification lists a field as "Required", then'), Constant(value='    the metadata MUST specify the field statically or list it in dynamic'), Constant(value='In turn, `core metadata`_ defines:'), Constant(value='    The required fields are: Metadata-Version, Name, Version.'), Constant(value='    All the other fields are optional.'), Constant(value='Since ``Metadata-Version`` is defined by the build back-end, ``name`` and'), Constant(value='``version`` are the only mandatory information in ``pyproject.toml``.'), Constant(value='.. _core metadata: https://packaging.python.org/specifications/core-metadata/')], ctx=Load())]), Dict(keys=[Constant(value='required'), Constant(value='$$description')], values=[List(elts=[Constant(value='version')], ctx=Load()), List(elts=[Constant(value='version should be statically defined in the ``version`` field')], ctx=Load())]), Dict(keys=[Constant(value='author'), Constant(value='entry-point-group'), Constant(value='dependency')], values=[Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])]), Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[]), Try(body=[Try(body=[Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='dynamic')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=" must contain ['dynamic'] properties"))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='required'), Constant(value='properties')], values=[List(elts=[Constant(value='dynamic')], ctx=Load()), Dict(keys=[Constant(value='dynamic')], values=[Dict(keys=[Constant(value='contains'), Constant(value='$$description')], values=[Dict(keys=[Constant(value='const')], values=[Constant(value='version')]), List(elts=[Constant(value='version is listed in ``dynamic``')], ctx=Load())])])])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[]), Assign(targets=[Name(id='data_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='dynamic'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='dynamic')], keywords=[])), Assign(targets=[Name(id='data__dynamic', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='dynamic'), ctx=Load())), Assign(targets=[Name(id='data__dynamic_is_list', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__dynamic', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='data__dynamic_is_list', ctx=Load()), body=[Assign(targets=[Name(id='data__dynamic_contains', ctx=Store())], value=Constant(value=False)), For(target=Name(id='data__dynamic_key', ctx=Store()), iter=Name(id='data__dynamic', ctx=Load()), body=[Try(body=[If(test=Compare(left=Name(id='data__dynamic_key', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='version')]), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic must be same as const definition: version'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic'))), keyword(arg='definition', value=Dict(keys=[Constant(value='const')], values=[Constant(value='version')])), keyword(arg='rule', value=Constant(value='const'))]))], orelse=[]), Assign(targets=[Name(id='data__dynamic_contains', ctx=Store())], value=Constant(value=True)), Break()], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data__dynamic_contains', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic must contain one of contains definition'))], keywords=[keyword(arg='value', value=Name(id='data__dynamic', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.dynamic'))), keyword(arg='definition', value=Dict(keys=[Constant(value='contains'), Constant(value='$$description')], values=[Dict(keys=[Constant(value='const')], values=[Constant(value='version')]), List(elts=[Constant(value='version is listed in ``dynamic``')], ctx=Load())])), keyword(arg='rule', value=Constant(value='contains'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must NOT match a disallowed definition'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='not'), Constant(value='$$comment')], values=[Dict(keys=[Constant(value='required'), Constant(value='properties')], values=[List(elts=[Constant(value='dynamic')], ctx=Load()), Dict(keys=[Constant(value='dynamic')], values=[Dict(keys=[Constant(value='contains'), Constant(value='$$description')], values=[Dict(keys=[Constant(value='const')], values=[Constant(value='version')]), List(elts=[Constant(value='version is listed in ``dynamic``')], ctx=Load())])])]), List(elts=[Constant(value='According to :pep:`621`:'), Constant(value='    If the core metadata specification lists a field as "Required", then'), Constant(value='    the metadata MUST specify the field statically or list it in dynamic'), Constant(value='In turn, `core metadata`_ defines:'), Constant(value='    The required fields are: Metadata-Version, Name, Version.'), Constant(value='    All the other fields are optional.'), Constant(value='Since ``Metadata-Version`` is defined by the build back-end, ``name`` and'), Constant(value='``version`` are the only mandatory information in ``pyproject.toml``.'), Constant(value='.. _core metadata: https://packaging.python.org/specifications/core-metadata/')], ctx=Load())])), keyword(arg='rule', value=Constant(value='not'))]))], finalbody=[])], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Pass()])], orelse=[Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='prop', ctx=Load()), ops=[In()], comparators=[Name(id='data', ctx=Load())]), generators=[comprehension(target=Name(id='prop', ctx=Store()), iter=List(elts=[Constant(value='version')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=" must contain ['version'] properties"))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='required'), Constant(value='$$description')], values=[List(elts=[Constant(value='version')], ctx=Load()), List(elts=[Constant(value='version should be statically defined in the ``version`` field')], ctx=Load())])), keyword(arg='rule', value=Constant(value='required'))]))], orelse=[])], orelse=[])], finalbody=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_dependency', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='pep508'), ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be pep508'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='description'), Constant(value='format')], values=[Constant(value='#/definitions/dependency'), Constant(value='Dependency'), Constant(value='string'), Constant(value='Project dependency specification according to PEP 508'), Constant(value='pep508')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_entry_point_group', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be object'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='data_key', ctx=Store()), Name(id='data_val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='^.+$'), ctx=Load()), attr='search', ctx=Load()), args=[Name(id='data_key', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='data_key', ctx=Load()), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='data_key', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data_val', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.{data_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be string'))], keywords=[keyword(arg='value', value=Name(id='data_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.{data_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data_val', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='python-entrypoint-reference'), ctx=Load()), args=[Name(id='data_val', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.{data_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=' must be python-entrypoint-reference'))], keywords=[keyword(arg='value', value=Name(id='data_val', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Call(func=Attribute(value=Constant(value='.{data_key}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]))])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[]), Assign(targets=[Name(id='data_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='data_len', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='data_property_names', ctx=Store())], value=Constant(value=True)), For(target=Name(id='data_key', ctx=Store()), iter=Name(id='data', ctx=Load()), body=[Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data_key', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='custom_formats', ctx=Load()), slice=Constant(value='python-entrypoint-name'), ctx=Load()), args=[Name(id='data_key', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be python-entrypoint-name'))], keywords=[keyword(arg='value', value=Name(id='data_key', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], handlers=[ExceptHandler(type=Name(id='JsonSchemaValueException', ctx=Load()), body=[Assign(targets=[Name(id='data_property_names', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='data_property_names', ctx=Load())), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be named by propertyName definition'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='type'), Constant(value='$$description'), Constant(value='propertyNames'), Constant(value='additionalProperties'), Constant(value='patternProperties')], values=[Constant(value='#/definitions/entry-point-group'), Constant(value='Entry-points'), Constant(value='object'), List(elts=[Constant(value='Entry-points are grouped together to indicate what sort of capabilities they'), Constant(value='provide.'), Constant(value='See the `packaging guides'), Constant(value='<https://packaging.python.org/specifications/entry-points/>`_'), Constant(value='and `setuptools docs'), Constant(value='<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_'), Constant(value='for more information.')], ctx=Load()), Dict(keys=[Constant(value='format')], values=[Constant(value='python-entrypoint-name')]), Constant(value=False), Dict(keys=[Constant(value='^.+$')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description'), Constant(value='format'), Constant(value='$comment')], values=[Constant(value='string'), List(elts=[Constant(value='Reference to a Python object. It is either in the form'), Constant(value='``importable.module``, or ``importable.module:object.attr``.')], ctx=Load()), Constant(value='python-entrypoint-reference'), Constant(value='https://packaging.python.org/specifications/entry-points/')])])])), keyword(arg='rule', value=Constant(value='propertyNames'))]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_author', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='custom_formats'), arg(arg='name_prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must be object'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), Assign(targets=[Name(id='data_is_dict', ctx=Store())], value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])), If(test=Name(id='data_is_dict', ctx=Load()), body=[Assign(targets=[Name(id='data_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='name'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='name')], keywords=[])), Assign(targets=[Name(id='data__name', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='name'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__name', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.name must be string'))], keywords=[keyword(arg='value', value=Name(id='data__name', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.name'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value='email'), ops=[In()], comparators=[Name(id='data_keys', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='data_keys', ctx=Load()), attr='remove', ctx=Load()), args=[Constant(value='email')], keywords=[])), Assign(targets=[Name(id='data__email', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='email'), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__email', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.email must be string'))], keywords=[keyword(arg='value', value=Name(id='data__email', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.email'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])), keyword(arg='rule', value=Constant(value='type'))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data__email', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Subscript(value=Name(id='REGEX_PATTERNS', ctx=Load()), slice=Constant(value='idn-email_re_pattern'), ctx=Load()), attr='match', ctx=Load()), args=[Name(id='data__email', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.email must be idn-email'))], keywords=[keyword(arg='value', value=Name(id='data__email', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value='.email'))), keyword(arg='definition', value=Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])), keyword(arg='rule', value=Constant(value='format'))]))], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='data_keys', ctx=Load()), body=[Raise(exc=Call(func=Name(id='JsonSchemaValueException', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=' must not contain ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='data_keys', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=' properties'))], keywords=[keyword(arg='value', value=Name(id='data', ctx=Load())), keyword(arg='name', value=BinOp(left=BinOp(left=Constant(value=''), op=Add(), right=BoolOp(op=Or(), values=[Name(id='name_prefix', ctx=Load()), Constant(value='data')])), op=Add(), right=Constant(value=''))), keyword(arg='definition', value=Dict(keys=[Constant(value='$id'), Constant(value='title'), Constant(value='$comment'), Constant(value='type'), Constant(value='additionalProperties'), Constant(value='properties')], values=[Constant(value='#/definitions/author'), Constant(value='Author or Maintainer'), Constant(value='https://peps.python.org/pep-0621/#authors-maintainers'), Constant(value='object'), Constant(value=False), Dict(keys=[Constant(value='name'), Constant(value='email')], values=[Dict(keys=[Constant(value='type'), Constant(value='$$description')], values=[Constant(value='string'), List(elts=[Constant(value='MUST be a valid email name, i.e. whatever can be put as a name, before an'), Constant(value='email, in :rfc:`822`.')], ctx=Load())]), Dict(keys=[Constant(value='type'), Constant(value='format'), Constant(value='description')], values=[Constant(value='string'), Constant(value='idn-email'), Constant(value='MUST be a valid email address')])])])), keyword(arg='rule', value=Constant(value='additionalProperties'))]))], orelse=[])], orelse=[]), Return(value=Name(id='data', ctx=Load()))], decorator_list=[])], type_ignores=[])