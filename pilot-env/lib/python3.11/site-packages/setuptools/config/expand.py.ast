Module(body=[Expr(value=Constant(value='Utility functions to expand configuration directives or special values\n(such glob patterns).\n\nWe can split the process of interpreting configuration files into 2 steps:\n\n1. The parsing the file contents from strings to value objects\n   that can be understand by Python (for example a string with a comma\n   separated list of keywords into an actual Python list of strings).\n\n2. The expansion (or post-processing) of these values according to the\n   semantics ``setuptools`` assign to them (for example a configuration field\n   with the ``file:`` directive should be expanded from a list of file paths to\n   a single string with the contents of those files concatenated)\n\nThis module focus on the second step, and therefore allow sharing the expansion\nfunctions among several configuration file formats.\n\n**PRIVATE MODULE**: API reserved for setuptools internal usage only.\n')), Import(names=[alias(name='ast')]), Import(names=[alias(name='importlib')]), Import(names=[alias(name='io')]), Import(names=[alias(name='os')]), Import(names=[alias(name='pathlib')]), Import(names=[alias(name='sys')]), ImportFrom(module='glob', names=[alias(name='iglob')], level=0), ImportFrom(module='configparser', names=[alias(name='ConfigParser')], level=0), ImportFrom(module='importlib.machinery', names=[alias(name='ModuleSpec')], level=0), ImportFrom(module='itertools', names=[alias(name='chain')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Callable'), alias(name='Dict'), alias(name='Iterable'), alias(name='Iterator'), alias(name='List'), alias(name='Mapping'), alias(name='Optional'), alias(name='Tuple'), alias(name='TypeVar'), alias(name='Union'), alias(name='cast')], level=0), ImportFrom(module='pathlib', names=[alias(name='Path')], level=0), ImportFrom(module='types', names=[alias(name='ModuleType')], level=0), ImportFrom(module='distutils.errors', names=[alias(name='DistutilsOptionError')], level=0), ImportFrom(module='_path', names=[alias(name='same_path', asname='_same_path')], level=2), ImportFrom(module='warnings', names=[alias(name='SetuptoolsWarning')], level=2), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='setuptools.dist', names=[alias(name='Distribution')], level=0), ImportFrom(module='setuptools.discovery', names=[alias(name='ConfigDiscovery')], level=0), ImportFrom(module='distutils.dist', names=[alias(name='DistributionMetadata')], level=0)], orelse=[]), Assign(targets=[Name(id='chain_iter', ctx=Store())], value=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load())), Assign(targets=[Name(id='_Path', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='PathLike', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='_K', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_K')], keywords=[])), Assign(targets=[Name(id='_V', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_V')], keywords=[keyword(arg='covariant', value=Constant(value=True))])), ClassDef(name='StaticModule', bases=[], keywords=[], body=[Expr(value=Constant(value='Proxy to a module object that avoids executing arbitrary code.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='spec', annotation=Name(id='ModuleSpec', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='parse', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Attribute(value=Name(id='spec', ctx=Load()), attr='origin', ctx=Load())], keywords=[]), attr='read_bytes', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='update', ctx=Load()), args=[Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[])], keywords=[])), Delete(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='self', ctx=Del())])], decorator_list=[]), FunctionDef(name='_find_assignments', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='statement', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='module', ctx=Load()), attr='body', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='statement', ctx=Load()), Attribute(value=Name(id='ast', ctx=Load()), attr='Assign', ctx=Load())], keywords=[]), body=[Expr(value=YieldFrom(value=GeneratorExp(elt=Tuple(elts=[Name(id='target', ctx=Load()), Attribute(value=Name(id='statement', ctx=Load()), attr='value', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='target', ctx=Store()), iter=Attribute(value=Name(id='statement', ctx=Load()), attr='targets', ctx=Load()), ifs=[], is_async=0)])))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='statement', ctx=Load()), Attribute(value=Name(id='ast', ctx=Load()), attr='AnnAssign', ctx=Load())], keywords=[]), Attribute(value=Name(id='statement', ctx=Load()), attr='value', ctx=Load())]), body=[Expr(value=Yield(value=Tuple(elts=[Attribute(value=Name(id='statement', ctx=Load()), attr='target', ctx=Load()), Attribute(value=Name(id='statement', ctx=Load()), attr='value', ctx=Load())], ctx=Load())))], orelse=[])])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='ast', ctx=Load()), attr='AST', ctx=Load()), Attribute(value=Name(id='ast', ctx=Load()), attr='AST', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='attr')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Attempt to load an attribute "statically", via :func:`ast.literal_eval`.')), Try(body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='literal_eval', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='target', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_assignments', ctx=Load()), args=[], keywords=[]), ifs=[BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='target', ctx=Load()), Attribute(value=Name(id='ast', ctx=Load()), attr='Name', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='target', ctx=Load()), attr='id', ctx=Load()), ops=[Eq()], comparators=[Name(id='attr', ctx=Load())])])], is_async=0)])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value=' has no attribute '), FormattedValue(value=Name(id='attr', ctx=Load()), conversion=-1)])], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[])], decorator_list=[]), FunctionDef(name='glob_relative', args=arguments(posonlyargs=[], args=[arg(arg='patterns', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='root_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Expand the list of glob patterns, but preserving relative paths.\n\n    :param list[str] patterns: List of glob patterns\n    :param str root_dir: Path to which globs should be relative\n                         (current directory by default)\n    :rtype: list\n    ')), Assign(targets=[Name(id='glob_characters', ctx=Store())], value=Set(elts=[Constant(value='*'), Constant(value='?'), Constant(value='['), Constant(value=']'), Constant(value='{'), Constant(value='}')])), Assign(targets=[Name(id='expanded_values', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='root_dir', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='root_dir', ctx=Load()), Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[])])), For(target=Name(id='value', ctx=Store()), iter=Name(id='patterns', ctx=Load()), body=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='char', ctx=Load()), ops=[In()], comparators=[Name(id='value', ctx=Load())]), generators=[comprehension(target=Name(id='char', ctx=Store()), iter=Name(id='glob_characters', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='glob_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root_dir', ctx=Load()), Name(id='value', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='expanded_values', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='relpath', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[]), attr='replace', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), Constant(value='/')], keywords=[]), generators=[comprehension(target=Name(id='path', ctx=Store()), iter=Call(func=Name(id='iglob', ctx=Load()), args=[Name(id='glob_path', ctx=Load())], keywords=[keyword(arg='recursive', value=Constant(value=True))]), ifs=[], is_async=0)])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='relpath', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[]), attr='replace', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), Constant(value='/')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='expanded_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))])], orelse=[]), Return(value=Name(id='expanded_values', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='read_files', args=arguments(posonlyargs=[], args=[arg(arg='filepaths', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bytes', ctx=Load()), Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='root_dir')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Return the content of the files concatenated using ``\n`` as str\n\n    This function is sandboxed and won't reach anything outside ``root_dir``\n\n    (By default ``root_dir`` is the current directory).\n    ")), ImportFrom(module='setuptools.extern.more_itertools', names=[alias(name='always_iterable')], level=0), Assign(targets=[Name(id='root_dir', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='root_dir', ctx=Load()), Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[])])], keywords=[])), Assign(targets=[Name(id='_filepaths', ctx=Store())], value=GeneratorExp(elt=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root_dir', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='path', ctx=Store()), iter=Call(func=Name(id='always_iterable', ctx=Load()), args=[Name(id='filepaths', ctx=Load())], keywords=[]), ifs=[], is_async=0)])), Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_read_file', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='path', ctx=Store()), iter=Call(func=Name(id='_filter_existing_files', ctx=Load()), args=[Name(id='_filepaths', ctx=Load())], keywords=[]), ifs=[Call(func=Name(id='_assert_local', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[])], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_filter_existing_files', args=arguments(posonlyargs=[], args=[arg(arg='filepaths', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='path', ctx=Store()), iter=Name(id='filepaths', ctx=Load()), body=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='path', ctx=Load())))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='SetuptoolsWarning', ctx=Load()), attr='emit', ctx=Load()), args=[JoinedStr(values=[Constant(value='File '), FormattedValue(value=Name(id='path', ctx=Load()), conversion=114), Constant(value=' cannot be found')])], keywords=[]))])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load())), FunctionDef(name='_read_file', args=arguments(posonlyargs=[], args=[arg(arg='filepath', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bytes', ctx=Load()), Name(id='_Path', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='io', ctx=Load()), attr='open', ctx=Load()), args=[Name(id='filepath', ctx=Load())], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='f', ctx=Store()))], body=[Return(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_assert_local', args=arguments(posonlyargs=[], args=[arg(arg='filepath', annotation=Name(id='_Path', ctx=Load())), arg(arg='root_dir', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Call(func=Name(id='Path', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Name(id='root_dir', ctx=Load())], keywords=[])], keywords=[]), ops=[NotIn()], comparators=[Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Name(id='filepath', ctx=Load())], keywords=[])], keywords=[]), attr='parents', ctx=Load())]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='Cannot access '), FormattedValue(value=Name(id='filepath', ctx=Load()), conversion=114), Constant(value=' (or anything outside '), FormattedValue(value=Name(id='root_dir', ctx=Load()), conversion=114), Constant(value=')')])), Raise(exc=Call(func=Name(id='DistutilsOptionError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='read_attr', args=arguments(posonlyargs=[], args=[arg(arg='attr_desc', annotation=Name(id='str', ctx=Load())), arg(arg='package_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='root_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Reads the value of an attribute from a module.\n\n    This function will try to read the attributed statically first\n    (via :func:`ast.literal_eval`), and only evaluate the module if it fails.\n\n    Examples:\n        read_attr("package.attr")\n        read_attr("package.module.attr")\n\n    :param str attr_desc: Dot-separated string describing how to reach the\n        attribute (see examples above)\n    :param dict[str, str] package_dir: Mapping of package names to their\n        location in disk (represented by paths relative to ``root_dir``).\n    :param str root_dir: Path to directory containing all the packages in\n        ``package_dir`` (current directory by default).\n    :rtype: str\n    ')), Assign(targets=[Name(id='root_dir', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='root_dir', ctx=Load()), Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[])])), Assign(targets=[Name(id='attrs_path', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='attr_desc', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), Assign(targets=[Name(id='attr_name', ctx=Store())], value=Call(func=Attribute(value=Name(id='attrs_path', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='module_name', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Name(id='attrs_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module_name', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='module_name', ctx=Load()), Constant(value='__init__')])), Assign(targets=[Tuple(elts=[Name(id='_parent_path', ctx=Store()), Name(id='path', ctx=Store()), Name(id='module_name', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_find_module', ctx=Load()), args=[Name(id='module_name', ctx=Load()), Name(id='package_dir', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='spec', ctx=Store())], value=Call(func=Name(id='_find_spec', ctx=Load()), args=[Name(id='module_name', ctx=Load()), Name(id='path', ctx=Load())], keywords=[])), Try(body=[Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Call(func=Name(id='StaticModule', ctx=Load()), args=[Name(id='module_name', ctx=Load()), Name(id='spec', ctx=Load())], keywords=[]), Name(id='attr_name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Name(id='_load_spec', ctx=Load()), args=[Name(id='spec', ctx=Load()), Name(id='module_name', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='module', ctx=Load()), Name(id='attr_name', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='_find_spec', args=arguments(posonlyargs=[], args=[arg(arg='module_name', annotation=Name(id='str', ctx=Load())), arg(arg='module_path', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='spec', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='util', ctx=Load()), attr='spec_from_file_location', ctx=Load()), args=[Name(id='module_name', ctx=Load()), Name(id='module_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='spec', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='spec', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='util', ctx=Load()), attr='find_spec', ctx=Load()), args=[Name(id='module_name', ctx=Load())], keywords=[])])), If(test=Compare(left=Name(id='spec', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ModuleNotFoundError', ctx=Load()), args=[Name(id='module_name', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='spec', ctx=Load()))], decorator_list=[], returns=Name(id='ModuleSpec', ctx=Load())), FunctionDef(name='_load_spec', args=arguments(posonlyargs=[], args=[arg(arg='spec', annotation=Name(id='ModuleSpec', ctx=Load())), arg(arg='module_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='spec', ctx=Load()), Constant(value='__name__'), Name(id='module_name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load())]), body=[Return(value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='util', ctx=Load()), attr='module_from_spec', ctx=Load()), args=[Name(id='spec', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Name(id='module', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='spec', ctx=Load()), attr='loader', ctx=Load()), attr='exec_module', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[])), Return(value=Name(id='module', ctx=Load()))], decorator_list=[], returns=Name(id='ModuleType', ctx=Load())), FunctionDef(name='_find_module', args=arguments(posonlyargs=[], args=[arg(arg='module_name', annotation=Name(id='str', ctx=Load())), arg(arg='package_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='root_dir', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Given a module (that could normally be imported by ``module_name``\n    after the build is complete), find the path to the parent directory where\n    it is contained and the canonical name that could be used to import it\n    considering the ``package_dir`` in the build configuration and ``root_dir``\n    ')), Assign(targets=[Name(id='parent_path', ctx=Store())], value=Name(id='root_dir', ctx=Load())), Assign(targets=[Name(id='module_parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='module_name', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), If(test=Name(id='package_dir', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='module_parts', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[In()], comparators=[Name(id='package_dir', ctx=Load())]), body=[Assign(targets=[Name(id='custom_path', ctx=Store())], value=Subscript(value=Name(id='package_dir', ctx=Load()), slice=Subscript(value=Name(id='module_parts', ctx=Load()), slice=Constant(value=0), ctx=Load()), ctx=Load())), Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='custom_path', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='/'), Constant(value=1)], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='parent_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root_dir', ctx=Load()), Subscript(value=Name(id='parts', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), Assign(targets=[Name(id='parent_module', ctx=Store())], value=Subscript(value=Name(id='parts', ctx=Load()), slice=Constant(value=1), ctx=Load()))], orelse=[Assign(targets=[Name(id='parent_module', ctx=Store())], value=Name(id='custom_path', ctx=Load()))]), Assign(targets=[Name(id='module_name', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[List(elts=[Name(id='parent_module', ctx=Load()), Starred(value=Subscript(value=Name(id='module_parts', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Constant(value=''), ops=[In()], comparators=[Name(id='package_dir', ctx=Load())]), body=[Assign(targets=[Name(id='parent_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root_dir', ctx=Load()), Subscript(value=Name(id='package_dir', ctx=Load()), slice=Constant(value=''), ctx=Load())], keywords=[]))], orelse=[])])], orelse=[]), Assign(targets=[Name(id='path_start', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='parent_path', ctx=Load()), Starred(value=Call(func=Attribute(value=Name(id='module_name', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]), ctx=Load())], keywords=[])), Assign(targets=[Name(id='candidates', ctx=Store())], value=Call(func=Name(id='chain', ctx=Load()), args=[Tuple(elts=[JoinedStr(values=[FormattedValue(value=Name(id='path_start', ctx=Load()), conversion=-1), Constant(value='.py')]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path_start', ctx=Load()), Constant(value='__init__.py')], keywords=[])], ctx=Load()), Call(func=Name(id='iglob', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='path_start', ctx=Load()), conversion=-1), Constant(value='.*')])], keywords=[])], keywords=[])), Assign(targets=[Name(id='module_path', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[GeneratorExp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='candidates', ctx=Load()), ifs=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])], is_async=0)]), Constant(value=None)], keywords=[])), Return(value=Tuple(elts=[Name(id='parent_path', ctx=Load()), Name(id='module_path', ctx=Load()), Name(id='module_name', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='_Path', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='resolve_class', args=arguments(posonlyargs=[], args=[arg(arg='qualified_class_name', annotation=Name(id='str', ctx=Load())), arg(arg='package_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='root_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Given a qualified class name, return the associated class object')), Assign(targets=[Name(id='root_dir', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='root_dir', ctx=Load()), Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[])])), Assign(targets=[Name(id='idx', ctx=Store())], value=Call(func=Attribute(value=Name(id='qualified_class_name', ctx=Load()), attr='rfind', ctx=Load()), args=[Constant(value='.')], keywords=[])), Assign(targets=[Name(id='class_name', ctx=Store())], value=Subscript(value=Name(id='qualified_class_name', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='idx', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load())), Assign(targets=[Name(id='pkg_name', ctx=Store())], value=Subscript(value=Name(id='qualified_class_name', ctx=Load()), slice=Slice(upper=Name(id='idx', ctx=Load())), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='_parent_path', ctx=Store()), Name(id='path', ctx=Store()), Name(id='module_name', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_find_module', ctx=Load()), args=[Name(id='pkg_name', ctx=Load()), Name(id='package_dir', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Name(id='_load_spec', ctx=Load()), args=[Call(func=Name(id='_find_spec', ctx=Load()), args=[Name(id='module_name', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]), Name(id='module_name', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='module', ctx=Load()), Name(id='class_name', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Callable', ctx=Load())), FunctionDef(name='cmdclass', args=arguments(posonlyargs=[], args=[arg(arg='values', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='package_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='root_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Given a dictionary mapping command names to strings for qualified class\n    names, apply :func:`resolve_class` to the dict values.\n    ')), Return(value=DictComp(key=Name(id='k', ctx=Load()), value=Call(func=Name(id='resolve_class', ctx=Load()), args=[Name(id='v', ctx=Load()), Name(id='package_dir', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='values', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='find_packages', args=arguments(posonlyargs=[], args=[], kwonlyargs=[arg(arg='namespaces'), arg(arg='fill_package_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='root_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=True), Constant(value=None), Constant(value=None)], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Works similarly to :func:`setuptools.find_packages`, but with all\n    arguments given as keyword arguments. Moreover, ``where`` can be given\n    as a list (the results will be simply concatenated).\n\n    When the additional keyword argument ``namespaces`` is ``True``, it will\n    behave like :func:`setuptools.find_namespace_packages`` (i.e. include\n    implicit namespaces as per :pep:`420`).\n\n    The ``where`` argument will be considered relative to ``root_dir`` (or the current\n    working directory when ``root_dir`` is not given).\n\n    If the ``fill_package_dir`` argument is passed, this function will consider it as a\n    similar data structure to the ``package_dir`` configuration parameter add fill-in\n    any missing package location.\n\n    :rtype: list\n    ')), ImportFrom(module='setuptools.discovery', names=[alias(name='construct_package_dir')], level=0), ImportFrom(module='setuptools.extern.more_itertools', names=[alias(name='unique_everseen'), alias(name='always_iterable')], level=0), If(test=Name(id='namespaces', ctx=Load()), body=[ImportFrom(module='setuptools.discovery', names=[alias(name='PEP420PackageFinder', asname='PackageFinder')], level=0)], orelse=[ImportFrom(module='setuptools.discovery', names=[alias(name='PackageFinder')], level=0)]), Assign(targets=[Name(id='root_dir', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='root_dir', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='curdir', ctx=Load())])), Assign(targets=[Name(id='where', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='where'), List(elts=[Constant(value='.')], ctx=Load())], keywords=[])), AnnAssign(target=Name(id='packages', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='fill_package_dir', ctx=Store())], value=IfExp(test=Compare(left=Name(id='fill_package_dir', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Dict(keys=[], values=[]), orelse=Name(id='fill_package_dir', ctx=Load()))), Assign(targets=[Name(id='search', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='unique_everseen', ctx=Load()), args=[Call(func=Name(id='always_iterable', ctx=Load()), args=[Name(id='where', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='search', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=UnaryOp(op=Not(), operand=Call(func=Name(id='_same_path', ctx=Load()), args=[Subscript(value=Name(id='search', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='x', ctx=Load())], keywords=[])), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Tuple(elts=[Constant(value='.'), Name(id='root_dir', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='fill_package_dir', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value=''), Subscript(value=Name(id='search', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='path', ctx=Store()), iter=Name(id='search', ctx=Load()), body=[Assign(targets=[Name(id='package_path', ctx=Store())], value=Call(func=Name(id='_nest_path', ctx=Load()), args=[Name(id='root_dir', ctx=Load()), Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='pkgs', ctx=Store())], value=Call(func=Attribute(value=Name(id='PackageFinder', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='package_path', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='packages', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='pkgs', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='pkgs', ctx=Load()), UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Compare(left=Call(func=Attribute(value=Name(id='fill_package_dir', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='')], keywords=[]), ops=[Eq()], comparators=[Name(id='path', ctx=Load())]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='samefile', ctx=Load()), args=[Name(id='package_path', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[])]))]), body=[Expr(value=Call(func=Attribute(value=Name(id='fill_package_dir', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Name(id='construct_package_dir', ctx=Load()), args=[Name(id='pkgs', ctx=Load()), Name(id='path', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='packages', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_nest_path', args=arguments(posonlyargs=[], args=[arg(arg='parent', annotation=Name(id='_Path', ctx=Load())), arg(arg='path', annotation=Name(id='_Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=IfExp(test=Compare(left=Name(id='path', ctx=Load()), ops=[In()], comparators=[Set(elts=[Constant(value='.'), Constant(value='')])]), body=Name(id='parent', ctx=Load()), orelse=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='parent', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]))), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='version', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Callable', ctx=Load()), Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='When getting the version directly from an attribute,\n    it should be normalised to string.\n    ')), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='value', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), Name(id='value', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='value', ctx=Load()), Constant(value='__iter__')], keywords=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='value', ctx=Store())], value=BinOp(left=Constant(value='%s'), op=Mod(), right=Name(id='value', ctx=Load())))])], orelse=[]), Return(value=Name(id='value', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='canonic_package_data', args=arguments(posonlyargs=[], args=[arg(arg='package_data', annotation=Name(id='dict', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Constant(value='*'), ops=[In()], comparators=[Name(id='package_data', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='package_data', ctx=Load()), slice=Constant(value=''), ctx=Store())], value=Call(func=Attribute(value=Name(id='package_data', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='*')], keywords=[]))], orelse=[]), Return(value=Name(id='package_data', ctx=Load()))], decorator_list=[], returns=Name(id='dict', ctx=Load())), FunctionDef(name='canonic_data_files', args=arguments(posonlyargs=[], args=[arg(arg='data_files', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='list', ctx=Load()), Name(id='dict', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='root_dir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_Path', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='For compatibility with ``setup.py``, ``data_files`` should be a list\n    of pairs instead of a dict.\n\n    This function also expands glob patterns.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data_files', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Return(value=Name(id='data_files', ctx=Load()))], orelse=[]), Return(value=ListComp(elt=Tuple(elts=[Name(id='dest', ctx=Load()), Call(func=Name(id='glob_relative', ctx=Load()), args=[Name(id='patterns', ctx=Load()), Name(id='root_dir', ctx=Load())], keywords=[])], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='dest', ctx=Store()), Name(id='patterns', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data_files', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='entry_points', args=arguments(posonlyargs=[], args=[arg(arg='text', annotation=Name(id='str', ctx=Load())), arg(arg='text_source')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='entry-points')]), body=[Expr(value=Constant(value='Given the contents of entry-points file,\n    process it into a 2-level dictionary (``dict[str, dict[str, str]]``).\n    The first level keys are entry-point groups, the second level keys are\n    entry-point names, and the second level values are references to objects\n    (that correspond to the entry-point value).\n    ')), Assign(targets=[Name(id='parser', ctx=Store())], value=Call(func=Name(id='ConfigParser', ctx=Load()), args=[], keywords=[keyword(arg='default_section', value=Constant(value=None)), keyword(arg='delimiters', value=Tuple(elts=[Constant(value='=')], ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='parser', ctx=Load()), attr='optionxform', ctx=Store())], value=Name(id='str', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='read_string', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='text_source', ctx=Load())], keywords=[])), Assign(targets=[Name(id='groups', ctx=Store())], value=DictComp(key=Name(id='k', ctx=Load()), value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Attribute(value=Name(id='v', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='groups', ctx=Load()), attr='pop', ctx=Load()), args=[Attribute(value=Name(id='parser', ctx=Load()), attr='default_section', ctx=Load()), Constant(value=None)], keywords=[])), Return(value=Name(id='groups', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='dict', ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='EnsurePackagesDiscovered', bases=[], keywords=[], body=[Expr(value=Constant(value='Some expand functions require all the packages to already be discovered before\n    they run, e.g. :func:`read_attr`, :func:`resolve_class`, :func:`cmdclass`.\n\n    Therefore in some cases we will need to run autodiscovery during the evaluation of\n    the configuration. However, it is better to postpone calling package discovery as\n    much as possible, because some parameters can influence it (e.g. ``package_dir``),\n    and those might not have been processed yet.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='distribution', annotation=Constant(value='Distribution'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_dist', ctx=Store())], value=Name(id='distribution', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_called', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Trigger the automatic package discovery, if it is still necessary.')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_called', ctx=Load())), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_called', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_dist', ctx=Load()), attr='set_defaults', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Constant(value=False))]))], orelse=[])], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_exc_type'), arg(arg='_exc_value'), arg(arg='_traceback')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_called', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_dist', ctx=Load()), attr='set_defaults', ctx=Load()), attr='analyse_name', ctx=Load()), args=[], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_get_package_dir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Name(id='self', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='pkg_dir', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_dist', ctx=Load()), attr='package_dir', ctx=Load())), Return(value=IfExp(test=Compare(left=Name(id='pkg_dir', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Dict(keys=[], values=[]), orelse=Name(id='pkg_dir', ctx=Load())))], decorator_list=[], returns=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='package_dir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Proxy to ``package_dir`` that may trigger auto-discovery when used.')), Return(value=Call(func=Name(id='LazyMappingProxy', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_get_package_dir', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='LazyMappingProxy', bases=[Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='_K', ctx=Load()), Name(id='_V', ctx=Load())], ctx=Load()), ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Mapping proxy that delays resolving the target object, until really needed.\n\n    >>> def obtain_mapping():\n    ...     print("Running expensive function!")\n    ...     return {"key": "value", "other key": "other value"}\n    >>> mapping = LazyMappingProxy(obtain_mapping)\n    >>> mapping["key"]\n    Running expensive function!\n    \'value\'\n    >>> mapping["other key"]\n    \'other value\'\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obtain_mapping_value', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='_K', ctx=Load()), Name(id='_V', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_obtain', ctx=Store())], value=Name(id='obtain_mapping_value', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_value', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='_K', ctx=Load()), Name(id='_V', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[]), FunctionDef(name='_target', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_obtain', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_value', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='_K', ctx=Load()), Name(id='_V', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key', annotation=Name(id='_K', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_target', ctx=Load()), args=[], keywords=[]), slice=Name(id='key', ctx=Load()), ctx=Load()))], decorator_list=[], returns=Name(id='_V', ctx=Load())), FunctionDef(name='__len__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_target', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_target', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='_K', ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])