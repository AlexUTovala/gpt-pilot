Module(body=[Expr(value=Constant(value='Module for parsing and testing package version predicate strings.\n')), Import(names=[alias(name='re')]), ImportFrom(names=[alias(name='version')], level=1), Import(names=[alias(name='operator')]), Assign(targets=[Name(id='re_validPackage', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='(?i)^\\s*([a-z_]\\w*(?:\\.[a-z_]\\w*)*)(.*)'), Attribute(value=Name(id='re', ctx=Load()), attr='ASCII', ctx=Load())], keywords=[])), Assign(targets=[Name(id='re_paren', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^\\s*\\((.*)\\)\\s*$')], keywords=[])), Assign(targets=[Name(id='re_splitComparison', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^\\s*(<=|>=|<|>|!=|==)\\s*([^\\s,]+)\\s*$')], keywords=[])), FunctionDef(name='splitUp', args=arguments(posonlyargs=[], args=[arg(arg='pred')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parse a single version comparison.\n\n    Return (comparison string, StrictVersion)\n    ')), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Name(id='re_splitComparison', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='pred', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='res', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='bad package restriction syntax: %r'), op=Mod(), right=Name(id='pred', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='comp', ctx=Store()), Name(id='verStr', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='version', ctx=Load()), attr='suppress_known_deprecation', ctx=Load()), args=[], keywords=[]))], body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='version', ctx=Load()), attr='StrictVersion', ctx=Load()), args=[Name(id='verStr', ctx=Load())], keywords=[]))]), Return(value=Tuple(elts=[Name(id='comp', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='compmap', ctx=Store())], value=Dict(keys=[Constant(value='<'), Constant(value='<='), Constant(value='=='), Constant(value='>'), Constant(value='>='), Constant(value='!=')], values=[Attribute(value=Name(id='operator', ctx=Load()), attr='lt', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='le', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='eq', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='gt', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='ge', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='ne', ctx=Load())])), ClassDef(name='VersionPredicate', bases=[], keywords=[], body=[Expr(value=Constant(value="Parse and test package version predicates.\n\n    >>> v = VersionPredicate('pyepat.abc (>1.0, <3333.3a1, !=1555.1b3)')\n\n    The `name` attribute provides the full dotted name that is given::\n\n    >>> v.name\n    'pyepat.abc'\n\n    The str() of a `VersionPredicate` provides a normalized\n    human-readable version of the expression::\n\n    >>> print(v)\n    pyepat.abc (> 1.0, < 3333.3a1, != 1555.1b3)\n\n    The `satisfied_by()` method can be used to determine with a given\n    version number is included in the set described by the version\n    restrictions::\n\n    >>> v.satisfied_by('1.1')\n    True\n    >>> v.satisfied_by('1.4')\n    True\n    >>> v.satisfied_by('1.0')\n    False\n    >>> v.satisfied_by('4444.4')\n    False\n    >>> v.satisfied_by('1555.1b3')\n    False\n\n    `VersionPredicate` is flexible in accepting extra whitespace::\n\n    >>> v = VersionPredicate(' pat( ==  0.1  )  ')\n    >>> v.name\n    'pat'\n    >>> v.satisfied_by('0.1')\n    True\n    >>> v.satisfied_by('0.2')\n    False\n\n    If any version numbers passed in do not conform to the\n    restrictions of `StrictVersion`, a `ValueError` is raised::\n\n    >>> v = VersionPredicate('p1.p2.p3.p4(>=1.0, <=1.3a1, !=1.2zb3)')\n    Traceback (most recent call last):\n      ...\n    ValueError: invalid version number '1.2zb3'\n\n    It the module or package name given does not conform to what's\n    allowed as a legal module or package name, `ValueError` is\n    raised::\n\n    >>> v = VersionPredicate('foo-bar')\n    Traceback (most recent call last):\n      ...\n    ValueError: expected parenthesized list: '-bar'\n\n    >>> v = VersionPredicate('foo bar (12.21)')\n    Traceback (most recent call last):\n      ...\n    ValueError: expected parenthesized list: 'bar (12.21)'\n\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='versionPredicateStr')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parse a version predicate string.')), Assign(targets=[Name(id='versionPredicateStr', ctx=Store())], value=Call(func=Attribute(value=Name(id='versionPredicateStr', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='versionPredicateStr', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='empty package restriction')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re_validPackage', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='versionPredicateStr', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='match', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='bad package name in %r'), op=Mod(), right=Name(id='versionPredicateStr', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store()), Name(id='paren', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='paren', ctx=Store())], value=Call(func=Attribute(value=Name(id='paren', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Name(id='paren', ctx=Load()), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re_paren', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='paren', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='match', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='expected parenthesized list: %r'), op=Mod(), right=Name(id='paren', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='str', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pred', ctx=Store())], value=ListComp(elt=Call(func=Name(id='splitUp', ctx=Load()), args=[Name(id='aPred', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='aPred', ctx=Store()), iter=Call(func=Attribute(value=Name(id='str', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',')], keywords=[]), ifs=[], is_async=0)])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='pred', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='empty parenthesized list in %r'), op=Mod(), right=Name(id='versionPredicateStr', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pred', ctx=Store())], value=List(elts=[], ctx=Load()))])], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='pred', ctx=Load()), body=[Assign(targets=[Name(id='seq', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Name(id='cond', ctx=Load()), op=Add(), right=Constant(value=' ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='ver', ctx=Load())], keywords=[])), generators=[comprehension(target=Tuple(elts=[Name(id='cond', ctx=Store()), Name(id='ver', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='pred', ctx=Load()), ifs=[], is_async=0)])), Return(value=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), op=Add(), right=Constant(value=' (')), op=Add(), right=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=')')))], orelse=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))])], decorator_list=[]), FunctionDef(name='satisfied_by', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='version')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='True if version is compatible with all the predicates in self.\n        The parameter version must be acceptable to the StrictVersion\n        constructor.  It may be either a string or StrictVersion.\n        ')), For(target=Tuple(elts=[Name(id='cond', ctx=Store()), Name(id='ver', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='pred', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='compmap', ctx=Load()), slice=Name(id='cond', ctx=Load()), ctx=Load()), args=[Name(id='version', ctx=Load()), Name(id='ver', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[])], orelse=[]), Return(value=Constant(value=True))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='_provision_rx', ctx=Store())], value=Constant(value=None)), FunctionDef(name='split_provision', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the name and optional version number of a provision.\n\n    The version number, if given, will be returned as a `StrictVersion`\n    instance, otherwise it will be `None`.\n\n    >>> split_provision('mypkg')\n    ('mypkg', None)\n    >>> split_provision(' mypkg( 1.2 ) ')\n    ('mypkg', StrictVersion ('1.2'))\n    ")), Global(names=['_provision_rx']), If(test=Compare(left=Name(id='_provision_rx', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='_provision_rx', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='([a-zA-Z_]\\w*(?:\\.[a-zA-Z_]\\w*)*)(?:\\s*\\(\\s*([^)\\s]+)\\s*\\))?$'), Attribute(value=Name(id='re', ctx=Load()), attr='ASCII', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='m', ctx=Store())], value=Call(func=Attribute(value=Name(id='_provision_rx', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='m', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='illegal provides specification: %r'), op=Mod(), right=Name(id='value', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='ver', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='m', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=2)], keywords=[]), Constant(value=None)])), If(test=Name(id='ver', ctx=Load()), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='version', ctx=Load()), attr='suppress_known_deprecation', ctx=Load()), args=[], keywords=[]))], body=[Assign(targets=[Name(id='ver', ctx=Store())], value=Call(func=Attribute(value=Name(id='version', ctx=Load()), attr='StrictVersion', ctx=Load()), args=[Name(id='ver', ctx=Load())], keywords=[]))])], orelse=[]), Return(value=Tuple(elts=[Call(func=Attribute(value=Name(id='m', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), Name(id='ver', ctx=Load())], ctx=Load()))], decorator_list=[])], type_ignores=[])