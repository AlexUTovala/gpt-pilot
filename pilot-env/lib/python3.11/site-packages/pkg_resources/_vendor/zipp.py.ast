Module(body=[Import(names=[alias(name='io')]), Import(names=[alias(name='posixpath')]), Import(names=[alias(name='zipfile')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='pathlib')]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[Lt()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())]), body=[ImportFrom(module='collections', names=[alias(name='OrderedDict')], level=0)], orelse=[Assign(targets=[Name(id='OrderedDict', ctx=Store())], value=Name(id='dict', ctx=Load()))]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Path')], ctx=Load())), FunctionDef(name='_parents', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Given a path with elements separated by\n    posixpath.sep, generate all parents of that path.\n\n    >>> list(_parents('b/d'))\n    ['b']\n    >>> list(_parents('/b/d/'))\n    ['/b']\n    >>> list(_parents('b/d/f/'))\n    ['b/d', 'b']\n    >>> list(_parents('b'))\n    []\n    >>> list(_parents(''))\n    []\n    ")), Return(value=Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='islice', ctx=Load()), args=[Call(func=Name(id='_ancestry', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), Constant(value=1), Constant(value=None)], keywords=[]))], decorator_list=[]), FunctionDef(name='_ancestry', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Given a path with elements separated by\n    posixpath.sep, generate all elements of that path\n\n    >>> list(_ancestry('b/d'))\n    ['b/d', 'b']\n    >>> list(_ancestry('/b/d/'))\n    ['/b/d', '/b']\n    >>> list(_ancestry('b/d/f/'))\n    ['b/d/f', 'b/d', 'b']\n    >>> list(_ancestry('b'))\n    ['b']\n    >>> list(_ancestry(''))\n    []\n    ")), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='rstrip', ctx=Load()), args=[Attribute(value=Name(id='posixpath', ctx=Load()), attr='sep', ctx=Load())], keywords=[])), While(test=BoolOp(op=And(), values=[Name(id='path', ctx=Load()), Compare(left=Name(id='path', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='posixpath', ctx=Load()), attr='sep', ctx=Load())])]), body=[Expr(value=Yield(value=Name(id='path', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='path', ctx=Store()), Name(id='tail', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='_dedupe', ctx=Store())], value=Attribute(value=Name(id='OrderedDict', ctx=Load()), attr='fromkeys', ctx=Load())), Expr(value=Constant(value='Deduplicate an iterable in original order')), FunctionDef(name='_difference', args=arguments(posonlyargs=[], args=[arg(arg='minuend'), arg(arg='subtrahend')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return items in minuend not in subtrahend, retaining order\n    with O(1) lookup.\n    ')), Return(value=Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='filterfalse', ctx=Load()), args=[Attribute(value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='subtrahend', ctx=Load())], keywords=[]), attr='__contains__', ctx=Load()), Name(id='minuend', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='CompleteDirs', bases=[Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A ZipFile subclass that ensures that implied directories\n    are always included in the namelist.\n    ')), FunctionDef(name='_implied_dirs', args=arguments(posonlyargs=[], args=[arg(arg='names')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parents', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='_parents', ctx=Load()), Name(id='names', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='as_dirs', ctx=Store())], value=GeneratorExp(elt=BinOp(left=Name(id='p', ctx=Load()), op=Add(), right=Attribute(value=Name(id='posixpath', ctx=Load()), attr='sep', ctx=Load())), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='parents', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Name(id='_dedupe', ctx=Load()), args=[Call(func=Name(id='_difference', ctx=Load()), args=[Name(id='as_dirs', ctx=Load()), Name(id='names', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='namelist', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='names', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='CompleteDirs', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='namelist', ctx=Load()), args=[], keywords=[])), Return(value=BinOp(left=Name(id='names', ctx=Load()), op=Add(), right=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_implied_dirs', ctx=Load()), args=[Name(id='names', ctx=Load())], keywords=[])], keywords=[])))], decorator_list=[]), FunctionDef(name='_name_set', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='namelist', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='resolve_dir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        If the name represents a directory, return that name\n        as a directory (with the trailing slash).\n        ')), Assign(targets=[Name(id='names', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_name_set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='dirname', ctx=Store())], value=BinOp(left=Name(id='name', ctx=Load()), op=Add(), right=Constant(value='/'))), Assign(targets=[Name(id='dir_match', ctx=Store())], value=BoolOp(op=And(), values=[Compare(left=Name(id='name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='names', ctx=Load())]), Compare(left=Name(id='dirname', ctx=Load()), ops=[In()], comparators=[Name(id='names', ctx=Load())])])), Return(value=IfExp(test=Name(id='dir_match', ctx=Load()), body=Name(id='dirname', ctx=Load()), orelse=Name(id='name', ctx=Load())))], decorator_list=[]), FunctionDef(name='make', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='source')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Given a source (filename or zipfile), return an\n        appropriate CompleteDirs subclass.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='CompleteDirs', ctx=Load())], keywords=[]), body=[Return(value=Name(id='source', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='source', ctx=Load()), Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load())], keywords=[])), body=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Call(func=Name(id='_pathlib_compat', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='r'), ops=[NotIn()], comparators=[Attribute(value=Name(id='source', ctx=Load()), attr='mode', ctx=Load())]), body=[Assign(targets=[Name(id='cls', ctx=Store())], value=Name(id='CompleteDirs', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='source', ctx=Load()), attr='__class__', ctx=Store())], value=Name(id='cls', ctx=Load())), Return(value=Name(id='source', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())])], decorator_list=[]), ClassDef(name='FastLookup', bases=[Name(id='CompleteDirs', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    ZipFile subclass to ensure implicit\n    dirs exist and are resolved rapidly.\n    ')), FunctionDef(name='namelist', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='suppress', ctx=Load()), args=[Name(id='AttributeError', ctx=Load())], keywords=[]))], body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__names', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__names', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='FastLookup', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='namelist', ctx=Load()), args=[], keywords=[])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__names', ctx=Load()))], decorator_list=[]), FunctionDef(name='_name_set', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='suppress', ctx=Load()), args=[Name(id='AttributeError', ctx=Load())], keywords=[]))], body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__lookup', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__lookup', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='FastLookup', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='_name_set', ctx=Load()), args=[], keywords=[])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__lookup', ctx=Load()))], decorator_list=[])], decorator_list=[]), FunctionDef(name='_pathlib_compat', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    For path-like objects, convert to a filename for compatibility\n    on Python 3.6.1 and earlier.\n    ')), Try(body=[Return(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='__fspath__', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), ClassDef(name='Path', bases=[], keywords=[], body=[Expr(value=Constant(value="\n    A pathlib-compatible interface for zip files.\n\n    Consider a zip file with this structure::\n\n        .\n        ├── a.txt\n        └── b\n            ├── c.txt\n            └── d\n                └── e.txt\n\n    >>> data = io.BytesIO()\n    >>> zf = zipfile.ZipFile(data, 'w')\n    >>> zf.writestr('a.txt', 'content of a')\n    >>> zf.writestr('b/c.txt', 'content of c')\n    >>> zf.writestr('b/d/e.txt', 'content of e')\n    >>> zf.filename = 'mem/abcde.zip'\n\n    Path accepts the zipfile object itself or a filename\n\n    >>> root = Path(zf)\n\n    From there, several path operations are available.\n\n    Directory iteration (including the zip file itself):\n\n    >>> a, b = root.iterdir()\n    >>> a\n    Path('mem/abcde.zip', 'a.txt')\n    >>> b\n    Path('mem/abcde.zip', 'b/')\n\n    name property:\n\n    >>> b.name\n    'b'\n\n    join with divide operator:\n\n    >>> c = b / 'c.txt'\n    >>> c\n    Path('mem/abcde.zip', 'b/c.txt')\n    >>> c.name\n    'c.txt'\n\n    Read text:\n\n    >>> c.read_text()\n    'content of c'\n\n    existence:\n\n    >>> c.exists()\n    True\n    >>> (b / 'missing.txt').exists()\n    False\n\n    Coercion to string:\n\n    >>> import os\n    >>> str(c).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip/b/c.txt'\n\n    At the root, ``name``, ``filename``, and ``parent``\n    resolve to the zipfile. Note these attributes are not\n    valid and will raise a ``ValueError`` if the zipfile\n    has no filename.\n\n    >>> root.name\n    'abcde.zip'\n    >>> str(root.filename).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip'\n    >>> str(root.parent)\n    'mem'\n    ")), Assign(targets=[Name(id='__repr', ctx=Store())], value=Constant(value='{self.__class__.__name__}({self.root.filename!r}, {self.at!r})')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='root'), arg(arg='at')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='')]), body=[Expr(value=Constant(value='\n        Construct a Path from a ZipFile or filename.\n\n        Note: When the source is an existing ZipFile object,\n        its type (__class__) will be mutated to a\n        specialized type. If the caller wishes to retain the\n        original type, the caller should either create a\n        separate ZipFile object or pass a filename.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Store())], value=Call(func=Attribute(value=Name(id='FastLookup', ctx=Load()), attr='make', ctx=Load()), args=[Name(id='root', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Store())], value=Name(id='at', ctx=Load()))], decorator_list=[]), FunctionDef(name='open', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode')], vararg=arg(arg='args'), kwonlyargs=[arg(arg='pwd')], kw_defaults=[Constant(value=None)], kwarg=arg(arg='kwargs'), defaults=[Constant(value='r')]), body=[Expr(value=Constant(value='\n        Open this entry as text or binary following the semantics\n        of ``pathlib.Path.open()`` by passing arguments through\n        to io.TextIOWrapper().\n        ')), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[]), body=[Raise(exc=Call(func=Name(id='IsADirectoryError', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='zip_mode', ctx=Store())], value=Subscript(value=Name(id='mode', ctx=Load()), slice=Constant(value=0), ctx=Load())), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='exists', ctx=Load()), args=[], keywords=[])), Compare(left=Name(id='zip_mode', ctx=Load()), ops=[Eq()], comparators=[Constant(value='r')])]), body=[Raise(exc=Call(func=Name(id='FileNotFoundError', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='stream', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load()), attr='open', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load()), Name(id='zip_mode', ctx=Load())], keywords=[keyword(arg='pwd', value=Name(id='pwd', ctx=Load()))])), If(test=Compare(left=Constant(value='b'), ops=[In()], comparators=[Name(id='mode', ctx=Load())]), body=[If(test=BoolOp(op=Or(), values=[Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='encoding args invalid for binary operation')], keywords=[]))], orelse=[]), Return(value=Name(id='stream', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='io', ctx=Load()), attr='TextIOWrapper', ctx=Load()), args=[Name(id='stream', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load())], keywords=[]), attr='name', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='filename', ctx=Load()), attr='name', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='suffix', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load())], keywords=[]), attr='suffix', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='filename', ctx=Load()), attr='suffix', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='suffixes', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load())], keywords=[]), attr='suffixes', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='filename', ctx=Load()), attr='suffixes', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='stem', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load())], keywords=[]), attr='stem', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='filename', ctx=Load()), attr='stem', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='filename', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load()), attr='filename', ctx=Load())], keywords=[]), attr='joinpath', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='read_text', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='open', ctx=Load()), args=[Constant(value='r'), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]), optional_vars=Name(id='strm', ctx=Store()))], body=[Return(value=Call(func=Attribute(value=Name(id='strm', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='read_bytes', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='open', ctx=Load()), args=[Constant(value='rb')], keywords=[]), optional_vars=Name(id='strm', ctx=Store()))], body=[Return(value=Call(func=Attribute(value=Name(id='strm', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='_is_child', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='dirname', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='path', ctx=Load()), attr='at', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='/')], keywords=[])], keywords=[]), ops=[Eq()], comparators=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='/')], keywords=[])]))], decorator_list=[]), FunctionDef(name='_next', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='at')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load()), Name(id='at', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='is_dir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load())), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='/')], keywords=[])]))], decorator_list=[]), FunctionDef(name='is_file', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='exists', ctx=Load()), args=[], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[]))]))], decorator_list=[]), FunctionDef(name='exists', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load()), attr='_name_set', ctx=Load()), args=[], keywords=[])]))], decorator_list=[]), FunctionDef(name='iterdir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Can't listdir a file")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='subs', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_next', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load()), attr='namelist', ctx=Load()), args=[], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='filter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_is_child', ctx=Load()), Name(id='subs', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load()), attr='filename', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__repr', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='self', value=Name(id='self', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='joinpath', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='other'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='next', ctx=Store())], value=Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load()), Starred(value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='_pathlib_compat', ctx=Load()), Name(id='other', ctx=Load())], keywords=[]), ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_next', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='root', ctx=Load()), attr='resolve_dir', ctx=Load()), args=[Name(id='next', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='__truediv__', ctx=Store())], value=Name(id='joinpath', ctx=Load())), FunctionDef(name='parent', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load())), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='filename', ctx=Load()), attr='parent', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='parent_at', ctx=Store())], value=Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='dirname', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='at', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='/')], keywords=[])], keywords=[])), If(test=Name(id='parent_at', ctx=Load()), body=[AugAssign(target=Name(id='parent_at', ctx=Store()), op=Add(), value=Constant(value='/'))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_next', ctx=Load()), args=[Name(id='parent_at', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())])], decorator_list=[])], type_ignores=[])