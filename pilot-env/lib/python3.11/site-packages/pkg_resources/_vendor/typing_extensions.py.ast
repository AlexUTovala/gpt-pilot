Module(body=[Import(names=[alias(name='abc')]), Import(names=[alias(name='collections')]), Import(names=[alias(name='collections.abc')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='operator')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='types', asname='_types')]), Import(names=[alias(name='typing')]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Any'), Constant(value='ClassVar'), Constant(value='Concatenate'), Constant(value='Final'), Constant(value='LiteralString'), Constant(value='ParamSpec'), Constant(value='ParamSpecArgs'), Constant(value='ParamSpecKwargs'), Constant(value='Self'), Constant(value='Type'), Constant(value='TypeVar'), Constant(value='TypeVarTuple'), Constant(value='Unpack'), Constant(value='Awaitable'), Constant(value='AsyncIterator'), Constant(value='AsyncIterable'), Constant(value='Coroutine'), Constant(value='AsyncGenerator'), Constant(value='AsyncContextManager'), Constant(value='ChainMap'), Constant(value='ContextManager'), Constant(value='Counter'), Constant(value='Deque'), Constant(value='DefaultDict'), Constant(value='NamedTuple'), Constant(value='OrderedDict'), Constant(value='TypedDict'), Constant(value='SupportsIndex'), Constant(value='Annotated'), Constant(value='assert_never'), Constant(value='assert_type'), Constant(value='clear_overloads'), Constant(value='dataclass_transform'), Constant(value='get_overloads'), Constant(value='final'), Constant(value='get_args'), Constant(value='get_origin'), Constant(value='get_type_hints'), Constant(value='IntVar'), Constant(value='is_typeddict'), Constant(value='Literal'), Constant(value='NewType'), Constant(value='overload'), Constant(value='override'), Constant(value='Protocol'), Constant(value='reveal_type'), Constant(value='runtime'), Constant(value='runtime_checkable'), Constant(value='Text'), Constant(value='TypeAlias'), Constant(value='TypeGuard'), Constant(value='TYPE_CHECKING'), Constant(value='Never'), Constant(value='NoReturn'), Constant(value='Required'), Constant(value='NotRequired')], ctx=Load())), Assign(targets=[Name(id='PEP_560', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='GenericMeta', ctx=Store())], value=Name(id='type', ctx=Load())), Assign(targets=[Name(id='_marker', ctx=Store())], value=Call(func=Name(id='object', ctx=Load()), args=[], keywords=[])), FunctionDef(name='_check_generic', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='parameters'), arg(arg='elen')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='_marker', ctx=Load())]), body=[Expr(value=Constant(value='Check correct count for parameters of a generic cls (internal helper).\n    This gives a nice error message in case of count mismatch.\n    ')), If(test=UnaryOp(op=Not(), operand=Name(id='elen', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='cls', ctx=Load()), conversion=-1), Constant(value=' is not a generic class')])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='elen', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='__parameters__')], keywords=[])), UnaryOp(op=Not(), operand=Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='cls', ctx=Load()), conversion=-1), Constant(value=' is not a generic class')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='elen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='alen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='alen', ctx=Load()), ops=[NotEq()], comparators=[Name(id='elen', ctx=Load())]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='__parameters__')], keywords=[]), body=[Assign(targets=[Name(id='parameters', ctx=Store())], value=ListComp(elt=Name(id='p', ctx=Load()), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Call(func=Name(id='_is_unpack', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[]))], is_async=0)])), Assign(targets=[Name(id='num_tv_tuples', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='TypeVarTuple', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='parameters', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_tv_tuples', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), Compare(left=Name(id='alen', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='elen', ctx=Load()), op=Sub(), right=Name(id='num_tv_tuples', ctx=Load()))])]), body=[Return()], orelse=[])], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Too '), FormattedValue(value=IfExp(test=Compare(left=Name(id='alen', ctx=Load()), ops=[Gt()], comparators=[Name(id='elen', ctx=Load())]), body=Constant(value='many'), orelse=Constant(value='few')), conversion=-1), Constant(value=' parameters for '), FormattedValue(value=Name(id='cls', ctx=Load()), conversion=-1), Constant(value='; actual '), FormattedValue(value=Name(id='alen', ctx=Load()), conversion=-1), Constant(value=', expected '), FormattedValue(value=Name(id='elen', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], decorator_list=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=10)], ctx=Load())]), body=[FunctionDef(name='_should_collect_from_parameters', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='GenericAlias', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='UnionType', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], orelse=[If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[FunctionDef(name='_should_collect_from_parameters', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), Attribute(value=Name(id='_types', ctx=Load()), attr='GenericAlias', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], orelse=[FunctionDef(name='_should_collect_from_parameters', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='t', ctx=Load()), attr='_special', ctx=Load()))]))], decorator_list=[])])]), FunctionDef(name='_collect_type_vars', args=arguments(posonlyargs=[], args=[arg(arg='types'), arg(arg='typevar_types')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Collect all type variable contained in types in order of\n    first appearance (lexicographic order). For example::\n\n        _collect_type_vars((T, List[S, T])) == (T, S)\n    ')), If(test=Compare(left=Name(id='typevar_types', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='typevar_types', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='tvars', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='t', ctx=Store()), iter=Name(id='types', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Name(id='typevar_types', ctx=Load())], keywords=[]), Compare(left=Name(id='t', ctx=Load()), ops=[NotIn()], comparators=[Name(id='tvars', ctx=Load())]), UnaryOp(op=Not(), operand=Call(func=Name(id='_is_unpack', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]))]), body=[Expr(value=Call(func=Attribute(value=Name(id='tvars', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='_should_collect_from_parameters', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='tvars', ctx=Load()), attr='extend', ctx=Load()), args=[ListComp(elt=Name(id='t', ctx=Load()), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Attribute(value=Name(id='t', ctx=Load()), attr='__parameters__', ctx=Load()), ifs=[Compare(left=Name(id='t', ctx=Load()), ops=[NotIn()], comparators=[Name(id='tvars', ctx=Load())])], is_async=0)])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='tvars', ctx=Load())], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='NoReturn', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NoReturn', ctx=Load())), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='T')], keywords=[])), Assign(targets=[Name(id='KT', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='KT')], keywords=[])), Assign(targets=[Name(id='VT', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='VT')], keywords=[])), Assign(targets=[Name(id='T_co', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='T_co')], keywords=[keyword(arg='covariant', value=Constant(value=True))])), Assign(targets=[Name(id='T_contra', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='T_contra')], keywords=[keyword(arg='contravariant', value=Constant(value=True))])), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=11)], ctx=Load())]), body=[ImportFrom(module='typing', names=[alias(name='Any')], level=0)], orelse=[ClassDef(name='_AnyMeta', bases=[Name(id='type', ctx=Load())], keywords=[], body=[FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='Any', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='typing_extensions.Any cannot be used with isinstance()')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__instancecheck__', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='Any', ctx=Load())]), body=[Return(value=Constant(value='typing_extensions.Any'))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__repr__', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Any', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='_AnyMeta', ctx=Load()))], body=[Expr(value=Constant(value='Special type indicating an unconstrained type.\n        - Any is compatible with every type.\n        - Any assumed to have all methods.\n        - All values assumed to be instances of Any.\n        Note that all the above statements are true from the point of view of\n        static type checkers. At runtime, Any should not be used with instance\n        checks.\n        ')), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Any', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Any cannot be instantiated')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[])]), Assign(targets=[Name(id='ClassVar', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load())), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Final')], keywords=[]), Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=7)], ctx=Load())])]), body=[Assign(targets=[Name(id='Final', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Final', ctx=Load()))], orelse=[ClassDef(name='_FinalForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Final', ctx=Store())], value=Call(func=Name(id='_FinalForm', ctx=Load()), args=[Constant(value='Final')], keywords=[keyword(arg='doc', value=Constant(value='A special typing construct to indicate that a name\n                       cannot be re-assigned or overridden in a subclass.\n                       For example:\n\n                           MAX_SIZE: Final = 9000\n                           MAX_SIZE += 1  # Error reported by type checker\n\n                           class Connection:\n                               TIMEOUT: Final[int] = 10\n                           class FastConnector(Connection):\n                               TIMEOUT = 1  # Error reported by type checker\n\n                       There is no runtime checking of these properties.'))]))]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=11)], ctx=Load())]), body=[Assign(targets=[Name(id='final', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='final', ctx=Load()))], orelse=[FunctionDef(name='final', args=arguments(posonlyargs=[], args=[arg(arg='f')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='This decorator can be used to indicate to type checkers that\n        the decorated method cannot be overridden, and decorated class\n        cannot be subclassed. For example:\n\n            class Base:\n                @final\n                def done(self) -> None:\n                    ...\n            class Sub(Base):\n                def done(self) -> None:  # Error reported by type checker\n                    ...\n            @final\n            class Leaf:\n                ...\n            class Other(Leaf):  # Error reported by type checker\n                ...\n\n        There is no runtime checking of these properties. The decorator\n        sets the ``__final__`` attribute to ``True`` on the decorated object\n        to allow runtime introspection.\n        ')), Try(body=[Assign(targets=[Attribute(value=Name(id='f', ctx=Load()), attr='__final__', ctx=Store())], value=Constant(value=True))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Name(id='f', ctx=Load()))], decorator_list=[])]), FunctionDef(name='IntVar', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Literal')], keywords=[]), body=[Assign(targets=[Name(id='Literal', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Literal', ctx=Load()))], orelse=[ClassDef(name='_LiteralForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Literal', ctx=Store())], value=Call(func=Name(id='_LiteralForm', ctx=Load()), args=[Constant(value='Literal')], keywords=[keyword(arg='doc', value=Constant(value="A type that can be used to indicate to type checkers\n                           that the corresponding value has a value literally equivalent\n                           to the provided parameter. For example:\n\n                               var: Literal[4] = 4\n\n                           The type checker understands that 'var' is literally equal to\n                           the value 4 and no other value.\n\n                           Literal[...] cannot be subclassed. There is no runtime\n                           checking verifying that the parameter is actually a value\n                           instead of a type."))]))]), Assign(targets=[Name(id='_overload_dummy', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_overload_dummy', ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='get_overloads')], keywords=[]), body=[Assign(targets=[Name(id='overload', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())), Assign(targets=[Name(id='get_overloads', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_overloads', ctx=Load())), Assign(targets=[Name(id='clear_overloads', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='clear_overloads', ctx=Load()))], orelse=[Assign(targets=[Name(id='_overload_registry', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='defaultdict', ctx=Load()), args=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Attribute(value=Name(id='collections', ctx=Load()), attr='defaultdict', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])], keywords=[])), FunctionDef(name='overload', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Decorator for overloaded functions/methods.\n\n        In a stub file, place two or more stub definitions for the same\n        function in a row, each decorated with @overload.  For example:\n\n        @overload\n        def utf8(value: None) -> None: ...\n        @overload\n        def utf8(value: bytes) -> bytes: ...\n        @overload\n        def utf8(value: str) -> bytes: ...\n\n        In a non-stub file (i.e. a regular .py file), do the same but\n        follow it with an implementation.  The implementation should *not*\n        be decorated with @overload.  For example:\n\n        @overload\n        def utf8(value: None) -> None: ...\n        @overload\n        def utf8(value: bytes) -> bytes: ...\n        @overload\n        def utf8(value: str) -> bytes: ...\n        def utf8(value):\n            # implementation goes here\n\n        The overloads for a function can be retrieved at runtime using the\n        get_overloads() function.\n        ')), Assign(targets=[Name(id='f', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__func__'), Name(id='func', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id='_overload_registry', ctx=Load()), slice=Attribute(value=Name(id='f', ctx=Load()), attr='__module__', ctx=Load()), ctx=Load()), slice=Attribute(value=Name(id='f', ctx=Load()), attr='__qualname__', ctx=Load()), ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='f', ctx=Load()), attr='__code__', ctx=Load()), attr='co_firstlineno', ctx=Load()), ctx=Store())], value=Name(id='func', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Name(id='_overload_dummy', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_overloads', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return all defined overloads for *func* as a sequence.')), Assign(targets=[Name(id='f', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__func__'), Name(id='func', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='f', ctx=Load()), attr='__module__', ctx=Load()), ops=[NotIn()], comparators=[Name(id='_overload_registry', ctx=Load())]), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='mod_dict', ctx=Store())], value=Subscript(value=Name(id='_overload_registry', ctx=Load()), slice=Attribute(value=Name(id='f', ctx=Load()), attr='__module__', ctx=Load()), ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='f', ctx=Load()), attr='__qualname__', ctx=Load()), ops=[NotIn()], comparators=[Name(id='mod_dict', ctx=Load())]), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Name(id='mod_dict', ctx=Load()), slice=Attribute(value=Name(id='f', ctx=Load()), attr='__qualname__', ctx=Load()), ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='clear_overloads', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Clear all overloads in the registry.')), Expr(value=Call(func=Attribute(value=Name(id='_overload_registry', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[]))], decorator_list=[])]), Assign(targets=[Name(id='Type', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Type', ctx=Load())), Assign(targets=[Name(id='Awaitable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Awaitable', ctx=Load())), Assign(targets=[Name(id='Coroutine', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Coroutine', ctx=Load())), Assign(targets=[Name(id='AsyncIterable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncIterable', ctx=Load())), Assign(targets=[Name(id='AsyncIterator', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncIterator', ctx=Load())), Assign(targets=[Name(id='Deque', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Deque', ctx=Load())), Assign(targets=[Name(id='ContextManager', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ContextManager', ctx=Load())), Assign(targets=[Name(id='AsyncContextManager', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncContextManager', ctx=Load())), Assign(targets=[Name(id='DefaultDict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='DefaultDict', ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='OrderedDict')], keywords=[]), body=[Assign(targets=[Name(id='OrderedDict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='OrderedDict', ctx=Load()))], orelse=[Assign(targets=[Name(id='OrderedDict', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_alias', ctx=Load()), args=[Attribute(value=Name(id='collections', ctx=Load()), attr='OrderedDict', ctx=Load()), Tuple(elts=[Name(id='KT', ctx=Load()), Name(id='VT', ctx=Load())], ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='Counter', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Counter', ctx=Load())), Assign(targets=[Name(id='ChainMap', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ChainMap', ctx=Load())), Assign(targets=[Name(id='AsyncGenerator', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='AsyncGenerator', ctx=Load())), Assign(targets=[Name(id='NewType', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NewType', ctx=Load())), Assign(targets=[Name(id='Text', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Text', ctx=Load())), Assign(targets=[Name(id='TYPE_CHECKING', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TYPE_CHECKING', ctx=Load())), Assign(targets=[Name(id='_PROTO_WHITELIST', ctx=Store())], value=List(elts=[Constant(value='Callable'), Constant(value='Awaitable'), Constant(value='Iterable'), Constant(value='Iterator'), Constant(value='AsyncIterable'), Constant(value='AsyncIterator'), Constant(value='Hashable'), Constant(value='Sized'), Constant(value='Container'), Constant(value='Collection'), Constant(value='Reversible'), Constant(value='ContextManager'), Constant(value='AsyncContextManager')], ctx=Load())), FunctionDef(name='_get_protocol_attrs', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='base', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__mro__', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__name__', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='Protocol'), Constant(value='Generic')], ctx=Load())]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='annotations', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='base', ctx=Load()), Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), For(target=Name(id='attr', ctx=Store()), iter=BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Add(), right=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='annotations', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), body=[If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='attr', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_abc_')], keywords=[])), Compare(left=Name(id='attr', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value='__abstractmethods__'), Constant(value='__annotations__'), Constant(value='__weakref__'), Constant(value='_is_protocol'), Constant(value='_is_runtime_protocol'), Constant(value='__dict__'), Constant(value='__args__'), Constant(value='__slots__'), Constant(value='__next_in_mro__'), Constant(value='__parameters__'), Constant(value='__origin__'), Constant(value='__orig_bases__'), Constant(value='__extra__'), Constant(value='__tree_hash__'), Constant(value='__doc__'), Constant(value='__subclasshook__'), Constant(value='__init__'), Constant(value='__new__'), Constant(value='__module__'), Constant(value='_MutableMapping__marker'), Constant(value='_gorg')], ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='attrs', ctx=Load()))], decorator_list=[]), FunctionDef(name='_is_callable_members_only', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='callable', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='attr', ctx=Load()), Constant(value=None)], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='attr', ctx=Store()), iter=Call(func=Name(id='_get_protocol_attrs', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='_maybe_adjust_parameters', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper function used in Protocol.__init_subclass__ and _TypedDictMeta.__new__.\n\n    The contents of this function are very similar\n    to logic found in typing.Generic.__init_subclass__\n    on the CPython main branch.\n    ')), Assign(targets=[Name(id='tvars', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Constant(value='__orig_bases__'), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Name(id='tvars', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_collect_type_vars', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='__orig_bases__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='gvars', ctx=Store())], value=Constant(value=None)), For(target=Name(id='base', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__orig_bases__', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='base', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__origin__', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), Name(id='Protocol', ctx=Load())], ctx=Load())])]), body=[Assign(targets=[Name(id='the_base', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__origin__', ctx=Load()), attr='__name__', ctx=Load())), If(test=Compare(left=Name(id='gvars', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot inherit from Generic[...] and/or Protocol[...] multiple types.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='gvars', ctx=Store())], value=Attribute(value=Name(id='base', ctx=Load()), attr='__parameters__', ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='gvars', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='gvars', ctx=Store())], value=Name(id='tvars', ctx=Load()))], orelse=[Assign(targets=[Name(id='tvarset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='tvars', ctx=Load())], keywords=[])), Assign(targets=[Name(id='gvarset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='gvars', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='tvarset', ctx=Load()), ops=[LtE()], comparators=[Name(id='gvarset', ctx=Load())])), body=[Assign(targets=[Name(id='s_vars', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Name(id='tvars', ctx=Load()), ifs=[Compare(left=Name(id='t', ctx=Load()), ops=[NotIn()], comparators=[Name(id='gvarset', ctx=Load())])], is_async=0)])], keywords=[])), Assign(targets=[Name(id='s_args', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='g', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='g', ctx=Store()), iter=Name(id='gvars', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Some type variables ('), FormattedValue(value=Name(id='s_vars', ctx=Load()), conversion=-1), Constant(value=') are not listed in '), FormattedValue(value=Name(id='the_base', ctx=Load()), conversion=-1), Constant(value='['), FormattedValue(value=Name(id='s_args', ctx=Load()), conversion=-1), Constant(value=']')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='tvars', ctx=Store())], value=Name(id='gvars', ctx=Load()))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='tvars', ctx=Load())], keywords=[]))], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Protocol')], keywords=[]), body=[Assign(targets=[Name(id='Protocol', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Protocol', ctx=Load()))], orelse=[FunctionDef(name='_no_init', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='_is_protocol', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Protocols cannot be instantiated')], keywords=[]))], orelse=[])], decorator_list=[]), ClassDef(name='_ProtocolMeta', bases=[Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load())], keywords=[], body=[FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='instance')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_is_protocol'), Constant(value=False)], keywords=[])), Call(func=Name(id='_is_callable_members_only', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[])]), Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Name(id='instance', ctx=Load()), attr='__class__', ctx=Load()), Name(id='cls', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=True))], orelse=[]), If(test=Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Load()), body=[If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='instance', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='attr', ctx=Load()), Constant(value=None)], keywords=[])], keywords=[])), Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='instance', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)])])]), generators=[comprehension(target=Name(id='attr', ctx=Store()), iter=Call(func=Name(id='_get_protocol_attrs', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__instancecheck__', ctx=Load()), args=[Name(id='instance', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Protocol', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='_ProtocolMeta', ctx=Load()))], body=[Expr(value=Constant(value='Base class for protocol classes. Protocol classes are defined as::\n\n            class Proto(Protocol):\n                def meth(self) -> int:\n                    ...\n\n        Such classes are primarily used with static type checkers that recognize\n        structural subtyping (static duck-typing), for example::\n\n            class C:\n                def meth(self) -> int:\n                    return 0\n\n            def func(x: Proto) -> int:\n                return x.meth()\n\n            func(C())  # Passes static type check\n\n        See PEP 544 for details. Protocol classes decorated with\n        @typing_extensions.runtime act as simple-minded runtime protocol that checks\n        only the presence of given attributes, ignoring their type signatures.\n\n        Protocol classes can be generic, they are defined as::\n\n            class GenProto(Protocol[T]):\n                def meth(self) -> T:\n                    ...\n        ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), Assign(targets=[Name(id='_is_protocol', ctx=Store())], value=Constant(value=True)), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Type Protocol cannot be instantiated; it can only be used as a base class')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__class_getitem__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='params', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='params', ctx=Store())], value=Tuple(elts=[Name(id='params', ctx=Load())], ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='params', ctx=Load())), Compare(left=Name(id='cls', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Tuple', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Parameter list to '), FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__qualname__', ctx=Load()), conversion=-1), Constant(value='[...] cannot be empty')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Parameters to generic types must be types.')), Assign(targets=[Name(id='params', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='params', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='p', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='params', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Assign(targets=[Name(id='i', ctx=Store())], value=Constant(value=0)), While(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Parameters to Protocol[...] must all be type variables. Parameter '), FormattedValue(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), conversion=-1), Constant(value=' is '), FormattedValue(value=Subscript(value=Name(id='params', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[])], keywords=[]), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Parameters to Protocol[...] must all be unique')], keywords=[]))], orelse=[])], orelse=[Expr(value=Call(func=Name(id='_check_generic', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='params', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='__parameters__', ctx=Load())], keywords=[])], keywords=[]))]), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='params', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Compare(left=Constant(value='__orig_bases__'), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Name(id='error', ctx=Store())], value=Compare(left=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__orig_bases__', ctx=Load())]))], orelse=[Assign(targets=[Name(id='error', ctx=Store())], value=Compare(left=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load())]))]), If(test=Name(id='error', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot inherit from plain Generic')], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='_maybe_adjust_parameters', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_protocol'), Constant(value=None)], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='b', ctx=Load()), ops=[Is()], comparators=[Name(id='Protocol', ctx=Load())]), generators=[comprehension(target=Name(id='b', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), FunctionDef(name='_proto_hook', args=arguments(posonlyargs=[], args=[arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='_is_protocol'), Constant(value=None)], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='_is_runtime_protocol'), Constant(value=False)], keywords=[])), body=[If(test=Compare(left=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=2)], keywords=[]), attr='f_globals', ctx=Load()), slice=Constant(value='__name__'), ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='abc'), Constant(value='functools')], ctx=Load())]), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Instance and class checks can only be used with @runtime protocols')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='_is_callable_members_only', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[])), body=[If(test=Compare(left=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=2)], keywords=[]), attr='f_globals', ctx=Load()), slice=Constant(value='__name__'), ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='abc'), Constant(value='functools')], ctx=Load())]), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="Protocols with non-method members don't support issubclass()")], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='type', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='issubclass() arg 1 must be a class')], keywords=[]))], orelse=[]), For(target=Name(id='attr', ctx=Store()), iter=Call(func=Name(id='_get_protocol_attrs', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), body=[For(target=Name(id='base', ctx=Store()), iter=Attribute(value=Name(id='other', ctx=Load()), attr='__mro__', ctx=Load()), body=[If(test=Compare(left=Name(id='attr', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load())]), body=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), slice=Name(id='attr', ctx=Load()), ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Break()], orelse=[]), Assign(targets=[Name(id='annotations', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='base', ctx=Load()), Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='annotations', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Mapping', ctx=Load())], keywords=[]), Compare(left=Name(id='attr', ctx=Load()), ops=[In()], comparators=[Name(id='annotations', ctx=Load())]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='_ProtocolMeta', ctx=Load())], keywords=[]), Attribute(value=Name(id='other', ctx=Load()), attr='_is_protocol', ctx=Load())]), body=[Break()], orelse=[])], orelse=[Return(value=Name(id='NotImplemented', ctx=Load()))])], orelse=[]), Return(value=Constant(value=True))], decorator_list=[]), If(test=Compare(left=Constant(value='__subclasshook__'), ops=[NotIn()], comparators=[Attribute(value=Name(id='cls', ctx=Load()), attr='__dict__', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__subclasshook__', ctx=Store())], value=Name(id='_proto_hook', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Load())), body=[Return()], orelse=[]), For(target=Name(id='base', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Compare(left=Name(id='base', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Name(id='object', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())], ctx=Load())]), BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__module__', ctx=Load()), ops=[Eq()], comparators=[Constant(value='collections.abc')]), Compare(left=Attribute(value=Name(id='base', ctx=Load()), attr='__name__', ctx=Load()), ops=[In()], comparators=[Name(id='_PROTO_WHITELIST', ctx=Load())])]), BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='base', ctx=Load()), Name(id='_ProtocolMeta', ctx=Load())], keywords=[]), Attribute(value=Name(id='base', ctx=Load()), attr='_is_protocol', ctx=Load())])])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Protocols can only inherit from other protocols, got '), FormattedValue(value=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__init__', ctx=Store())], value=Name(id='_no_init', ctx=Load()))], decorator_list=[])], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='runtime_checkable')], keywords=[]), body=[Assign(targets=[Name(id='runtime_checkable', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='runtime_checkable', ctx=Load()))], orelse=[FunctionDef(name='runtime_checkable', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Mark a protocol class as a runtime protocol, so that it\n        can be used with isinstance() and issubclass(). Raise TypeError\n        if applied to a non-protocol class.\n\n        This allows a simple-minded structural check very similar to the\n        one-offs in collections.abc such as Hashable.\n        ')), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='_ProtocolMeta', ctx=Load())], keywords=[])), UnaryOp(op=Not(), operand=Attribute(value=Name(id='cls', ctx=Load()), attr='_is_protocol', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='@runtime_checkable can be only applied to protocol classes, got '), FormattedValue(value=Name(id='cls', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='_is_runtime_protocol', ctx=Store())], value=Constant(value=True)), Return(value=Name(id='cls', ctx=Load()))], decorator_list=[])]), Assign(targets=[Name(id='runtime', ctx=Store())], value=Name(id='runtime_checkable', ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='SupportsIndex')], keywords=[]), body=[Assign(targets=[Name(id='SupportsIndex', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='SupportsIndex', ctx=Load()))], orelse=[ClassDef(name='SupportsIndex', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__index__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Required')], keywords=[]), body=[Assign(targets=[Name(id='TypedDict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypedDict', ctx=Load())), Assign(targets=[Name(id='_TypedDictMeta', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_TypedDictMeta', ctx=Load())), Assign(targets=[Name(id='is_typeddict', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='is_typeddict', ctx=Load()))], orelse=[FunctionDef(name='_check_fails', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[If(test=Compare(left=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), slice=Constant(value='__name__'), ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='abc'), Constant(value='functools'), Constant(value='typing')], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypedDict does not support instance and class checks')], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='_dict_new', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='args', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypedDict.__new__(): not enough arguments')], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='args', ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], ctx=Load())), Return(value=Call(func=Name(id='dict', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='_dict_new', ctx=Load()), attr='__text_signature__', ctx=Store())], value=Constant(value='($cls, _typename, _fields=None, /, **kwargs)')), FunctionDef(name='_typeddict_new', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[arg(arg='total')], kw_defaults=[Constant(value=True)], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='args', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypedDict.__new__(): not enough arguments')], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='args', ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], ctx=Load())), If(test=Name(id='args', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='typename', ctx=Store()), Name(id='args', ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], ctx=Load()))], orelse=[If(test=Compare(left=Constant(value='_typename'), ops=[In()], comparators=[Name(id='kwargs', ctx=Load())]), body=[Assign(targets=[Name(id='typename', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='_typename')], keywords=[])), Import(names=[alias(name='warnings')]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value="Passing '_typename' as keyword argument is deprecated"), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="TypedDict.__new__() missing 1 required positional argument: '_typename'")], keywords=[]))])]), If(test=Name(id='args', ctx=Load()), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='fields', ctx=Store())], ctx=Store())], value=Name(id='args', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='TypedDict.__new__() takes from 2 to 3 positional arguments but '), FormattedValue(value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=2)), conversion=-1), Constant(value=' were given')])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='_fields'), ops=[In()], comparators=[Name(id='kwargs', ctx=Load())]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)])]), body=[Assign(targets=[Name(id='fields', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='_fields')], keywords=[])), Import(names=[alias(name='warnings')]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value="Passing '_fields' as keyword argument is deprecated"), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))], orelse=[Assign(targets=[Name(id='fields', ctx=Store())], value=Constant(value=None))])]), If(test=Compare(left=Name(id='fields', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='fields', ctx=Store())], value=Name(id='kwargs', ctx=Load()))], orelse=[If(test=Name(id='kwargs', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='TypedDict takes either a dict or keyword arguments, but not both')], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='ns', ctx=Store())], value=Dict(keys=[Constant(value='__annotations__')], values=[Call(func=Name(id='dict', ctx=Load()), args=[Name(id='fields', ctx=Load())], keywords=[])])), Try(body=[Assign(targets=[Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__module__'), ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__name__'), Constant(value='__main__')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Call(func=Name(id='_TypedDictMeta', ctx=Load()), args=[Name(id='typename', ctx=Load()), Tuple(elts=[], ctx=Load()), Name(id='ns', ctx=Load())], keywords=[keyword(arg='total', value=Name(id='total', ctx=Load()))]))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='_typeddict_new', ctx=Load()), attr='__text_signature__', ctx=Store())], value=Constant(value='($cls, _typename, _fields=None, /, *, total=True, **kwargs)')), ClassDef(name='_TypedDictMeta', bases=[Name(id='type', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name'), arg(arg='bases'), arg(arg='ns'), arg(arg='total')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='bases', ctx=Load()), Name(id='ns', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name'), arg(arg='bases'), arg(arg='ns'), arg(arg='total')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__new__'), ctx=Store())], value=IfExp(test=Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='TypedDict')]), body=Name(id='_typeddict_new', ctx=Load()), orelse=Name(id='_dict_new', ctx=Load()))), Assign(targets=[Name(id='tp_dict', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='name', ctx=Load()), Tuple(elts=[Name(id='dict', ctx=Load())], ctx=Load()), Name(id='ns', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='issubclass', ctx=Load()), args=[Name(id='base', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__bases__', ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), Name(id='dict', ctx=Load())], ctx=Load())), Expr(value=Call(func=Name(id='_maybe_adjust_parameters', ctx=Load()), args=[Name(id='tp_dict', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='annotations', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='own_annotations', ctx=Store())], value=Call(func=Attribute(value=Name(id='ns', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value="TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type")), Assign(targets=[Name(id='own_annotations', ctx=Store())], value=DictComp(key=Name(id='n', ctx=Load()), value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='tp', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='own_annotations', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='required_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='optional_keys', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='annotations', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='required_keys', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__required_keys__'), Tuple(elts=[], ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='optional_keys', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='base', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__optional_keys__'), Tuple(elts=[], ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='annotations', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='own_annotations', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='annotation_key', ctx=Store()), Name(id='annotation_type', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='own_annotations', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='annotation_origin', ctx=Store())], value=Call(func=Name(id='get_origin', ctx=Load()), args=[Name(id='annotation_type', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='annotation_origin', ctx=Load()), ops=[Is()], comparators=[Name(id='Annotated', ctx=Load())]), body=[Assign(targets=[Name(id='annotation_args', ctx=Store())], value=Call(func=Name(id='get_args', ctx=Load()), args=[Name(id='annotation_type', ctx=Load())], keywords=[])), If(test=Name(id='annotation_args', ctx=Load()), body=[Assign(targets=[Name(id='annotation_type', ctx=Store())], value=Subscript(value=Name(id='annotation_args', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='annotation_origin', ctx=Store())], value=Call(func=Name(id='get_origin', ctx=Load()), args=[Name(id='annotation_type', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='annotation_origin', ctx=Load()), ops=[Is()], comparators=[Name(id='Required', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='required_keys', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='annotation_key', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='annotation_origin', ctx=Load()), ops=[Is()], comparators=[Name(id='NotRequired', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='optional_keys', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='annotation_key', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='total', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='required_keys', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='annotation_key', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='optional_keys', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='annotation_key', ctx=Load())], keywords=[]))])])])], orelse=[]), Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__annotations__', ctx=Store())], value=Name(id='annotations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__required_keys__', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='required_keys', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__optional_keys__', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='optional_keys', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='tp_dict', ctx=Load()), Constant(value='__total__')], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='tp_dict', ctx=Load()), attr='__total__', ctx=Store())], value=Name(id='total', ctx=Load()))], orelse=[]), Return(value=Name(id='tp_dict', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='__instancecheck__', ctx=Store()), Name(id='__subclasscheck__', ctx=Store())], value=Name(id='_check_fails', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='TypedDict', ctx=Store())], value=Call(func=Name(id='_TypedDictMeta', ctx=Load()), args=[Constant(value='TypedDict'), Tuple(elts=[Name(id='dict', ctx=Load())], ctx=Load()), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='TypedDict', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='__name__', ctx=Load())), Assign(targets=[Attribute(value=Name(id='TypedDict', ctx=Load()), attr='__doc__', ctx=Store())], value=Constant(value="A simple typed name space. At runtime it is equivalent to a plain dict.\n\n        TypedDict creates a dictionary type that expects all of its\n        instances to have a certain set of keys, with each key\n        associated with a value of a consistent type. This expectation\n        is not checked at runtime but is only enforced by type checkers.\n        Usage::\n\n            class Point2D(TypedDict):\n                x: int\n                y: int\n                label: str\n\n            a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\n            b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check\n\n            assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')\n\n        The type info can be accessed via the Point2D.__annotations__ dict, and\n        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.\n        TypedDict supports two additional equivalent forms::\n\n            Point2D = TypedDict('Point2D', x=int, y=int, label=str)\n            Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})\n\n        The class syntax is only supported in Python 3.6+, while two other\n        syntax forms work for Python 2.7 and 3.2+\n        ")), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='_TypedDictMeta')], keywords=[]), body=[Assign(targets=[Name(id='_TYPEDDICT_TYPES', ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_TypedDictMeta', ctx=Load()), Name(id='_TypedDictMeta', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Name(id='_TYPEDDICT_TYPES', ctx=Store())], value=Tuple(elts=[Name(id='_TypedDictMeta', ctx=Load())], ctx=Load()))]), FunctionDef(name='is_typeddict', args=arguments(posonlyargs=[], args=[arg(arg='tp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if an annotation is a TypedDict class\n\n        For example::\n            class Film(TypedDict):\n                title: str\n                year: int\n\n            is_typeddict(Film)  # => True\n            is_typeddict(Union[list, str])  # => False\n        ')), Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='_TYPEDDICT_TYPES', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='assert_type')], keywords=[]), body=[Assign(targets=[Name(id='assert_type', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='assert_type', ctx=Load()))], orelse=[FunctionDef(name='assert_type', args=arguments(posonlyargs=[], args=[arg(arg='__val'), arg(arg='__typ')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Assert (to the type checker) that the value is of the given type.\n\n        When the type checker encounters a call to assert_type(), it\n        emits an error if the value is not of the specified type::\n\n            def greet(name: str) -> None:\n                assert_type(name, str)  # ok\n                assert_type(name, int)  # type checker error\n\n        At runtime this returns the first argument unchanged and otherwise\n        does nothing.\n        ')), Return(value=Name(id='__val', ctx=Load()))], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Required')], keywords=[]), body=[Assign(targets=[Name(id='get_type_hints', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_type_hints', ctx=Load()))], orelse=[Import(names=[alias(name='functools')]), Import(names=[alias(name='types')]), FunctionDef(name='_strip_extras', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Strips Annotated, Required and NotRequired from a given type.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Attribute(value=Name(id='t', ctx=Load()), attr='__origin__', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='t', ctx=Load()), Constant(value='__origin__')], keywords=[]), Compare(left=Attribute(value=Name(id='t', ctx=Load()), attr='__origin__', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Name(id='Required', ctx=Load()), Name(id='NotRequired', ctx=Load())], ctx=Load())])]), body=[Return(value=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='stripped_args', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='stripped_args', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load())]), body=[Return(value=Name(id='t', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='copy_with', ctx=Load()), args=[Name(id='stripped_args', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='types', ctx=Load()), Constant(value='GenericAlias')], keywords=[]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Attribute(value=Name(id='types', ctx=Load()), attr='GenericAlias', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='stripped_args', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='stripped_args', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load())]), body=[Return(value=Name(id='t', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='types', ctx=Load()), attr='GenericAlias', ctx=Load()), args=[Attribute(value=Name(id='t', ctx=Load()), attr='__origin__', ctx=Load()), Name(id='stripped_args', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='types', ctx=Load()), Constant(value='UnionType')], keywords=[]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Attribute(value=Name(id='types', ctx=Load()), attr='UnionType', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='stripped_args', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Name(id='stripped_args', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='t', ctx=Load()), attr='__args__', ctx=Load())]), body=[Return(value=Name(id='t', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='reduce', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='or_', ctx=Load()), Name(id='stripped_args', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='t', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_type_hints', args=arguments(posonlyargs=[], args=[arg(arg='obj'), arg(arg='globalns'), arg(arg='localns'), arg(arg='include_extras')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Return type hints for an object.\n\n        This is often the same as obj.__annotations__, but it handles\n        forward references encoded as string literals, adds Optional[t] if a\n        default value equal to None is set and recursively replaces all\n        'Annotated[T, ...]', 'Required[T]' or 'NotRequired[T]' with 'T'\n        (unless 'include_extras=True').\n\n        The argument may be a module, class, method, or function. The annotations\n        are returned as a dictionary. For classes, annotations include also\n        inherited members.\n\n        TypeError is raised if the argument is not of a type that can contain\n        annotations, and an empty dictionary is returned if no annotations are\n        present.\n\n        BEWARE -- the behavior of globalns and localns is counterintuitive\n        (unless you are familiar with how eval() and exec() work).  The\n        search order is locals first, then globals.\n\n        - If no dict arguments are passed, an attempt is made to use the\n          globals from obj (or the respective module's globals for classes),\n          and these are also used as the locals.  If the object does not appear\n          to have globals, an empty dictionary is used.\n\n        - If one dict argument is passed, it is used for both globals and\n          locals.\n\n        - If two dict arguments are passed, they specify globals and\n          locals, respectively.\n        ")), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Annotated')], keywords=[]), body=[Assign(targets=[Name(id='hint', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='get_type_hints', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[keyword(arg='globalns', value=Name(id='globalns', ctx=Load())), keyword(arg='localns', value=Name(id='localns', ctx=Load())), keyword(arg='include_extras', value=Constant(value=True))]))], orelse=[Assign(targets=[Name(id='hint', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='get_type_hints', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[keyword(arg='globalns', value=Name(id='globalns', ctx=Load())), keyword(arg='localns', value=Name(id='localns', ctx=Load()))]))]), If(test=Name(id='include_extras', ctx=Load()), body=[Return(value=Name(id='hint', ctx=Load()))], orelse=[]), Return(value=DictComp(key=Name(id='k', ctx=Load()), value=Call(func=Name(id='_strip_extras', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='t', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='hint', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Annotated')], keywords=[]), body=[Assign(targets=[Name(id='Annotated', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Annotated', ctx=Load())), Assign(targets=[Name(id='_AnnotatedAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_AnnotatedAlias', ctx=Load()))], orelse=[ClassDef(name='_AnnotatedAlias', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value="Runtime representation of an annotated type.\n\n        At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'\n        with extra annotations. The alias behaves like a normal typing alias,\n        instantiating is the same as instantiating the underlying type, binding\n        it to types is also the same.\n        ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin'), arg(arg='metadata')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='origin', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='origin', ctx=Load()), attr='__metadata__', ctx=Load()), op=Add(), right=Name(id='metadata', ctx=Load()))), Assign(targets=[Name(id='origin', ctx=Store())], value=Attribute(value=Name(id='origin', ctx=Load()), attr='__origin__', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='origin', ctx=Load()), Name(id='origin', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Store())], value=Name(id='metadata', ctx=Load()))], decorator_list=[]), FunctionDef(name='copy_with', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)])), Assign(targets=[Name(id='new_type', ctx=Store())], value=Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load())), Return(value=Call(func=Name(id='_AnnotatedAlias', ctx=Load()), args=[Name(id='new_type', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='typing_extensions.Annotated['), FormattedValue(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load())], keywords=[]), conversion=-1), Constant(value=', '), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), conversion=-1), Constant(value=']')]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='operator', ctx=Load()), attr='getitem', ctx=Load()), Tuple(elts=[Name(id='Annotated', ctx=Load()), BinOp(left=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load())], ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load()))], ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__origin__', ctx=Load())]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__metadata__', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__metadata__', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Annotated', bases=[], keywords=[], body=[Expr(value=Constant(value="Add context specific metadata to a type.\n\n        Example: Annotated[int, runtime_check.Unsigned] indicates to the\n        hypothetical runtime_check module that this type is an unsigned int.\n        Every other consumer of this type can ignore this metadata and treat\n        this type as int.\n\n        The first argument to Annotated must be a valid type (and will be in\n        the __origin__ field), the remaining arguments are kept as a tuple in\n        the __extra__ field.\n\n        Details:\n\n        - It's an error to call `Annotated` with less than two arguments.\n        - Nested Annotated are flattened::\n\n            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n        - Instantiating an annotated type is equivalent to instantiating the\n        underlying type::\n\n            Annotated[C, Ann1](5) == C(5)\n\n        - Annotated can be used as a generic type alias::\n\n            Optimized = Annotated[T, runtime.Optimize()]\n            Optimized[int] == Annotated[int, runtime.Optimize()]\n\n            OptimizedList = Annotated[List[T], runtime.Optimize()]\n            OptimizedList[int] == Annotated[List[int], runtime.Optimize()]\n        ")), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Type Annotated cannot be instantiated.')], keywords=[]))], decorator_list=[]), FunctionDef(name='__class_getitem__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='params', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='params', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=2)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Annotated[...] should be used with at least two arguments (a type and an annotation).')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='allowed_special_forms', ctx=Store())], value=Tuple(elts=[Name(id='ClassVar', ctx=Load()), Name(id='Final', ctx=Load())], ctx=Load())), If(test=Compare(left=Call(func=Name(id='get_origin', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), ops=[In()], comparators=[Name(id='allowed_special_forms', ctx=Load())]), body=[Assign(targets=[Name(id='origin', ctx=Store())], value=Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Annotated[t, ...]: t must be a type.')), Assign(targets=[Name(id='origin', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='params', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='_AnnotatedAlias', ctx=Load()), args=[Name(id='origin', ctx=Load()), Name(id='metadata', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot subclass '), FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__module__', ctx=Load()), conversion=-1), Constant(value='.Annotated')])], keywords=[]))], decorator_list=[])], decorator_list=[])]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=10)], ctx=Load())]), body=[Assign(targets=[Name(id='get_origin', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_origin', ctx=Load())), Assign(targets=[Name(id='get_args', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='get_args', ctx=Load()))], orelse=[Try(body=[ImportFrom(module='typing', names=[alias(name='_BaseGenericAlias')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='_BaseGenericAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()))])], orelse=[], finalbody=[]), Try(body=[ImportFrom(module='typing', names=[alias(name='GenericAlias', asname='_typing_GenericAlias')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='_typing_GenericAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()))])], orelse=[], finalbody=[]), FunctionDef(name='get_origin', args=arguments(posonlyargs=[], args=[arg(arg='tp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the unsubscripted version of a type.\n\n        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar\n        and Annotated. Return None for unsupported types. Examples::\n\n            get_origin(Literal[42]) is Literal\n            get_origin(int) is None\n            get_origin(ClassVar[int]) is ClassVar\n            get_origin(Generic) is Generic\n            get_origin(Generic[T]) is Generic\n            get_origin(Union[T, int]) is Union\n            get_origin(List[Tuple[T, T]][int]) == list\n            get_origin(P.args) is P\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Return(value=Name(id='Annotated', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), Name(id='_typing_GenericAlias', ctx=Load()), Name(id='_BaseGenericAlias', ctx=Load()), Name(id='ParamSpecArgs', ctx=Load()), Name(id='ParamSpecKwargs', ctx=Load())], ctx=Load())], keywords=[]), body=[Return(value=Attribute(value=Name(id='tp', ctx=Load()), attr='__origin__', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='tp', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())]), body=[Return(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='get_args', args=arguments(posonlyargs=[], args=[arg(arg='tp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get type arguments with all substitutions performed.\n\n        For unions, basic simplifications used by Union constructor are performed.\n        Examples::\n            get_args(Dict[str, int]) == (str, int)\n            get_args(int) == ()\n            get_args(Union[int, Union[T, int], str][int]) == (int, str)\n            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])\n            get_args(Callable[[], T][int]) == ([], int)\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Name(id='_AnnotatedAlias', ctx=Load())], keywords=[]), body=[Return(value=BinOp(left=Tuple(elts=[Attribute(value=Name(id='tp', ctx=Load()), attr='__origin__', ctx=Load())], ctx=Load()), op=Add(), right=Attribute(value=Name(id='tp', ctx=Load()), attr='__metadata__', ctx=Load())))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), Name(id='_typing_GenericAlias', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='tp', ctx=Load()), Constant(value='_special'), Constant(value=False)], keywords=[]), body=[Return(value=Tuple(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='res', ctx=Store())], value=Attribute(value=Name(id='tp', ctx=Load()), attr='__args__', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='get_origin', ctx=Load()), args=[Name(id='tp', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Attribute(value=Attribute(value=Name(id='collections', ctx=Load()), attr='abc', ctx=Load()), attr='Callable', ctx=Load())]), Compare(left=Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[IsNot()], comparators=[Name(id='Ellipsis', ctx=Load())])]), body=[Assign(targets=[Name(id='res', ctx=Store())], value=Tuple(elts=[Call(func=Name(id='list', ctx=Load()), args=[Subscript(value=Name(id='res', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[]), Subscript(value=Name(id='res', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[], ctx=Load()))], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeAlias')], keywords=[]), body=[Assign(targets=[Name(id='TypeAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeAlias', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[ClassDef(name='_TypeAliasForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[])], decorator_list=[]), FunctionDef(name='TypeAlias', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Special marker indicating that an assignment should\n        be recognized as a proper type alias definition by type\n        checkers.\n\n        For example::\n\n            Predicate: TypeAlias = Callable[..., bool]\n\n        It's invalid when used anywhere except as in the example above.\n        ")), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not subscriptable')])], keywords=[]))], decorator_list=[Name(id='_TypeAliasForm', ctx=Load())])], orelse=[ClassDef(name='_TypeAliasForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='TypeAlias', ctx=Store())], value=Call(func=Name(id='_TypeAliasForm', ctx=Load()), args=[Constant(value='TypeAlias')], keywords=[keyword(arg='doc', value=Constant(value="Special marker indicating that an assignment should\n                               be recognized as a proper type alias definition by type\n                               checkers.\n\n                               For example::\n\n                                   Predicate: TypeAlias = Callable[..., bool]\n\n                               It's invalid when used anywhere except as in the example\n                               above."))]))])]), ClassDef(name='_DefaultMixin', bases=[], keywords=[], body=[Expr(value=Constant(value='Mixin for TypeVarLike defaults.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='default', ctx=Load()), Tuple(elts=[Name(id='tuple', ctx=Load()), Name(id='list', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__default__', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='d', ctx=Load()), Constant(value='Default must be a type')], keywords=[]), generators=[comprehension(target=Name(id='d', ctx=Store()), iter=Name(id='default', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[If(test=Name(id='default', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__default__', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='default', ctx=Load()), Constant(value='Default must be a type')], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__default__', ctx=Store())], value=Constant(value=None))])])], decorator_list=[])], decorator_list=[]), ClassDef(name='TypeVar', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), Name(id='_DefaultMixin', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value='Type variable.')), Assign(targets=[Name(id='__module__', ctx=Store())], value=Constant(value='typing')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], vararg=arg(arg='constraints'), kwonlyargs=[arg(arg='bound'), arg(arg='covariant'), arg(arg='contravariant'), arg(arg='default'), arg(arg='infer_variance')], kw_defaults=[Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=None), Constant(value=False)], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='name', ctx=Load()), Starred(value=Name(id='constraints', ctx=Load()), ctx=Load())], keywords=[keyword(arg='bound', value=Name(id='bound', ctx=Load())), keyword(arg='covariant', value=Name(id='covariant', ctx=Load())), keyword(arg='contravariant', value=Name(id='contravariant', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='_DefaultMixin', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__infer_variance__', ctx=Store())], value=Name(id='infer_variance', ctx=Load())), Try(body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__name__'), Constant(value='__main__')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[])], decorator_list=[])], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='ParamSpecArgs')], keywords=[]), body=[Assign(targets=[Name(id='ParamSpecArgs', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpecArgs', ctx=Load())), Assign(targets=[Name(id='ParamSpecKwargs', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpecKwargs', ctx=Load()))], orelse=[ClassDef(name='_Immutable', bases=[], keywords=[], body=[Expr(value=Constant(value='Mixin to indicate that object should not be copied.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[], ctx=Load())), FunctionDef(name='__copy__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__deepcopy__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='memo')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='ParamSpecArgs', bases=[Name(id='_Immutable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The args for a ParamSpec object.\n\n        Given a ParamSpec object P, P.args is an instance of ParamSpecArgs.\n\n        ParamSpecArgs objects have a reference back to their ParamSpec:\n\n        P.args.__origin__ is P\n\n        This type is meant for runtime introspection and has no special meaning to\n        static type checkers.\n        ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Store())], value=Name(id='origin', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='.args')]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParamSpecArgs', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__origin__', ctx=Load())]))], decorator_list=[])], decorator_list=[]), ClassDef(name='ParamSpecKwargs', bases=[Name(id='_Immutable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The kwargs for a ParamSpec object.\n\n        Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs.\n\n        ParamSpecKwargs objects have a reference back to their ParamSpec:\n\n        P.kwargs.__origin__ is P\n\n        This type is meant for runtime introspection and has no special meaning to\n        static type checkers.\n        ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Store())], value=Name(id='origin', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='.kwargs')]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParamSpecKwargs', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='__origin__', ctx=Load())]))], decorator_list=[])], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='ParamSpec')], keywords=[]), body=[ClassDef(name='ParamSpec', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='ParamSpec', ctx=Load()), Name(id='_DefaultMixin', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value='Parameter specification variable.')), Assign(targets=[Name(id='__module__', ctx=Store())], value=Constant(value='typing')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[arg(arg='bound'), arg(arg='covariant'), arg(arg='contravariant'), arg(arg='default')], kw_defaults=[Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=None)], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[keyword(arg='bound', value=Name(id='bound', ctx=Load())), keyword(arg='covariant', value=Name(id='covariant', ctx=Load())), keyword(arg='contravariant', value=Name(id='contravariant', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='_DefaultMixin', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__name__'), Constant(value='__main__')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[])], decorator_list=[])], decorator_list=[])], orelse=[ClassDef(name='ParamSpec', bases=[Name(id='list', ctx=Load()), Name(id='_DefaultMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Parameter specification variable.\n\n        Usage::\n\n           P = ParamSpec('P')\n\n        Parameter specification variables exist primarily for the benefit of static\n        type checkers.  They are used to forward the parameter types of one\n        callable to another callable, a pattern commonly found in higher order\n        functions and decorators.  They are only valid when used in ``Concatenate``,\n        or s the first argument to ``Callable``. In Python 3.10 and higher,\n        they are also supported in user-defined Generics at runtime.\n        See class Generic for more information on generic types.  An\n        example for annotating a decorator::\n\n           T = TypeVar('T')\n           P = ParamSpec('P')\n\n           def add_logging(f: Callable[P, T]) -> Callable[P, T]:\n               '''A type-safe decorator to add logging to a function.'''\n               def inner(*args: P.args, **kwargs: P.kwargs) -> T:\n                   logging.info(f'{f.__name__} was called')\n                   return f(*args, **kwargs)\n               return inner\n\n           @add_logging\n           def add_two(x: float, y: float) -> float:\n               '''Add two numbers together.'''\n               return x + y\n\n        Parameter specification variables defined with covariant=True or\n        contravariant=True can be used to declare covariant or contravariant\n        generic types.  These keyword arguments are valid, but their actual semantics\n        are yet to be decided.  See PEP 612 for details.\n\n        Parameter specification variables can be introspected. e.g.:\n\n           P.__name__ == 'T'\n           P.__bound__ == None\n           P.__covariant__ == False\n           P.__contravariant__ == False\n\n        Note that only parameter specification variables defined in global scope can\n        be pickled.\n        ")), Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())), FunctionDef(name='args', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='ParamSpecArgs', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='kwargs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='ParamSpecKwargs', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[arg(arg='bound'), arg(arg='covariant'), arg(arg='contravariant'), arg(arg='default')], kw_defaults=[Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=None)], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__covariant__', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='covariant', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__contravariant__', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='contravariant', ctx=Load())], keywords=[])), If(test=Name(id='bound', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__bound__', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='bound', ctx=Load()), Constant(value='Bound must be a type.')], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__bound__', ctx=Store())], value=Constant(value=None))]), Expr(value=Call(func=Attribute(value=Name(id='_DefaultMixin', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__name__'), Constant(value='__main__')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='__covariant__', ctx=Load()), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value='+'))], orelse=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='__contravariant__', ctx=Load()), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value='-'))], orelse=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value='~'))])]), Return(value=BinOp(left=Name(id='prefix', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load())))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__hash__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='other', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Pass()], decorator_list=[])], decorator_list=[])]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Concatenate')], keywords=[])), body=[ClassDef(name='_ConcatenateGenericAlias', bases=[Name(id='list', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())), Assign(targets=[Name(id='_special', ctx=Store())], value=Constant(value=False)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='origin'), arg(arg='args')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Store())], value=Name(id='origin', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Store())], value=Name(id='args', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='_type_repr', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_repr', ctx=Load())), Return(value=JoinedStr(values=[FormattedValue(value=Call(func=Name(id='_type_repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load())], keywords=[]), conversion=-1), Constant(value='['), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_type_repr', ctx=Load()), args=[Name(id='arg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='arg', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), conversion=-1), Constant(value=']')]))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='__origin__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Pass()], decorator_list=[]), FunctionDef(name='__parameters__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Name(id='tp', ctx=Load()), generators=[comprehension(target=Name(id='tp', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='__args__', ctx=Load()), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tp', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), Name(id='ParamSpec', ctx=Load())], ctx=Load())], keywords=[])], is_async=0)])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())])], decorator_list=[])], orelse=[]), FunctionDef(name='_concatenate_getitem', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='parameters', ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot take a Concatenate of no types.')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='parameters', ctx=Store())], value=Tuple(elts=[Name(id='parameters', ctx=Load())], ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='parameters', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='ParamSpec', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='The last parameter to Concatenate should be a ParamSpec variable.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Concatenate[arg, ...]: each arg must be a type.')), Assign(targets=[Name(id='parameters', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='p', ctx=Store()), iter=Name(id='parameters', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Call(func=Name(id='_ConcatenateGenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Concatenate')], keywords=[]), body=[Assign(targets=[Name(id='Concatenate', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Concatenate', ctx=Load())), Assign(targets=[Name(id='_ConcatenateGenericAlias', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_ConcatenateGenericAlias', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[FunctionDef(name='Concatenate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a\n        higher order function which adds, removes or transforms parameters of a\n        callable.\n\n        For example::\n\n           Callable[Concatenate[int, P], int]\n\n        See PEP 612 for detailed information.\n        ')), Return(value=Call(func=Name(id='_concatenate_getitem', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[Name(id='_TypeAliasForm', ctx=Load())])], orelse=[ClassDef(name='_ConcatenateForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='_concatenate_getitem', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Concatenate', ctx=Store())], value=Call(func=Name(id='_ConcatenateForm', ctx=Load()), args=[Constant(value='Concatenate')], keywords=[keyword(arg='doc', value=Constant(value='Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a\n        higher order function which adds, removes or transforms parameters of a\n        callable.\n\n        For example::\n\n           Callable[Concatenate[int, P], int]\n\n        See PEP 612 for detailed information.\n        '))]))])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeGuard')], keywords=[]), body=[Assign(targets=[Name(id='TypeGuard', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeGuard', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[ClassDef(name='_TypeGuardForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[])], decorator_list=[]), FunctionDef(name='TypeGuard', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Special typing form used to annotate the return type of a user-defined\n        type guard function.  ``TypeGuard`` only accepts a single type argument.\n        At runtime, functions marked this way should return a boolean.\n\n        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static\n        type checkers to determine a more precise type of an expression within a\n        program\'s code flow.  Usually type narrowing is done by analyzing\n        conditional code flow and applying the narrowing to a block of code.  The\n        conditional expression here is sometimes referred to as a "type guard".\n\n        Sometimes it would be convenient to use a user-defined boolean function\n        as a type guard.  Such a function should use ``TypeGuard[...]`` as its\n        return type to alert static type checkers to this intention.\n\n        Using  ``-> TypeGuard`` tells the static type checker that for a given\n        function:\n\n        1. The return value is a boolean.\n        2. If the return value is ``True``, the type of its argument\n        is the type inside ``TypeGuard``.\n\n        For example::\n\n            def is_str(val: Union[str, float]):\n                # "isinstance" type guard\n                if isinstance(val, str):\n                    # Type of ``val`` is narrowed to ``str``\n                    ...\n                else:\n                    # Else, type of ``val`` is narrowed to ``float``.\n                    ...\n\n        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower\n        form of ``TypeA`` (it can even be a wider form) and this may lead to\n        type-unsafe results.  The main reason is to allow for things like\n        narrowing ``List[object]`` to ``List[str]`` even though the latter is not\n        a subtype of the former, since ``List`` is invariant.  The responsibility of\n        writing type-safe type guards is left to the user.\n\n        ``TypeGuard`` also works with type variables.  For more information, see\n        PEP 647 (User-Defined Type Guards).\n        ')), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_TypeGuardForm', ctx=Load())])], orelse=[ClassDef(name='_TypeGuardForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='TypeGuard', ctx=Store())], value=Call(func=Name(id='_TypeGuardForm', ctx=Load()), args=[Constant(value='TypeGuard')], keywords=[keyword(arg='doc', value=Constant(value='Special typing form used to annotate the return type of a user-defined\n        type guard function.  ``TypeGuard`` only accepts a single type argument.\n        At runtime, functions marked this way should return a boolean.\n\n        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static\n        type checkers to determine a more precise type of an expression within a\n        program\'s code flow.  Usually type narrowing is done by analyzing\n        conditional code flow and applying the narrowing to a block of code.  The\n        conditional expression here is sometimes referred to as a "type guard".\n\n        Sometimes it would be convenient to use a user-defined boolean function\n        as a type guard.  Such a function should use ``TypeGuard[...]`` as its\n        return type to alert static type checkers to this intention.\n\n        Using  ``-> TypeGuard`` tells the static type checker that for a given\n        function:\n\n        1. The return value is a boolean.\n        2. If the return value is ``True``, the type of its argument\n        is the type inside ``TypeGuard``.\n\n        For example::\n\n            def is_str(val: Union[str, float]):\n                # "isinstance" type guard\n                if isinstance(val, str):\n                    # Type of ``val`` is narrowed to ``str``\n                    ...\n                else:\n                    # Else, type of ``val`` is narrowed to ``float``.\n                    ...\n\n        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower\n        form of ``TypeA`` (it can even be a wider form) and this may lead to\n        type-unsafe results.  The main reason is to allow for things like\n        narrowing ``List[object]`` to ``List[str]`` even though the latter is not\n        a subtype of the former, since ``List`` is invariant.  The responsibility of\n        writing type-safe type guards is left to the user.\n\n        ``TypeGuard`` also works with type variables.  For more information, see\n        PEP 647 (User-Defined Type Guards).\n        '))]))])]), ClassDef(name='_SpecialForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_Final', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='_name'), Constant(value='__doc__'), Constant(value='_getitem')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='getitem')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_getitem', ctx=Store())], value=Name(id='getitem', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Store())], value=Attribute(value=Name(id='getitem', ctx=Load()), attr='__name__', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__doc__', ctx=Store())], value=Attribute(value=Name(id='getitem', ctx=Load()), attr='__doc__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='item', ctx=Load()), ops=[In()], comparators=[Set(elts=[Constant(value='__name__'), Constant(value='__qualname__')])]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__mro_entries__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='bases')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot subclass '), FormattedValue(value=Name(id='self', ctx=Load()), conversion=114)])], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='typing_extensions.'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1)]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot instantiate '), FormattedValue(value=Name(id='self', ctx=Load()), conversion=114)])], keywords=[]))], decorator_list=[]), FunctionDef(name='__or__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__ror__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='other', ctx=Load()), Name(id='self', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__instancecheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' cannot be used with isinstance()')])], keywords=[]))], decorator_list=[]), FunctionDef(name='__subclasscheck__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' cannot be used with issubclass()')])], keywords=[]))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_getitem', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='parameters', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='_tp_cache', ctx=Load())])], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='LiteralString')], keywords=[]), body=[Assign(targets=[Name(id='LiteralString', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='LiteralString', ctx=Load()))], orelse=[FunctionDef(name='LiteralString', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Represents an arbitrary literal string.\n\n        Example::\n\n          from typing_extensions import LiteralString\n\n          def query(sql: LiteralString) -> ...:\n              ...\n\n          query("SELECT * FROM table")  # ok\n          query(f"SELECT * FROM {input()}")  # not ok\n\n        See PEP 675 for details.\n\n        ')), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not subscriptable')])], keywords=[]))], decorator_list=[Name(id='_SpecialForm', ctx=Load())])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Self')], keywords=[]), body=[Assign(targets=[Name(id='Self', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Self', ctx=Load()))], orelse=[FunctionDef(name='Self', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Used to spell the type of "self" in classes.\n\n        Example::\n\n          from typing import Self\n\n          class ReturnsSelf:\n              def parse(self, data: bytes) -> Self:\n                  ...\n                  return self\n\n        ')), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not subscriptable')])], keywords=[]))], decorator_list=[Name(id='_SpecialForm', ctx=Load())])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Never')], keywords=[]), body=[Assign(targets=[Name(id='Never', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Never', ctx=Load()))], orelse=[FunctionDef(name='Never', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The bottom type, a type that has no members.\n\n        This can be used to define a function that should never be\n        called, or a function that never returns::\n\n            from typing_extensions import Never\n\n            def never_call_me(arg: Never) -> None:\n                pass\n\n            def int_or_str(arg: int | str) -> None:\n                never_call_me(arg)  # type checker error\n                match arg:\n                    case int():\n                        print("It\'s an int")\n                    case str():\n                        print("It\'s a str")\n                    case _:\n                        never_call_me(arg)  # ok, arg is of type Never\n\n        ')), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not subscriptable')])], keywords=[]))], decorator_list=[Name(id='_SpecialForm', ctx=Load())])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Required')], keywords=[]), body=[Assign(targets=[Name(id='Required', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Required', ctx=Load())), Assign(targets=[Name(id='NotRequired', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NotRequired', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[ClassDef(name='_ExtensionsSpecialForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[])], decorator_list=[]), FunctionDef(name='Required', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A special typing construct to mark a key of a total=False TypedDict\n        as required. For example:\n\n            class Movie(TypedDict, total=False):\n                title: Required[str]\n                year: int\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n\n        There is no runtime checking that a required key is actually provided\n        when instantiating a related TypedDict.\n        ")), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_ExtensionsSpecialForm', ctx=Load())]), FunctionDef(name='NotRequired', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A special typing construct to mark a key of a TypedDict as\n        potentially missing. For example:\n\n            class Movie(TypedDict):\n                title: str\n                year: NotRequired[int]\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n        ")), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_ExtensionsSpecialForm', ctx=Load())])], orelse=[ClassDef(name='_RequiredForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Required', ctx=Store())], value=Call(func=Name(id='_RequiredForm', ctx=Load()), args=[Constant(value='Required')], keywords=[keyword(arg='doc', value=Constant(value="A special typing construct to mark a key of a total=False TypedDict\n        as required. For example:\n\n            class Movie(TypedDict, total=False):\n                title: Required[str]\n                year: int\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n\n        There is no runtime checking that a required key is actually provided\n        when instantiating a related TypedDict.\n        "))])), Assign(targets=[Name(id='NotRequired', ctx=Store())], value=Call(func=Name(id='_RequiredForm', ctx=Load()), args=[Constant(value='NotRequired')], keywords=[keyword(arg='doc', value=Constant(value="A special typing construct to mark a key of a TypedDict as\n        potentially missing. For example:\n\n            class Movie(TypedDict):\n                title: str\n                year: NotRequired[int]\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n        "))]))])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='Unpack')], keywords=[]), body=[Assign(targets=[Name(id='Unpack', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='Unpack', ctx=Load()))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[ClassDef(name='_UnpackSpecialForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[])], decorator_list=[]), ClassDef(name='_UnpackAlias', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()))], decorator_list=[]), FunctionDef(name='Unpack', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A special typing construct to unpack a variadic type. For example:\n\n            Shape = TypeVarTuple('Shape')\n            Batch = NewType('Batch', int)\n\n            def add_batch_axis(\n                x: Array[Unpack[Shape]]\n            ) -> Array[Batch, Unpack[Shape]]: ...\n\n        ")), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Name(id='_UnpackAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='_UnpackSpecialForm', ctx=Load())]), FunctionDef(name='_is_unpack', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='_UnpackAlias', ctx=Load())], keywords=[]))], decorator_list=[])], orelse=[ClassDef(name='_UnpackAlias', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_GenericAlias', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()))], decorator_list=[]), ClassDef(name='_UnpackForm', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='_SpecialForm', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='typing_extensions.'), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='parameters', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=-1), Constant(value=' accepts only a single type.')])], keywords=[])), Return(value=Call(func=Name(id='_UnpackAlias', ctx=Load()), args=[Name(id='self', ctx=Load()), Tuple(elts=[Name(id='item', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='Unpack', ctx=Store())], value=Call(func=Name(id='_UnpackForm', ctx=Load()), args=[Constant(value='Unpack')], keywords=[keyword(arg='doc', value=Constant(value="A special typing construct to unpack a variadic type. For example:\n\n            Shape = TypeVarTuple('Shape')\n            Batch = NewType('Batch', int)\n\n            def add_batch_axis(\n                x: Array[Unpack[Shape]]\n            ) -> Array[Batch, Unpack[Shape]]: ...\n\n        "))])), FunctionDef(name='_is_unpack', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='_UnpackAlias', ctx=Load())], keywords=[]))], decorator_list=[])])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeVarTuple')], keywords=[]), body=[ClassDef(name='TypeVarTuple', bases=[Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVarTuple', ctx=Load()), Name(id='_DefaultMixin', ctx=Load())], keywords=[keyword(arg='_root', value=Constant(value=True))], body=[Expr(value=Constant(value='Type variable tuple.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[arg(arg='default')], kw_defaults=[Constant(value=None)], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='_DefaultMixin', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__name__'), Constant(value='__main__')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[])], decorator_list=[])], decorator_list=[])], orelse=[ClassDef(name='TypeVarTuple', bases=[Name(id='_DefaultMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Type variable tuple.\n\n        Usage::\n\n            Ts = TypeVarTuple('Ts')\n\n        In the same way that a normal type variable is a stand-in for a single\n        type such as ``int``, a type variable *tuple* is a stand-in for a *tuple*\n        type such as ``Tuple[int, str]``.\n\n        Type variable tuples can be used in ``Generic`` declarations.\n        Consider the following example::\n\n            class Array(Generic[*Ts]): ...\n\n        The ``Ts`` type variable tuple here behaves like ``tuple[T1, T2]``,\n        where ``T1`` and ``T2`` are type variables. To use these type variables\n        as type parameters of ``Array``, we must *unpack* the type variable tuple using\n        the star operator: ``*Ts``. The signature of ``Array`` then behaves\n        as if we had simply written ``class Array(Generic[T1, T2]): ...``.\n        In contrast to ``Generic[T1, T2]``, however, ``Generic[*Shape]`` allows\n        us to parameterise the class with an *arbitrary* number of type parameters.\n\n        Type variable tuples can be used anywhere a normal ``TypeVar`` can.\n        This includes class definitions, as shown above, as well as function\n        signatures and variable annotations::\n\n            class Array(Generic[*Ts]):\n\n                def __init__(self, shape: Tuple[*Ts]):\n                    self._shape: Tuple[*Ts] = shape\n\n                def get_shape(self) -> Tuple[*Ts]:\n                    return self._shape\n\n            shape = (Height(480), Width(640))\n            x: Array[Height, Width] = Array(shape)\n            y = abs(x)  # Inferred type is Array[Height, Width]\n            z = x + x   #        ...    is Array[Height, Width]\n            x.get_shape()  #     ...    is tuple[Height, Width]\n\n        ")), Assign(targets=[Name(id='__class__', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load())), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Yield(value=Attribute(value=Name(id='self', ctx=Load()), attr='__unpacked__', ctx=Load())))], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[arg(arg='default')], kw_defaults=[Constant(value=None)], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Store())], value=Name(id='name', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='_DefaultMixin', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='default', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_globals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__name__'), Constant(value='__main__')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='def_mod', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='def_mod', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='typing_extensions')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Store())], value=Name(id='def_mod', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__unpacked__', ctx=Store())], value=Subscript(value=Name(id='Unpack', ctx=Load()), slice=Name(id='self', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__hash__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='other', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__reduce__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()))], decorator_list=[]), FunctionDef(name='__init_subclass__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds'), defaults=[]), body=[If(test=Compare(left=Constant(value='_root'), ops=[NotIn()], comparators=[Name(id='kwds', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Cannot subclass special typing classes')], keywords=[]))], orelse=[])], decorator_list=[])], decorator_list=[])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='reveal_type')], keywords=[]), body=[Assign(targets=[Name(id='reveal_type', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='reveal_type', ctx=Load()))], orelse=[FunctionDef(name='reveal_type', args=arguments(posonlyargs=[], args=[arg(arg='__obj', annotation=Name(id='T', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Reveal the inferred type of a variable.\n\n        When a static type checker encounters a call to ``reveal_type()``,\n        it will emit the inferred type of the argument::\n\n            x: int = 1\n            reveal_type(x)\n\n        Running a static type checker (e.g., ``mypy``) on this example\n        will produce output similar to \'Revealed type is "builtins.int"\'.\n\n        At runtime, the function prints the runtime type of the\n        argument and returns it unchanged.\n\n        ')), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Runtime type is '), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='__obj', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=114)])], keywords=[keyword(arg='file', value=Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Load()))])), Return(value=Name(id='__obj', ctx=Load()))], decorator_list=[], returns=Name(id='T', ctx=Load()))]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='assert_never')], keywords=[]), body=[Assign(targets=[Name(id='assert_never', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='assert_never', ctx=Load()))], orelse=[FunctionDef(name='assert_never', args=arguments(posonlyargs=[], args=[arg(arg='__arg', annotation=Name(id='Never', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Assert to the type checker that a line of code is unreachable.\n\n        Example::\n\n            def int_or_str(arg: int | str) -> None:\n                match arg:\n                    case int():\n                        print("It\'s an int")\n                    case str():\n                        print("It\'s a str")\n                    case _:\n                        assert_never(arg)\n\n        If a type checker finds that a call to assert_never() is\n        reachable, it will emit an error.\n\n        At runtime, this throws an exception when called.\n\n        ')), Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Constant(value='Expected code to be unreachable')], keywords=[]))], decorator_list=[], returns=Name(id='Never', ctx=Load()))]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='dataclass_transform')], keywords=[]), body=[Assign(targets=[Name(id='dataclass_transform', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='dataclass_transform', ctx=Load()))], orelse=[FunctionDef(name='dataclass_transform', args=arguments(posonlyargs=[], args=[], kwonlyargs=[arg(arg='eq_default', annotation=Name(id='bool', ctx=Load())), arg(arg='order_default', annotation=Name(id='bool', ctx=Load())), arg(arg='kw_only_default', annotation=Name(id='bool', ctx=Load())), arg(arg='field_specifiers', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Type', ctx=Load()), slice=Attribute(value=Name(id='typing', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Attribute(value=Name(id='typing', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=True), Constant(value=False), Constant(value=False), Tuple(elts=[], ctx=Load())], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='typing', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Decorator that marks a function, class, or metaclass as providing\n        dataclass-like behavior.\n\n        Example:\n\n            from typing_extensions import dataclass_transform\n\n            _T = TypeVar("_T")\n\n            # Used on a decorator function\n            @dataclass_transform()\n            def create_model(cls: type[_T]) -> type[_T]:\n                ...\n                return cls\n\n            @create_model\n            class CustomerModel:\n                id: int\n                name: str\n\n            # Used on a base class\n            @dataclass_transform()\n            class ModelBase: ...\n\n            class CustomerModel(ModelBase):\n                id: int\n                name: str\n\n            # Used on a metaclass\n            @dataclass_transform()\n            class ModelMeta(type): ...\n\n            class ModelBase(metaclass=ModelMeta): ...\n\n            class CustomerModel(ModelBase):\n                id: int\n                name: str\n\n        Each of the ``CustomerModel`` classes defined in this example will now\n        behave similarly to a dataclass created with the ``@dataclasses.dataclass``\n        decorator. For example, the type checker will synthesize an ``__init__``\n        method.\n\n        The arguments to this decorator can be used to customize this behavior:\n        - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be\n          True or False if it is omitted by the caller.\n        - ``order_default`` indicates whether the ``order`` parameter is\n          assumed to be True or False if it is omitted by the caller.\n        - ``kw_only_default`` indicates whether the ``kw_only`` parameter is\n          assumed to be True or False if it is omitted by the caller.\n        - ``field_specifiers`` specifies a static list of supported classes\n          or functions that describe fields, similar to ``dataclasses.field()``.\n\n        At runtime, this decorator records its arguments in the\n        ``__dataclass_transform__`` attribute on the decorated object.\n\n        See PEP 681 for details.\n\n        ')), FunctionDef(name='decorator', args=arguments(posonlyargs=[], args=[arg(arg='cls_or_fn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='cls_or_fn', ctx=Load()), attr='__dataclass_transform__', ctx=Store())], value=Dict(keys=[Constant(value='eq_default'), Constant(value='order_default'), Constant(value='kw_only_default'), Constant(value='field_specifiers'), Constant(value='kwargs')], values=[Name(id='eq_default', ctx=Load()), Name(id='order_default', ctx=Load()), Name(id='kw_only_default', ctx=Load()), Name(id='field_specifiers', ctx=Load()), Name(id='kwargs', ctx=Load())])), Return(value=Name(id='cls_or_fn', ctx=Load()))], decorator_list=[]), Return(value=Name(id='decorator', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='T', ctx=Load())], ctx=Load()), Name(id='T', ctx=Load())], ctx=Load()), ctx=Load()))]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='override')], keywords=[]), body=[Assign(targets=[Name(id='override', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='override', ctx=Load()))], orelse=[Assign(targets=[Name(id='_F', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='_F')], keywords=[keyword(arg='bound', value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Attribute(value=Name(id='typing', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))])), FunctionDef(name='override', args=arguments(posonlyargs=[], args=[arg(arg='__arg', annotation=Name(id='_F', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Indicate that a method is intended to override a method in a base class.\n\n        Usage:\n\n            class Base:\n                def method(self) -> None: ...\n                    pass\n\n            class Child(Base):\n                @override\n                def method(self) -> None:\n                    super().method()\n\n        When this decorator is applied to a method, the type checker will\n        validate that it overrides a method with the same name on a base class.\n        This helps prevent bugs that may occur when a base class is changed\n        without an equivalent change to a child class.\n\n        See PEP 698 for details.\n\n        ')), Return(value=Name(id='__arg', ctx=Load()))], decorator_list=[], returns=Name(id='_F', ctx=Load()))]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='typing', ctx=Load()), Constant(value='TypeVarTuple')], keywords=[])), body=[Assign(targets=[Attribute(value=Name(id='typing', ctx=Load()), attr='_collect_type_vars', ctx=Store())], value=Name(id='_collect_type_vars', ctx=Load())), Assign(targets=[Attribute(value=Name(id='typing', ctx=Load()), attr='_check_generic', ctx=Store())], value=Name(id='_check_generic', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=11)], ctx=Load())]), body=[Assign(targets=[Name(id='NamedTuple', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='NamedTuple', ctx=Load()))], orelse=[FunctionDef(name='_caller', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=2)], keywords=[]), attr='f_globals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__name__'), Constant(value='__main__')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Return(value=Constant(value=None))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='_make_nmtuple', args=arguments(posonlyargs=[], args=[arg(arg='name'), arg(arg='types'), arg(arg='module'), arg(arg='defaults')], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[], ctx=Load())]), body=[Assign(targets=[Name(id='fields', ctx=Store())], value=ListComp(elt=Name(id='n', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='t', ctx=Store())], ctx=Store()), iter=Name(id='types', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='annotations', ctx=Store())], value=DictComp(key=Name(id='n', ctx=Load()), value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='_type_check', ctx=Load()), args=[Name(id='t', ctx=Load()), JoinedStr(values=[Constant(value='field '), FormattedValue(value=Name(id='n', ctx=Load()), conversion=-1), Constant(value=' annotation must be a type')])], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='t', ctx=Store())], ctx=Store()), iter=Name(id='types', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='nm_tpl', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='namedtuple', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='fields', ctx=Load())], keywords=[keyword(arg='defaults', value=Name(id='defaults', ctx=Load())), keyword(arg='module', value=Name(id='module', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__annotations__', ctx=Store()), Attribute(value=Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__new__', ctx=Load()), attr='__annotations__', ctx=Store())], value=Name(id='annotations', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[Lt()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='_field_types', ctx=Store())], value=Name(id='annotations', ctx=Load()))], orelse=[]), Return(value=Name(id='nm_tpl', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_prohibited_namedtuple_fields', ctx=Store())], value=Attribute(value=Name(id='typing', ctx=Load()), attr='_prohibited', ctx=Load())), Assign(targets=[Name(id='_special_namedtuple_fields', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Set(elts=[Constant(value='__module__'), Constant(value='__name__'), Constant(value='__annotations__')])], keywords=[])), ClassDef(name='_NamedTupleMeta', bases=[Name(id='type', ctx=Load())], keywords=[], body=[FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='typename'), arg(arg='bases'), arg(arg='ns')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Name(id='_NamedTuple', ctx=Load()), ops=[In()], comparators=[Name(id='bases', ctx=Load())])), For(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='base', ctx=Load()), ops=[IsNot()], comparators=[Name(id='_NamedTuple', ctx=Load())]), Compare(left=Name(id='base', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='can only inherit from a NamedTuple type and Generic')], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='bases', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=IfExp(test=Compare(left=Name(id='base', ctx=Load()), ops=[Is()], comparators=[Name(id='_NamedTuple', ctx=Load())]), body=Name(id='tuple', ctx=Load()), orelse=Name(id='base', ctx=Load())), generators=[comprehension(target=Name(id='base', ctx=Store()), iter=Name(id='bases', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='types', ctx=Store())], value=Call(func=Attribute(value=Name(id='ns', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='__annotations__'), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Name(id='default_names', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='field_name', ctx=Store()), iter=Name(id='types', ctx=Load()), body=[If(test=Compare(left=Name(id='field_name', ctx=Load()), ops=[In()], comparators=[Name(id='ns', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='default_names', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='field_name', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='default_names', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Non-default namedtuple field '), FormattedValue(value=Name(id='field_name', ctx=Load()), conversion=-1), Constant(value=' cannot follow default field'), FormattedValue(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='default_names', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=Constant(value='s'), orelse=Constant(value='')), conversion=-1), Constant(value=' '), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='default_names', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))], orelse=[])])], orelse=[]), Assign(targets=[Name(id='nm_tpl', ctx=Store())], value=Call(func=Name(id='_make_nmtuple', ctx=Load()), args=[Name(id='typename', ctx=Load()), Call(func=Attribute(value=Name(id='types', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='defaults', value=ListComp(elt=Subscript(value=Name(id='ns', ctx=Load()), slice=Name(id='n', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='n', ctx=Store()), iter=Name(id='default_names', ctx=Load()), ifs=[], is_async=0)])), keyword(arg='module', value=Subscript(value=Name(id='ns', ctx=Load()), slice=Constant(value='__module__'), ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__bases__', ctx=Store())], value=Name(id='bases', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), ops=[In()], comparators=[Name(id='bases', ctx=Load())]), body=[Assign(targets=[Name(id='class_getitem', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), attr='__class_getitem__', ctx=Load()), attr='__func__', ctx=Load())), Assign(targets=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__class_getitem__', ctx=Store())], value=Call(func=Name(id='classmethod', ctx=Load()), args=[Name(id='class_getitem', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='key', ctx=Store()), iter=Name(id='ns', ctx=Load()), body=[If(test=Compare(left=Name(id='key', ctx=Load()), ops=[In()], comparators=[Name(id='_prohibited_namedtuple_fields', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[BinOp(left=Constant(value='Cannot overwrite NamedTuple attribute '), op=Add(), right=Name(id='key', ctx=Load()))], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='key', ctx=Load()), ops=[NotIn()], comparators=[Name(id='_special_namedtuple_fields', ctx=Load())]), Compare(left=Name(id='key', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='_fields', ctx=Load())])]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='nm_tpl', ctx=Load()), Name(id='key', ctx=Load()), Subscript(value=Name(id='ns', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[])])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='typing', ctx=Load()), attr='Generic', ctx=Load()), ops=[In()], comparators=[Name(id='bases', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='nm_tpl', ctx=Load()), attr='__init_subclass__', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='nm_tpl', ctx=Load()))], decorator_list=[])], decorator_list=[]), FunctionDef(name='NamedTuple', args=arguments(posonlyargs=[], args=[arg(arg='__typename'), arg(arg='__fields')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='__fields', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='__fields', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))], orelse=[If(test=Name(id='kwargs', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Either list of fields or keywords can be provided to NamedTuple, not both')], keywords=[]))], orelse=[])]), Return(value=Call(func=Name(id='_make_nmtuple', ctx=Load()), args=[Name(id='__typename', ctx=Load()), Name(id='__fields', ctx=Load())], keywords=[keyword(arg='module', value=Call(func=Name(id='_caller', ctx=Load()), args=[], keywords=[]))]))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='NamedTuple', ctx=Load()), attr='__doc__', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='typing', ctx=Load()), attr='NamedTuple', ctx=Load()), attr='__doc__', ctx=Load())), Assign(targets=[Name(id='_NamedTuple', ctx=Store())], value=Call(func=Attribute(value=Name(id='type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='_NamedTupleMeta', ctx=Load()), Constant(value='NamedTuple'), Tuple(elts=[], ctx=Load()), Dict(keys=[], values=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='NamedTuple', ctx=Load()), attr='__text_signature__', ctx=Store())], value=Constant(value='(typename, fields=None, /, **kwargs)'))], orelse=[]), FunctionDef(name='_namedtuple_mro_entries', args=arguments(posonlyargs=[], args=[arg(arg='bases')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Name(id='NamedTuple', ctx=Load()), ops=[In()], comparators=[Name(id='bases', ctx=Load())])), Return(value=Tuple(elts=[Name(id='_NamedTuple', ctx=Load())], ctx=Load()))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='NamedTuple', ctx=Load()), attr='__mro_entries__', ctx=Store())], value=Name(id='_namedtuple_mro_entries', ctx=Load()))])], type_ignores=[])