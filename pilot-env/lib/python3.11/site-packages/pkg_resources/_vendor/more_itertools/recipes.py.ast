Module(body=[Expr(value=Constant(value='Imported from the recipes section of the itertools documentation.\n\nAll functions taken from the recipes section of the itertools library docs\n[1]_.\nSome backward-compatible usability improvements have been made.\n\n.. [1] http://docs.python.org/library/itertools.html#recipes\n\n')), Import(names=[alias(name='math')]), Import(names=[alias(name='operator')]), Import(names=[alias(name='warnings')]), ImportFrom(module='collections', names=[alias(name='deque')], level=0), ImportFrom(module='collections.abc', names=[alias(name='Sized')], level=0), ImportFrom(module='functools', names=[alias(name='reduce')], level=0), ImportFrom(module='itertools', names=[alias(name='chain'), alias(name='combinations'), alias(name='compress'), alias(name='count'), alias(name='cycle'), alias(name='groupby'), alias(name='islice'), alias(name='product'), alias(name='repeat'), alias(name='starmap'), alias(name='tee'), alias(name='zip_longest')], level=0), ImportFrom(module='random', names=[alias(name='randrange'), alias(name='sample'), alias(name='choice')], level=0), ImportFrom(module='sys', names=[alias(name='hexversion')], level=0), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='all_equal'), Constant(value='batched'), Constant(value='before_and_after'), Constant(value='consume'), Constant(value='convolve'), Constant(value='dotproduct'), Constant(value='first_true'), Constant(value='factor'), Constant(value='flatten'), Constant(value='grouper'), Constant(value='iter_except'), Constant(value='iter_index'), Constant(value='matmul'), Constant(value='ncycles'), Constant(value='nth'), Constant(value='nth_combination'), Constant(value='padnone'), Constant(value='pad_none'), Constant(value='pairwise'), Constant(value='partition'), Constant(value='polynomial_from_roots'), Constant(value='powerset'), Constant(value='prepend'), Constant(value='quantify'), Constant(value='random_combination_with_replacement'), Constant(value='random_combination'), Constant(value='random_permutation'), Constant(value='random_product'), Constant(value='repeatfunc'), Constant(value='roundrobin'), Constant(value='sieve'), Constant(value='sliding_window'), Constant(value='subslices'), Constant(value='tabulate'), Constant(value='tail'), Constant(value='take'), Constant(value='transpose'), Constant(value='triplewise'), Constant(value='unique_everseen'), Constant(value='unique_justseen')], ctx=Load())), Assign(targets=[Name(id='_marker', ctx=Store())], value=Call(func=Name(id='object', ctx=Load()), args=[], keywords=[])), FunctionDef(name='take', args=arguments(posonlyargs=[], args=[arg(arg='n'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return first *n* items of the iterable as a list.\n\n        >>> take(3, range(10))\n        [0, 1, 2]\n\n    If there are fewer than *n* items in the iterable, all of them are\n    returned.\n\n        >>> take(10, range(3))\n        [0, 1, 2]\n\n    ')), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='n', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='tabulate', args=arguments(posonlyargs=[], args=[arg(arg='function'), arg(arg='start')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Return an iterator over the results of ``func(start)``,\n    ``func(start + 1)``, ``func(start + 2)``...\n\n    *func* should be a function that accepts one integer argument.\n\n    If *start* is not specified it defaults to 0. It will be incremented each\n    time the iterator is advanced.\n\n        >>> square = lambda x: x ** 2\n        >>> iterator = tabulate(square, -3)\n        >>> take(4, iterator)\n        [9, 4, 1, 0]\n\n    ')), Return(value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='function', ctx=Load()), Call(func=Name(id='count', ctx=Load()), args=[Name(id='start', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='tail', args=arguments(posonlyargs=[], args=[arg(arg='n'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return an iterator over the last *n* items of *iterable*.\n\n    >>> t = tail(3, 'ABCDEFG')\n    >>> list(t)\n    ['E', 'F', 'G']\n\n    ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='Sized', ctx=Load())], keywords=[]), body=[Expr(value=YieldFrom(value=Call(func=Name(id='islice', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]), op=Sub(), right=Name(id='n', ctx=Load()))], keywords=[]), Constant(value=None)], keywords=[])))], orelse=[Expr(value=YieldFrom(value=Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Name(id='deque', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[keyword(arg='maxlen', value=Name(id='n', ctx=Load()))])], keywords=[])))])], decorator_list=[]), FunctionDef(name='consume', args=arguments(posonlyargs=[], args=[arg(arg='iterator'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Advance *iterable* by *n* steps. If *n* is ``None``, consume it\n    entirely.\n\n    Efficiently exhausts an iterator without returning values. Defaults to\n    consuming the whole iterator, but an optional second argument may be\n    provided to limit consumption.\n\n        >>> i = (x for x in range(10))\n        >>> next(i)\n        0\n        >>> consume(i, 3)\n        >>> next(i)\n        4\n        >>> consume(i)\n        >>> next(i)\n        Traceback (most recent call last):\n          File "<stdin>", line 1, in <module>\n        StopIteration\n\n    If the iterator has fewer items remaining than the provided limit, the\n    whole iterator will be consumed.\n\n        >>> i = (x for x in range(3))\n        >>> consume(i, 5)\n        >>> next(i)\n        Traceback (most recent call last):\n          File "<stdin>", line 1, in <module>\n        StopIteration\n\n    ')), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='deque', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[keyword(arg='maxlen', value=Constant(value=0))]))], orelse=[Expr(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='iterator', ctx=Load()), Name(id='n', ctx=Load()), Name(id='n', ctx=Load())], keywords=[]), Constant(value=None)], keywords=[]))])], decorator_list=[]), FunctionDef(name='nth', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Returns the nth item or a default value.\n\n    >>> l = range(10)\n    >>> nth(l, 3)\n    3\n    >>> nth(l, 20, "zebra")\n    \'zebra\'\n\n    ')), Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='n', ctx=Load()), Constant(value=None)], keywords=[]), Name(id='default', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='all_equal', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Returns ``True`` if all the elements are equal to each other.\n\n        >>> all_equal('aaaa')\n        True\n        >>> all_equal('aaab')\n        False\n\n    ")), Assign(targets=[Name(id='g', ctx=Store())], value=Call(func=Name(id='groupby', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Return(value=BoolOp(op=And(), values=[Call(func=Name(id='next', ctx=Load()), args=[Name(id='g', ctx=Load()), Constant(value=True)], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='next', ctx=Load()), args=[Name(id='g', ctx=Load()), Constant(value=False)], keywords=[]))]))], decorator_list=[]), FunctionDef(name='quantify', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='pred')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='bool', ctx=Load())]), body=[Expr(value=Constant(value='Return the how many times the predicate is true.\n\n    >>> quantify([True, False, True])\n    2\n\n    ')), Return(value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='pred', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='pad_none', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns the sequence of elements and then returns ``None`` indefinitely.\n\n        >>> take(5, pad_none(range(3)))\n        [0, 1, 2, None, None]\n\n    Useful for emulating the behavior of the built-in :func:`map` function.\n\n    See also :func:`padded`.\n\n    ')), Return(value=Call(func=Name(id='chain', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Constant(value=None)], keywords=[])], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='padnone', ctx=Store())], value=Name(id='pad_none', ctx=Load())), FunctionDef(name='ncycles', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns the sequence elements *n* times\n\n    >>> list(ncycles(["a", "b"], 3))\n    [\'a\', \'b\', \'a\', \'b\', \'a\', \'b\']\n\n    ')), Return(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Call(func=Name(id='repeat', ctx=Load()), args=[Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]), Name(id='n', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='dotproduct', args=arguments(posonlyargs=[], args=[arg(arg='vec1'), arg(arg='vec2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns the dot product of the two iterables.\n\n    >>> dotproduct([10, 10], [20, 20])\n    400\n\n    ')), Return(value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='mul', ctx=Load()), Name(id='vec1', ctx=Load()), Name(id='vec2', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='flatten', args=arguments(posonlyargs=[], args=[arg(arg='listOfLists')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return an iterator flattening one level of nesting in a list of lists.\n\n        >>> list(flatten([[0, 1], [2, 3]]))\n        [0, 1, 2, 3]\n\n    See also :func:`collapse`, which can flatten multiple levels of nesting.\n\n    ')), Return(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[Name(id='listOfLists', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='repeatfunc', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='times')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Call *func* with *args* repeatedly, returning an iterable over the\n    results.\n\n    If *times* is specified, the iterable will terminate after that many\n    repetitions:\n\n        >>> from operator import add\n        >>> times = 4\n        >>> args = 3, 5\n        >>> list(repeatfunc(add, times, *args))\n        [8, 8, 8, 8]\n\n    If *times* is ``None`` the iterable will not terminate:\n\n        >>> from random import randrange\n        >>> times = None\n        >>> args = 1, 11\n        >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP\n        [2, 4, 8, 1, 8, 4]\n\n    ')), If(test=Compare(left=Name(id='times', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='starmap', ctx=Load()), args=[Name(id='func', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='starmap', ctx=Load()), args=[Name(id='func', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='args', ctx=Load()), Name(id='times', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='_pairwise', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns an iterator of paired items, overlapping, from the original\n\n    >>> take(4, pairwise(count()))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n\n    On Python 3.10 and above, this is an alias for :func:`itertools.pairwise`.\n\n    ')), Assign(targets=[Tuple(elts=[Name(id='a', ctx=Store()), Name(id='b', ctx=Store())], ctx=Store())], value=Call(func=Name(id='tee', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='b', ctx=Load()), Constant(value=None)], keywords=[])), Expr(value=YieldFrom(value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[])))], decorator_list=[]), Try(body=[ImportFrom(module='itertools', names=[alias(name='pairwise', asname='itertools_pairwise')], level=0)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='pairwise', ctx=Store())], value=Name(id='_pairwise', ctx=Load()))])], orelse=[FunctionDef(name='pairwise', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=YieldFrom(value=Call(func=Name(id='itertools_pairwise', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='pairwise', ctx=Load()), attr='__doc__', ctx=Store())], value=Attribute(value=Name(id='_pairwise', ctx=Load()), attr='__doc__', ctx=Load()))], finalbody=[]), ClassDef(name='UnequalIterablesError', bases=[Name(id='ValueError', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='details')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='Iterables have different lengths')), If(test=Compare(left=Name(id='details', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Constant(value=': index 0 has length {}; index {} has length {}'), attr='format', ctx=Load()), args=[Starred(value=Name(id='details', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='_zip_equal_generator', args=arguments(posonlyargs=[], args=[arg(arg='iterables')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='combo', ctx=Store()), iter=Call(func=Name(id='zip_longest', ctx=Load()), args=[Starred(value=Name(id='iterables', ctx=Load()), ctx=Load())], keywords=[keyword(arg='fillvalue', value=Name(id='_marker', ctx=Load()))]), body=[For(target=Name(id='val', ctx=Store()), iter=Name(id='combo', ctx=Load()), body=[If(test=Compare(left=Name(id='val', ctx=Load()), ops=[Is()], comparators=[Name(id='_marker', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='UnequalIterablesError', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Yield(value=Name(id='combo', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='_zip_equal', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='iterables'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='first_size', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='iterables', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='it', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Subscript(value=Name(id='iterables', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), Constant(value=1)], keywords=[]), body=[Assign(targets=[Name(id='size', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='size', ctx=Load()), ops=[NotEq()], comparators=[Name(id='first_size', ctx=Load())]), body=[Break()], orelse=[])], orelse=[Return(value=Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Name(id='iterables', ctx=Load()), ctx=Load())], keywords=[]))]), Raise(exc=Call(func=Name(id='UnequalIterablesError', ctx=Load()), args=[], keywords=[keyword(arg='details', value=Tuple(elts=[Name(id='first_size', ctx=Load()), Name(id='i', ctx=Load()), Name(id='size', ctx=Load())], ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Return(value=Call(func=Name(id='_zip_equal_generator', ctx=Load()), args=[Name(id='iterables', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='grouper', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n'), arg(arg='incomplete'), arg(arg='fillvalue')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='fill'), Constant(value=None)]), body=[Expr(value=Constant(value="Group elements from *iterable* into fixed-length groups of length *n*.\n\n    >>> list(grouper('ABCDEF', 3))\n    [('A', 'B', 'C'), ('D', 'E', 'F')]\n\n    The keyword arguments *incomplete* and *fillvalue* control what happens for\n    iterables whose length is not a multiple of *n*.\n\n    When *incomplete* is `'fill'`, the last group will contain instances of\n    *fillvalue*.\n\n    >>> list(grouper('ABCDEFG', 3, incomplete='fill', fillvalue='x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]\n\n    When *incomplete* is `'ignore'`, the last group will not be emitted.\n\n    >>> list(grouper('ABCDEFG', 3, incomplete='ignore', fillvalue='x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F')]\n\n    When *incomplete* is `'strict'`, a subclass of `ValueError` will be raised.\n\n    >>> it = grouper('ABCDEFG', 3, incomplete='strict')\n    >>> list(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    UnequalIterablesError\n\n    ")), Assign(targets=[Name(id='args', ctx=Store())], value=BinOp(left=List(elts=[Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])], ctx=Load()), op=Mult(), right=Name(id='n', ctx=Load()))), If(test=Compare(left=Name(id='incomplete', ctx=Load()), ops=[Eq()], comparators=[Constant(value='fill')]), body=[Return(value=Call(func=Name(id='zip_longest', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(arg='fillvalue', value=Name(id='fillvalue', ctx=Load()))]))], orelse=[]), If(test=Compare(left=Name(id='incomplete', ctx=Load()), ops=[Eq()], comparators=[Constant(value='strict')]), body=[Return(value=Call(func=Name(id='_zip_equal', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='incomplete', ctx=Load()), ops=[Eq()], comparators=[Constant(value='ignore')]), body=[Return(value=Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Expected fill, strict, or ignore')], keywords=[]))])], decorator_list=[]), FunctionDef(name='roundrobin', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='iterables'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yields an item from each iterable, alternating between them.\n\n        >>> list(roundrobin('ABC', 'D', 'EF'))\n        ['A', 'D', 'E', 'B', 'F', 'C']\n\n    This function produces the same output as :func:`interleave_longest`, but\n    may perform better for some inputs (in particular when the number of\n    iterables is small).\n\n    ")), Assign(targets=[Name(id='pending', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='iterables', ctx=Load())], keywords=[])), Assign(targets=[Name(id='nexts', ctx=Store())], value=Call(func=Name(id='cycle', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]), attr='__next__', ctx=Load()), generators=[comprehension(target=Name(id='it', ctx=Store()), iter=Name(id='iterables', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), While(test=Name(id='pending', ctx=Load()), body=[Try(body=[For(target=Name(id='next', ctx=Store()), iter=Name(id='nexts', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Name(id='next', ctx=Load()), args=[], keywords=[])))], orelse=[])], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[AugAssign(target=Name(id='pending', ctx=Store()), op=Sub(), value=Constant(value=1)), Assign(targets=[Name(id='nexts', ctx=Store())], value=Call(func=Name(id='cycle', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='nexts', ctx=Load()), Name(id='pending', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='partition', args=arguments(posonlyargs=[], args=[arg(arg='pred'), arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Returns a 2-tuple of iterables derived from the input iterable.\n    The first yields the items that have ``pred(item) == False``.\n    The second yields the items that have ``pred(item) == True``.\n\n        >>> is_odd = lambda x: x % 2 != 0\n        >>> iterable = range(10)\n        >>> even_items, odd_items = partition(is_odd, iterable)\n        >>> list(even_items), list(odd_items)\n        ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9])\n\n    If *pred* is None, :func:`bool` is used.\n\n        >>> iterable = [0, 1, False, True, '', ' ']\n        >>> false_items, true_items = partition(None, iterable)\n        >>> list(false_items), list(true_items)\n        ([0, False, ''], [1, True, ' '])\n\n    ")), If(test=Compare(left=Name(id='pred', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='pred', ctx=Store())], value=Name(id='bool', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='evaluations', ctx=Store())], value=GeneratorExp(elt=Tuple(elts=[Call(func=Name(id='pred', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), Name(id='x', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='iterable', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Tuple(elts=[Name(id='t1', ctx=Store()), Name(id='t2', ctx=Store())], ctx=Store())], value=Call(func=Name(id='tee', ctx=Load()), args=[Name(id='evaluations', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[GeneratorExp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='cond', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store()), iter=Name(id='t1', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Name(id='cond', ctx=Load()))], is_async=0)]), GeneratorExp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='cond', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store()), iter=Name(id='t2', ctx=Load()), ifs=[Name(id='cond', ctx=Load())], is_async=0)])], ctx=Load()))], decorator_list=[]), FunctionDef(name='powerset', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yields all possible subsets of the iterable.\n\n        >>> list(powerset([1, 2, 3]))\n        [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n\n    :func:`powerset` will operate on iterables that aren't :class:`set`\n    instances, so repeated elements in the input will produce repeated elements\n    in the output. Use :func:`unique_everseen` on the input to avoid generating\n    duplicates:\n\n        >>> seq = [1, 1, 0]\n        >>> list(powerset(seq))\n        [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]\n        >>> from more_itertools import unique_everseen\n        >>> list(powerset(unique_everseen(seq)))\n        [(), (1,), (0,), (1, 0)]\n\n    ")), Assign(targets=[Name(id='s', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='combinations', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='r', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='r', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='unique_everseen', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n    Yield unique elements, preserving order.\n\n        >>> list(unique_everseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D']\n        >>> list(unique_everseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'D']\n\n    Sequences with a mix of hashable and unhashable items can be used.\n    The function will be slower (i.e., `O(n^2)`) for unhashable items.\n\n    Remember that ``list`` objects are unhashable - you can use the *key*\n    parameter to transform the list to a tuple (which is hashable) to\n    avoid a slowdown.\n\n        >>> iterable = ([1, 2], [2, 3], [1, 2])\n        >>> list(unique_everseen(iterable))  # Slow\n        [[1, 2], [2, 3]]\n        >>> list(unique_everseen(iterable, key=tuple))  # Faster\n        [[1, 2], [2, 3]]\n\n    Similary, you may want to convert unhashable ``set`` objects with\n    ``key=frozenset``. For ``dict`` objects,\n    ``key=lambda x: frozenset(x.items())`` can be used.\n\n    ")), Assign(targets=[Name(id='seenset', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='seenset_add', ctx=Store())], value=Attribute(value=Name(id='seenset', ctx=Load()), attr='add', ctx=Load())), Assign(targets=[Name(id='seenlist', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='seenlist_add', ctx=Store())], value=Attribute(value=Name(id='seenlist', ctx=Load()), attr='append', ctx=Load())), Assign(targets=[Name(id='use_key', ctx=Store())], value=Compare(left=Name(id='key', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), For(target=Name(id='element', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[Assign(targets=[Name(id='k', ctx=Store())], value=IfExp(test=Name(id='use_key', ctx=Load()), body=Call(func=Name(id='key', ctx=Load()), args=[Name(id='element', ctx=Load())], keywords=[]), orelse=Name(id='element', ctx=Load()))), Try(body=[If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotIn()], comparators=[Name(id='seenset', ctx=Load())]), body=[Expr(value=Call(func=Name(id='seenset_add', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Yield(value=Name(id='element', ctx=Load())))], orelse=[])], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotIn()], comparators=[Name(id='seenlist', ctx=Load())]), body=[Expr(value=Call(func=Name(id='seenlist_add', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Yield(value=Name(id='element', ctx=Load())))], orelse=[])])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='unique_justseen', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Yields elements in order, ignoring serial duplicates\n\n    >>> list(unique_justseen('AAAABBBCCDAABBB'))\n    ['A', 'B', 'C', 'D', 'A', 'B']\n    >>> list(unique_justseen('ABBCcAD', str.lower))\n    ['A', 'B', 'C', 'A', 'D']\n\n    ")), Return(value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='next', ctx=Load()), Call(func=Name(id='map', ctx=Load()), args=[Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Constant(value=1)], keywords=[]), Call(func=Name(id='groupby', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='key', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='iter_except', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='exception'), arg(arg='first')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Yields results from a function repeatedly until an exception is raised.\n\n    Converts a call-until-exception interface to an iterator interface.\n    Like ``iter(func, sentinel)``, but uses an exception instead of a sentinel\n    to end the loop.\n\n        >>> l = [0, 1, 2]\n        >>> list(iter_except(l.pop, IndexError))\n        [2, 1, 0]\n\n    Multiple exceptions can be specified as a stopping condition:\n\n        >>> l = [1, 2, 3, '...', 4, 5, 6]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        [7, 6, 5]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        [4, 3, 2]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        []\n\n    ")), Try(body=[If(test=Compare(left=Name(id='first', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Call(func=Name(id='first', ctx=Load()), args=[], keywords=[])))], orelse=[]), While(test=Constant(value=1), body=[Expr(value=Yield(value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[])))], orelse=[])], handlers=[ExceptHandler(type=Name(id='exception', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='first_true', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='default'), arg(arg='pred')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="\n    Returns the first true value in the iterable.\n\n    If no true value is found, returns *default*\n\n    If *pred* is not None, returns the first item for which\n    ``pred(item) == True`` .\n\n        >>> first_true(range(10))\n        1\n        >>> first_true(range(10), pred=lambda x: x > 5)\n        6\n        >>> first_true(range(10), default='missing', pred=lambda x: x > 9)\n        'missing'\n\n    ")), Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='filter', ctx=Load()), args=[Name(id='pred', ctx=Load()), Name(id='iterable', ctx=Load())], keywords=[]), Name(id='default', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='random_product', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[arg(arg='repeat')], kw_defaults=[Constant(value=1)], defaults=[]), body=[Expr(value=Constant(value="Draw an item at random from each of the input iterables.\n\n        >>> random_product('abc', range(4), 'XYZ')  # doctest:+SKIP\n        ('c', 3, 'Z')\n\n    If *repeat* is provided as a keyword argument, that many items will be\n    drawn from each iterable.\n\n        >>> random_product('abcd', range(4), repeat=2)  # doctest:+SKIP\n        ('a', 2, 'd', 3)\n\n    This equivalent to taking a random selection from\n    ``itertools.product(*args, **kwarg)``.\n\n    ")), Assign(targets=[Name(id='pools', ctx=Store())], value=BinOp(left=ListComp(elt=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='pool', ctx=Store()), iter=Name(id='args', ctx=Load()), ifs=[], is_async=0)]), op=Mult(), right=Name(id='repeat', ctx=Load()))), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='choice', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='pool', ctx=Store()), iter=Name(id='pools', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='random_permutation', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return a random *r* length permutation of the elements in *iterable*.\n\n    If *r* is not specified or is ``None``, then *r* defaults to the length of\n    *iterable*.\n\n        >>> random_permutation(range(5))  # doctest:+SKIP\n        (3, 4, 0, 1, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.permutations(iterable, r)``.\n\n    ')), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=IfExp(test=Compare(left=Name(id='r', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[]), orelse=Name(id='r', ctx=Load()))), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='sample', ctx=Load()), args=[Name(id='pool', ctx=Load()), Name(id='r', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='random_combination', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a random *r* length subsequence of the elements in *iterable*.\n\n        >>> random_combination(range(5), 3)  # doctest:+SKIP\n        (2, 3, 4)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations(iterable, r)``.\n\n    ')), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[])), Assign(targets=[Name(id='indices', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Name(id='sample', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), Name(id='r', ctx=Load())], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='pool', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Name(id='indices', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='random_combination_with_replacement', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a random *r* length subsequence of elements in *iterable*,\n    allowing individual elements to be repeated.\n\n        >>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP\n        (0, 0, 1, 2, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations_with_replacement(iterable, r)``.\n\n    ')), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[])), Assign(targets=[Name(id='indices', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='randrange', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='pool', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Name(id='indices', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='nth_combination', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='r'), arg(arg='index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Equivalent to ``list(combinations(iterable, r))[index]``.\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`nth_combination` computes the subsequence at\n    sort position *index* directly, without computing the previous\n    subsequences.\n\n        >>> nth_combination(range(5), 3, 5)\n        (0, 3, 4)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    ')), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='pool', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='r', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), Compare(left=Name(id='r', ctx=Load()), ops=[Gt()], comparators=[Name(id='n', ctx=Load())])]), body=[Raise(exc=Name(id='ValueError', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='c', ctx=Store())], value=Constant(value=1)), Assign(targets=[Name(id='k', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='r', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='r', ctx=Load()))], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=1), BinOp(left=Name(id='k', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), body=[Assign(targets=[Name(id='c', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='c', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='k', ctx=Load())), op=Add(), right=Name(id='i', ctx=Load()))), op=FloorDiv(), right=Name(id='i', ctx=Load())))], orelse=[]), If(test=Compare(left=Name(id='index', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[AugAssign(target=Name(id='index', ctx=Store()), op=Add(), value=Name(id='c', ctx=Load()))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='index', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), Compare(left=Name(id='index', ctx=Load()), ops=[GtE()], comparators=[Name(id='c', ctx=Load())])]), body=[Raise(exc=Name(id='IndexError', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=List(elts=[], ctx=Load())), While(test=Name(id='r', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='c', ctx=Store()), Name(id='n', ctx=Store()), Name(id='r', ctx=Store())], ctx=Store())], value=Tuple(elts=[BinOp(left=BinOp(left=Name(id='c', ctx=Load()), op=Mult(), right=Name(id='r', ctx=Load())), op=FloorDiv(), right=Name(id='n', ctx=Load())), BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Constant(value=1)), BinOp(left=Name(id='r', ctx=Load()), op=Sub(), right=Constant(value=1))], ctx=Load())), While(test=Compare(left=Name(id='index', ctx=Load()), ops=[GtE()], comparators=[Name(id='c', ctx=Load())]), body=[AugAssign(target=Name(id='index', ctx=Store()), op=Sub(), value=Name(id='c', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='c', ctx=Store()), Name(id='n', ctx=Store())], ctx=Store())], value=Tuple(elts=[BinOp(left=BinOp(left=Name(id='c', ctx=Load()), op=Mult(), right=BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Name(id='r', ctx=Load()))), op=FloorDiv(), right=Name(id='n', ctx=Load())), BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Constant(value=1))], ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='pool', ctx=Load()), slice=BinOp(left=UnaryOp(op=USub(), operand=Constant(value=1)), op=Sub(), right=Name(id='n', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='prepend', args=arguments(posonlyargs=[], args=[arg(arg='value'), arg(arg='iterator')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Yield *value*, followed by the elements in *iterator*.\n\n        >>> value = '0'\n        >>> iterator = ['1', '2', '3']\n        >>> list(prepend(value, iterator))\n        ['0', '1', '2', '3']\n\n    To prepend multiple values, see :func:`itertools.chain`\n    or :func:`value_chain`.\n\n    ")), Return(value=Call(func=Name(id='chain', ctx=Load()), args=[List(elts=[Name(id='value', ctx=Load())], ctx=Load()), Name(id='iterator', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='convolve', args=arguments(posonlyargs=[], args=[arg(arg='signal'), arg(arg='kernel')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Convolve the iterable *signal* with the iterable *kernel*.\n\n        >>> signal = (1, 2, 3, 4, 5)\n        >>> kernel = [3, 2, 1]\n        >>> list(convolve(signal, kernel))\n        [3, 8, 14, 20, 26, 14, 5]\n\n    Note: the input arguments are not interchangeable, as the *kernel*\n    is immediately consumed and stored.\n\n    ')), Assign(targets=[Name(id='kernel', ctx=Store())], value=Subscript(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='kernel', ctx=Load())], keywords=[]), slice=Slice(step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='kernel', ctx=Load())], keywords=[])), Assign(targets=[Name(id='window', ctx=Store())], value=BinOp(left=Call(func=Name(id='deque', ctx=Load()), args=[List(elts=[Constant(value=0)], ctx=Load())], keywords=[keyword(arg='maxlen', value=Name(id='n', ctx=Load()))]), op=Mult(), right=Name(id='n', ctx=Load()))), For(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='chain', ctx=Load()), args=[Name(id='signal', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Constant(value=0), BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Constant(value=1))], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='window', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Expr(value=Yield(value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='mul', ctx=Load()), Name(id='kernel', ctx=Load()), Name(id='window', ctx=Load())], keywords=[])], keywords=[])))], orelse=[])], decorator_list=[]), FunctionDef(name='before_and_after', args=arguments(posonlyargs=[], args=[arg(arg='predicate'), arg(arg='it')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A variant of :func:`takewhile` that allows complete access to the\n    remainder of the iterator.\n\n         >>> it = iter('ABCdEfGhI')\n         >>> all_upper, remainder = before_and_after(str.isupper, it)\n         >>> ''.join(all_upper)\n         'ABC'\n         >>> ''.join(remainder) # takewhile() would lose the 'd'\n         'dEfGhI'\n\n    Note that the first iterator must be fully consumed before the second\n    iterator can generate valid results.\n    ")), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[])), Assign(targets=[Name(id='transition', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='true_iterator', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='elem', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[If(test=Call(func=Name(id='predicate', ctx=Load()), args=[Name(id='elem', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='elem', ctx=Load())))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='transition', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='elem', ctx=Load())], keywords=[])), Return()])], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='remainder_iterator', ctx=Store())], value=Call(func=Name(id='chain', ctx=Load()), args=[Name(id='transition', ctx=Load()), Name(id='it', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Call(func=Name(id='true_iterator', ctx=Load()), args=[], keywords=[]), Name(id='remainder_iterator', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='triplewise', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return overlapping triplets from *iterable*.\n\n    >>> list(triplewise('ABCDE'))\n    [('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E')]\n\n    ")), For(target=Tuple(elts=[Tuple(elts=[Name(id='a', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store()), Tuple(elts=[Name(id='b', ctx=Store()), Name(id='c', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Name(id='pairwise', ctx=Load()), args=[Call(func=Name(id='pairwise', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load()), Name(id='c', ctx=Load())], ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='sliding_window', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a sliding window of width *n* over *iterable*.\n\n        >>> list(sliding_window(range(6), 4))\n        [(0, 1, 2, 3), (1, 2, 3, 4), (2, 3, 4, 5)]\n\n    If *iterable* has fewer than *n* items, then nothing is yielded:\n\n        >>> list(sliding_window(range(3), 4))\n        []\n\n    For a variant with more features, see :func:`windowed`.\n    ')), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='window', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='n', ctx=Load())], keywords=[])], keywords=[keyword(arg='maxlen', value=Name(id='n', ctx=Load()))])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='window', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Name(id='n', ctx=Load())]), body=[Expr(value=Yield(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='window', ctx=Load())], keywords=[])))], orelse=[]), For(target=Name(id='x', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='window', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Expr(value=Yield(value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='window', ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[]), FunctionDef(name='subslices', args=arguments(posonlyargs=[], args=[arg(arg='iterable')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return all contiguous non-empty subslices of *iterable*.\n\n        >>> list(subslices('ABC'))\n        [['A'], ['A', 'B'], ['A', 'B', 'C'], ['B'], ['B', 'C'], ['C']]\n\n    This is similar to :func:`substrings`, but emits items in a different\n    order.\n    ")), Assign(targets=[Name(id='seq', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), Assign(targets=[Name(id='slices', ctx=Store())], value=Call(func=Name(id='starmap', ctx=Load()), args=[Name(id='slice', ctx=Load()), Call(func=Name(id='combinations', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))], keywords=[]), Constant(value=2)], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='getitem', ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[]), Name(id='slices', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='polynomial_from_roots', args=arguments(posonlyargs=[], args=[arg(arg='roots')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Compute a polynomial's coefficients from its roots.\n\n    >>> roots = [5, -4, 3]  # (x - 5) * (x + 4) * (x - 3)\n    >>> polynomial_from_roots(roots)  # x^3 - 4 * x^2 - 17 * x + 60\n    [1, -4, -17, 60]\n    ")), Assign(targets=[Name(id='prod', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='math', ctx=Load()), Constant(value='prod'), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='reduce', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='mul', ctx=Load()), Name(id='x', ctx=Load()), Constant(value=1)], keywords=[]))], keywords=[])), Assign(targets=[Name(id='roots', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='neg', ctx=Load()), Name(id='roots', ctx=Load())], keywords=[])], keywords=[])), Return(value=ListComp(elt=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='prod', ctx=Load()), Call(func=Name(id='combinations', ctx=Load()), args=[Name(id='roots', ctx=Load()), Name(id='k', ctx=Load())], keywords=[])], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='roots', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[]), FunctionDef(name='iter_index', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='value'), arg(arg='start')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value="Yield the index of each place in *iterable* that *value* occurs,\n    beginning with index *start*.\n\n    See :func:`locate` for a more general means of finding the indexes\n    associated with particular values.\n\n    >>> list(iter_index('AABCADEAF', 'A'))\n    [0, 1, 4, 7]\n    ")), Try(body=[Assign(targets=[Name(id='seq_index', ctx=Store())], value=Attribute(value=Name(id='iterable', ctx=Load()), attr='index', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='islice', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='start', ctx=Load()), Constant(value=None)], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='element', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='start', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='element', ctx=Load()), ops=[Is()], comparators=[Name(id='value', ctx=Load())]), Compare(left=Name(id='element', ctx=Load()), ops=[Eq()], comparators=[Name(id='value', ctx=Load())])]), body=[Expr(value=Yield(value=Name(id='i', ctx=Load())))], orelse=[])], orelse=[])])], orelse=[Assign(targets=[Name(id='i', ctx=Store())], value=BinOp(left=Name(id='start', ctx=Load()), op=Sub(), right=Constant(value=1))), Try(body=[While(test=Constant(value=True), body=[Assign(targets=[Name(id='i', ctx=Store())], value=Call(func=Name(id='seq_index', ctx=Load()), args=[Name(id='value', ctx=Load()), BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[])), Expr(value=Yield(value=Name(id='i', ctx=Load())))], orelse=[])], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], finalbody=[])], decorator_list=[]), FunctionDef(name='sieve', args=arguments(posonlyargs=[], args=[arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Yield the primes less than n.\n\n    >>> list(sieve(30))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    ')), Assign(targets=[Name(id='isqrt', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='math', ctx=Load()), Constant(value='isqrt'), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])], keywords=[]))], keywords=[])), Assign(targets=[Name(id='data', ctx=Store())], value=BinOp(left=Call(func=Name(id='bytearray', ctx=Load()), args=[Tuple(elts=[Constant(value=0), Constant(value=1)], ctx=Load())], keywords=[]), op=Mult(), right=BinOp(left=Name(id='n', ctx=Load()), op=FloorDiv(), right=Constant(value=2)))), Assign(targets=[Subscript(value=Name(id='data', ctx=Load()), slice=Slice(upper=Constant(value=3)), ctx=Store())], value=Tuple(elts=[Constant(value=0), Constant(value=0), Constant(value=0)], ctx=Load())), Assign(targets=[Name(id='limit', ctx=Store())], value=BinOp(left=Call(func=Name(id='isqrt', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))), For(target=Name(id='p', ctx=Store()), iter=Call(func=Name(id='compress', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='limit', ctx=Load())], keywords=[]), Name(id='data', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='data', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='p', ctx=Load()), op=Mult(), right=Name(id='p', ctx=Load())), upper=Name(id='n', ctx=Load()), step=BinOp(left=Name(id='p', ctx=Load()), op=Add(), right=Name(id='p', ctx=Load()))), ctx=Store())], value=Call(func=Name(id='bytes', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='p', ctx=Load()), op=Mult(), right=Name(id='p', ctx=Load())), Name(id='n', ctx=Load()), BinOp(left=Name(id='p', ctx=Load()), op=Add(), right=Name(id='p', ctx=Load()))], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value=2), ctx=Store())], value=Constant(value=1)), Return(value=IfExp(test=Compare(left=Name(id='n', ctx=Load()), ops=[Gt()], comparators=[Constant(value=2)]), body=Call(func=Name(id='iter_index', ctx=Load()), args=[Name(id='data', ctx=Load()), Constant(value=1)], keywords=[]), orelse=Call(func=Name(id='iter', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[])))], decorator_list=[]), FunctionDef(name='batched', args=arguments(posonlyargs=[], args=[arg(arg='iterable'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Batch data into lists of length *n*. The last batch may be shorter.\n\n    >>> list(batched('ABCDEFG', 3))\n    [['A', 'B', 'C'], ['D', 'E', 'F'], ['G']]\n\n    This recipe is from the ``itertools`` docs. This library also provides\n    :func:`chunked`, which has a different implementation.\n    ")), If(test=Compare(left=Name(id='hexversion', ctx=Load()), ops=[GtE()], comparators=[Constant(value=51118240)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='batched will be removed in a future version of more-itertools. Use the standard library itertools.batched function instead'), Name(id='DeprecationWarning', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[])), While(test=Constant(value=True), body=[Assign(targets=[Name(id='batch', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='islice', ctx=Load()), args=[Name(id='it', ctx=Load()), Name(id='n', ctx=Load())], keywords=[])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='batch', ctx=Load())), body=[Break()], orelse=[]), Expr(value=Yield(value=Name(id='batch', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='transpose', args=arguments(posonlyargs=[], args=[arg(arg='it')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Swap the rows and columns of the input.\n\n    >>> list(transpose([(1, 2, 3), (11, 22, 33)]))\n    [(1, 11), (2, 22), (3, 33)]\n\n    The caller should ensure that the dimensions of the input are compatible.\n    ')), Return(value=Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Name(id='it', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='matmul', args=arguments(posonlyargs=[], args=[arg(arg='m1'), arg(arg='m2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Multiply two matrices.\n    >>> list(matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]))\n    [[49, 80], [41, 60]]\n\n    The caller should ensure that the dimensions of the input matrices are\n    compatible with each other.\n    ')), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='m2', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='batched', ctx=Load()), args=[Call(func=Name(id='starmap', ctx=Load()), args=[Name(id='dotproduct', ctx=Load()), Call(func=Name(id='product', ctx=Load()), args=[Name(id='m1', ctx=Load()), Call(func=Name(id='transpose', ctx=Load()), args=[Name(id='m2', ctx=Load())], keywords=[])], keywords=[])], keywords=[]), Name(id='n', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='factor', args=arguments(posonlyargs=[], args=[arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Yield the prime factors of n.\n    >>> list(factor(360))\n    [2, 2, 2, 3, 3, 5]\n    ')), Assign(targets=[Name(id='isqrt', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='math', ctx=Load()), Constant(value='isqrt'), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])], keywords=[]))], keywords=[])), For(target=Name(id='prime', ctx=Store()), iter=Call(func=Name(id='sieve', ctx=Load()), args=[BinOp(left=Call(func=Name(id='isqrt', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))], keywords=[]), body=[While(test=Constant(value=True), body=[Assign(targets=[Tuple(elts=[Name(id='quotient', ctx=Store()), Name(id='remainder', ctx=Store())], ctx=Store())], value=Call(func=Name(id='divmod', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='prime', ctx=Load())], keywords=[])), If(test=Name(id='remainder', ctx=Load()), body=[Break()], orelse=[]), Expr(value=Yield(value=Name(id='prime', ctx=Load()))), Assign(targets=[Name(id='n', ctx=Store())], value=Name(id='quotient', ctx=Load())), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return()], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='n', ctx=Load()), ops=[GtE()], comparators=[Constant(value=2)]), body=[Expr(value=Yield(value=Name(id='n', ctx=Load())))], orelse=[])], decorator_list=[])], type_ignores=[])