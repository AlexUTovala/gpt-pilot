Module(body=[Expr(value=Constant(value='Sub-module providing sequence-formatting functions.')), Import(names=[alias(name='platform')]), Import(names=[alias(name='six')]), ImportFrom(module='blessed.colorspace', names=[alias(name='CGA_COLORS'), alias(name='X11_COLORNAMES_TO_RGB')], level=0), If(test=Compare(left=Call(func=Attribute(value=Name(id='platform', ctx=Load()), attr='system', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='Windows')]), body=[Import(names=[alias(name='jinxed', asname='curses')])], orelse=[Import(names=[alias(name='curses')])]), FunctionDef(name='_make_colors', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return set of valid colors and their derivatives.\n\n    :rtype: set\n    :returns: Color names with prefixes\n    ')), Assign(targets=[Name(id='colors', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='cga_color', ctx=Store()), iter=Name(id='CGA_COLORS', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='colors', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='cga_color', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='colors', ctx=Load()), attr='add', ctx=Load()), args=[BinOp(left=Constant(value='on_'), op=Add(), right=Name(id='cga_color', ctx=Load()))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='colors', ctx=Load()), attr='add', ctx=Load()), args=[BinOp(left=Constant(value='bright_'), op=Add(), right=Name(id='cga_color', ctx=Load()))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='colors', ctx=Load()), attr='add', ctx=Load()), args=[BinOp(left=Constant(value='on_bright_'), op=Add(), right=Name(id='cga_color', ctx=Load()))], keywords=[]))], orelse=[]), For(target=Name(id='vga_color', ctx=Store()), iter=Name(id='X11_COLORNAMES_TO_RGB', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='colors', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='vga_color', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='colors', ctx=Load()), attr='add', ctx=Load()), args=[BinOp(left=Constant(value='on_'), op=Add(), right=Name(id='vga_color', ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Name(id='colors', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='COLORS', ctx=Store())], value=Call(func=Name(id='_make_colors', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='COMPOUNDABLES', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='bold underline reverse blink italic standout'), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[])), ClassDef(name='ParameterizingString', bases=[Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    A Unicode string which can be called as a parameterizing termcap.\n\n    For example::\n\n        >>> from blessed import Terminal\n        >>> term = Terminal()\n        >>> color = ParameterizingString(term.color, term.normal, 'color')\n        >>> color(9)('color #9')\n        u'\\x1b[91mcolor #9\\x1b(B\\x1b[m'\n    ")), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='cap'), arg(arg='normal'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='', kind='u'), Constant(value='<not specified>', kind='u')]), body=[Expr(value=Constant(value='\n        Class constructor accepting 3 positional arguments.\n\n        :arg str cap: parameterized string suitable for curses.tparm()\n        :arg str normal: terminating sequence for this capability (optional).\n        :arg str name: name of this terminal capability (optional).\n        ')), Assign(targets=[Name(id='new', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='cap', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='new', ctx=Load()), attr='_normal', ctx=Store())], value=Name(id='normal', ctx=Load())), Assign(targets=[Attribute(value=Name(id='new', ctx=Load()), attr='_name', ctx=Store())], value=Name(id='name', ctx=Load())), Return(value=Name(id='new', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returning :class:`FormattingString` instance for given parameters.\n\n        Return evaluated terminal capability (self), receiving arguments\n        ``*args``, followed by the terminating sequence (self.normal) into\n        a :class:`FormattingString` capable of being called.\n\n        :raises TypeError: Mismatch between capability and arguments\n        :raises curses.error: :func:`curses.tparm` raised an exception\n        :rtype: :class:`FormattingString` or :class:`NullCallableString`\n        :returns: Callable string for given parameters\n        ')), Try(body=[Assign(targets=[Name(id='attr', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='curses', ctx=Load()), attr='tparm', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='encode', ctx=Load()), args=[Constant(value='latin1')], keywords=[]), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[]), attr='decode', ctx=Load()), args=[Constant(value='latin1')], keywords=[])), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Name(id='attr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), name='err', body=[If(test=BoolOp(op=And(), values=[Name(id='args', ctx=Load()), Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), Attribute(value=Name(id='six', ctx=Load()), attr='string_types', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Constant(value='Unknown terminal capability, %r, or, TypeError for arguments %r: %s'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), Name(id='args', ctx=Load()), Name(id='err', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Raise()]), ExceptHandler(type=Attribute(value=Name(id='curses', ctx=Load()), attr='error', ctx=Load()), name='err', body=[If(test=Compare(left=Constant(value='tparm() returned NULL'), ops=[NotIn()], comparators=[Call(func=Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load()), args=[Name(id='err', ctx=Load())], keywords=[])]), body=[Raise()], orelse=[]), Return(value=Call(func=Name(id='NullCallableString', ctx=Load()), args=[], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='ParameterizingProxyString', bases=[Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    A Unicode string which can be called to proxy missing termcap entries.\n\n    This class supports the function :func:`get_proxy_string`, and mirrors\n    the behavior of :class:`ParameterizingString`, except that instead of\n    a capability name, receives a format string, and callable to filter the\n    given positional ``*args`` of :meth:`ParameterizingProxyString.__call__`\n    into a terminal sequence.\n\n    For example::\n\n        >>> from blessed import Terminal\n        >>> term = Terminal('screen')\n        >>> hpa = ParameterizingString(term.hpa, term.normal, 'hpa')\n        >>> hpa(9)\n        u''\n        >>> fmt = u'\\x1b[{0}G'\n        >>> fmt_arg = lambda *arg: (arg[0] + 1,)\n        >>> hpa = ParameterizingProxyString((fmt, fmt_arg), term.normal, 'hpa')\n        >>> hpa(9)\n        u'\\x1b[10G'\n    ")), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='fmt_pair'), arg(arg='normal'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='', kind='u'), Constant(value='<not specified>', kind='u')]), body=[Expr(value=Constant(value='\n        Class constructor accepting 4 positional arguments.\n\n        :arg tuple fmt_pair: Two element tuple containing:\n            - format string suitable for displaying terminal sequences\n            - callable suitable for receiving  __call__ arguments for formatting string\n        :arg str normal: terminating sequence for this capability (optional).\n        :arg str name: name of this terminal capability (optional).\n        ')), Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='fmt_pair', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), msg=Name(id='fmt_pair', ctx=Load())), Assert(test=Call(func=Name(id='callable', ctx=Load()), args=[Subscript(value=Name(id='fmt_pair', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[]), msg=Subscript(value=Name(id='fmt_pair', ctx=Load()), slice=Constant(value=1), ctx=Load())), Assign(targets=[Name(id='new', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Subscript(value=Name(id='fmt_pair', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='new', ctx=Load()), attr='_fmt_args', ctx=Store())], value=Subscript(value=Name(id='fmt_pair', ctx=Load()), slice=Constant(value=1), ctx=Load())), Assign(targets=[Attribute(value=Name(id='new', ctx=Load()), attr='_normal', ctx=Store())], value=Name(id='normal', ctx=Load())), Assign(targets=[Attribute(value=Name(id='new', ctx=Load()), attr='_name', ctx=Store())], value=Name(id='name', ctx=Load())), Return(value=Name(id='new', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returning :class:`FormattingString` instance for given parameters.\n\n        Arguments are determined by the capability.  For example, ``hpa``\n        (move_x) receives only a single integer, whereas ``cup`` (move)\n        receives two integers.  See documentation in terminfo(5) for the\n        given capability.\n\n        :rtype: FormattingString\n        :returns: Callable string for given parameters\n        ')), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='format', ctx=Load()), args=[Starred(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fmt_args', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[]), ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='FormattingString', bases=[Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    A Unicode string which doubles as a callable.\n\n    This is used for terminal attributes, so that it may be used both\n    directly, or as a callable.  When used directly, it simply emits\n    the given terminal sequence.  When used as a callable, it wraps the\n    given (string) argument with the 2nd argument used by the class\n    constructor::\n\n        >>> from blessed import Terminal\n        >>> term = Terminal()\n        >>> style = FormattingString(term.bright_blue, term.normal)\n        >>> print(repr(style))\n        u'\\x1b[94m'\n        >>> style('Big Blue')\n        u'\\x1b[94mBig Blue\\x1b(B\\x1b[m'\n    ")), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='sequence'), arg(arg='normal')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='', kind='u')]), body=[Expr(value=Constant(value='\n        Class constructor accepting 2 positional arguments.\n\n        :arg str sequence: terminal attribute sequence.\n        :arg str normal: terminating sequence for this attribute (optional).\n        ')), Assign(targets=[Name(id='new', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='sequence', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='new', ctx=Load()), attr='_normal', ctx=Store())], value=Name(id='normal', ctx=Load())), Return(value=Name(id='new', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return ``text`` joined by ``sequence`` and ``normal``.\n\n        :raises TypeError: Not a string type\n        :rtype: str\n        :returns: Arguments wrapped in sequence and normal\n        ')), For(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='ucs_part', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='ucs_part', ctx=Load()), Attribute(value=Name(id='six', ctx=Load()), attr='string_types', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='expected_types', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='_type', ctx=Load()), attr='__name__', ctx=Load()), generators=[comprehension(target=Name(id='_type', ctx=Store()), iter=Attribute(value=Name(id='six', ctx=Load()), attr='string_types', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Constant(value='TypeError for FormattingString argument, %r, at position %s: expected type %s, got %s'), op=Mod(), right=Tuple(elts=[Name(id='ucs_part', ctx=Load()), Name(id='idx', ctx=Load()), Name(id='expected_types', ctx=Load()), Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='ucs_part', ctx=Load())], keywords=[]), attr='__name__', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='postfix', ctx=Store())], value=Constant(value='', kind='u')), If(test=BoolOp(op=And(), values=[Name(id='self', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Load())]), body=[Assign(targets=[Name(id='postfix', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Load())), Assign(targets=[Name(id='_refresh', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Load()), op=Add(), right=Name(id='self', ctx=Load()))), Assign(targets=[Name(id='args', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='_refresh', ctx=Load()), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ucs_part', ctx=Load()), attr='split', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='ucs_part', ctx=Store()), iter=Name(id='args', ctx=Load()), ifs=[], is_async=0)]))], orelse=[]), Return(value=BinOp(left=BinOp(left=Name(id='self', ctx=Load()), op=Add(), right=Call(func=Attribute(value=Constant(value='', kind='u'), attr='join', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])), op=Add(), right=Name(id='postfix', ctx=Load())))], decorator_list=[])], decorator_list=[]), ClassDef(name='FormattingOtherString', bases=[Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    A Unicode string which doubles as a callable for another sequence when called.\n\n    This is used for the :meth:`~.Terminal.move_up`, ``down``, ``left``, and ``right()``\n    family of functions::\n\n        >>> from blessed import Terminal\n        >>> term = Terminal()\n        >>> move_right = FormattingOtherString(term.cuf1, term.cuf)\n        >>> print(repr(move_right))\n        u'\\x1b[C'\n        >>> print(repr(move_right(666)))\n        u'\\x1b[666C'\n        >>> print(repr(move_right()))\n        u'\\x1b[C'\n    ")), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='direct'), arg(arg='target')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Class constructor accepting 2 positional arguments.\n\n        :arg str direct: capability name for direct formatting, eg ``('x' + term.right)``.\n        :arg str target: capability name for callable, eg ``('x' + term.right(99))``.\n        ")), Assign(targets=[Name(id='new', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='direct', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='new', ctx=Load()), attr='_callable', ctx=Store())], value=Name(id='target', ctx=Load())), Return(value=Name(id='new', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getnewargs__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Call(func=Attribute(value=Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load()), attr='__new__', ctx=Load()), args=[Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='_callable', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return ``text`` by ``target``.')), Return(value=IfExp(test=Name(id='args', ctx=Load()), body=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callable', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[]), orelse=Name(id='self', ctx=Load())))], decorator_list=[])], decorator_list=[]), ClassDef(name='NullCallableString', bases=[Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A dummy callable Unicode alternative to :class:`FormattingString`.\n\n    This is used for colors on terminals that do not support colors, it is just a basic form of\n    unicode that may also act as a callable.\n    ')), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Class constructor.')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='', kind='u')], keywords=[]))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Allow empty string to be callable, returning given string, if any.\n\n        When called with an int as the first arg, return an empty Unicode. An\n        int is a good hint that I am a :class:`ParameterizingString`, as there\n        are only about half a dozen string-returning capabilities listed in\n        terminfo(5) which accept non-int arguments, they are seldom used.\n\n        When called with a non-int as the first arg (no no args at all), return\n        the first arg, acting in place of :class:`FormattingString` without\n        any attributes.\n        ')), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='args', ctx=Load())), Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='int', ctx=Load())], keywords=[])]), body=[Return(value=Call(func=Name(id='NullCallableString', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='', kind='u'), attr='join', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='get_proxy_string', args=arguments(posonlyargs=[], args=[arg(arg='term'), arg(arg='attr')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Proxy and return callable string for proxied attributes.\n\n    :arg Terminal term: :class:`~.Terminal` instance.\n    :arg str attr: terminal capability name that may be proxied.\n    :rtype: None or :class:`ParameterizingProxyString`.\n    :returns: :class:`ParameterizingProxyString` for some attributes\n        of some terminal types that support it, where the terminfo(5)\n        database would otherwise come up empty, such as ``move_x``\n        attribute for ``term.kind`` of ``screen``.  Otherwise, None.\n    ')), Assign(targets=[Name(id='term_kind', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[GeneratorExp(elt=Name(id='_kind', ctx=Load()), generators=[comprehension(target=Name(id='_kind', ctx=Store()), iter=Tuple(elts=[Constant(value='screen'), Constant(value='ansi')], ctx=Load()), ifs=[Call(func=Attribute(value=Attribute(value=Name(id='term', ctx=Load()), attr='kind', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='_kind', ctx=Load())], keywords=[])], is_async=0)])], keywords=[]), Name(id='term', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_proxy_table', ctx=Store())], value=Dict(keys=[Constant(value='screen'), Constant(value='ansi')], values=[Dict(keys=[Constant(value='hpa'), Constant(value='vpa')], values=[Call(func=Name(id='ParameterizingProxyString', ctx=Load()), args=[Tuple(elts=[Constant(value='\x1b[{0}G', kind='u'), Lambda(args=arguments(posonlyargs=[], args=[], vararg=arg(arg='arg'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[BinOp(left=Subscript(value=Name(id='arg', ctx=Load()), slice=Constant(value=0), ctx=Load()), op=Add(), right=Constant(value=1))], ctx=Load()))], ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), Call(func=Name(id='ParameterizingProxyString', ctx=Load()), args=[Tuple(elts=[Constant(value='\x1b[{0}d', kind='u'), Lambda(args=arguments(posonlyargs=[], args=[], vararg=arg(arg='arg'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[BinOp(left=Subscript(value=Name(id='arg', ctx=Load()), slice=Constant(value=0), ctx=Load()), op=Add(), right=Constant(value=1))], ctx=Load()))], ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[])]), Dict(keys=[Constant(value='civis'), Constant(value='cnorm'), Constant(value='hpa'), Constant(value='vpa'), Constant(value='sc'), Constant(value='rc')], values=[Call(func=Name(id='ParameterizingProxyString', ctx=Load()), args=[Tuple(elts=[Constant(value='\x1b[?25l', kind='u'), Lambda(args=arguments(posonlyargs=[], args=[], vararg=arg(arg='arg'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[], ctx=Load()))], ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), Call(func=Name(id='ParameterizingProxyString', ctx=Load()), args=[Tuple(elts=[Constant(value='\x1b[?25h', kind='u'), Lambda(args=arguments(posonlyargs=[], args=[], vararg=arg(arg='arg'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[], ctx=Load()))], ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), Call(func=Name(id='ParameterizingProxyString', ctx=Load()), args=[Tuple(elts=[Constant(value='\x1b[{0}G', kind='u'), Lambda(args=arguments(posonlyargs=[], args=[], vararg=arg(arg='arg'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[BinOp(left=Subscript(value=Name(id='arg', ctx=Load()), slice=Constant(value=0), ctx=Load()), op=Add(), right=Constant(value=1))], ctx=Load()))], ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), Call(func=Name(id='ParameterizingProxyString', ctx=Load()), args=[Tuple(elts=[Constant(value='\x1b[{0}d', kind='u'), Lambda(args=arguments(posonlyargs=[], args=[], vararg=arg(arg='arg'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[BinOp(left=Subscript(value=Name(id='arg', ctx=Load()), slice=Constant(value=0), ctx=Load()), op=Add(), right=Constant(value=1))], ctx=Load()))], ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), Constant(value='\x1b[s'), Constant(value='\x1b[u')])])), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='_proxy_table', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='term_kind', ctx=Load()), Dict(keys=[], values=[])], keywords=[]), attr='get', ctx=Load()), args=[Name(id='attr', ctx=Load()), Constant(value=None)], keywords=[]))], decorator_list=[]), FunctionDef(name='split_compound', args=arguments(posonlyargs=[], args=[arg(arg='compound')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Split compound formating string into segments.\n\n    >>> split_compound('bold_underline_bright_blue_on_red')\n    ['bold', 'underline', 'bright_blue', 'on_red']\n\n    :arg str compound: a string that may contain compounds, separated by\n        underline (``_``).\n    :rtype: list\n    :returns: List of formating string segments\n    ")), Assign(targets=[Name(id='merged_segs', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='mergeable_prefixes', ctx=Store())], value=List(elts=[Constant(value='on'), Constant(value='bright'), Constant(value='on_bright')], ctx=Load())), For(target=Name(id='segment', ctx=Store()), iter=Call(func=Attribute(value=Name(id='compound', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='_')], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Name(id='merged_segs', ctx=Load()), Compare(left=Subscript(value=Name(id='merged_segs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), ops=[In()], comparators=[Name(id='mergeable_prefixes', ctx=Load())])]), body=[AugAssign(target=Subscript(value=Name(id='merged_segs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Store()), op=Add(), value=BinOp(left=Constant(value='_'), op=Add(), right=Name(id='segment', ctx=Load())))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='merged_segs', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[]))])], orelse=[]), Return(value=Name(id='merged_segs', ctx=Load()))], decorator_list=[]), FunctionDef(name='resolve_capability', args=arguments(posonlyargs=[], args=[arg(arg='term'), arg(arg='attr')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Resolve a raw terminal capability using :func:`tigetstr`.\n\n    :arg Terminal term: :class:`~.Terminal` instance.\n    :arg str attr: terminal capability name.\n    :returns: string of the given terminal capability named by ``attr``,\n       which may be empty (u'') if not found or not supported by the\n       given :attr:`~.Terminal.kind`.\n    :rtype: str\n    ")), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='term', ctx=Load()), attr='does_styling', ctx=Load())), body=[Return(value=Constant(value='', kind='u'))], orelse=[]), Assign(targets=[Name(id='val', ctx=Store())], value=Call(func=Attribute(value=Name(id='curses', ctx=Load()), attr='tigetstr', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='term', ctx=Load()), attr='_sugar', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='attr', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[])], keywords=[])), Return(value=IfExp(test=Compare(left=Name(id='val', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Constant(value='', kind='u'), orelse=Call(func=Attribute(value=Name(id='val', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value='latin1')], keywords=[])))], decorator_list=[]), FunctionDef(name='resolve_color', args=arguments(posonlyargs=[], args=[arg(arg='term'), arg(arg='color')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Resolve a simple color name to a callable capability.\n\n    This function supports :func:`resolve_attribute`.\n\n    :arg Terminal term: :class:`~.Terminal` instance.\n    :arg str color: any string found in set :const:`COLORS`.\n    :returns: a string class instance which emits the terminal sequence\n        for the given color, and may be used as a callable to wrap the\n        given string with such sequence.\n    :returns: :class:`NullCallableString` when\n        :attr:`~.Terminal.number_of_colors` is 0,\n        otherwise :class:`FormattingString`.\n    :rtype: :class:`NullCallableString` or :class:`FormattingString`\n    ')), If(test=Compare(left=Attribute(value=Name(id='term', ctx=Load()), attr='number_of_colors', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Call(func=Name(id='NullCallableString', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='vga_color_cap', ctx=Store())], value=IfExp(test=Compare(left=Constant(value='on_'), ops=[In()], comparators=[Name(id='color', ctx=Load())]), body=Attribute(value=Name(id='term', ctx=Load()), attr='_background_color', ctx=Load()), orelse=Attribute(value=Name(id='term', ctx=Load()), attr='_foreground_color', ctx=Load()))), Assign(targets=[Name(id='base_color', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='color', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='_'), Constant(value=1)], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), If(test=Compare(left=Name(id='base_color', ctx=Load()), ops=[In()], comparators=[Name(id='CGA_COLORS', ctx=Load())]), body=[Assign(targets=[Name(id='offset', ctx=Store())], value=IfExp(test=Compare(left=Constant(value='bright_'), ops=[In()], comparators=[Name(id='color', ctx=Load())]), body=Constant(value=8), orelse=Constant(value=0))), Assign(targets=[Name(id='base_color', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='color', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='_'), Constant(value=1)], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), Assign(targets=[Name(id='attr', ctx=Store())], value=BinOp(left=Constant(value='COLOR_%s'), op=Mod(), right=Tuple(elts=[Call(func=Attribute(value=Name(id='base_color', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[])], ctx=Load()))), Assign(targets=[Name(id='fmt_attr', ctx=Store())], value=Call(func=Name(id='vga_color_cap', ctx=Load()), args=[BinOp(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='curses', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]), op=Add(), right=Name(id='offset', ctx=Load()))], keywords=[])), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Name(id='fmt_attr', ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load())], keywords=[]))], orelse=[]), Assert(test=Compare(left=Name(id='base_color', ctx=Load()), ops=[In()], comparators=[Name(id='X11_COLORNAMES_TO_RGB', ctx=Load())]), msg=Tuple(elts=[Constant(value='color not known'), Name(id='base_color', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='rgb', ctx=Store())], value=Subscript(value=Name(id='X11_COLORNAMES_TO_RGB', ctx=Load()), slice=Name(id='base_color', ctx=Load()), ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='term', ctx=Load()), attr='number_of_colors', ctx=Load()), ops=[LtE()], comparators=[Constant(value=256)]), body=[Assign(targets=[Name(id='fmt_attr', ctx=Store())], value=Call(func=Name(id='vga_color_cap', ctx=Load()), args=[Call(func=Attribute(value=Name(id='term', ctx=Load()), attr='rgb_downconvert', ctx=Load()), args=[Starred(value=Name(id='rgb', ctx=Load()), ctx=Load())], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Name(id='fmt_attr', ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='fgbg_seq', ctx=Store())], value=IfExp(test=Compare(left=Constant(value='on_'), ops=[In()], comparators=[Name(id='color', ctx=Load())]), body=Constant(value='48'), orelse=Constant(value='38'))), Assert(test=Compare(left=Attribute(value=Name(id='term', ctx=Load()), attr='number_of_colors', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Constant(value=1), op=LShift(), right=Constant(value=24))])), Assign(targets=[Name(id='fmt_attr', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value='\x1b[', kind='u'), op=Add(), right=Name(id='fgbg_seq', ctx=Load())), op=Add(), right=Constant(value=';2;{0};{1};{2}m'))), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Call(func=Attribute(value=Name(id='fmt_attr', ctx=Load()), attr='format', ctx=Load()), args=[Starred(value=Name(id='rgb', ctx=Load()), ctx=Load())], keywords=[]), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='resolve_attribute', args=arguments(posonlyargs=[], args=[arg(arg='term'), arg(arg='attr')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Resolve a terminal attribute name into a capability class.\n\n    :arg Terminal term: :class:`~.Terminal` instance.\n    :arg str attr: Sugary, ordinary, or compound formatted terminal\n        capability, such as "red_on_white", "normal", "red", or\n        "bold_on_black".\n    :returns: a string class instance which emits the terminal sequence\n        for the given terminal capability, or may be used as a callable to\n        wrap the given string with such sequence.\n    :returns: :class:`NullCallableString` when\n        :attr:`~.Terminal.number_of_colors` is 0,\n        otherwise :class:`FormattingString`.\n    :rtype: :class:`NullCallableString` or :class:`FormattingString`\n    ')), If(test=Compare(left=Name(id='attr', ctx=Load()), ops=[In()], comparators=[Name(id='COLORS', ctx=Load())]), body=[Return(value=Call(func=Name(id='resolve_color', ctx=Load()), args=[Name(id='term', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='attr', ctx=Load()), ops=[In()], comparators=[Name(id='COMPOUNDABLES', ctx=Load())]), body=[Assign(targets=[Name(id='sequence', ctx=Store())], value=Call(func=Name(id='resolve_capability', ctx=Load()), args=[Name(id='term', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Name(id='sequence', ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='formatters', ctx=Store())], value=Call(func=Name(id='split_compound', ctx=Load()), args=[Name(id='attr', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=Or(), values=[Compare(left=Name(id='fmt', ctx=Load()), ops=[In()], comparators=[Name(id='COLORS', ctx=Load())]), Compare(left=Name(id='fmt', ctx=Load()), ops=[In()], comparators=[Name(id='COMPOUNDABLES', ctx=Load())])]), generators=[comprehension(target=Name(id='fmt', ctx=Store()), iter=Name(id='formatters', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='resolution', ctx=Store())], value=GeneratorExp(elt=Call(func=Name(id='resolve_attribute', ctx=Load()), args=[Name(id='term', ctx=Load()), Name(id='fmt', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='fmt', ctx=Store()), iter=Name(id='formatters', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='', kind='u'), attr='join', ctx=Load()), args=[Name(id='resolution', ctx=Load())], keywords=[]), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='tparm_capseq', ctx=Store())], value=Call(func=Name(id='resolve_capability', ctx=Load()), args=[Name(id='term', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='tparm_capseq', ctx=Load())), body=[Assign(targets=[Name(id='proxy', ctx=Store())], value=Call(func=Name(id='get_proxy_string', ctx=Load()), args=[Name(id='term', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='term', ctx=Load()), attr='_sugar', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='attr', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='proxy', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='proxy', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='ParameterizingString', ctx=Load()), args=[Name(id='tparm_capseq', ctx=Load()), Attribute(value=Name(id='term', ctx=Load()), attr='normal', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]))], decorator_list=[])], type_ignores=[])