Module(body=[Expr(value=Constant(value='Module containing :class:`Terminal`, the primary API entry point.')), Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='time')]), Import(names=[alias(name='codecs')]), Import(names=[alias(name='locale')]), Import(names=[alias(name='select')]), Import(names=[alias(name='struct')]), Import(names=[alias(name='platform')]), Import(names=[alias(name='warnings')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='collections')]), ImportFrom(module='color', names=[alias(name='COLOR_DISTANCE_ALGORITHMS')], level=1), ImportFrom(module='keyboard', names=[alias(name='_time_left'), alias(name='_read_until'), alias(name='resolve_sequence'), alias(name='get_keyboard_codes'), alias(name='get_leading_prefixes'), alias(name='get_keyboard_sequences')], level=1), ImportFrom(module='sequences', names=[alias(name='Termcap'), alias(name='Sequence'), alias(name='SequenceTextWrapper')], level=1), ImportFrom(module='colorspace', names=[alias(name='RGB_256TABLE')], level=1), ImportFrom(module='formatters', names=[alias(name='COLORS'), alias(name='COMPOUNDABLES'), alias(name='FormattingString'), alias(name='NullCallableString'), alias(name='ParameterizingString'), alias(name='FormattingOtherString'), alias(name='split_compound'), alias(name='resolve_attribute'), alias(name='resolve_capability')], level=1), ImportFrom(module='_capabilities', names=[alias(name='CAPABILITY_DATABASE'), alias(name='CAPABILITIES_ADDITIVES'), alias(name='CAPABILITIES_RAW_MIXIN')], level=1), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[Lt()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=3)], ctx=Load())]), body=[Assign(targets=[Name(id='InterruptedError', ctx=Store())], value=Attribute(value=Name(id='select', ctx=Load()), attr='error', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='HAS_TTY', ctx=Store())], value=Constant(value=True)), If(test=Compare(left=Call(func=Attribute(value=Name(id='platform', ctx=Load()), attr='system', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='Windows')]), body=[Assign(targets=[Name(id='IS_WINDOWS', ctx=Store())], value=Constant(value=True)), Import(names=[alias(name='jinxed', asname='curses')]), ImportFrom(module='jinxed.win32', names=[alias(name='get_console_input_encoding')], level=0)], orelse=[Assign(targets=[Name(id='IS_WINDOWS', ctx=Store())], value=Constant(value=False)), Import(names=[alias(name='curses')]), Try(body=[Import(names=[alias(name='fcntl')]), Import(names=[alias(name='termios')]), Import(names=[alias(name='tty')])], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='_TTY_METHODS', ctx=Store())], value=Tuple(elts=[Constant(value='setraw'), Constant(value='cbreak'), Constant(value='kbhit'), Constant(value='height'), Constant(value='width')], ctx=Load())), Assign(targets=[Name(id='_MSG_NOSUPPORT', ctx=Store())], value=Call(func=Attribute(value=Constant(value="One or more of the modules: 'termios', 'fcntl', and 'tty' are not found on your platform '{platform}'. The following methods of Terminal are dummy/no-op unless a deriving class overrides them: {tty_methods}."), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='platform', value=Call(func=Attribute(value=Name(id='platform', ctx=Load()), attr='system', ctx=Load()), args=[], keywords=[])), keyword(arg='tty_methods', value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='_TTY_METHODS', ctx=Load())], keywords=[]))])), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='_MSG_NOSUPPORT', ctx=Load())], keywords=[])), Assign(targets=[Name(id='HAS_TTY', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[])]), Assign(targets=[Name(id='_CUR_TERM', ctx=Store())], value=Constant(value=None)), ClassDef(name='Terminal', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    An abstraction for color, style, positioning, and input in the terminal.\n\n    This keeps the endless calls to ``tigetstr()`` and ``tparm()`` out of your code, acts\n    intelligently when somebody pipes your output to a non-terminal, and abstracts over the\n    complexity of unbuffered keyboard input. It uses the terminfo database to remain portable across\n    terminal types.\n    ')), Assign(targets=[Name(id='_sugar', ctx=Store())], value=Dict(keys=[Constant(value='save'), Constant(value='restore'), Constant(value='clear_eol'), Constant(value='clear_bol'), Constant(value='clear_eos'), Constant(value='enter_fullscreen'), Constant(value='exit_fullscreen'), Constant(value='move'), Constant(value='move_yx'), Constant(value='move_x'), Constant(value='move_y'), Constant(value='hide_cursor'), Constant(value='normal_cursor'), Constant(value='reset_colors'), Constant(value='normal'), Constant(value='reverse'), Constant(value='italic'), Constant(value='no_italic'), Constant(value='shadow'), Constant(value='no_shadow'), Constant(value='standout'), Constant(value='no_standout'), Constant(value='subscript'), Constant(value='no_subscript'), Constant(value='superscript'), Constant(value='no_superscript'), Constant(value='underline'), Constant(value='no_underline'), Constant(value='cursor_report'), Constant(value='cursor_request'), Constant(value='terminal_answerback'), Constant(value='terminal_enquire')], values=[Constant(value='sc'), Constant(value='rc'), Constant(value='el'), Constant(value='el1'), Constant(value='ed'), Constant(value='smcup'), Constant(value='rmcup'), Constant(value='cup'), Constant(value='cup'), Constant(value='hpa'), Constant(value='vpa'), Constant(value='civis'), Constant(value='cnorm'), Constant(value='op'), Constant(value='sgr0'), Constant(value='rev'), Constant(value='sitm'), Constant(value='ritm'), Constant(value='sshm'), Constant(value='rshm'), Constant(value='smso'), Constant(value='rmso'), Constant(value='ssubm'), Constant(value='rsubm'), Constant(value='ssupm'), Constant(value='rsupm'), Constant(value='smul'), Constant(value='rmul'), Constant(value='u6'), Constant(value='u7'), Constant(value='u8'), Constant(value='u9')])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='kind'), arg(arg='stream'), arg(arg='force_styling')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='\n        Initialize the terminal.\n\n        :arg str kind: A terminal string as taken by :func:`curses.setupterm`.\n            Defaults to the value of the ``TERM`` environment variable.\n\n            .. note:: Terminals withing a single process must share a common\n                ``kind``. See :obj:`_CUR_TERM`.\n\n        :arg file stream: A file-like object representing the Terminal output.\n            Defaults to the original value of :obj:`sys.__stdout__`, like\n            :func:`curses.initscr` does.\n\n            If ``stream`` is not a tty, empty Unicode strings are returned for\n            all capability values, so things like piping your program output to\n            a pipe or file does not emit terminal sequences.\n\n        :arg bool force_styling: Whether to force the emission of capabilities\n            even if :obj:`sys.__stdout__` does not seem to be connected to a\n            terminal. If you want to force styling to not happen, use\n            ``force_styling=None``.\n\n            This comes in handy if users are trying to pipe your output through\n            something like ``less -r`` or build systems which support decoding\n            of terminal sequences.\n        ')), Global(names=['_CUR_TERM']), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Store())], value=List(elts=[BinOp(left=Constant(value='parameters: kind=%r, stream=%r, force_styling=%r'), op=Mod(), right=Tuple(elts=[Name(id='kind', ctx=Load()), Name(id='stream', ctx=Load()), Name(id='force_styling', ctx=Load())], ctx=Load()))], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_line_buffered', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_stream', ctx=Store())], value=Name(id='stream', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_init_descriptor', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_is_a_tty', ctx=Store())], value=Constant(value=False)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__init__streams', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='IS_WINDOWS', ctx=Load()), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_init_descriptor', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_kind', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='kind', ctx=Load()), Call(func=Attribute(value=Name(id='curses', ctx=Load()), attr='get_term', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_init_descriptor', ctx=Load())], keywords=[])]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_kind', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='kind', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='TERM'), Constant(value='dumb')], keywords=[]), Constant(value='dumb')]))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_does_styling', ctx=Store())], value=Constant(value=False)), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='force_styling', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Attribute(value=Name(id='self', ctx=Load()), attr='is_a_tty', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='force_styling is None')], keywords=[]))], orelse=[If(test=BoolOp(op=Or(), values=[Name(id='force_styling', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='is_a_tty', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_does_styling', ctx=Store())], value=Constant(value=True))], orelse=[])]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='does_styling', ctx=Load()), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='curses', ctx=Load()), attr='setupterm', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_kind', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_init_descriptor', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='curses', ctx=Load()), attr='error', ctx=Load()), name='err', body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Constant(value='Failed to setupterm(kind={0!r}): {1}'), attr='format', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_kind', ctx=Load()), Name(id='err', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_kind', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_does_styling', ctx=Store())], value=Constant(value=False))])], orelse=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='_CUR_TERM', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_kind', ctx=Load()), ops=[Eq()], comparators=[Name(id='_CUR_TERM', ctx=Load())])]), body=[Assign(targets=[Name(id='_CUR_TERM', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_kind', ctx=Load()))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[BinOp(left=Constant(value='A terminal of kind "%s" has been requested; due to an internal python curses bug, terminal capabilities for a terminal of kind "%s" will continue to be returned for the remainder of this process.'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_kind', ctx=Load()), Name(id='_CUR_TERM', ctx=Load())], ctx=Load()))], keywords=[]))])], finalbody=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__init__color_capabilities', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__init__capabilities', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__init__keycodes', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='__init__streams', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='stream_fd', ctx=Store())], value=Constant(value=None)), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_stream', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_stream', ctx=Store())], value=Attribute(value=Name(id='sys', ctx=Load()), attr='__stdout__', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_stream', ctx=Load()), Constant(value='fileno')], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='stream has no fileno method')], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_stream', ctx=Load()), attr='fileno', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='stream.fileno is not callable')], keywords=[]))], orelse=[Try(body=[Assign(targets=[Name(id='stream_fd', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_stream', ctx=Load()), attr='fileno', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='err', body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='Unable to determine output stream file descriptor: %s'), op=Mod(), right=Name(id='err', ctx=Load()))], keywords=[]))])], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_is_a_tty', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='isatty', ctx=Load()), args=[Name(id='stream_fd', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_is_a_tty', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='stream not a TTY')], keywords=[]))], orelse=[])], finalbody=[])])]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_stream', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Attribute(value=Name(id='sys', ctx=Load()), attr='__stdout__', ctx=Load()), Attribute(value=Name(id='sys', ctx=Load()), attr='__stderr__', ctx=Load())], ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='__stdin__', ctx=Load()), attr='fileno', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), name='err', body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='Unable to determine input stream file descriptor: %s'), op=Mod(), right=Name(id='err', ctx=Load()))], keywords=[]))])], orelse=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='is_a_tty', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='Output stream is not a TTY')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Store())], value=Constant(value=None))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='isatty', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='Input stream is not a TTY')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Store())], value=Constant(value=None))], orelse=[])])], finalbody=[])], orelse=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='Output stream is not a default stream')], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_init_descriptor', ctx=Store())], value=Name(id='stream_fd', ctx=Load())), If(test=Compare(left=Name(id='stream_fd', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_init_descriptor', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='__stdout__', ctx=Load()), attr='fileno', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='err', body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='Unable to determine __stdout__ file descriptor: %s'), op=Mod(), right=Name(id='err', ctx=Load()))], keywords=[]))])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='__init__color_capabilities', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_color_distance_algorithm', ctx=Store())], value=Constant(value='cie2000')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='does_styling', ctx=Load())), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='number_of_colors', ctx=Store())], value=Constant(value=0))], orelse=[If(test=BoolOp(op=Or(), values=[Name(id='IS_WINDOWS', ctx=Load()), Compare(left=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='COLORTERM')], keywords=[]), ops=[In()], comparators=[Tuple(elts=[Constant(value='truecolor'), Constant(value='24bit')], ctx=Load())])]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='number_of_colors', ctx=Store())], value=BinOp(left=Constant(value=1), op=LShift(), right=Constant(value=24)))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='number_of_colors', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='curses', ctx=Load()), attr='tigetnum', ctx=Load()), args=[Constant(value='colors')], keywords=[]), UnaryOp(op=USub(), operand=Constant(value=1))])], keywords=[]))])])], decorator_list=[]), FunctionDef(name='__clear_color_capabilities', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='cached_color_cap', ctx=Store()), iter=BinOp(left=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Name(id='dir', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])], keywords=[]), op=BitAnd(), right=Name(id='COLORS', ctx=Load())), body=[Expr(value=Call(func=Name(id='delattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='cached_color_cap', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__init__capabilities', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='caps', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='OrderedDict', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Tuple(elts=[Name(id='attribute', ctx=Store()), Name(id='pattern', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='CAPABILITIES_ADDITIVES', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='caps', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='Termcap', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='pattern', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]))], orelse=[]), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Tuple(elts=[Name(id='attribute', ctx=Store()), Name(id='kwds', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='CAPABILITY_DATABASE', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='does_styling', ctx=Load()), body=[Assign(targets=[Name(id='cap', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[])), If(test=Name(id='cap', ctx=Load()), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='caps', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='Termcap', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='cap', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[keyword(value=Name(id='kwds', ctx=Load()))])), Continue()], orelse=[])], orelse=[]), Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='CAPABILITIES_RAW_MIXIN', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=Name(id='pattern', ctx=Load()), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='caps', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='Termcap', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='pattern', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='caps_compiled', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='cap', ctx=Load()), attr='pattern', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='cap', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='caps', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_caps_compiled_any', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='cap', ctx=Load()), attr='named_pattern', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='cap', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='caps', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]), op=Add(), right=Constant(value='|(?P<MISMATCH>.)'))], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_caps_unnamed_any', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Constant(value='({0})'), attr='format', ctx=Load()), args=[Attribute(value=Name(id='cap', ctx=Load()), attr='pattern', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='cap', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='caps', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]), op=Add(), right=Constant(value='|(.)'))], keywords=[]))], decorator_list=[]), FunctionDef(name='__init__keycodes', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keycodes', ctx=Store())], value=Call(func=Name(id='get_keyboard_codes', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='key_code', ctx=Store()), Name(id='key_name', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_keycodes', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='key_name', ctx=Load()), Name(id='key_code', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keymap', ctx=Store())], value=Call(func=Name(id='get_keyboard_sequences', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keymap_prefixes', ctx=Store())], value=Call(func=Name(id='get_leading_prefixes', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_keymap', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_buf', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='deque', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Name(id='IS_WINDOWS', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_encoding', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Name(id='get_console_input_encoding', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='locale', ctx=Load()), attr='getpreferredencoding', ctx=Load()), args=[], keywords=[]), Constant(value='UTF-8')]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_encoding', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='locale', ctx=Load()), attr='getpreferredencoding', ctx=Load()), args=[], keywords=[]), Constant(value='UTF-8')]))]), Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_decoder', ctx=Store())], value=Call(func=Call(func=Attribute(value=Name(id='codecs', ctx=Load()), attr='getincrementaldecoder', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_encoding', ctx=Load())], keywords=[]), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='LookupError', ctx=Load()), name='err', body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='LookupError: {0}, defaulting to UTF-8 for keyboard.'), attr='format', ctx=Load()), args=[Name(id='err', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_encoding', ctx=Store())], value=Constant(value='UTF-8')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_decoder', ctx=Store())], value=Call(func=Call(func=Attribute(value=Name(id='codecs', ctx=Load()), attr='getincrementaldecoder', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_encoding', ctx=Load())], keywords=[]), args=[], keywords=[]))])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='attr')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a terminal capability as Unicode string.\n\n        For example, ``term.bold`` is a unicode string that may be prepended\n        to text to set the video attribute for bold, which should also be\n        terminated with the pairing :attr:`normal`. This capability\n        returns a callable, so you can use ``term.bold("hi")`` which\n        results in the joining of ``(term.bold, "hi", term.normal)``.\n\n        Compound formatters may also be used. For example::\n\n            >>> term.bold_blink_red_on_green("merry x-mas!")\n\n        For a parameterized capability such as ``move`` (or ``cup``), pass the\n        parameters as positional arguments::\n\n            >>> term.move(line, column)\n\n        See the manual page `terminfo(5)\n        <https://invisible-island.net/ncurses/man/terminfo.5.html>`_ for a\n        complete list of capabilities and their arguments.\n        ')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_does_styling', ctx=Load())), body=[Return(value=Call(func=Name(id='NullCallableString', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='val', ctx=Store())], value=Call(func=Name(id='resolve_attribute', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='attr', ctx=Load()), Name(id='val', ctx=Load())], keywords=[])), Return(value=Name(id='val', ctx=Load()))], decorator_list=[]), FunctionDef(name='kind', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read-only property: Terminal kind determined on class initialization.\n\n        :rtype: str\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_kind', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='does_styling', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read-only property: Whether this class instance may emit sequences.\n\n        :rtype: bool\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_does_styling', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='is_a_tty', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read-only property: Whether :attr:`~.stream` is a terminal.\n\n        :rtype: bool\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_is_a_tty', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='height', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read-only property: Height of the terminal (in number of lines).\n\n        :rtype: int\n        ')), Return(value=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_height_and_width', ctx=Load()), args=[], keywords=[]), attr='ws_row', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='width', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read-only property: Width of the terminal (in number of columns).\n\n        :rtype: int\n        ')), Return(value=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_height_and_width', ctx=Load()), args=[], keywords=[]), attr='ws_col', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='pixel_height', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read-only property: Height ofthe terminal (in pixels).\n\n        :rtype: int\n        ')), Return(value=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_height_and_width', ctx=Load()), args=[], keywords=[]), attr='ws_ypixel', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='pixel_width', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read-only property: Width of terminal (in pixels).\n\n        :rtype: int\n        ')), Return(value=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_height_and_width', ctx=Load()), args=[], keywords=[]), attr='ws_xpixel', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_winsize', args=arguments(posonlyargs=[], args=[arg(arg='fd')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return named tuple describing size of the terminal by ``fd``.\n\n        If the given platform does not have modules :mod:`termios`,\n        :mod:`fcntl`, or :mod:`tty`, window size of 80 columns by 25\n        rows is always returned.\n\n        :arg int fd: file descriptor queries for its window size.\n        :raises IOError: the file descriptor ``fd`` is not a terminal.\n        :rtype: WINSZ\n        :returns: named tuple describing size of the terminal\n\n        WINSZ is a :class:`collections.namedtuple` instance, whose structure\n        directly maps to the return value of the :const:`termios.TIOCGWINSZ`\n        ioctl return value. The return parameters are:\n\n            - ``ws_row``: width of terminal by its number of character cells.\n            - ``ws_col``: height of terminal by its number of character cells.\n            - ``ws_xpixel``: width of terminal by pixels (not accurate).\n            - ``ws_ypixel``: height of terminal by pixels (not accurate).\n        ')), If(test=Name(id='HAS_TTY', ctx=Load()), body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='fcntl', ctx=Load()), attr='ioctl', ctx=Load()), args=[Name(id='fd', ctx=Load()), Attribute(value=Name(id='termios', ctx=Load()), attr='TIOCGWINSZ', ctx=Load()), Attribute(value=Name(id='WINSZ', ctx=Load()), attr='_BUF', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='WINSZ', ctx=Load()), args=[Starred(value=Call(func=Attribute(value=Name(id='struct', ctx=Load()), attr='unpack', ctx=Load()), args=[Attribute(value=Name(id='WINSZ', ctx=Load()), attr='_FMT', ctx=Load()), Name(id='data', ctx=Load())], keywords=[]), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='WINSZ', ctx=Load()), args=[], keywords=[keyword(arg='ws_row', value=Constant(value=25)), keyword(arg='ws_col', value=Constant(value=80)), keyword(arg='ws_xpixel', value=Constant(value=0)), keyword(arg='ws_ypixel', value=Constant(value=0))]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_height_and_width', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a tuple of (terminal height, terminal width).\n\n        If :attr:`stream` or :obj:`sys.__stdout__` is not a tty or does not\n        support :func:`fcntl.ioctl` of :const:`termios.TIOCGWINSZ`, a window\n        size of 80 columns by 25 rows is returned for any values not\n        represented by environment variables ``LINES`` and ``COLUMNS``, which\n        is the default text mode of IBM PC compatibles.\n\n        :rtype: WINSZ\n        :returns: Named tuple specifying the terminal size\n\n        WINSZ is a :class:`collections.namedtuple` instance, whose structure\n        directly maps to the return value of the :const:`termios.TIOCGWINSZ`\n        ioctl return value. The return parameters are:\n\n            - ``ws_row``: height of terminal by its number of cell rows.\n            - ``ws_col``: width of terminal by its number of cell columns.\n            - ``ws_xpixel``: width of terminal by pixels (not accurate).\n            - ``ws_ypixel``: height of terminal by pixels (not accurate).\n\n            .. note:: the peculiar (height, width, width, height) order, which\n               matches the return order of TIOCGWINSZ!\n        ')), For(target=Name(id='fd', ctx=Store()), iter=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_init_descriptor', ctx=Load()), Attribute(value=Name(id='sys', ctx=Load()), attr='__stdout__', ctx=Load())], ctx=Load()), body=[Try(body=[If(test=Compare(left=Name(id='fd', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_winsize', ctx=Load()), args=[Name(id='fd', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='IOError', ctx=Load()), Name(id='OSError', ctx=Load()), Name(id='ValueError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Return(value=Call(func=Name(id='WINSZ', ctx=Load()), args=[], keywords=[keyword(arg='ws_row', value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getenv', ctx=Load()), args=[Constant(value='LINES'), Constant(value='25')], keywords=[])], keywords=[])), keyword(arg='ws_col', value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getenv', ctx=Load()), args=[Constant(value='COLUMNS'), Constant(value='80')], keywords=[])], keywords=[])), keyword(arg='ws_xpixel', value=Constant(value=None)), keyword(arg='ws_ypixel', value=Constant(value=None))]))], decorator_list=[]), FunctionDef(name='_query_response', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='query_str'), arg(arg='response_re'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Sends a query string to the terminal and waits for a response.\n\n        :arg str query_str: Query string written to output\n        :arg str response_re: Regular expression matching query response\n        :arg float timeout: Return after time elapsed in seconds\n        :return: re.match object for response_re or None if not found\n        :rtype: re.Match\n        ')), Assign(targets=[Name(id='ctx', ctx=Store())], value=Constant(value=None)), Try(body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_line_buffered', ctx=Load()), body=[Assign(targets=[Name(id='ctx', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='cbreak', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ctx', ctx=Load()), attr='__enter__', ctx=Load()), args=[], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='query_str', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='match', ctx=Store()), Name(id='data', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_read_until', ctx=Load()), args=[], keywords=[keyword(arg='term', value=Name(id='self', ctx=Load())), keyword(arg='pattern', value=Name(id='response_re', ctx=Load())), keyword(arg='timeout', value=Name(id='timeout', ctx=Load()))])), If(test=Name(id='match', ctx=Load()), body=[Assign(targets=[Name(id='data', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='data', ctx=Load()), slice=Slice(upper=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[])), ctx=Load()), op=Add(), right=Subscript(value=Name(id='data', ctx=Load()), slice=Slice(lower=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[])), ctx=Load())))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='ungetch', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[]))], handlers=[], orelse=[], finalbody=[If(test=Compare(left=Name(id='ctx', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='ctx', ctx=Load()), attr='__exit__', ctx=Load()), args=[Constant(value=None), Constant(value=None), Constant(value=None)], keywords=[]))], orelse=[])]), Return(value=Name(id='match', ctx=Load()))], decorator_list=[]), FunctionDef(name='location', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x'), arg(arg='y')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="\n        Context manager for temporarily moving the cursor.\n\n        :arg int x: horizontal position, from left, *0*, to right edge of screen, *self.width - 1*.\n        :arg int y: vertical position, from top, *0*, to bottom of screen, *self.height - 1*.\n        :return: a context manager.\n        :rtype: Iterator\n\n        Move the cursor to a certain position on entry, do any kind of I/O, and upon exit\n        let you print stuff there, then return the cursor to its original position:\n\n\n        .. code-block:: python\n\n            term = Terminal()\n            with term.location(y=0, x=0):\n                for row_num in range(term.height-1):\n                    print('Row #{row_num}')\n            print(term.clear_eol + 'Back to original location.')\n\n        Specify ``x`` to move to a certain column, ``y`` to move to a certain\n        row, both, or neither. If you specify neither, only the saving and\n        restoration of cursor position will happen. This can be useful if you\n        simply want to restore your place after doing some manual cursor\n        movement.\n\n        Calls cannot be nested: only one should be entered at a time.\n\n        .. note:: The argument order *(x, y)* differs from the return value order *(y, x)*\n            of :meth:`get_location`, or argument order *(y, x)* of :meth:`move`. This is\n            for API Compaibility with the blessings library, sorry for the trouble!\n        ")), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='save', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='x', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='y', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='move', ctx=Load()), args=[Name(id='y', ctx=Load()), Name(id='x', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=Compare(left=Name(id='x', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='move_x', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=Compare(left=Name(id='y', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='move_y', ctx=Load()), args=[Name(id='y', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])])]), Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[])), Expr(value=Yield())], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='restore', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[]))])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='get_location', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n        Return tuple (row, column) of cursor position.\n\n        :arg float timeout: Return after time elapsed in seconds with value ``(-1, -1)`` indicating\n            that the remote end did not respond.\n        :rtype: tuple\n        :returns: cursor position as tuple in form of ``(y, x)``.  When a timeout is specified,\n            always ensure the return value is checked for ``(-1, -1)``.\n\n        The location of the cursor is determined by emitting the ``u7`` terminal capability, or\n        VT100 `Query Cursor Position\n        <https://www2.ccs.neu.edu/research/gpc/VonaUtils/vona/terminal/vtansi.htm#status>`_\n        when such capability is undefined, which elicits a response from a reply string described by\n        capability ``u6``, or again VT100's definition of ``\\x1b[%i%d;%dR`` when undefined.\n\n        The ``(y, x)`` return value matches the parameter order of the :meth:`move_xy` capability.\n        The following sequence should cause the cursor to not move at all::\n\n            >>> term = Terminal()\n            >>> term.move_yx(*term.get_location()))\n\n        And the following should assert True with a terminal:\n\n            >>> term = Terminal()\n            >>> given_y, given_x = 10, 20\n            >>> with term.location(y=given_y, x=given_x):\n            ...     result_y, result_x = term.get_location()\n            ...\n            >>> assert given_x == result_x, (given_x, result_x)\n            >>> assert given_y == result_y, (given_y, result_y)\n        ")), Assign(targets=[Name(id='response_str', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='caps', ctx=Load()), slice=Constant(value='cursor_report'), ctx=Load()), attr='attribute', ctx=Load())], keywords=[]), Constant(value='\x1b[%i%d;%dR', kind='u')])), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_query_response', ctx=Load()), args=[BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='u7', ctx=Load()), Constant(value='\x1b[6n', kind='u')]), Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='caps', ctx=Load()), slice=Constant(value='cursor_report'), ctx=Load()), attr='re_compiled', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='row', ctx=Store()), Name(id='col', ctx=Store())], ctx=Store())], value=GeneratorExp(elt=Call(func=Name(id='int', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='val', ctx=Store()), iter=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), If(test=Compare(left=Constant(value='%i', kind='u'), ops=[In()], comparators=[Name(id='response_str', ctx=Load())]), body=[AugAssign(target=Name(id='row', ctx=Store()), op=Sub(), value=Constant(value=1)), AugAssign(target=Name(id='col', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[]), Return(value=Tuple(elts=[Name(id='row', ctx=Load()), Name(id='col', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[UnaryOp(op=USub(), operand=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1))], ctx=Load()))], decorator_list=[]), FunctionDef(name='get_fgcolor', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Return tuple (r, g, b) of foreground color.\n\n        :arg float timeout: Return after time elapsed in seconds with value ``(-1, -1, -1)``\n            indicating that the remote end did not respond.\n        :rtype: tuple\n        :returns: foreground color as tuple in form of ``(r, g, b)``.  When a timeout is specified,\n            always ensure the return value is checked for ``(-1, -1, -1)``.\n\n        The foreground color is determined by emitting an `OSC 10 color query\n        <https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands>`_.\n        ')), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_query_response', ctx=Load()), args=[Constant(value='\x1b]10;?\x07', kind='u'), Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\x1b]10;rgb:([0-9a-fA-F]+)/([0-9a-fA-F]+)/([0-9a-fA-F]+)\x07', kind='u')], keywords=[]), Name(id='timeout', ctx=Load())], keywords=[])), Return(value=IfExp(test=Name(id='match', ctx=Load()), body=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='int', ctx=Load()), args=[Name(id='val', ctx=Load()), Constant(value=16)], keywords=[]), generators=[comprehension(target=Name(id='val', ctx=Store()), iter=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]), orelse=Tuple(elts=[UnaryOp(op=USub(), operand=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1))], ctx=Load())))], decorator_list=[]), FunctionDef(name='get_bgcolor', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Return tuple (r, g, b) of background color.\n\n        :arg float timeout: Return after time elapsed in seconds with value ``(-1, -1, -1)``\n            indicating that the remote end did not respond.\n        :rtype: tuple\n        :returns: background color as tuple in form of ``(r, g, b)``.  When a timeout is specified,\n            always ensure the return value is checked for ``(-1, -1, -1)``.\n\n        The background color is determined by emitting an `OSC 11 color query\n        <https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands>`_.\n        ')), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_query_response', ctx=Load()), args=[Constant(value='\x1b]11;?\x07', kind='u'), Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\x1b]11;rgb:([0-9a-fA-F]+)/([0-9a-fA-F]+)/([0-9a-fA-F]+)\x07', kind='u')], keywords=[]), Name(id='timeout', ctx=Load())], keywords=[])), Return(value=IfExp(test=Name(id='match', ctx=Load()), body=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='int', ctx=Load()), args=[Name(id='val', ctx=Load()), Constant(value=16)], keywords=[]), generators=[comprehension(target=Name(id='val', ctx=Store()), iter=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]), orelse=Tuple(elts=[UnaryOp(op=USub(), operand=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1))], ctx=Load())))], decorator_list=[]), FunctionDef(name='fullscreen', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Context manager that switches to secondary screen, restoring on exit.\n\n        Under the hood, this switches between the primary screen buffer and\n        the secondary one. The primary one is saved on entry and restored on\n        exit.  Likewise, the secondary contents are also stable and are\n        faithfully restored on the next entry::\n\n            with term.fullscreen():\n                main()\n\n        .. note:: There is only one primary and one secondary screen buffer.\n           :meth:`fullscreen` calls cannot be nested, only one should be\n           entered at a time.\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='enter_fullscreen', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[])), Try(body=[Expr(value=Yield())], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='exit_fullscreen', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[]))])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='hidden_cursor', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Context manager that hides the cursor, setting visibility on exit.\n\n            with term.hidden_cursor():\n                main()\n\n        .. note:: :meth:`hidden_cursor` calls cannot be nested: only one\n            should be entered at a time.\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='hide_cursor', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[])), Try(body=[Expr(value=Yield())], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='normal_cursor', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[]))])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='move_xy', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x'), arg(arg='y')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        A callable string that moves the cursor to the given ``(x, y)`` screen coordinates.\n\n        :arg int x: horizontal position, from left, *0*, to right edge of screen, *self.width - 1*.\n        :arg int y: vertical position, from top, *0*, to bottom of screen, *self.height - 1*.\n        :rtype: ParameterizingString\n        :returns: Callable string that moves the cursor to the given coordinates\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='move', ctx=Load()), args=[Name(id='y', ctx=Load()), Name(id='x', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='move_yx', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='y'), arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        A callable string that moves the cursor to the given ``(y, x)`` screen coordinates.\n\n        :arg int y: vertical position, from top, *0*, to bottom of screen, *self.height - 1*.\n        :arg int x: horizontal position, from left, *0*, to right edge of screen, *self.width - 1*.\n        :rtype: ParameterizingString\n        :returns: Callable string that moves the cursor to the given coordinates\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='move', ctx=Load()), args=[Name(id='y', ctx=Load()), Name(id='x', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='move_left', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Move cursor 1 cells to the left, or callable string for n>1 cells.')), Return(value=Call(func=Name(id='FormattingOtherString', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='cub1', ctx=Load()), Call(func=Name(id='ParameterizingString', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='cub', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='move_right', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Move cursor 1 or more cells to the right, or callable string for n>1 cells.')), Return(value=Call(func=Name(id='FormattingOtherString', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='cuf1', ctx=Load()), Call(func=Name(id='ParameterizingString', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='cuf', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='move_up', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Move cursor 1 or more cells upwards, or callable string for n>1 cells.')), Return(value=Call(func=Name(id='FormattingOtherString', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='cuu1', ctx=Load()), Call(func=Name(id='ParameterizingString', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='cuu', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='move_down', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Move cursor 1 or more cells downwards, or callable string for n>1 cells.')), Return(value=Call(func=Name(id='FormattingOtherString', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='cud1', ctx=Load()), Call(func=Name(id='ParameterizingString', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='cud', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='color', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        A callable string that sets the foreground color.\n\n        :rtype: ParameterizingString\n\n        The capability is unparameterized until called and passed a number, at which point it\n        returns another string which represents a specific color change. This second string can\n        further be called to color a piece of text and set everything back to normal afterward.\n\n        This should not be used directly, but rather a specific color by name or\n        :meth:`~.Terminal.color_rgb` value.\n        ')), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='does_styling', ctx=Load()), body=[Return(value=Call(func=Name(id='ParameterizingString', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_foreground_color', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='normal', ctx=Load()), Constant(value='color')], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='NullCallableString', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='color_rgb', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='red'), arg(arg='green'), arg(arg='blue')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Provides callable formatting string to set foreground color to the specified RGB color.\n\n        :arg int red: RGB value of Red.\n        :arg int green: RGB value of Green.\n        :arg int blue: RGB value of Blue.\n        :rtype: FormattingString\n        :returns: Callable string that sets the foreground color\n\n        If the terminal does not support RGB color, the nearest supported\n        color will be determined using :py:attr:`color_distance_algorithm`.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='number_of_colors', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Constant(value=1), op=LShift(), right=Constant(value=24))]), body=[Assign(targets=[Name(id='fmt_attr', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\x1b[38;2;{0};{1};{2}m', kind='u'), attr='format', ctx=Load()), args=[Name(id='red', ctx=Load()), Name(id='green', ctx=Load()), Name(id='blue', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Name(id='fmt_attr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='normal', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='color_idx', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='rgb_downconvert', ctx=Load()), args=[Name(id='red', ctx=Load()), Name(id='green', ctx=Load()), Name(id='blue', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_foreground_color', ctx=Load()), args=[Name(id='color_idx', ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='normal', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='on_color', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        A callable capability that sets the background color.\n\n        :rtype: ParameterizingString\n        ')), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='does_styling', ctx=Load()), body=[Return(value=Call(func=Name(id='ParameterizingString', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_background_color', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='normal', ctx=Load()), Constant(value='on_color')], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='NullCallableString', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='on_color_rgb', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='red'), arg(arg='green'), arg(arg='blue')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Provides callable formatting string to set background color to the specified RGB color.\n\n        :arg int red: RGB value of Red.\n        :arg int green: RGB value of Green.\n        :arg int blue: RGB value of Blue.\n        :rtype: FormattingString\n        :returns: Callable string that sets the foreground color\n\n        If the terminal does not support RGB color, the nearest supported\n        color will be determined using :py:attr:`color_distance_algorithm`.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='number_of_colors', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Constant(value=1), op=LShift(), right=Constant(value=24))]), body=[Assign(targets=[Name(id='fmt_attr', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\x1b[48;2;{0};{1};{2}m', kind='u'), attr='format', ctx=Load()), args=[Name(id='red', ctx=Load()), Name(id='green', ctx=Load()), Name(id='blue', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Name(id='fmt_attr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='normal', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='color_idx', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='rgb_downconvert', ctx=Load()), args=[Name(id='red', ctx=Load()), Name(id='green', ctx=Load()), Name(id='blue', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='FormattingString', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_background_color', ctx=Load()), args=[Name(id='color_idx', ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='normal', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='formatter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Provides callable formatting string to set color and other text formatting options.\n\n        :arg str value: Sugary, ordinary, or compound formatted terminal capability,\n            such as "red_on_white", "normal", "red", or "bold_on_black".\n        :rtype: :class:`FormattingString` or :class:`NullCallableString`\n        :returns: Callable string that sets color and other text formatting options\n\n        Calling ``term.formatter(\'bold_on_red\')`` is equivalent to ``term.bold_on_red``, but a\n        string that is not a valid text formatter will return a :class:`NullCallableString`.\n        This is intended to allow validation of text formatters without the possibility of\n        inadvertently returning another terminal capability.\n        ')), Assign(targets=[Name(id='formatters', ctx=Store())], value=Call(func=Name(id='split_compound', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=Or(), values=[Compare(left=Name(id='fmt', ctx=Load()), ops=[In()], comparators=[Name(id='COLORS', ctx=Load())]), Compare(left=Name(id='fmt', ctx=Load()), ops=[In()], comparators=[Name(id='COMPOUNDABLES', ctx=Load())])]), generators=[comprehension(target=Name(id='fmt', ctx=Store()), iter=Name(id='formatters', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='NullCallableString', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='rgb_downconvert', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='red'), arg(arg='green'), arg(arg='blue')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Translate an RGB color to a color code of the terminal's color depth.\n\n        :arg int red: RGB value of Red (0-255).\n        :arg int green: RGB value of Green (0-255).\n        :arg int blue: RGB value of Blue (0-255).\n        :rtype: int\n        :returns: Color code of downconverted RGB color\n        ")), Assign(targets=[Name(id='fn_distance', ctx=Store())], value=Subscript(value=Name(id='COLOR_DISTANCE_ALGORITHMS', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='color_distance_algorithm', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='color_idx', ctx=Store())], value=Constant(value=7)), Assign(targets=[Name(id='shortest_distance', ctx=Store())], value=Constant(value=None)), For(target=Tuple(elts=[Name(id='cmp_depth', ctx=Store()), Name(id='cmp_rgb', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='RGB_256TABLE', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='cmp_distance', ctx=Store())], value=Call(func=Name(id='fn_distance', ctx=Load()), args=[Name(id='cmp_rgb', ctx=Load()), Tuple(elts=[Name(id='red', ctx=Load()), Name(id='green', ctx=Load()), Name(id='blue', ctx=Load())], ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='shortest_distance', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='cmp_distance', ctx=Load()), ops=[Lt()], comparators=[Name(id='shortest_distance', ctx=Load())])]), body=[Assign(targets=[Name(id='shortest_distance', ctx=Store())], value=Name(id='cmp_distance', ctx=Load())), Assign(targets=[Name(id='color_idx', ctx=Store())], value=Name(id='cmp_depth', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='cmp_depth', ctx=Load()), ops=[GtE()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='number_of_colors', ctx=Load())]), body=[Break()], orelse=[])], orelse=[]), Return(value=Name(id='color_idx', ctx=Load()))], decorator_list=[]), FunctionDef(name='normal', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        A capability that resets all video attributes.\n\n        :rtype: str\n\n        ``normal`` is an alias for ``sgr0`` or ``exit_attribute_mode``. Any\n        styling attributes previously applied, such as foreground or\n        background colors, reverse video, or bold are reset to defaults.\n        ')), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Load()), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Store())], value=Call(func=Name(id='resolve_capability', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='normal')], keywords=[])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_normal', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='link', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='url'), arg(arg='text'), arg(arg='url_id')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='')]), body=[Expr(value=Constant(value='\n        Display ``text`` that when touched or clicked, navigates to ``url``.\n\n        Optional ``url_id`` may be specified, so that non-adjacent cells can reference a single\n        target, all cells painted with the same "id" will highlight on hover, rather than any\n        individual one, as described in "Hovering and underlining the id parameter" of gist\n        https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda.\n\n        :param str url: Hyperlink URL.\n        :param str text: Clickable text.\n        :param str url_id: Optional \'id\'.\n        :rtype: str\n        :returns: String of ``text`` as a hyperlink to ``url``.\n        ')), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=2000)]), msg=Tuple(elts=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[]), Name(id='url', ctx=Load())], ctx=Load())), If(test=Name(id='url_id', ctx=Load()), body=[Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='url_id', ctx=Load())], keywords=[])], keywords=[]), ops=[Lt()], comparators=[Constant(value=250)]), msg=Tuple(elts=[Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='url_id', ctx=Load())], keywords=[])], keywords=[]), Name(id='url_id', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='params', ctx=Store())], value=Call(func=Attribute(value=Constant(value='id={0}'), attr='format', ctx=Load()), args=[Name(id='url_id', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='params', ctx=Store())], value=Constant(value=''))]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='does_styling', ctx=Load())), body=[Return(value=Name(id='text', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='\x1b]8;{0};{1}\x1b\\{2}\x1b]8;;\x1b\\'), attr='format', ctx=Load()), args=[Name(id='params', ctx=Load()), Name(id='url', ctx=Load()), Name(id='text', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='stream', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Read-only property: stream the terminal outputs to.\n\n        This is a convenience attribute. It is used internally for implied\n        writes performed by context managers :meth:`~.hidden_cursor`,\n        :meth:`~.fullscreen`, :meth:`~.location`, and :meth:`~.keypad`.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_stream', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='number_of_colors', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Number of colors supported by terminal.\n\n        Common return values are 0, 8, 16, 256, or 1 << 24.\n\n        This may be used to test whether the terminal supports colors,\n        and at what depth, if that's a concern.\n\n        If this property is assigned a value of 88, the value 16 will be saved. This is due to the\n        the rarity of 88 color support and the inconsistency of behavior between implementations.\n\n        Assigning this property to a value other than 0, 4, 8, 16, 88, 256, or 1 << 24 will\n        raise an :py:exc:`AssertionError`.\n        ")), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_number_of_colors', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='number_of_colors', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Name(id='value', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value=0), Constant(value=4), Constant(value=8), Constant(value=16), Constant(value=88), Constant(value=256), BinOp(left=Constant(value=1), op=LShift(), right=Constant(value=24))], ctx=Load())])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_number_of_colors', ctx=Store())], value=IfExp(test=Compare(left=Name(id='value', ctx=Load()), ops=[Eq()], comparators=[Constant(value=88)]), body=Constant(value=16), orelse=Name(id='value', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__clear_color_capabilities', ctx=Load()), args=[], keywords=[]))], decorator_list=[Attribute(value=Name(id='number_of_colors', ctx=Load()), attr='setter', ctx=Load())]), FunctionDef(name='color_distance_algorithm', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Color distance algorithm used by :meth:`rgb_downconvert`.\n\n        The slowest, but most accurate, 'cie2000', is default. Other available options are 'rgb',\n        'rgb-weighted', 'cie76', and 'cie94'.\n        ")), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_color_distance_algorithm', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='color_distance_algorithm', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Name(id='value', ctx=Load()), ops=[In()], comparators=[Name(id='COLOR_DISTANCE_ALGORITHMS', ctx=Load())])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_color_distance_algorithm', ctx=Store())], value=Name(id='value', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__clear_color_capabilities', ctx=Load()), args=[], keywords=[]))], decorator_list=[Attribute(value=Name(id='color_distance_algorithm', ctx=Load()), attr='setter', ctx=Load())]), FunctionDef(name='_foreground_color', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Convenience capability to support :attr:`~.on_color`.\n\n        Prefers returning sequence for capability ``setaf``, "Set foreground color to #1, using ANSI\n        escape". If the given terminal does not support such sequence, fallback to returning\n        attribute ``setf``, "Set foreground color #1".\n        ')), Return(value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='setaf', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='setf', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_background_color', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Convenience capability to support :attr:`~.on_color`.\n\n        Prefers returning sequence for capability ``setab``, "Set background color to #1, using ANSI\n        escape". If the given terminal does not support such sequence, fallback to returning\n        attribute ``setb``, "Set background color #1".\n        ')), Return(value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='setab', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='setb', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='ljust', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text'), arg(arg='width'), arg(arg='fillchar')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=' ', kind='u')]), body=[Expr(value=Constant(value='\n        Left-align ``text``, which may contain terminal sequences.\n\n        :arg str text: String to be aligned\n        :arg int width: Total width to fill with aligned text. If\n            unspecified, the whole width of the terminal is filled.\n        :arg str fillchar: String for padding the right of ``text``\n        :rtype: str\n        :returns: String of ``text``, left-aligned by ``width``.\n        ')), If(test=Compare(left=Name(id='width', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='width', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='width', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='ljust', ctx=Load()), args=[Name(id='width', ctx=Load()), Name(id='fillchar', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='rjust', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text'), arg(arg='width'), arg(arg='fillchar')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=' ', kind='u')]), body=[Expr(value=Constant(value='\n        Right-align ``text``, which may contain terminal sequences.\n\n        :arg str text: String to be aligned\n        :arg int width: Total width to fill with aligned text. If\n            unspecified, the whole width of the terminal is used.\n        :arg str fillchar: String for padding the left of ``text``\n        :rtype: str\n        :returns: String of ``text``, right-aligned by ``width``.\n        ')), If(test=Compare(left=Name(id='width', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='width', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='width', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='rjust', ctx=Load()), args=[Name(id='width', ctx=Load()), Name(id='fillchar', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='center', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text'), arg(arg='width'), arg(arg='fillchar')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=' ', kind='u')]), body=[Expr(value=Constant(value='\n        Center ``text``, which may contain terminal sequences.\n\n        :arg str text: String to be centered\n        :arg int width: Total width in which to center text. If\n            unspecified, the whole width of the terminal is used.\n        :arg str fillchar: String for padding the left and right of ``text``\n        :rtype: str\n        :returns: String of ``text``, centered by ``width``\n        ')), If(test=Compare(left=Name(id='width', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='width', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='width', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='center', ctx=Load()), args=[Name(id='width', ctx=Load()), Name(id='fillchar', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='truncate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text'), arg(arg='width')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n        Truncate ``text`` to maximum ``width`` printable characters, retaining terminal sequences.\n\n        :arg str text: Text to truncate\n        :arg int width: The maximum width to truncate it to\n        :rtype: str\n        :returns: ``text`` truncated to at most ``width`` printable characters\n\n        >>> term.truncate(u'xyz\\x1b[0;3m', 2)\n        u'xy\\x1b[0;3m'\n        ")), If(test=Compare(left=Name(id='width', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='width', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='width', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='truncate', ctx=Load()), args=[Name(id='width', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='length', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return printable length of a string containing sequences.\n\n        :arg str text: String to measure. May contain terminal sequences.\n        :rtype: int\n        :returns: The number of terminal character cells the string will occupy\n            when printed\n\n        Wide characters that consume 2 character cells are supported:\n\n        >>> term = Terminal()\n        >>> term.length(term.clear + term.red(u\'コンニチハ\'))\n        10\n\n        .. note:: Sequences such as \'clear\', which is considered as a\n            "movement sequence" because it would move the cursor to\n            (y, x)(0, 0), are evaluated as a printable length of\n            *0*.\n        ', kind='u')), Return(value=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='length', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='strip', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text'), arg(arg='chars')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n        Return ``text`` without sequences and leading or trailing whitespace.\n\n        :rtype: str\n        :returns: Text with leading and trailing whitespace removed\n\n        >>> term.strip(u' \\x1b[0;3m xyz ')\n        u'xyz'\n        ")), Return(value=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='strip', ctx=Load()), args=[Name(id='chars', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='rstrip', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text'), arg(arg='chars')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n        Return ``text`` without terminal sequences or trailing whitespace.\n\n        :rtype: str\n        :returns: Text with terminal sequences and trailing whitespace removed\n\n        >>> term.rstrip(u' \\x1b[0;3m xyz ')\n        u'  xyz'\n        ")), Return(value=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='rstrip', ctx=Load()), args=[Name(id='chars', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='lstrip', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text'), arg(arg='chars')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n        Return ``text`` without terminal sequences or leading whitespace.\n\n        :rtype: str\n        :returns: Text with terminal sequences and leading whitespace removed\n\n        >>> term.lstrip(u' \\x1b[0;3m xyz ')\n        u'xyz '\n        ")), Return(value=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='lstrip', ctx=Load()), args=[Name(id='chars', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='strip_seqs', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Return ``text`` stripped of only its terminal sequences.\n\n        :rtype: str\n        :returns: Text with terminal sequences removed\n\n        >>> term.strip_seqs(u'\\x1b[0;3mxyz')\n        u'xyz'\n        >>> term.strip_seqs(term.cuf(5) + term.red(u'test'))\n        u'     test'\n\n        .. note:: Non-destructive sequences that adjust horizontal distance\n            (such as ``\\b`` or ``term.cuf(5)``) are replaced by destructive\n            space or erasing.\n        ")), Return(value=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='strip_seqs', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='split_seqs', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text'), arg(arg='maxsplit')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value="\n        Return ``text`` split by individual character elements and sequences.\n\n        :arg str text: String containing sequences\n        :arg int maxsplit: When maxsplit is nonzero, at most maxsplit splits\n            occur, and the remainder of the string is returned as the final element\n            of the list (same meaning is argument for :func:`re.split`).\n        :rtype: list[str]\n        :returns: List of sequences and individual characters\n\n        >>> term.split_seqs(term.underline(u'xyz'))\n        ['\\x1b[4m', 'x', 'y', 'z', '\\x1b(B', '\\x1b[m']\n\n        >>> term.split_seqs(term.underline(u'xyz'), 1)\n        ['\\x1b[4m', r'xyz\\x1b(B\\x1b[m']\n        ")), Assign(targets=[Name(id='pattern', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_caps_unnamed_any', ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='match', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='finditer', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='text', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='maxsplit', ctx=Load()), Compare(left=Name(id='idx', ctx=Load()), ops=[Eq()], comparators=[Name(id='maxsplit', ctx=Load())])]), body=[Assign(targets=[Name(id='remaining', ctx=Store())], value=Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[])), ctx=Load())), If(test=Name(id='remaining', ctx=Load()), body=[AugAssign(target=Subscript(value=Name(id='result', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Store()), op=Add(), value=Name(id='remaining', ctx=Load()))], orelse=[]), Break()], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='wrap', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text'), arg(arg='width')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Text-wrap a string, returning a list of wrapped lines.\n\n        :arg str text: Unlike :func:`textwrap.wrap`, ``text`` may contain\n            terminal sequences, such as colors, bold, or underline. By\n            default, tabs in ``text`` are expanded by\n            :func:`string.expandtabs`.\n        :arg int width: Unlike :func:`textwrap.wrap`, ``width`` will\n            default to the width of the attached terminal.\n        :arg \\**kwargs: See :py:class:`textwrap.TextWrapper`\n        :rtype: list\n        :returns: List of wrapped lines\n\n        See :class:`textwrap.TextWrapper` for keyword arguments that can\n        customize wrapping behaviour.\n        ')), Assign(targets=[Name(id='width', ctx=Store())], value=IfExp(test=Compare(left=Name(id='width', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='width', ctx=Load()), orelse=Name(id='width', ctx=Load()))), Assign(targets=[Name(id='wrapper', ctx=Store())], value=Call(func=Name(id='SequenceTextWrapper', ctx=Load()), args=[], keywords=[keyword(arg='width', value=Name(id='width', ctx=Load())), keyword(arg='term', value=Name(id='self', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Name(id='lines', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='extend', ctx=Load()), args=[IfExp(test=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), body=Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Attribute(value=Name(id='wrapper', ctx=Load()), attr='wrap', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])], keywords=[]), orelse=Tuple(elts=[Constant(value='', kind='u')], ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Name(id='lines', ctx=Load()))], decorator_list=[]), FunctionDef(name='getch', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Read, decode, and return the next byte from the keyboard stream.\n\n        :rtype: unicode\n        :returns: a single unicode character, or ``u''`` if a multi-byte\n            sequence has not yet been fully received.\n\n        This method name and behavior mimics curses ``getch(void)``, and\n        it supports :meth:`inkey`, reading only one byte from\n        the keyboard string at a time. This method should always return\n        without blocking if called after :meth:`kbhit` has returned True.\n\n        Implementors of alternate input stream methods should override\n        this method.\n        ")), Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='byte', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='read', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), Constant(value=1)], keywords=[])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_decoder', ctx=Load()), attr='decode', ctx=Load()), args=[Name(id='byte', ctx=Load())], keywords=[keyword(arg='final', value=Constant(value=False))]))], decorator_list=[]), FunctionDef(name='ungetch', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Buffer input data to be discovered by next call to :meth:`~.inkey`.\n\n        :arg str text: String to be buffered as keyboard input.\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_buf', ctx=Load()), attr='extendleft', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='kbhit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Return whether a keypress has been detected on the keyboard.\n\n        This method is used by :meth:`inkey` to determine if a byte may\n        be read using :meth:`getch` without blocking.  The standard\n        implementation simply uses the :func:`select.select` call on stdin.\n\n        :arg float timeout: When ``timeout`` is 0, this call is\n            non-blocking, otherwise blocking indefinitely until keypress\n            is detected when None (default). When ``timeout`` is a\n            positive number, returns after ``timeout`` seconds have\n            elapsed (float).\n        :rtype: bool\n        :returns: True if a keypress is awaiting to be read on the keyboard\n            attached to this terminal.  When input is not a terminal, False is\n            always returned.\n        ')), Assign(targets=[Name(id='stime', ctx=Store())], value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ready_r', ctx=Store())], value=List(elts=[Constant(value=None)], ctx=Load())), Assign(targets=[Name(id='check_r', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=List(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load())], ctx=Load()), orelse=List(elts=[], ctx=Load()))), While(test=Name(id='HAS_TTY', ctx=Load()), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='ready_r', ctx=Store()), Name(id='_', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='select', ctx=Load()), attr='select', ctx=Load()), args=[Name(id='check_r', ctx=Load()), List(elts=[], ctx=Load()), List(elts=[], ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='InterruptedError', ctx=Load()), body=[If(test=Compare(left=Name(id='timeout', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='timeout', ctx=Store()), op=Sub(), value=BinOp(left=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='stime', ctx=Load()))), If(test=Compare(left=Name(id='timeout', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='ready_r', ctx=Store())], value=List(elts=[], ctx=Load())), Break()], orelse=[])])], orelse=[Break()], finalbody=[])], orelse=[]), Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Constant(value=False), orelse=Compare(left=Name(id='check_r', ctx=Load()), ops=[Eq()], comparators=[Name(id='ready_r', ctx=Load())])))], decorator_list=[]), FunctionDef(name='cbreak', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Allow each keystroke to be read immediately after it is pressed.\n\n        This is a context manager for :func:`tty.setcbreak`.\n\n        This context manager activates 'rare' mode, the opposite of 'cooked'\n        mode: On entry, :func:`tty.setcbreak` mode is activated disabling\n        line-buffering of keyboard input and turning off automatic echo of\n        input as output.\n\n        .. note:: You must explicitly print any user input you would like\n            displayed.  If you provide any kind of editing, you must handle\n            backspace and other line-editing control functions in this mode\n            as well!\n\n        **Normally**, characters received from the keyboard cannot be read\n        by Python until the *Return* key is pressed. Also known as *cooked* or\n        *canonical input* mode, it allows the tty driver to provide\n        line-editing before shuttling the input to your program and is the\n        (implicit) default terminal mode set by most unix shells before\n        executing programs.\n\n        Technically, this context manager sets the :mod:`termios` attributes\n        of the terminal attached to :obj:`sys.__stdin__`.\n\n        .. note:: :func:`tty.setcbreak` sets ``VMIN = 1`` and ``VTIME = 0``,\n            see http://www.unixwiz.net/techtips/termios-vmin-vtime.html\n        ")), If(test=BoolOp(op=And(), values=[Name(id='HAS_TTY', ctx=Load()), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Name(id='save_mode', ctx=Store())], value=Call(func=Attribute(value=Name(id='termios', ctx=Load()), attr='tcgetattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load())], keywords=[])), Assign(targets=[Name(id='save_line_buffered', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_line_buffered', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='tty', ctx=Load()), attr='setcbreak', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), Attribute(value=Name(id='termios', ctx=Load()), attr='TCSANOW', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_line_buffered', ctx=Store())], value=Constant(value=False)), Expr(value=Yield())], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='termios', ctx=Load()), attr='tcsetattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), Attribute(value=Name(id='termios', ctx=Load()), attr='TCSAFLUSH', ctx=Load()), Name(id='save_mode', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_line_buffered', ctx=Store())], value=Name(id='save_line_buffered', ctx=Load()))])], orelse=[Expr(value=Yield())])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='raw', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        A context manager for :func:`tty.setraw`.\n\n        Although both :meth:`break` and :meth:`raw` modes allow each keystroke\n        to be read immediately after it is pressed, Raw mode disables\n        processing of input and output.\n\n        In cbreak mode, special input characters such as ``^C`` or ``^S`` are\n        interpreted by the terminal driver and excluded from the stdin stream.\n        In raw mode these values are receive by the :meth:`inkey` method.\n\n        Because output processing is not done, the newline ``\'\\n\'`` is not\n        enough, you must also print carriage return to ensure that the cursor\n        is returned to the first column::\n\n            with term.raw():\n                print("printing in raw mode", end="\\r\\n")\n        ')), If(test=BoolOp(op=And(), values=[Name(id='HAS_TTY', ctx=Load()), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Name(id='save_mode', ctx=Store())], value=Call(func=Attribute(value=Name(id='termios', ctx=Load()), attr='tcgetattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load())], keywords=[])), Assign(targets=[Name(id='save_line_buffered', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_line_buffered', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='tty', ctx=Load()), attr='setraw', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), Attribute(value=Name(id='termios', ctx=Load()), attr='TCSANOW', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_line_buffered', ctx=Store())], value=Constant(value=False)), Expr(value=Yield())], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='termios', ctx=Load()), attr='tcsetattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_fd', ctx=Load()), Attribute(value=Name(id='termios', ctx=Load()), attr='TCSAFLUSH', ctx=Load()), Name(id='save_mode', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_line_buffered', ctx=Store())], value=Name(id='save_line_buffered', ctx=Load()))])], orelse=[Expr(value=Yield())])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='keypad', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Context manager that enables directional keypad input.\n\n        On entrying, this puts the terminal into "keyboard_transmit" mode by\n        emitting the keypad_xmit (smkx) capability. On exit, it emits\n        keypad_local (rmkx).\n\n        On an IBM-PC keyboard with numeric keypad of terminal-type *xterm*,\n        with numlock off, the lower-left diagonal key transmits sequence\n        ``\\\\x1b[F``, translated to :class:`~.Terminal` attribute\n        ``KEY_END``.\n\n        However, upon entering :meth:`keypad`, ``\\\\x1b[OF`` is transmitted,\n        translating to ``KEY_LL`` (lower-left key), allowing you to determine\n        diagonal direction keys.\n        ')), Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='smkx', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[])), Expr(value=Yield())], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='write', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='rmkx', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stream', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[]))])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='inkey', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='timeout'), arg(arg='esc_delay')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=0.35)]), body=[Expr(value=Constant(value="\n        Read and return the next keyboard event within given timeout.\n\n        Generally, this should be used inside the :meth:`raw` context manager.\n\n        :arg float timeout: Number of seconds to wait for a keystroke before\n            returning.  When ``None`` (default), this method may block\n            indefinitely.\n        :arg float esc_delay: To distinguish between the keystroke of\n           ``KEY_ESCAPE``, and sequences beginning with escape, the parameter\n           ``esc_delay`` specifies the amount of time after receiving escape\n           (``chr(27)``) to seek for the completion of an application key\n           before returning a :class:`~.Keystroke` instance for\n           ``KEY_ESCAPE``.\n        :rtype: :class:`~.Keystroke`.\n        :returns: :class:`~.Keystroke`, which may be empty (``u''``) if\n           ``timeout`` is specified and keystroke is not received.\n\n        .. note:: When used without the context manager :meth:`cbreak`, or\n            :meth:`raw`, :obj:`sys.__stdin__` remains line-buffered, and this\n            function will block until the return key is pressed!\n\n        .. note:: On Windows, a 10 ms sleep is added to the key press detection loop to reduce CPU\n            load. Due to the behavior of :py:func:`time.sleep` on Windows, this will actually\n            result in a 15.6 ms delay when using the default `time resolution\n            <https://docs.microsoft.com/en-us/windows/win32/api/timeapi/nf-timeapi-timebeginperiod>`_.\n            Decreasing the time resolution will reduce this to 10 ms, while increasing it, which\n            is rarely done, will have a perceptable impact on the behavior.\n        ")), Assign(targets=[Name(id='resolve', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Name(id='resolve_sequence', ctx=Load())], keywords=[keyword(arg='mapper', value=Attribute(value=Name(id='self', ctx=Load()), attr='_keymap', ctx=Load())), keyword(arg='codes', value=Attribute(value=Name(id='self', ctx=Load()), attr='_keycodes', ctx=Load()))])), Assign(targets=[Name(id='stime', ctx=Store())], value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ucs', ctx=Store())], value=Constant(value='', kind='u')), While(test=Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_buf', ctx=Load()), body=[AugAssign(target=Name(id='ucs', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_keyboard_buf', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[]))], orelse=[]), While(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='kbhit', ctx=Load()), args=[], keywords=[keyword(arg='timeout', value=Constant(value=0))]), body=[AugAssign(target=Name(id='ucs', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getch', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='ks', ctx=Store())], value=Call(func=Name(id='resolve', ctx=Load()), args=[], keywords=[keyword(arg='text', value=Name(id='ucs', ctx=Load()))])), While(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='ks', ctx=Load())), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='kbhit', ctx=Load()), args=[], keywords=[keyword(arg='timeout', value=Call(func=Name(id='_time_left', ctx=Load()), args=[Name(id='stime', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))])]), body=[AugAssign(target=Name(id='ucs', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getch', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ks', ctx=Store())], value=Call(func=Name(id='resolve', ctx=Load()), args=[], keywords=[keyword(arg='text', value=Name(id='ucs', ctx=Load()))]))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='ks', ctx=Load()), attr='code', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='KEY_ESCAPE', ctx=Load())]), body=[Assign(targets=[Name(id='esctime', ctx=Store())], value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[])), While(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='ks', ctx=Load()), attr='code', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='KEY_ESCAPE', ctx=Load())]), Compare(left=Name(id='ucs', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_keymap_prefixes', ctx=Load())]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='kbhit', ctx=Load()), args=[], keywords=[keyword(arg='timeout', value=Call(func=Name(id='_time_left', ctx=Load()), args=[Name(id='esctime', ctx=Load()), Name(id='esc_delay', ctx=Load())], keywords=[]))])]), body=[AugAssign(target=Name(id='ucs', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getch', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ks', ctx=Store())], value=Call(func=Name(id='resolve', ctx=Load()), args=[], keywords=[keyword(arg='text', value=Name(id='ucs', ctx=Load()))]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='ungetch', ctx=Load()), args=[Subscript(value=Name(id='ucs', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='ks', ctx=Load())], keywords=[])), ctx=Load())], keywords=[])), Return(value=Name(id='ks', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='WINSZ', bases=[Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='namedtuple', ctx=Load()), args=[Constant(value='WINSZ'), Tuple(elts=[Constant(value='ws_row'), Constant(value='ws_col'), Constant(value='ws_xpixel'), Constant(value='ws_ypixel')], ctx=Load())], keywords=[])], keywords=[], body=[Expr(value=Constant(value='\n    Structure represents return value of :const:`termios.TIOCGWINSZ`.\n\n    .. py:attribute:: ws_row\n\n        rows, in characters\n\n    .. py:attribute:: ws_col\n\n        columns, in characters\n\n    .. py:attribute:: ws_xpixel\n\n        horizontal size, pixels\n\n    .. py:attribute:: ws_ypixel\n\n        vertical size, pixels\n    ')), Assign(targets=[Name(id='_FMT', ctx=Store())], value=Constant(value='hhhh')), Assign(targets=[Name(id='_BUF', ctx=Store())], value=BinOp(left=Constant(value='\x00'), op=Mult(), right=Call(func=Attribute(value=Name(id='struct', ctx=Load()), attr='calcsize', ctx=Load()), args=[Name(id='_FMT', ctx=Load())], keywords=[])))], decorator_list=[])], type_ignores=[])