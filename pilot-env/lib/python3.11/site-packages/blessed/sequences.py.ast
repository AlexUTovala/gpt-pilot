Module(body=[Expr(value=Constant(value="Module providing 'sequence awareness'.")), Import(names=[alias(name='re')]), Import(names=[alias(name='math')]), Import(names=[alias(name='textwrap')]), Import(names=[alias(name='six')]), ImportFrom(module='wcwidth', names=[alias(name='wcwidth')], level=0), ImportFrom(module='blessed._capabilities', names=[alias(name='CAPABILITIES_CAUSE_MOVEMENT')], level=0), Assign(targets=[Name(id='__all__', ctx=Store())], value=Tuple(elts=[Constant(value='Sequence'), Constant(value='SequenceTextWrapper'), Constant(value='iter_parse'), Constant(value='measure_length')], ctx=Load())), ClassDef(name='Termcap', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Terminal capability of given variable name and pattern.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='pattern'), arg(arg='attribute')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Class initializer.\n\n        :arg str name: name describing capability.\n        :arg str pattern: regular expression string.\n        :arg str attribute: :class:`~.Terminal` attribute used to build\n            this terminal capability.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Store())], value=Name(id='pattern', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='attribute', ctx=Store())], value=Name(id='attribute', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_re_compiled', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<Termcap {self.name}:{self.pattern!r}>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='self', value=Name(id='self', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='named_pattern', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Regular expression pattern for capability with named group.')), Return(value=Call(func=Attribute(value=Constant(value='(?P<{self.name}>{self.pattern})'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='self', value=Name(id='self', ctx=Load()))]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='re_compiled', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compiled regular expression pattern for capability.')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_re_compiled', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_re_compiled', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_re_compiled', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='will_move', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether capability causes cursor movement.')), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), ops=[In()], comparators=[Name(id='CAPABILITIES_CAUSE_MOVEMENT', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='horizontal_distance', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Horizontal carriage adjusted by capability, may be negative.\n\n        :rtype: int\n        :arg str text: for capabilities *parm_left_cursor*,\n            *parm_right_cursor*, provide the matching sequence\n            text, its interpreted distance is returned.\n\n        :returns: 0 except for matching '\n        ")), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Dict(keys=[Constant(value='cursor_left'), Constant(value='backspace'), Constant(value='cursor_right'), Constant(value='tab'), Constant(value='ascii_tab')], values=[UnaryOp(op=USub(), operand=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1)), Constant(value=1), Constant(value=8), Constant(value=8)]), attr='get', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='value', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='unit', ctx=Store())], value=Call(func=Attribute(value=Dict(keys=[Constant(value='parm_left_cursor'), Constant(value='parm_right_cursor')], values=[UnaryOp(op=USub(), operand=Constant(value=1)), Constant(value=1)]), attr='get', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='unit', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='re_compiled', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[])], keywords=[])), Return(value=BinOp(left=Name(id='unit', ctx=Load()), op=Mult(), right=Name(id='value', ctx=Load())))], orelse=[]), Return(value=Constant(value=0))], decorator_list=[]), FunctionDef(name='build', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='name'), arg(arg='capability'), arg(arg='attribute'), arg(arg='nparams'), arg(arg='numeric'), arg(arg='match_grouped'), arg(arg='match_any'), arg(arg='match_optional')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=99), Constant(value=False), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value="\n        Class factory builder for given capability definition.\n\n        :arg str name: Variable name given for this pattern.\n        :arg str capability: A unicode string representing a terminal\n            capability to build for. When ``nparams`` is non-zero, it\n            must be a callable unicode string (such as the result from\n            ``getattr(term, 'bold')``.\n        :arg str attribute: The terminfo(5) capability name by which this\n            pattern is known.\n        :arg int nparams: number of positional arguments for callable.\n        :arg int numeric: Value to substitute into capability to when generating pattern\n        :arg bool match_grouped: If the numeric pattern should be\n            grouped, ``(\\d+)`` when ``True``, ``\\d+`` default.\n        :arg bool match_any: When keyword argument ``nparams`` is given,\n            *any* numeric found in output is suitable for building as\n            pattern ``(\\d+)``.  Otherwise, only the first matching value of\n            range *(numeric - 1)* through *(numeric + 1)* will be replaced by\n            pattern ``(\\d+)`` in builder.\n        :arg bool match_optional: When ``True``, building of numeric patterns\n            containing ``(\\d+)`` will be built as optional, ``(\\d+)?``.\n        :rtype: blessed.sequences.Termcap\n        :returns: Terminal capability instance for given capability definition\n        ")), Assign(targets=[Name(id='_numeric_regex', ctx=Store())], value=Constant(value='\\d+')), If(test=Name(id='match_grouped', ctx=Load()), body=[Assign(targets=[Name(id='_numeric_regex', ctx=Store())], value=Constant(value='(\\d+)'))], orelse=[]), If(test=Name(id='match_optional', ctx=Load()), body=[Assign(targets=[Name(id='_numeric_regex', ctx=Store())], value=Constant(value='(\\d+)?'))], orelse=[]), Assign(targets=[Name(id='numeric', ctx=Store())], value=IfExp(test=Compare(left=Name(id='numeric', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Constant(value=99), orelse=Name(id='numeric', ctx=Load()))), If(test=Compare(left=Name(id='nparams', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='name', ctx=Load()), Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='capability', ctx=Load())], keywords=[]), Name(id='attribute', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='_outp', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Call(func=Name(id='capability', ctx=Load()), args=[Starred(value=BinOp(left=Tuple(elts=[Name(id='numeric', ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='nparams', ctx=Load())), ctx=Load())], keywords=[])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='match_any', ctx=Load())), body=[For(target=Name(id='num', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='numeric', ctx=Load()), op=Sub(), right=Constant(value=1)), BinOp(left=Name(id='numeric', ctx=Load()), op=Add(), right=Constant(value=2))], keywords=[]), body=[If(test=Compare(left=Call(func=Name(id='str', ctx=Load()), args=[Name(id='num', ctx=Load())], keywords=[]), ops=[In()], comparators=[Name(id='_outp', ctx=Load())]), body=[Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='_outp', ctx=Load()), attr='replace', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='num', ctx=Load())], keywords=[]), Name(id='_numeric_regex', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='pattern', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='match_grouped', ctx=Load()), body=[Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='(\\d+)'), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='_numeric_regex', ctx=Load())), Name(id='_outp', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='\\d+'), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='_numeric_regex', ctx=Load())), Name(id='_outp', ctx=Load())], keywords=[]))]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='pattern', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())])], decorator_list=[]), ClassDef(name='SequenceTextWrapper', bases=[Attribute(value=Name(id='textwrap', ctx=Load()), attr='TextWrapper', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Docstring overridden.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='width'), arg(arg='term')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='\n        Class initializer.\n\n        This class supports the :meth:`~.Terminal.wrap` method.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='term', ctx=Store())], value=Name(id='term', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='textwrap', ctx=Load()), attr='TextWrapper', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='width', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_wrap_chunks', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='chunks')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Sequence-aware variant of :meth:`textwrap.TextWrapper._wrap_chunks`.\n\n        :raises ValueError: ``self.width`` is not a positive integer\n        :rtype: list\n        :returns: text chunks adjusted for width\n\n        This simply ensures that word boundaries are not broken mid-sequence, as standard python\n        textwrap would incorrectly determine the length of a string containing sequences, and may\n        also break consider sequences part of a "word" that may be broken by hyphen (``-``), where\n        this implementation corrects both.\n        ')), Assign(targets=[Name(id='lines', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='width', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)]), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='width', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='invalid width {0!r}({1!r}) (must be integer > 0)'), attr='format', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='width', ctx=Load()), Call(func=Name(id='type', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='width', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='term', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='term', ctx=Load())), Assign(targets=[Name(id='drop_whitespace', ctx=Store())], value=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='drop_whitespace')], keywords=[])), Attribute(value=Name(id='self', ctx=Load()), attr='drop_whitespace', ctx=Load())])), Expr(value=Call(func=Attribute(value=Name(id='chunks', ctx=Load()), attr='reverse', ctx=Load()), args=[], keywords=[])), While(test=Name(id='chunks', ctx=Load()), body=[Assign(targets=[Name(id='cur_line', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='cur_len', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='indent', ctx=Store())], value=IfExp(test=Name(id='lines', ctx=Load()), body=Attribute(value=Name(id='self', ctx=Load()), attr='subsequent_indent', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='initial_indent', ctx=Load()))), Assign(targets=[Name(id='width', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='width', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indent', ctx=Load())], keywords=[]))), If(test=BoolOp(op=And(), values=[Name(id='drop_whitespace', ctx=Load()), BoolOp(op=And(), values=[Compare(left=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Subscript(value=Name(id='chunks', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='term', ctx=Load())], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='')]), Name(id='lines', ctx=Load())])]), body=[Delete(targets=[Subscript(value=Name(id='chunks', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Del())])], orelse=[]), While(test=Name(id='chunks', ctx=Load()), body=[Assign(targets=[Name(id='chunk_len', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Subscript(value=Name(id='chunks', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='term', ctx=Load())], keywords=[]), attr='length', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=BinOp(left=Name(id='cur_len', ctx=Load()), op=Add(), right=Name(id='chunk_len', ctx=Load())), ops=[Gt()], comparators=[Name(id='width', ctx=Load())]), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='cur_line', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='chunks', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[])], keywords=[])), AugAssign(target=Name(id='cur_len', ctx=Store()), op=Add(), value=Name(id='chunk_len', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='chunks', ctx=Load()), Compare(left=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Subscript(value=Name(id='chunks', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='term', ctx=Load())], keywords=[]), attr='length', ctx=Load()), args=[], keywords=[]), ops=[Gt()], comparators=[Name(id='width', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_handle_long_word', ctx=Load()), args=[Name(id='chunks', ctx=Load()), Name(id='cur_line', ctx=Load()), Name(id='cur_len', ctx=Load()), Name(id='width', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='drop_whitespace', ctx=Load()), BoolOp(op=And(), values=[Name(id='cur_line', ctx=Load()), Compare(left=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Subscript(value=Name(id='cur_line', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='term', ctx=Load())], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='')])])]), body=[Delete(targets=[Subscript(value=Name(id='cur_line', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Del())])], orelse=[]), If(test=Name(id='cur_line', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='indent', ctx=Load()), op=Add(), right=Call(func=Attribute(value=Constant(value='', kind='u'), attr='join', ctx=Load()), args=[Name(id='cur_line', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='lines', ctx=Load()))], decorator_list=[]), FunctionDef(name='_handle_long_word', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='reversed_chunks'), arg(arg='cur_line'), arg(arg='cur_len'), arg(arg='width')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Sequence-aware :meth:`textwrap.TextWrapper._handle_long_word`.\n\n        This simply ensures that word boundaries are not broken mid-sequence, as standard python\n        textwrap would incorrectly determine the length of a string containing sequences, and may\n        also break consider sequences part of a "word" that may be broken by hyphen (``-``), where\n        this implementation corrects both.\n        ')), Assign(targets=[Name(id='space_left', ctx=Store())], value=IfExp(test=Compare(left=Name(id='width', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=Constant(value=1), orelse=BinOp(left=Name(id='width', ctx=Load()), op=Sub(), right=Name(id='cur_len', ctx=Load())))), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='break_long_words', ctx=Load()), body=[Assign(targets=[Name(id='term', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='term', ctx=Load())), Assign(targets=[Name(id='chunk', ctx=Store())], value=Subscript(value=Name(id='reversed_chunks', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), Assign(targets=[Name(id='idx', ctx=Store()), Name(id='nxt', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='text', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter_parse', ctx=Load()), args=[Name(id='term', ctx=Load()), Name(id='chunk', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='nxt', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Call(func=Name(id='Sequence', ctx=Load()), args=[Subscript(value=Name(id='chunk', ctx=Load()), slice=Slice(upper=Name(id='nxt', ctx=Load())), ctx=Load()), Name(id='term', ctx=Load())], keywords=[]), attr='length', ctx=Load()), args=[], keywords=[]), ops=[Gt()], comparators=[Name(id='space_left', ctx=Load())]), body=[Break()], orelse=[]), Assign(targets=[Name(id='idx', ctx=Store())], value=Name(id='nxt', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='cur_line', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='chunk', ctx=Load()), slice=Slice(upper=Name(id='idx', ctx=Load())), ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='reversed_chunks', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Store())], value=Subscript(value=Name(id='chunk', ctx=Load()), slice=Slice(lower=Name(id='idx', ctx=Load())), ctx=Load()))], orelse=[If(test=UnaryOp(op=Not(), operand=Name(id='cur_line', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='cur_line', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reversed_chunks', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[])])], decorator_list=[])], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='SequenceTextWrapper', ctx=Load()), attr='__doc__', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='textwrap', ctx=Load()), attr='TextWrapper', ctx=Load()), attr='__doc__', ctx=Load())), ClassDef(name='Sequence', bases=[Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A "sequence-aware" version of the base :class:`str` class.\n\n    This unicode-derived class understands the effect of escape sequences\n    of printable length, allowing a properly implemented :meth:`rjust`,\n    :meth:`ljust`, :meth:`center`, and :meth:`length`.\n    ')), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='sequence_text'), arg(arg='term')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Class constructor.\n\n        :arg str sequence_text: A string that may contain sequences.\n        :arg blessed.Terminal term: :class:`~.Terminal` instance.\n        ')), Assign(targets=[Name(id='new', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='six', ctx=Load()), attr='text_type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='sequence_text', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='new', ctx=Load()), attr='_term', ctx=Store())], value=Name(id='term', ctx=Load())), Return(value=Name(id='new', ctx=Load()))], decorator_list=[]), FunctionDef(name='ljust', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='width'), arg(arg='fillchar')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=' ', kind='u')]), body=[Expr(value=Constant(value='\n        Return string containing sequences, left-adjusted.\n\n        :arg int width: Total width given to left-adjust ``text``.  If\n            unspecified, the width of the attached terminal is used (default).\n        :arg str fillchar: String for padding right-of ``text``.\n        :returns: String of ``text``, left-aligned by ``width``.\n        :rtype: str\n        ')), Assign(targets=[Name(id='rightside', ctx=Store())], value=BinOp(left=Name(id='fillchar', ctx=Load()), op=Mult(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0.0), Call(func=Name(id='float', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='width', ctx=Load()), attr='__index__', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='length', ctx=Load()), args=[], keywords=[]))], keywords=[])], keywords=[]), op=Div(), right=Call(func=Name(id='float', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='fillchar', ctx=Load())], keywords=[])], keywords=[]))], keywords=[]))), Return(value=Call(func=Attribute(value=Constant(value='', kind='u'), attr='join', ctx=Load()), args=[Tuple(elts=[Name(id='self', ctx=Load()), Name(id='rightside', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='rjust', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='width'), arg(arg='fillchar')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=' ', kind='u')]), body=[Expr(value=Constant(value='\n        Return string containing sequences, right-adjusted.\n\n        :arg int width: Total width given to right-adjust ``text``.  If\n            unspecified, the width of the attached terminal is used (default).\n        :arg str fillchar: String for padding left-of ``text``.\n        :returns: String of ``text``, right-aligned by ``width``.\n        :rtype: str\n        ')), Assign(targets=[Name(id='leftside', ctx=Store())], value=BinOp(left=Name(id='fillchar', ctx=Load()), op=Mult(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0.0), Call(func=Name(id='float', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='width', ctx=Load()), attr='__index__', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='length', ctx=Load()), args=[], keywords=[]))], keywords=[])], keywords=[]), op=Div(), right=Call(func=Name(id='float', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='fillchar', ctx=Load())], keywords=[])], keywords=[]))], keywords=[]))), Return(value=Call(func=Attribute(value=Constant(value='', kind='u'), attr='join', ctx=Load()), args=[Tuple(elts=[Name(id='leftside', ctx=Load()), Name(id='self', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='center', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='width'), arg(arg='fillchar')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=' ', kind='u')]), body=[Expr(value=Constant(value='\n        Return string containing sequences, centered.\n\n        :arg int width: Total width given to center ``text``.  If\n            unspecified, the width of the attached terminal is used (default).\n        :arg str fillchar: String for padding left and right-of ``text``.\n        :returns: String of ``text``, centered by ``width``.\n        :rtype: str\n        ')), Assign(targets=[Name(id='split', ctx=Store())], value=BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0.0), BinOp(left=Call(func=Name(id='float', ctx=Load()), args=[Call(func=Attribute(value=Name(id='width', ctx=Load()), attr='__index__', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Sub(), right=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='length', ctx=Load()), args=[], keywords=[]))], keywords=[]), op=Div(), right=Constant(value=2))), Assign(targets=[Name(id='leftside', ctx=Store())], value=BinOp(left=Name(id='fillchar', ctx=Load()), op=Mult(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0.0), Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='split', ctx=Load())], keywords=[])], keywords=[]), op=Div(), right=Call(func=Name(id='float', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='fillchar', ctx=Load())], keywords=[])], keywords=[]))], keywords=[]))), Assign(targets=[Name(id='rightside', ctx=Store())], value=BinOp(left=Name(id='fillchar', ctx=Load()), op=Mult(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0.0), Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='ceil', ctx=Load()), args=[Name(id='split', ctx=Load())], keywords=[])], keywords=[]), op=Div(), right=Call(func=Name(id='float', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='fillchar', ctx=Load())], keywords=[])], keywords=[]))], keywords=[]))), Return(value=Call(func=Attribute(value=Constant(value='', kind='u'), attr='join', ctx=Load()), args=[Tuple(elts=[Name(id='leftside', ctx=Load()), Name(id='self', ctx=Load()), Name(id='rightside', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='truncate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='width')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Truncate a string in a sequence-aware manner.\n\n        Any printable characters beyond ``width`` are removed, while all\n        sequences remain in place. Horizontal Sequences are first expanded\n        by :meth:`padd`.\n\n        :arg int width: The printable width to truncate the string to.\n        :rtype: str\n        :returns: String truncated to at most ``width`` printable characters.\n        ')), Assign(targets=[Name(id='output', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='current_width', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='target_width', ctx=Store())], value=Call(func=Attribute(value=Name(id='width', ctx=Load()), attr='__index__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='parsed_seq', ctx=Store())], value=Call(func=Name(id='iter_parse', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_term', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='padd', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='text', ctx=Store()), Name(id='cap', ctx=Store())], ctx=Store()), iter=Name(id='parsed_seq', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Name(id='cap', ctx=Load())), body=[AugAssign(target=Name(id='current_width', ctx=Store()), op=Add(), value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='wcwidth', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), Constant(value=0)], keywords=[])), If(test=Compare(left=Name(id='current_width', ctx=Load()), ops=[Gt()], comparators=[Name(id='target_width', ctx=Load())]), body=[Break()], orelse=[])], orelse=[]), AugAssign(target=Name(id='output', ctx=Store()), op=Add(), value=Name(id='text', ctx=Load()))], orelse=[]), Return(value=BinOp(left=Name(id='output', ctx=Load()), op=Add(), right=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=Name(id='text', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='text', ctx=Store()), Name(id='cap', ctx=Store())], ctx=Store()), iter=Name(id='parsed_seq', ctx=Load()), ifs=[Name(id='cap', ctx=Load())], is_async=0)])], keywords=[])))], decorator_list=[]), FunctionDef(name='length', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the printable length of string containing sequences.\n\n        Strings containing ``term.left`` or ``\\b`` will cause "overstrike",\n        but a length less than 0 is not ever returned. So ``_\\b+`` is a\n        length of 1 (displays as ``+``), but ``\\b`` alone is simply a\n        length of 0.\n\n        Some characters may consume more than one cell, mainly those CJK\n        Unified Ideographs (Chinese, Japanese, Korean) defined by Unicode\n        as half or full-width characters.\n\n        For example:\n\n            >>> from blessed import Terminal\n            >>> from blessed.sequences import Sequence\n            >>> term = Terminal()\n            >>> msg = term.clear + term.red(u\'コンニチハ\')\n            >>> Sequence(msg, term).length()\n            10\n\n        .. note:: Although accounted for, strings containing sequences such\n            as ``term.clear`` will not give accurate returns, it is not\n            considered lengthy (a length of 0).\n        ')), Return(value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='wcwidth', ctx=Load()), args=[Name(id='w_char', ctx=Load())], keywords=[]), Constant(value=0)], keywords=[]), generators=[comprehension(target=Name(id='w_char', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='padd', ctx=Load()), args=[], keywords=[keyword(arg='strip', value=Constant(value=True))]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='strip', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='chars')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Return string of sequences, leading and trailing whitespace removed.\n\n        :arg str chars: Remove characters in chars instead of whitespace.\n        :rtype: str\n        :returns: string of sequences with leading and trailing whitespace removed.\n        ')), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='strip_seqs', ctx=Load()), args=[], keywords=[]), attr='strip', ctx=Load()), args=[Name(id='chars', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='lstrip', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='chars')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Return string of all sequences and leading whitespace removed.\n\n        :arg str chars: Remove characters in chars instead of whitespace.\n        :rtype: str\n        :returns: string of sequences with leading removed.\n        ')), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='strip_seqs', ctx=Load()), args=[], keywords=[]), attr='lstrip', ctx=Load()), args=[Name(id='chars', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='rstrip', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='chars')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Return string of all sequences and trailing whitespace removed.\n\n        :arg str chars: Remove characters in chars instead of whitespace.\n        :rtype: str\n        :returns: string of sequences with trailing removed.\n        ')), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='strip_seqs', ctx=Load()), args=[], keywords=[]), attr='rstrip', ctx=Load()), args=[Name(id='chars', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='strip_seqs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return ``text`` stripped of only its terminal sequences.\n\n        :rtype: str\n        :returns: Text with terminal sequences removed\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='padd', ctx=Load()), args=[], keywords=[keyword(arg='strip', value=Constant(value=True))]))], decorator_list=[]), FunctionDef(name='padd', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='strip')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n        Return non-destructive horizontal movement as destructive spacing.\n\n        :arg bool strip: Strip terminal sequences\n        :rtype: str\n        :returns: Text adjusted for horizontal movement\n        ')), Assign(targets=[Name(id='outp', ctx=Store())], value=Constant(value='')), For(target=Tuple(elts=[Name(id='text', ctx=Store()), Name(id='cap', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter_parse', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_term', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='cap', ctx=Load())), body=[AugAssign(target=Name(id='outp', ctx=Store()), op=Add(), value=Name(id='text', ctx=Load())), Continue()], orelse=[]), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='cap', ctx=Load()), attr='horizontal_distance', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[AugAssign(target=Name(id='outp', ctx=Store()), op=Add(), value=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='value', ctx=Load())))], orelse=[If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='outp', ctx=Store())], value=Subscript(value=Name(id='outp', ctx=Load()), slice=Slice(upper=Name(id='value', ctx=Load())), ctx=Load()))], orelse=[If(test=UnaryOp(op=Not(), operand=Name(id='strip', ctx=Load())), body=[AugAssign(target=Name(id='outp', ctx=Store()), op=Add(), value=Name(id='text', ctx=Load()))], orelse=[])])])], orelse=[]), Return(value=Name(id='outp', ctx=Load()))], decorator_list=[])], decorator_list=[]), FunctionDef(name='iter_parse', args=arguments(posonlyargs=[], args=[arg(arg='term'), arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Generator yields (text, capability) for characters of ``text``.\n\n    value for ``capability`` may be ``None``, where ``text`` is\n    :class:`str` of length 1.  Otherwise, ``text`` is a full\n    matching sequence of given capability.\n    ')), For(target=Name(id='match', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='term', ctx=Load()), attr='_caps_compiled_any', ctx=Load()), attr='finditer', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='match', ctx=Load()), attr='lastgroup', ctx=Load())), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='MISMATCH')]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='value', ctx=Load()), Constant(value=None)], ctx=Load())))], orelse=[Expr(value=Yield(value=Tuple(elts=[Name(id='value', ctx=Load()), Subscript(value=Attribute(value=Name(id='term', ctx=Load()), attr='caps', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load())], ctx=Load())))])], orelse=[])], decorator_list=[]), FunctionDef(name='measure_length', args=arguments(posonlyargs=[], args=[arg(arg='text'), arg(arg='term')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    .. deprecated:: 1.12.0.\n\n    :rtype: int\n    :returns: Length of the first sequence in the string\n    ')), Try(body=[Assign(targets=[Tuple(elts=[Name(id='text', ctx=Store()), Name(id='capability', ctx=Store())], ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter_parse', ctx=Load()), args=[Name(id='term', ctx=Load()), Name(id='text', ctx=Load())], keywords=[])], keywords=[])), If(test=Name(id='capability', ctx=Load()), body=[Return(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return(value=Constant(value=0))])], orelse=[], finalbody=[]), Return(value=Constant(value=0))], decorator_list=[])], type_ignores=[])