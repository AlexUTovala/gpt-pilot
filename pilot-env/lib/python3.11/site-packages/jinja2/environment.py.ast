Module(body=[Expr(value=Constant(value='Classes for managing templates and their runtime and compile time\noptions.\n')), Import(names=[alias(name='os')]), Import(names=[alias(name='typing')]), Import(names=[alias(name='typing', asname='t')]), Import(names=[alias(name='weakref')]), ImportFrom(module='collections', names=[alias(name='ChainMap')], level=0), ImportFrom(module='functools', names=[alias(name='lru_cache')], level=0), ImportFrom(module='functools', names=[alias(name='partial')], level=0), ImportFrom(module='functools', names=[alias(name='reduce')], level=0), ImportFrom(module='types', names=[alias(name='CodeType')], level=0), ImportFrom(module='markupsafe', names=[alias(name='Markup')], level=0), ImportFrom(names=[alias(name='nodes')], level=1), ImportFrom(module='compiler', names=[alias(name='CodeGenerator')], level=1), ImportFrom(module='compiler', names=[alias(name='generate')], level=1), ImportFrom(module='defaults', names=[alias(name='BLOCK_END_STRING')], level=1), ImportFrom(module='defaults', names=[alias(name='BLOCK_START_STRING')], level=1), ImportFrom(module='defaults', names=[alias(name='COMMENT_END_STRING')], level=1), ImportFrom(module='defaults', names=[alias(name='COMMENT_START_STRING')], level=1), ImportFrom(module='defaults', names=[alias(name='DEFAULT_FILTERS')], level=1), ImportFrom(module='defaults', names=[alias(name='DEFAULT_NAMESPACE')], level=1), ImportFrom(module='defaults', names=[alias(name='DEFAULT_POLICIES')], level=1), ImportFrom(module='defaults', names=[alias(name='DEFAULT_TESTS')], level=1), ImportFrom(module='defaults', names=[alias(name='KEEP_TRAILING_NEWLINE')], level=1), ImportFrom(module='defaults', names=[alias(name='LINE_COMMENT_PREFIX')], level=1), ImportFrom(module='defaults', names=[alias(name='LINE_STATEMENT_PREFIX')], level=1), ImportFrom(module='defaults', names=[alias(name='LSTRIP_BLOCKS')], level=1), ImportFrom(module='defaults', names=[alias(name='NEWLINE_SEQUENCE')], level=1), ImportFrom(module='defaults', names=[alias(name='TRIM_BLOCKS')], level=1), ImportFrom(module='defaults', names=[alias(name='VARIABLE_END_STRING')], level=1), ImportFrom(module='defaults', names=[alias(name='VARIABLE_START_STRING')], level=1), ImportFrom(module='exceptions', names=[alias(name='TemplateNotFound')], level=1), ImportFrom(module='exceptions', names=[alias(name='TemplateRuntimeError')], level=1), ImportFrom(module='exceptions', names=[alias(name='TemplatesNotFound')], level=1), ImportFrom(module='exceptions', names=[alias(name='TemplateSyntaxError')], level=1), ImportFrom(module='exceptions', names=[alias(name='UndefinedError')], level=1), ImportFrom(module='lexer', names=[alias(name='get_lexer')], level=1), ImportFrom(module='lexer', names=[alias(name='Lexer')], level=1), ImportFrom(module='lexer', names=[alias(name='TokenStream')], level=1), ImportFrom(module='nodes', names=[alias(name='EvalContext')], level=1), ImportFrom(module='parser', names=[alias(name='Parser')], level=1), ImportFrom(module='runtime', names=[alias(name='Context')], level=1), ImportFrom(module='runtime', names=[alias(name='new_context')], level=1), ImportFrom(module='runtime', names=[alias(name='Undefined')], level=1), ImportFrom(module='utils', names=[alias(name='_PassArg')], level=1), ImportFrom(module='utils', names=[alias(name='concat')], level=1), ImportFrom(module='utils', names=[alias(name='consume')], level=1), ImportFrom(module='utils', names=[alias(name='import_string')], level=1), ImportFrom(module='utils', names=[alias(name='internalcode')], level=1), ImportFrom(module='utils', names=[alias(name='LRUCache')], level=1), ImportFrom(module='utils', names=[alias(name='missing')], level=1), If(test=Attribute(value=Name(id='t', ctx=Load()), attr='TYPE_CHECKING', ctx=Load()), body=[Import(names=[alias(name='typing_extensions', asname='te')]), ImportFrom(module='bccache', names=[alias(name='BytecodeCache')], level=1), ImportFrom(module='ext', names=[alias(name='Extension')], level=1), ImportFrom(module='loaders', names=[alias(name='BaseLoader')], level=1)], orelse=[]), Assign(targets=[Name(id='_env_bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='_env_bound')], keywords=[keyword(arg='bound', value=Constant(value='Environment'))])), FunctionDef(name='get_spontaneous_environment', args=arguments(posonlyargs=[], args=[arg(arg='cls', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='_env_bound', ctx=Load()), ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a new spontaneous environment. A spontaneous environment\n    is used for templates created directly rather than through an\n    existing environment.\n\n    :param cls: Environment class to create.\n    :param args: Positional arguments passed to environment.\n    ')), Assign(targets=[Name(id='env', ctx=Store())], value=Call(func=Name(id='cls', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='env', ctx=Load()), attr='shared', ctx=Store())], value=Constant(value=True)), Return(value=Name(id='env', ctx=Load()))], decorator_list=[Call(func=Name(id='lru_cache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=10))])], returns=Name(id='_env_bound', ctx=Load())), FunctionDef(name='create_cache', args=arguments(posonlyargs=[], args=[arg(arg='size', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the cache class for the given size.')), If(test=Compare(left=Name(id='size', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Constant(value=None))], orelse=[]), If(test=Compare(left=Name(id='size', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Return(value=Dict(keys=[], values=[]))], orelse=[]), Return(value=Call(func=Name(id='LRUCache', ctx=Load()), args=[Name(id='size', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='weakref', ctx=Load()), attr='ref', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), Constant(value='Template')], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='copy_cache', args=arguments(posonlyargs=[], args=[arg(arg='cache', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create an empty copy of the given cache.')), If(test=Compare(left=Name(id='cache', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), If(test=Compare(left=Call(func=Name(id='type', ctx=Load()), args=[Name(id='cache', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Name(id='dict', ctx=Load())]), body=[Return(value=Dict(keys=[], values=[]))], orelse=[]), Return(value=Call(func=Name(id='LRUCache', ctx=Load()), args=[Attribute(value=Name(id='cache', ctx=Load()), attr='capacity', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='weakref', ctx=Load()), attr='ref', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), Constant(value='Template')], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='load_extensions', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='extensions', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Sequence', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Constant(value='Extension'), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Load the extensions from the list and bind it to the environment.\n    Returns a dict of instantiated extensions.\n    ')), Assign(targets=[Name(id='result', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='extension', ctx=Store()), iter=Name(id='extensions', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='extension', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='extension', ctx=Store())], value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='cast', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Constant(value='Extension'), ctx=Load()), Call(func=Name(id='import_string', ctx=Load()), args=[Name(id='extension', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='result', ctx=Load()), slice=Attribute(value=Name(id='extension', ctx=Load()), attr='identifier', ctx=Load()), ctx=Store())], value=Call(func=Name(id='extension', ctx=Load()), args=[Name(id='environment', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='Extension')], ctx=Load()), ctx=Load())), FunctionDef(name='_environment_config_check', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Perform a sanity check on the environment.')), Assert(test=Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Name(id='environment', ctx=Load()), attr='undefined', ctx=Load()), Name(id='Undefined', ctx=Load())], keywords=[]), msg=Constant(value="'undefined' must be a subclass of 'jinja2.Undefined'.")), Assert(test=Compare(left=Attribute(value=Name(id='environment', ctx=Load()), attr='block_start_string', ctx=Load()), ops=[NotEq(), NotEq()], comparators=[Attribute(value=Name(id='environment', ctx=Load()), attr='variable_start_string', ctx=Load()), Attribute(value=Name(id='environment', ctx=Load()), attr='comment_start_string', ctx=Load())]), msg=Constant(value='block, variable and comment start strings must be different.')), Assert(test=Compare(left=Attribute(value=Name(id='environment', ctx=Load()), attr='newline_sequence', ctx=Load()), ops=[In()], comparators=[Set(elts=[Constant(value='\r'), Constant(value='\r\n'), Constant(value='\n')])]), msg=Constant(value="'newline_sequence' must be one of '\\n', '\\r\\n', or '\\r'.")), Return(value=Name(id='environment', ctx=Load()))], decorator_list=[], returns=Constant(value='Environment')), ClassDef(name='Environment', bases=[], keywords=[], body=[Expr(value=Constant(value="The core component of Jinja is the `Environment`.  It contains\n    important shared variables like configuration, filters, tests,\n    globals and others.  Instances of this class may be modified if\n    they are not shared and if no template was loaded so far.\n    Modifications on environments after the first template was loaded\n    will lead to surprising effects and undefined behavior.\n\n    Here are the possible initialization parameters:\n\n        `block_start_string`\n            The string marking the beginning of a block.  Defaults to ``'{%'``.\n\n        `block_end_string`\n            The string marking the end of a block.  Defaults to ``'%}'``.\n\n        `variable_start_string`\n            The string marking the beginning of a print statement.\n            Defaults to ``'{{'``.\n\n        `variable_end_string`\n            The string marking the end of a print statement.  Defaults to\n            ``'}}'``.\n\n        `comment_start_string`\n            The string marking the beginning of a comment.  Defaults to ``'{#'``.\n\n        `comment_end_string`\n            The string marking the end of a comment.  Defaults to ``'#}'``.\n\n        `line_statement_prefix`\n            If given and a string, this will be used as prefix for line based\n            statements.  See also :ref:`line-statements`.\n\n        `line_comment_prefix`\n            If given and a string, this will be used as prefix for line based\n            comments.  See also :ref:`line-statements`.\n\n            .. versionadded:: 2.2\n\n        `trim_blocks`\n            If this is set to ``True`` the first newline after a block is\n            removed (block, not variable tag!).  Defaults to `False`.\n\n        `lstrip_blocks`\n            If this is set to ``True`` leading spaces and tabs are stripped\n            from the start of a line to a block.  Defaults to `False`.\n\n        `newline_sequence`\n            The sequence that starts a newline.  Must be one of ``'\\r'``,\n            ``'\\n'`` or ``'\\r\\n'``.  The default is ``'\\n'`` which is a\n            useful default for Linux and OS X systems as well as web\n            applications.\n\n        `keep_trailing_newline`\n            Preserve the trailing newline when rendering templates.\n            The default is ``False``, which causes a single newline,\n            if present, to be stripped from the end of the template.\n\n            .. versionadded:: 2.7\n\n        `extensions`\n            List of Jinja extensions to use.  This can either be import paths\n            as strings or extension classes.  For more information have a\n            look at :ref:`the extensions documentation <jinja-extensions>`.\n\n        `optimized`\n            should the optimizer be enabled?  Default is ``True``.\n\n        `undefined`\n            :class:`Undefined` or a subclass of it that is used to represent\n            undefined values in the template.\n\n        `finalize`\n            A callable that can be used to process the result of a variable\n            expression before it is output.  For example one can convert\n            ``None`` implicitly into an empty string here.\n\n        `autoescape`\n            If set to ``True`` the XML/HTML autoescaping feature is enabled by\n            default.  For more details about autoescaping see\n            :class:`~markupsafe.Markup`.  As of Jinja 2.4 this can also\n            be a callable that is passed the template name and has to\n            return ``True`` or ``False`` depending on autoescape should be\n            enabled by default.\n\n            .. versionchanged:: 2.4\n               `autoescape` can now be a function\n\n        `loader`\n            The template loader for this environment.\n\n        `cache_size`\n            The size of the cache.  Per default this is ``400`` which means\n            that if more than 400 templates are loaded the loader will clean\n            out the least recently used template.  If the cache size is set to\n            ``0`` templates are recompiled all the time, if the cache size is\n            ``-1`` the cache will not be cleaned.\n\n            .. versionchanged:: 2.8\n               The cache size was increased to 400 from a low 50.\n\n        `auto_reload`\n            Some loaders load templates from locations where the template\n            sources may change (ie: file system or database).  If\n            ``auto_reload`` is set to ``True`` (default) every time a template is\n            requested the loader checks if the source changed and if yes, it\n            will reload the template.  For higher performance it's possible to\n            disable that.\n\n        `bytecode_cache`\n            If set to a bytecode cache object, this object will provide a\n            cache for the internal Jinja bytecode so that templates don't\n            have to be parsed if they were not changed.\n\n            See :ref:`bytecode-cache` for more information.\n\n        `enable_async`\n            If set to true this enables async template execution which\n            allows using async functions and generators.\n    ")), Assign(targets=[Name(id='sandboxed', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='overlayed', ctx=Store())], value=Constant(value=False)), AnnAssign(target=Name(id='linked_to', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Constant(value='Environment'), ctx=Load()), value=Constant(value=None), simple=1), Assign(targets=[Name(id='shared', ctx=Store())], value=Constant(value=False)), AnnAssign(target=Name(id='code_generator_class', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Constant(value='CodeGenerator'), ctx=Load()), value=Name(id='CodeGenerator', ctx=Load()), simple=1), Assign(targets=[Name(id='concat', ctx=Store())], value=Attribute(value=Constant(value=''), attr='join', ctx=Load())), AnnAssign(target=Name(id='context_class', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load()), value=Name(id='Context', ctx=Load()), simple=1), AnnAssign(target=Name(id='template_class', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Constant(value='Template'), ctx=Load()), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='block_start_string', annotation=Name(id='str', ctx=Load())), arg(arg='block_end_string', annotation=Name(id='str', ctx=Load())), arg(arg='variable_start_string', annotation=Name(id='str', ctx=Load())), arg(arg='variable_end_string', annotation=Name(id='str', ctx=Load())), arg(arg='comment_start_string', annotation=Name(id='str', ctx=Load())), arg(arg='comment_end_string', annotation=Name(id='str', ctx=Load())), arg(arg='line_statement_prefix', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='line_comment_prefix', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='trim_blocks', annotation=Name(id='bool', ctx=Load())), arg(arg='lstrip_blocks', annotation=Name(id='bool', ctx=Load())), arg(arg='newline_sequence', annotation=Constant(value="te.Literal['\\n', '\\r\\n', '\\r']")), arg(arg='keep_trailing_newline', annotation=Name(id='bool', ctx=Load())), arg(arg='extensions', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Sequence', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Constant(value='Extension'), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='optimized', annotation=Name(id='bool', ctx=Load())), arg(arg='undefined', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='Undefined', ctx=Load()), ctx=Load())), arg(arg='finalize', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='autoescape', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='loader', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Constant(value='BaseLoader'), ctx=Load())), arg(arg='cache_size', annotation=Name(id='int', ctx=Load())), arg(arg='auto_reload', annotation=Name(id='bool', ctx=Load())), arg(arg='bytecode_cache', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Constant(value='BytecodeCache'), ctx=Load())), arg(arg='enable_async', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='BLOCK_START_STRING', ctx=Load()), Name(id='BLOCK_END_STRING', ctx=Load()), Name(id='VARIABLE_START_STRING', ctx=Load()), Name(id='VARIABLE_END_STRING', ctx=Load()), Name(id='COMMENT_START_STRING', ctx=Load()), Name(id='COMMENT_END_STRING', ctx=Load()), Name(id='LINE_STATEMENT_PREFIX', ctx=Load()), Name(id='LINE_COMMENT_PREFIX', ctx=Load()), Name(id='TRIM_BLOCKS', ctx=Load()), Name(id='LSTRIP_BLOCKS', ctx=Load()), Name(id='NEWLINE_SEQUENCE', ctx=Load()), Name(id='KEEP_TRAILING_NEWLINE', ctx=Load()), Tuple(elts=[], ctx=Load()), Constant(value=True), Name(id='Undefined', ctx=Load()), Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=400), Constant(value=True), Constant(value=None), Constant(value=False)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='block_start_string', ctx=Store())], value=Name(id='block_start_string', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='block_end_string', ctx=Store())], value=Name(id='block_end_string', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='variable_start_string', ctx=Store())], value=Name(id='variable_start_string', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='variable_end_string', ctx=Store())], value=Name(id='variable_end_string', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='comment_start_string', ctx=Store())], value=Name(id='comment_start_string', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='comment_end_string', ctx=Store())], value=Name(id='comment_end_string', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='line_statement_prefix', ctx=Store())], value=Name(id='line_statement_prefix', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='line_comment_prefix', ctx=Store())], value=Name(id='line_comment_prefix', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trim_blocks', ctx=Store())], value=Name(id='trim_blocks', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='lstrip_blocks', ctx=Store())], value=Name(id='lstrip_blocks', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='newline_sequence', ctx=Store())], value=Name(id='newline_sequence', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='keep_trailing_newline', ctx=Store())], value=Name(id='keep_trailing_newline', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='undefined', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='Undefined', ctx=Load()), ctx=Load()), value=Name(id='undefined', ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimized', ctx=Store())], value=Name(id='optimized', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='finalize', ctx=Store())], value=Name(id='finalize', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='autoescape', ctx=Store())], value=Name(id='autoescape', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='filters', ctx=Store())], value=Call(func=Attribute(value=Name(id='DEFAULT_FILTERS', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='tests', ctx=Store())], value=Call(func=Attribute(value=Name(id='DEFAULT_TESTS', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='globals', ctx=Store())], value=Call(func=Attribute(value=Name(id='DEFAULT_NAMESPACE', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Store())], value=Name(id='loader', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='cache', ctx=Store())], value=Call(func=Name(id='create_cache', ctx=Load()), args=[Name(id='cache_size', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='bytecode_cache', ctx=Store())], value=Name(id='bytecode_cache', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='auto_reload', ctx=Store())], value=Name(id='auto_reload', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='policies', ctx=Store())], value=Call(func=Attribute(value=Name(id='DEFAULT_POLICIES', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='extensions', ctx=Store())], value=Call(func=Name(id='load_extensions', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='extensions', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='is_async', ctx=Store())], value=Name(id='enable_async', ctx=Load())), Expr(value=Call(func=Name(id='_environment_config_check', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='add_extension', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='extension', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Constant(value='Extension'), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Adds an extension after the environment was created.\n\n        .. versionadded:: 2.5\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='extensions', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Name(id='load_extensions', ctx=Load()), args=[Name(id='self', ctx=Load()), List(elts=[Name(id='extension', ctx=Load())], ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='extend', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='attributes', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Add the items to the instance of the environment if they do not exist\n        yet.  This is used by :ref:`extensions <writing-extensions>` to register\n        callbacks and configuration values without breaking inheritance.\n        ')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='attributes', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='key', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='key', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='overlay', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='block_start_string', annotation=Name(id='str', ctx=Load())), arg(arg='block_end_string', annotation=Name(id='str', ctx=Load())), arg(arg='variable_start_string', annotation=Name(id='str', ctx=Load())), arg(arg='variable_end_string', annotation=Name(id='str', ctx=Load())), arg(arg='comment_start_string', annotation=Name(id='str', ctx=Load())), arg(arg='comment_end_string', annotation=Name(id='str', ctx=Load())), arg(arg='line_statement_prefix', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='line_comment_prefix', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='trim_blocks', annotation=Name(id='bool', ctx=Load())), arg(arg='lstrip_blocks', annotation=Name(id='bool', ctx=Load())), arg(arg='newline_sequence', annotation=Constant(value="te.Literal['\\n', '\\r\\n', '\\r']")), arg(arg='keep_trailing_newline', annotation=Name(id='bool', ctx=Load())), arg(arg='extensions', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Sequence', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Constant(value='Extension'), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='optimized', annotation=Name(id='bool', ctx=Load())), arg(arg='undefined', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='Undefined', ctx=Load()), ctx=Load())), arg(arg='finalize', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='autoescape', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='loader', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Constant(value='BaseLoader'), ctx=Load())), arg(arg='cache_size', annotation=Name(id='int', ctx=Load())), arg(arg='auto_reload', annotation=Name(id='bool', ctx=Load())), arg(arg='bytecode_cache', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Constant(value='BytecodeCache'), ctx=Load())), arg(arg='enable_async', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Name(id='missing', ctx=Load()), Constant(value=False)]), body=[Expr(value=Constant(value='Create a new overlay environment that shares all the data with the\n        current environment except for cache and the overridden attributes.\n        Extensions cannot be removed for an overlayed environment.  An overlayed\n        environment automatically gets all the extensions of the environment it\n        is linked to plus optional extra extensions.\n\n        Creating overlays should happen after the initial environment was set\n        up completely.  Not all attributes are truly linked, some are just\n        copied over so modifications on the original environment may not shine\n        through.\n\n        .. versionchanged:: 3.1.2\n            Added the ``newline_sequence``,, ``keep_trailing_newline``,\n            and ``enable_async`` parameters to match ``__init__``.\n        ')), Assign(targets=[Name(id='args', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[])], keywords=[])), Delete(targets=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value='self'), ctx=Del()), Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value='cache_size'), ctx=Del()), Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value='extensions'), ctx=Del()), Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value='enable_async'), ctx=Del())]), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__new__', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='rv', ctx=Load()), attr='__dict__', ctx=Load()), attr='update', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='rv', ctx=Load()), attr='overlayed', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='rv', ctx=Load()), attr='linked_to', ctx=Store())], value=Name(id='self', ctx=Load())), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='args', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Name(id='missing', ctx=Load())]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='rv', ctx=Load()), Name(id='key', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='cache_size', ctx=Load()), ops=[IsNot()], comparators=[Name(id='missing', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='rv', ctx=Load()), attr='cache', ctx=Store())], value=Call(func=Name(id='create_cache', ctx=Load()), args=[Name(id='cache_size', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='rv', ctx=Load()), attr='cache', ctx=Store())], value=Call(func=Name(id='copy_cache', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='cache', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='rv', ctx=Load()), attr='extensions', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='extensions', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='rv', ctx=Load()), attr='extensions', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='bind', ctx=Load()), args=[Name(id='rv', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='extensions', ctx=Load()), ops=[IsNot()], comparators=[Name(id='missing', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='rv', ctx=Load()), attr='extensions', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Name(id='load_extensions', ctx=Load()), args=[Name(id='rv', ctx=Load()), Name(id='extensions', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='enable_async', ctx=Load()), ops=[IsNot()], comparators=[Name(id='missing', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='rv', ctx=Load()), attr='is_async', ctx=Store())], value=Name(id='enable_async', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='_environment_config_check', ctx=Load()), args=[Name(id='rv', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='Environment')), FunctionDef(name='lexer', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The lexer for this environment.')), Return(value=Call(func=Name(id='get_lexer', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Lexer', ctx=Load())), FunctionDef(name='iter_extensions', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterates over the extensions by priority.')), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='extensions', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Attribute(value=Name(id='x', ctx=Load()), attr='priority', ctx=Load())))])], keywords=[]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Constant(value='Extension'), ctx=Load())), FunctionDef(name='getitem', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), arg(arg='argument', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get an item or attribute of an object but prefer the item.')), Try(body=[Return(value=Subscript(value=Name(id='obj', ctx=Load()), slice=Name(id='argument', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='TypeError', ctx=Load()), Name(id='LookupError', ctx=Load())], ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='argument', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Try(body=[Assign(targets=[Name(id='attr', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='argument', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Pass()])], orelse=[Try(body=[Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], finalbody=[])], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='undefined', ctx=Load()), args=[], keywords=[keyword(arg='obj', value=Name(id='obj', ctx=Load())), keyword(arg='name', value=Name(id='argument', ctx=Load()))]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), Name(id='Undefined', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='getattr', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), arg(arg='attribute', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get an item or attribute of an object but prefer the attribute.\n        Unlike :meth:`getitem` the attribute *must* be a string.\n        ')), Try(body=[Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Try(body=[Return(value=Subscript(value=Name(id='obj', ctx=Load()), slice=Name(id='attribute', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TypeError', ctx=Load()), Name(id='LookupError', ctx=Load()), Name(id='AttributeError', ctx=Load())], ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='undefined', ctx=Load()), args=[], keywords=[keyword(arg='obj', value=Name(id='obj', ctx=Load())), keyword(arg='name', value=Name(id='attribute', ctx=Load()))]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), FunctionDef(name='_filter_test_common', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Undefined', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), arg(arg='args', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Sequence', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load())), arg(arg='is_filter', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Name(id='is_filter', ctx=Load()), body=[Assign(targets=[Name(id='env_map', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='filters', ctx=Load())), Assign(targets=[Name(id='type_name', ctx=Store())], value=Constant(value='filter'))], orelse=[Assign(targets=[Name(id='env_map', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='tests', ctx=Load())), Assign(targets=[Name(id='type_name', ctx=Store())], value=Constant(value='test'))]), Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Attribute(value=Name(id='env_map', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='func', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='No '), FormattedValue(value=Name(id='type_name', ctx=Load()), conversion=-1), Constant(value=' named '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=114), Constant(value='.')])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='Undefined', ctx=Load())], keywords=[]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='_fail_with_undefined_error', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='msg', ctx=Load()), conversion=-1), Constant(value=' ('), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1), Constant(value='; did you forget to quote the callable name?)')]))])], orelse=[], finalbody=[])], orelse=[]), Raise(exc=Call(func=Name(id='TemplateRuntimeError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='args', ctx=Store())], value=List(elts=[Name(id='value', ctx=Load()), Starred(value=IfExp(test=Compare(left=Name(id='args', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='args', ctx=Load()), orelse=Tuple(elts=[], ctx=Load())), ctx=Load())], ctx=Load())), Assign(targets=[Name(id='kwargs', ctx=Store())], value=IfExp(test=Compare(left=Name(id='kwargs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='kwargs', ctx=Load()), orelse=Dict(keys=[], values=[]))), Assign(targets=[Name(id='pass_arg', ctx=Store())], value=Call(func=Attribute(value=Name(id='_PassArg', ctx=Load()), attr='from_obj', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='pass_arg', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='_PassArg', ctx=Load()), attr='context', ctx=Load())]), body=[If(test=Compare(left=Name(id='context', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TemplateRuntimeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Attempted to invoke a context '), FormattedValue(value=Name(id='type_name', ctx=Load()), conversion=-1), Constant(value=' without context.')])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='args', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Name(id='context', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='pass_arg', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='_PassArg', ctx=Load()), attr='eval_context', ctx=Load())]), body=[If(test=Compare(left=Name(id='eval_ctx', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='context', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Attribute(value=Name(id='context', ctx=Load()), attr='eval_ctx', ctx=Load()))], orelse=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='EvalContext', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='args', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Name(id='eval_ctx', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='pass_arg', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='_PassArg', ctx=Load()), attr='environment', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='args', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Name(id='self', ctx=Load())], keywords=[]))], orelse=[])])]), Return(value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), FunctionDef(name='call_filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), arg(arg='args', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Sequence', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Invoke a filter on a value the same way the compiler does.\n\n        This might return a coroutine if the filter is running from an\n        environment in async mode and the filter supports async\n        execution. It's your responsibility to await this if needed.\n\n        .. versionadded:: 2.7\n        ")), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_filter_test_common', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Name(id='context', ctx=Load()), Name(id='eval_ctx', ctx=Load()), Constant(value=True)], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), FunctionDef(name='call_test', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), arg(arg='args', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Sequence', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load())), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Invoke a test on a value the same way the compiler does.\n\n        This might return a coroutine if the test is running from an\n        environment in async mode and the test supports async execution.\n        It's your responsibility to await this if needed.\n\n        .. versionchanged:: 3.0\n            Tests support ``@pass_context``, etc. decorators. Added\n            the ``context`` and ``eval_ctx`` parameters.\n\n        .. versionadded:: 2.7\n        ")), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_filter_test_common', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Name(id='context', ctx=Load()), Name(id='eval_ctx', ctx=Load()), Constant(value=False)], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), FunctionDef(name='parse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load())), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='filename', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Parse the sourcecode and return the abstract syntax tree.  This\n        tree of nodes is used by the compiler to convert the template into\n        executable source- or bytecode.  This is useful for debugging or to\n        extract information from templates.\n\n        If you are :ref:`developing Jinja extensions <writing-extensions>`\n        this gives you a good overview of the node tree generated.\n        ')), Try(body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TemplateSyntaxError', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='handle_exception', ctx=Load()), args=[], keywords=[keyword(arg='source', value=Name(id='source', ctx=Load()))]))])], orelse=[], finalbody=[])], decorator_list=[Name(id='internalcode', ctx=Load())], returns=Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load())), FunctionDef(name='_parse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load())), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='filename', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Internal parsing function used by `parse` and `compile`.')), Return(value=Call(func=Attribute(value=Call(func=Name(id='Parser', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='source', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[]), attr='parse', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load())), FunctionDef(name='lex', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load())), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='filename', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Lex the given sourcecode and return a generator that yields\n        tokens as tuples in the form ``(lineno, token_type, value)``.\n        This can be useful for :ref:`extension development <writing-extensions>`\n        and debugging templates.\n\n        This does not perform preprocessing.  If you want the preprocessing\n        of the extensions to be applied you have to filter source through\n        the :meth:`preprocess` method.\n        ')), Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])), Try(body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='lexer', ctx=Load()), attr='tokeniter', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TemplateSyntaxError', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='handle_exception', ctx=Load()), args=[], keywords=[keyword(arg='source', value=Name(id='source', ctx=Load()))]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='preprocess', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load())), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='filename', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Preprocesses the source with all extensions.  This is automatically\n        called for all parsing and compiling methods but *not* for :meth:`lex`\n        because there you usually only want the actual source tokenized.\n        ')), Return(value=Call(func=Name(id='reduce', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='e')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='preprocess', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[])), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iter_extensions', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='str', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_tokenize', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load())), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='filename', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='state', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Called by the parser to do the preprocessing and filtering\n        for all the extensions.  Returns a :class:`~jinja2.lexer.TokenStream`.\n        ')), Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='preprocess', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[])), Assign(targets=[Name(id='stream', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='lexer', ctx=Load()), attr='tokenize', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load()), Name(id='state', ctx=Load())], keywords=[])), For(target=Name(id='ext', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iter_extensions', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='stream', ctx=Store())], value=Call(func=Attribute(value=Name(id='ext', ctx=Load()), attr='filter_stream', ctx=Load()), args=[Name(id='stream', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='stream', ctx=Load()), Name(id='TokenStream', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='stream', ctx=Store())], value=Call(func=Name(id='TokenStream', ctx=Load()), args=[Name(id='stream', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='stream', ctx=Load()))], decorator_list=[], returns=Name(id='TokenStream', ctx=Load())), FunctionDef(name='_generate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load())), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='filename', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='defer_init', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Internal hook that can be overridden to hook a different generate\n        method in.\n\n        .. versionadded:: 2.5\n        ')), Return(value=Call(func=Name(id='generate', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='self', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[keyword(arg='defer_init', value=Name(id='defer_init', ctx=Load())), keyword(arg='optimized', value=Attribute(value=Name(id='self', ctx=Load()), attr='optimized', ctx=Load()))]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_compile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load())), arg(arg='filename', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Internal hook that can be overridden to hook a different compile\n        method in.\n\n        .. versionadded:: 2.5\n        ')), Return(value=Call(func=Name(id='compile', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='filename', ctx=Load()), Constant(value='exec')], keywords=[]))], decorator_list=[], returns=Name(id='CodeType', ctx=Load())), FunctionDef(name='compile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='filename', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='raw', annotation=Constant(value='te.Literal[False]')), arg(arg='defer_init', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())], returns=Name(id='CodeType', ctx=Load())), FunctionDef(name='compile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='filename', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='raw', annotation=Constant(value='te.Literal[True]')), arg(arg='defer_init', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=Ellipsis), Constant(value=False)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='compile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='filename', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='raw', annotation=Name(id='bool', ctx=Load())), arg(arg='defer_init', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value='Compile a node or template source code.  The `name` parameter is\n        the load name of the template after it was joined using\n        :meth:`join_path` if necessary, not the filename on the file system.\n        the `filename` parameter is the estimated filename of the template on\n        the file system.  If the template came from a database or memory this\n        can be omitted.\n\n        The return value of this method is a python code object.  If the `raw`\n        parameter is `True` the return value will be a string with python\n        code equivalent to the bytecode returned otherwise.  This method is\n        mainly used internally.\n\n        `defer_init` is use internally to aid the module code generator.  This\n        causes the generated code to be able to import without the global\n        environment variable to be set.\n\n        .. versionadded:: 2.4\n           `defer_init` parameter added.\n        ')), Assign(targets=[Name(id='source_hint', ctx=Store())], value=Constant(value=None)), Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='source_hint', ctx=Store())], value=Name(id='source', ctx=Load())), Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_generate', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[keyword(arg='defer_init', value=Name(id='defer_init', ctx=Load()))])), If(test=Name(id='raw', ctx=Load()), body=[Return(value=Name(id='source', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='filename', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='filename', ctx=Store())], value=Constant(value='<template>'))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compile', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TemplateSyntaxError', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='handle_exception', ctx=Load()), args=[], keywords=[keyword(arg='source', value=Name(id='source_hint', ctx=Load()))]))])], orelse=[], finalbody=[])], decorator_list=[Name(id='internalcode', ctx=Load())], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='CodeType', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='compile_expression', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load())), arg(arg='undefined_to_none', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='A handy helper method that returns a callable that accepts keyword\n        arguments that appear as variables in the expression.  If called it\n        returns the result of the expression.\n\n        This is useful if applications want to use the same rules as Jinja\n        in template "configuration files" or similar situations.\n\n        Example usage:\n\n        >>> env = Environment()\n        >>> expr = env.compile_expression(\'foo == 42\')\n        >>> expr(foo=23)\n        False\n        >>> expr(foo=42)\n        True\n\n        Per default the return value is converted to `None` if the\n        expression returns an undefined value.  This can be changed\n        by setting `undefined_to_none` to `False`.\n\n        >>> env.compile_expression(\'var\')() is None\n        True\n        >>> env.compile_expression(\'var\', undefined_to_none=False)()\n        Undefined\n\n        .. versionadded:: 2.1\n        ')), Assign(targets=[Name(id='parser', ctx=Store())], value=Call(func=Name(id='Parser', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='source', ctx=Load())], keywords=[keyword(arg='state', value=Constant(value='variable'))])), Try(body=[Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='parse_expression', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='parser', ctx=Load()), attr='stream', ctx=Load()), attr='eos', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TemplateSyntaxError', ctx=Load()), args=[Constant(value='chunk after expression'), Attribute(value=Attribute(value=Attribute(value=Name(id='parser', ctx=Load()), attr='stream', ctx=Load()), attr='current', ctx=Load()), attr='lineno', ctx=Load()), Constant(value=None), Constant(value=None)], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='expr', ctx=Load()), attr='set_environment', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TemplateSyntaxError', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='handle_exception', ctx=Load()), args=[], keywords=[keyword(arg='source', value=Name(id='source', ctx=Load()))]))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='body', ctx=Store())], value=List(elts=[Call(func=Attribute(value=Name(id='nodes', ctx=Load()), attr='Assign', ctx=Load()), args=[Call(func=Attribute(value=Name(id='nodes', ctx=Load()), attr='Name', ctx=Load()), args=[Constant(value='result'), Constant(value='store')], keywords=[]), Name(id='expr', ctx=Load())], keywords=[keyword(arg='lineno', value=Constant(value=1))])], ctx=Load())), Assign(targets=[Name(id='template', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='from_string', ctx=Load()), args=[Call(func=Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load()), args=[Name(id='body', ctx=Load())], keywords=[keyword(arg='lineno', value=Constant(value=1))])], keywords=[])), Return(value=Call(func=Name(id='TemplateExpression', ctx=Load()), args=[Name(id='template', ctx=Load()), Name(id='undefined_to_none', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='TemplateExpression')), FunctionDef(name='compile_templates', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='target', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='PathLike', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='extensions', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Collection', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='filter_func', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='zip', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='log_function', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='ignore_errors', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value='deflated'), Constant(value=None), Constant(value=True)]), body=[Expr(value=Constant(value="Finds all the templates the loader can find, compiles them\n        and stores them in `target`.  If `zip` is `None`, instead of in a\n        zipfile, the templates will be stored in a directory.\n        By default a deflate zip algorithm is used. To switch to\n        the stored algorithm, `zip` can be set to ``'stored'``.\n\n        `extensions` and `filter_func` are passed to :meth:`list_templates`.\n        Each template returned will be compiled to the target folder or\n        zipfile.\n\n        By default template compilation errors are ignored.  In case a\n        log function is provided, errors are logged.  If you want template\n        syntax errors to abort the compilation you can set `ignore_errors`\n        to `False` and you will get an exception on syntax errors.\n\n        .. versionadded:: 2.4\n        ")), ImportFrom(module='loaders', names=[alias(name='ModuleLoader')], level=1), If(test=Compare(left=Name(id='log_function', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[FunctionDef(name='log_function', args=arguments(posonlyargs=[], args=[arg(arg='x', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[], returns=Constant(value=None))], orelse=[]), Assert(test=Compare(left=Name(id='log_function', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), msg=Constant(value='No loader configured.')), FunctionDef(name='write_file', args=arguments(posonlyargs=[], args=[arg(arg='filename', annotation=Name(id='str', ctx=Load())), arg(arg='data', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Name(id='zip', ctx=Load()), body=[Assign(targets=[Name(id='info', ctx=Store())], value=Call(func=Name(id='ZipInfo', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='info', ctx=Load()), attr='external_attr', ctx=Store())], value=BinOp(left=Constant(value=493), op=LShift(), right=Constant(value=16))), Expr(value=Call(func=Attribute(value=Name(id='zip_file', ctx=Load()), attr='writestr', ctx=Load()), args=[Name(id='info', ctx=Load()), Name(id='data', ctx=Load())], keywords=[]))], orelse=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[]), Constant(value='wb')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='encode', ctx=Load()), args=[Constant(value='utf8')], keywords=[])], keywords=[]))])])], decorator_list=[], returns=Constant(value=None)), If(test=Compare(left=Name(id='zip', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[ImportFrom(module='zipfile', names=[alias(name='ZipFile'), alias(name='ZipInfo'), alias(name='ZIP_DEFLATED'), alias(name='ZIP_STORED')], level=0), Assign(targets=[Name(id='zip_file', ctx=Store())], value=Call(func=Name(id='ZipFile', ctx=Load()), args=[Name(id='target', ctx=Load()), Constant(value='w'), Subscript(value=Call(func=Name(id='dict', ctx=Load()), args=[], keywords=[keyword(arg='deflated', value=Name(id='ZIP_DEFLATED', ctx=Load())), keyword(arg='stored', value=Name(id='ZIP_STORED', ctx=Load()))]), slice=Name(id='zip', ctx=Load()), ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='log_function', ctx=Load()), args=[JoinedStr(values=[Constant(value='Compiling into Zip archive '), FormattedValue(value=Name(id='target', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='target', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='makedirs', ctx=Load()), args=[Name(id='target', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='log_function', ctx=Load()), args=[JoinedStr(values=[Constant(value='Compiling into folder '), FormattedValue(value=Name(id='target', ctx=Load()), conversion=114)])], keywords=[]))]), Try(body=[For(target=Name(id='name', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='list_templates', ctx=Load()), args=[Name(id='extensions', ctx=Load()), Name(id='filter_func', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='source', ctx=Store()), Name(id='filename', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), attr='get_source', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='code', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='name', ctx=Load()), Name(id='filename', ctx=Load()), Constant(value=True), Constant(value=True)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TemplateSyntaxError', ctx=Load()), name='e', body=[If(test=UnaryOp(op=Not(), operand=Name(id='ignore_errors', ctx=Load())), body=[Raise()], orelse=[]), Expr(value=Call(func=Name(id='log_function', ctx=Load()), args=[JoinedStr(values=[Constant(value='Could not compile "'), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='": '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Continue()])], orelse=[], finalbody=[]), Assign(targets=[Name(id='filename', ctx=Store())], value=Call(func=Attribute(value=Name(id='ModuleLoader', ctx=Load()), attr='get_module_filename', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='write_file', ctx=Load()), args=[Name(id='filename', ctx=Load()), Name(id='code', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='log_function', ctx=Load()), args=[JoinedStr(values=[Constant(value='Compiled "'), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='" as '), FormattedValue(value=Name(id='filename', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], handlers=[], orelse=[], finalbody=[If(test=Name(id='zip', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='zip_file', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[])]), Expr(value=Call(func=Name(id='log_function', ctx=Load()), args=[Constant(value='Finished compiling templates')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='list_templates', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='extensions', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Collection', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='filter_func', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Returns a list of templates for this environment.  This requires\n        that the loader supports the loader's\n        :meth:`~BaseLoader.list_templates` method.\n\n        If there are other files in the template folder besides the\n        actual templates, the returned list can be filtered.  There are two\n        ways: either `extensions` is set to a list of file extensions for\n        templates, or a `filter_func` can be provided which is a callable that\n        is passed a template name and should return `True` if it should end up\n        in the result list.\n\n        If the loader does not support that, a :exc:`TypeError` is raised.\n\n        .. versionadded:: 2.4\n        ")), Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), msg=Constant(value='No loader configured.')), Assign(targets=[Name(id='names', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), attr='list_templates', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='extensions', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='filter_func', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='either extensions or filter_func can be passed, but not both')], keywords=[]))], orelse=[]), FunctionDef(name='filter_func', args=arguments(posonlyargs=[], args=[arg(arg='x', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Compare(left=Constant(value='.'), ops=[In()], comparators=[Name(id='x', ctx=Load())]), Compare(left=Subscript(value=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[]), slice=Constant(value=1), ctx=Load()), ops=[In()], comparators=[Name(id='extensions', ctx=Load())])]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='filter_func', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='names', ctx=Store())], value=ListComp(elt=Name(id='name', ctx=Load()), generators=[comprehension(target=Name(id='name', ctx=Store()), iter=Name(id='names', ctx=Load()), ifs=[Call(func=Name(id='filter_func', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])], is_async=0)]))], orelse=[]), Return(value=Name(id='names', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='handle_exception', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Exception handling helper.  This is used internally to either raise\n        rewritten exceptions or return a rendered traceback for the template.\n        ')), ImportFrom(module='debug', names=[alias(name='rewrite_traceback_stack')], level=1), Raise(exc=Call(func=Name(id='rewrite_traceback_stack', ctx=Load()), args=[], keywords=[keyword(arg='source', value=Name(id='source', ctx=Load()))]))], decorator_list=[], returns=Constant(value='te.NoReturn')), FunctionDef(name='join_path', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='template', annotation=Name(id='str', ctx=Load())), arg(arg='parent', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Join a template with the parent.  By default all the lookups are\n        relative to the loader root so this method returns the `template`\n        parameter unchanged, but if the paths should be relative to the\n        parent template, this function can be used to calculate the real\n        template name.\n\n        Subclasses may override this method and implement template path\n        joining here.\n        ')), Return(value=Name(id='template', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_load_template', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='globals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='no loader for this environment specified')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='cache_key', ctx=Store())], value=Tuple(elts=[Call(func=Attribute(value=Name(id='weakref', ctx=Load()), attr='ref', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load())], keywords=[]), Name(id='name', ctx=Load())], ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='cache', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='template', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='cache', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='cache_key', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='template', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='auto_reload', ctx=Load())), Attribute(value=Name(id='template', ctx=Load()), attr='is_up_to_date', ctx=Load())])]), body=[If(test=Name(id='globals', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='template', ctx=Load()), attr='globals', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='globals', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='template', ctx=Load()))], orelse=[])], orelse=[]), Assign(targets=[Name(id='template', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loader', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_globals', ctx=Load()), args=[Name(id='globals', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='cache', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='cache', ctx=Load()), slice=Name(id='cache_key', ctx=Load()), ctx=Store())], value=Name(id='template', ctx=Load()))], orelse=[]), Return(value=Name(id='template', ctx=Load()))], decorator_list=[Name(id='internalcode', ctx=Load())], returns=Constant(value='Template')), FunctionDef(name='get_template', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='Template')], ctx=Load()), ctx=Load())), arg(arg='parent', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='globals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Load a template by name with :attr:`loader` and return a\n        :class:`Template`. If the template does not exist a\n        :exc:`TemplateNotFound` exception is raised.\n\n        :param name: Name of the template to load. When loading\n            templates from the filesystem, "/" is used as the path\n            separator, even on Windows.\n        :param parent: The name of the parent template importing this\n            template. :meth:`join_path` can be used to implement name\n            transformations with this.\n        :param globals: Extend the environment :attr:`globals` with\n            these extra variables available for all renders of this\n            template. If the template has already been loaded and\n            cached, its globals are updated with any new items.\n\n        .. versionchanged:: 3.0\n            If a template is loaded from cache, ``globals`` will update\n            the template\'s globals instead of ignoring the new values.\n\n        .. versionchanged:: 2.4\n            If ``name`` is a :class:`Template` object it is returned\n            unchanged.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='Template', ctx=Load())], keywords=[]), body=[Return(value=Name(id='name', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='join_path', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='parent', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_load_template', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='globals', ctx=Load())], keywords=[]))], decorator_list=[Name(id='internalcode', ctx=Load())], returns=Constant(value='Template')), FunctionDef(name='select_template', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='names', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='Template')], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='parent', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='globals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Like :meth:`get_template`, but tries loading multiple names.\n        If none of the names can be loaded a :exc:`TemplatesNotFound`\n        exception is raised.\n\n        :param names: List of template names to try loading in order.\n        :param parent: The name of the parent template importing this\n            template. :meth:`join_path` can be used to implement name\n            transformations with this.\n        :param globals: Extend the environment :attr:`globals` with\n            these extra variables available for all renders of this\n            template. If the template has already been loaded and\n            cached, its globals are updated with any new items.\n\n        .. versionchanged:: 3.0\n            If a template is loaded from cache, ``globals`` will update\n            the template's globals instead of ignoring the new values.\n\n        .. versionchanged:: 2.11\n            If ``names`` is :class:`Undefined`, an :exc:`UndefinedError`\n            is raised instead. If no templates were found and ``names``\n            contains :class:`Undefined`, the message is more helpful.\n\n        .. versionchanged:: 2.4\n            If ``names`` contains a :class:`Template` object it is\n            returned unchanged.\n\n        .. versionadded:: 2.3\n        ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='names', ctx=Load()), Name(id='Undefined', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='names', ctx=Load()), attr='_fail_with_undefined_error', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='names', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TemplatesNotFound', ctx=Load()), args=[], keywords=[keyword(arg='message', value=Constant(value='Tried to select from an empty list of templates.'))]))], orelse=[]), For(target=Name(id='name', ctx=Store()), iter=Name(id='names', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='Template', ctx=Load())], keywords=[]), body=[Return(value=Name(id='name', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='join_path', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='parent', ctx=Load())], keywords=[]))], orelse=[]), Try(body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_load_template', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='globals', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TemplateNotFound', ctx=Load()), Name(id='UndefinedError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Raise(exc=Call(func=Name(id='TemplatesNotFound', ctx=Load()), args=[Name(id='names', ctx=Load())], keywords=[]))], decorator_list=[Name(id='internalcode', ctx=Load())], returns=Constant(value='Template')), FunctionDef(name='get_or_select_template', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='template_name_or_list', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='Template'), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='Template')], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='parent', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='globals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Use :meth:`select_template` if an iterable of template names\n        is given, or :meth:`get_template` if one name is given.\n\n        .. versionadded:: 2.3\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='template_name_or_list', ctx=Load()), Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Undefined', ctx=Load())], ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_template', ctx=Load()), args=[Name(id='template_name_or_list', ctx=Load()), Name(id='parent', ctx=Load()), Name(id='globals', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='template_name_or_list', ctx=Load()), Name(id='Template', ctx=Load())], keywords=[]), body=[Return(value=Name(id='template_name_or_list', ctx=Load()))], orelse=[])]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='select_template', ctx=Load()), args=[Name(id='template_name_or_list', ctx=Load()), Name(id='parent', ctx=Load()), Name(id='globals', ctx=Load())], keywords=[]))], decorator_list=[Name(id='internalcode', ctx=Load())], returns=Constant(value='Template')), FunctionDef(name='from_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='globals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='template_class', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Constant(value='Template'), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Load a template from a source string without using\n        :attr:`loader`.\n\n        :param source: Jinja source to compile into a template.\n        :param globals: Extend the environment :attr:`globals` with\n            these extra variables available for all renders of this\n            template. If the template has already been loaded and\n            cached, its globals are updated with any new items.\n        :param template_class: Return an instance of this\n            :class:`Template` class.\n        ')), Assign(targets=[Name(id='gs', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_globals', ctx=Load()), args=[Name(id='globals', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cls', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='template_class', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='template_class', ctx=Load())])), Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='from_code', ctx=Load()), args=[Name(id='self', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[]), Name(id='gs', ctx=Load()), Constant(value=None)], keywords=[]))], decorator_list=[], returns=Constant(value='Template')), FunctionDef(name='make_globals', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='d', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Make the globals map for a template. Any given template\n        globals overlay the environment :attr:`globals`.\n\n        Returns a :class:`collections.ChainMap`. This allows any changes\n        to a template's globals to only affect that template, while\n        changes to the environment's globals are still reflected.\n        However, avoid modifying any globals after a template is loaded.\n\n        :param d: Dict of template-specific globals.\n\n        .. versionchanged:: 3.0\n            Use :class:`collections.ChainMap` to always prevent mutating\n            environment globals.\n        ")), If(test=Compare(left=Name(id='d', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='d', ctx=Store())], value=Dict(keys=[], values=[]))], orelse=[]), Return(value=Call(func=Name(id='ChainMap', ctx=Load()), args=[Name(id='d', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='globals', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='Template', bases=[], keywords=[], body=[Expr(value=Constant(value='A compiled template that can be rendered.\n\n    Use the methods on :class:`Environment` to create or load templates.\n    The environment is used to configure how templates are compiled and\n    behave.\n\n    It is also possible to create a template object directly. This is\n    not usually recommended. The constructor takes most of the same\n    arguments as :class:`Environment`. All templates created with the\n    same environment arguments share the same ephemeral ``Environment``\n    instance behind the scenes.\n\n    A template object should be considered immutable. Modifications on\n    the object are not supported.\n    ')), AnnAssign(target=Name(id='environment_class', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='Environment', ctx=Load()), ctx=Load()), value=Name(id='Environment', ctx=Load()), simple=1), AnnAssign(target=Name(id='environment', ctx=Store()), annotation=Name(id='Environment', ctx=Load()), simple=1), AnnAssign(target=Name(id='globals', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='filename', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='blocks', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Context', ctx=Load())], ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='root_render_func', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Context', ctx=Load())], ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Constant(value='TemplateModule'), ctx=Load()), simple=1), AnnAssign(target=Name(id='_debug_info', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='_uptodate', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='source', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='block_start_string', annotation=Name(id='str', ctx=Load())), arg(arg='block_end_string', annotation=Name(id='str', ctx=Load())), arg(arg='variable_start_string', annotation=Name(id='str', ctx=Load())), arg(arg='variable_end_string', annotation=Name(id='str', ctx=Load())), arg(arg='comment_start_string', annotation=Name(id='str', ctx=Load())), arg(arg='comment_end_string', annotation=Name(id='str', ctx=Load())), arg(arg='line_statement_prefix', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='line_comment_prefix', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='trim_blocks', annotation=Name(id='bool', ctx=Load())), arg(arg='lstrip_blocks', annotation=Name(id='bool', ctx=Load())), arg(arg='newline_sequence', annotation=Constant(value="te.Literal['\\n', '\\r\\n', '\\r']")), arg(arg='keep_trailing_newline', annotation=Name(id='bool', ctx=Load())), arg(arg='extensions', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Sequence', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Constant(value='Extension'), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='optimized', annotation=Name(id='bool', ctx=Load())), arg(arg='undefined', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='Undefined', ctx=Load()), ctx=Load())), arg(arg='finalize', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='autoescape', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='enable_async', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='BLOCK_START_STRING', ctx=Load()), Name(id='BLOCK_END_STRING', ctx=Load()), Name(id='VARIABLE_START_STRING', ctx=Load()), Name(id='VARIABLE_END_STRING', ctx=Load()), Name(id='COMMENT_START_STRING', ctx=Load()), Name(id='COMMENT_END_STRING', ctx=Load()), Name(id='LINE_STATEMENT_PREFIX', ctx=Load()), Name(id='LINE_COMMENT_PREFIX', ctx=Load()), Name(id='TRIM_BLOCKS', ctx=Load()), Name(id='LSTRIP_BLOCKS', ctx=Load()), Name(id='NEWLINE_SEQUENCE', ctx=Load()), Name(id='KEEP_TRAILING_NEWLINE', ctx=Load()), Tuple(elts=[], ctx=Load()), Constant(value=True), Name(id='Undefined', ctx=Load()), Constant(value=None), Constant(value=False), Constant(value=False)]), body=[Assign(targets=[Name(id='env', ctx=Store())], value=Call(func=Name(id='get_spontaneous_environment', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='environment_class', ctx=Load()), Name(id='block_start_string', ctx=Load()), Name(id='block_end_string', ctx=Load()), Name(id='variable_start_string', ctx=Load()), Name(id='variable_end_string', ctx=Load()), Name(id='comment_start_string', ctx=Load()), Name(id='comment_end_string', ctx=Load()), Name(id='line_statement_prefix', ctx=Load()), Name(id='line_comment_prefix', ctx=Load()), Name(id='trim_blocks', ctx=Load()), Name(id='lstrip_blocks', ctx=Load()), Name(id='newline_sequence', ctx=Load()), Name(id='keep_trailing_newline', ctx=Load()), Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='extensions', ctx=Load())], keywords=[]), Name(id='optimized', ctx=Load()), Name(id='undefined', ctx=Load()), Name(id='finalize', ctx=Load()), Name(id='autoescape', ctx=Load()), Constant(value=None), Constant(value=0), Constant(value=False), Constant(value=None), Name(id='enable_async', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='env', ctx=Load()), attr='from_string', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[keyword(arg='template_class', value=Name(id='cls', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), FunctionDef(name='from_code', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='environment', annotation=Name(id='Environment', ctx=Load())), arg(arg='code', annotation=Name(id='CodeType', ctx=Load())), arg(arg='globals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='uptodate', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Creates a template object from compiled code and the globals.  This\n        is used by the loaders and environment to create a template object.\n        ')), Assign(targets=[Name(id='namespace', ctx=Store())], value=Dict(keys=[Constant(value='environment'), Constant(value='__file__')], values=[Name(id='environment', ctx=Load()), Attribute(value=Name(id='code', ctx=Load()), attr='co_filename', ctx=Load())])), Expr(value=Call(func=Name(id='exec', ctx=Load()), args=[Name(id='code', ctx=Load()), Name(id='namespace', ctx=Load())], keywords=[])), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_from_namespace', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='namespace', ctx=Load()), Name(id='globals', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='rv', ctx=Load()), attr='_uptodate', ctx=Store())], value=Name(id='uptodate', ctx=Load())), Return(value=Name(id='rv', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='Template')), FunctionDef(name='from_module_dict', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='environment', annotation=Name(id='Environment', ctx=Load())), arg(arg='module_dict', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='globals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Creates a template object from a module.  This is used by the\n        module loader to create a template object.\n\n        .. versionadded:: 2.4\n        ')), Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_from_namespace', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='module_dict', ctx=Load()), Name(id='globals', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='Template')), FunctionDef(name='_from_namespace', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='environment', annotation=Name(id='Environment', ctx=Load())), arg(arg='namespace', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='globals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='t', ctx=Store()), annotation=Constant(value='Template'), value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), simple=1), Assign(targets=[Attribute(value=Name(id='t', ctx=Load()), attr='environment', ctx=Store())], value=Name(id='environment', ctx=Load())), Assign(targets=[Attribute(value=Name(id='t', ctx=Load()), attr='globals', ctx=Store())], value=Name(id='globals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='t', ctx=Load()), attr='name', ctx=Store())], value=Subscript(value=Name(id='namespace', ctx=Load()), slice=Constant(value='name'), ctx=Load())), Assign(targets=[Attribute(value=Name(id='t', ctx=Load()), attr='filename', ctx=Store())], value=Subscript(value=Name(id='namespace', ctx=Load()), slice=Constant(value='__file__'), ctx=Load())), Assign(targets=[Attribute(value=Name(id='t', ctx=Load()), attr='blocks', ctx=Store())], value=Subscript(value=Name(id='namespace', ctx=Load()), slice=Constant(value='blocks'), ctx=Load())), Assign(targets=[Attribute(value=Name(id='t', ctx=Load()), attr='root_render_func', ctx=Store())], value=Subscript(value=Name(id='namespace', ctx=Load()), slice=Constant(value='root'), ctx=Load())), Assign(targets=[Attribute(value=Name(id='t', ctx=Load()), attr='_module', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='t', ctx=Load()), attr='_debug_info', ctx=Store())], value=Subscript(value=Name(id='namespace', ctx=Load()), slice=Constant(value='debug_info'), ctx=Load())), Assign(targets=[Attribute(value=Name(id='t', ctx=Load()), attr='_uptodate', ctx=Store())], value=Constant(value=None)), Assign(targets=[Subscript(value=Name(id='namespace', ctx=Load()), slice=Constant(value='environment'), ctx=Store())], value=Name(id='environment', ctx=Load())), Assign(targets=[Subscript(value=Name(id='namespace', ctx=Load()), slice=Constant(value='__jinja_template__'), ctx=Store())], value=Name(id='t', ctx=Load())), Return(value=Name(id='t', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='Template')), FunctionDef(name='render', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value="This method accepts the same arguments as the `dict` constructor:\n        A dict, a dict subclass or some keyword arguments.  If no arguments\n        are given the context will be empty.  These two calls do the same::\n\n            template.render(knights='that say nih')\n            template.render({'knights': 'that say nih'})\n\n        This will return the rendered template as a string.\n        ")), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='is_async', ctx=Load()), body=[Import(names=[alias(name='asyncio')]), Assign(targets=[Name(id='close', ctx=Store())], value=Constant(value=False)), Try(body=[Assign(targets=[Name(id='loop', ctx=Store())], value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='get_running_loop', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='RuntimeError', ctx=Load()), body=[Assign(targets=[Name(id='loop', ctx=Store())], value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='new_event_loop', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='close', ctx=Store())], value=Constant(value=True))])], orelse=[], finalbody=[]), Try(body=[Return(value=Call(func=Attribute(value=Name(id='loop', ctx=Load()), attr='run_until_complete', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='render_async', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[]))], handlers=[], orelse=[], finalbody=[If(test=Name(id='close', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='loop', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[])])], orelse=[]), Assign(targets=[Name(id='ctx', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='new_context', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[])), Try(body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='concat', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='root_render_func', ctx=Load()), args=[Name(id='ctx', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='handle_exception', ctx=Load()), args=[], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='str', ctx=Load())), AsyncFunctionDef(name='render_async', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value="This works similar to :meth:`render` but returns a coroutine\n        that when awaited returns the entire rendered template string.  This\n        requires the async feature to be enabled.\n\n        Example usage::\n\n            await template.render_async(knights='that say nih; asynchronously')\n        ")), If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='is_async', ctx=Load())), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='The environment was not created with async mode enabled.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='ctx', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='new_context', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[])), Try(body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='concat', ctx=Load()), args=[ListComp(elt=Name(id='n', ctx=Load()), generators=[comprehension(target=Name(id='n', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='root_render_func', ctx=Load()), args=[Name(id='ctx', ctx=Load())], keywords=[]), ifs=[], is_async=1)])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='handle_exception', ctx=Load()), args=[], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='stream', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Works exactly like :meth:`generate` but returns a\n        :class:`TemplateStream`.\n        ')), Return(value=Call(func=Name(id='TemplateStream', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='generate', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[]))], decorator_list=[], returns=Constant(value='TemplateStream')), FunctionDef(name='generate', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='For very large templates it can be useful to not render the whole\n        template at once but evaluate each statement after another and yield\n        piece for piece.  This method basically does exactly that and returns\n        a generator that yields one item after another as strings.\n\n        It accepts the same arguments as :meth:`render`.\n        ')), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='is_async', ctx=Load()), body=[Import(names=[alias(name='asyncio')]), AsyncFunctionDef(name='to_list', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=ListComp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='generate_async', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]), ifs=[], is_async=1)]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='run', ctx=Load()), args=[Call(func=Name(id='to_list', ctx=Load()), args=[], keywords=[])], keywords=[]))), Return()], orelse=[]), Assign(targets=[Name(id='ctx', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='new_context', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[])), Try(body=[Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='root_render_func', ctx=Load()), args=[Name(id='ctx', ctx=Load())], keywords=[])))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='handle_exception', ctx=Load()), args=[], keywords=[])))])], orelse=[], finalbody=[])], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), AsyncFunctionDef(name='generate_async', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='An async version of :meth:`generate`.  Works very similarly but\n        returns an async iterator instead.\n        ')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='is_async', ctx=Load())), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='The environment was not created with async mode enabled.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='ctx', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='new_context', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[])), Try(body=[AsyncFor(target=Name(id='event', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='root_render_func', ctx=Load()), args=[Name(id='ctx', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='event', ctx=Load())))], orelse=[])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='handle_exception', ctx=Load()), args=[], keywords=[])))])], orelse=[], finalbody=[])], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='AsyncIterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='new_context', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='vars', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='shared', annotation=Name(id='bool', ctx=Load())), arg(arg='locals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='Create a new :class:`Context` for this template.  The vars\n        provided will be passed to the template.  Per default the globals\n        are added to the context.  If shared is set to `True` the data\n        is passed as is to the context without adding the globals.\n\n        `locals` can be a dict of local variables for internal usage.\n        ')), Return(value=Call(func=Name(id='new_context', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='blocks', ctx=Load()), Name(id='vars', ctx=Load()), Name(id='shared', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='globals', ctx=Load()), Name(id='locals', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Context', ctx=Load())), FunctionDef(name='make_module', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='vars', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='shared', annotation=Name(id='bool', ctx=Load())), arg(arg='locals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value="This method works like the :attr:`module` attribute when called\n        without arguments but it will evaluate the template on every call\n        rather than caching it.  It's also possible to provide\n        a dict which is then used as context.  The arguments are the same\n        as for the :meth:`new_context` method.\n        ")), Assign(targets=[Name(id='ctx', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='new_context', ctx=Load()), args=[Name(id='vars', ctx=Load()), Name(id='shared', ctx=Load()), Name(id='locals', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='TemplateModule', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='ctx', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='TemplateModule')), AsyncFunctionDef(name='make_module_async', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='vars', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='shared', annotation=Name(id='bool', ctx=Load())), arg(arg='locals', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='As template module creation can invoke template code for\n        asynchronous executions this method must be used instead of the\n        normal :meth:`make_module` one.  Likewise the module attribute\n        becomes unavailable in async mode.\n        ')), Assign(targets=[Name(id='ctx', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='new_context', ctx=Load()), args=[Name(id='vars', ctx=Load()), Name(id='shared', ctx=Load()), Name(id='locals', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='TemplateModule', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='ctx', ctx=Load()), ListComp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='root_render_func', ctx=Load()), args=[Name(id='ctx', ctx=Load())], keywords=[]), ifs=[], is_async=1)])], keywords=[]))], decorator_list=[], returns=Constant(value='TemplateModule')), FunctionDef(name='_get_default_module', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="If a context is passed in, this means that the template was\n        imported. Imported templates have access to the current\n        template's globals by default, but they can only be accessed via\n        the context during runtime.\n\n        If there are new globals, we need to create a new module because\n        the cached module is already rendered and will not have access\n        to globals from the current context. This new module is not\n        cached because the template can be imported elsewhere, and it\n        should have access to only the current template's globals.\n        ")), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='is_async', ctx=Load()), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='Module is not available in async mode.')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='ctx', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='keys', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='ctx', ctx=Load()), attr='globals_keys', ctx=Load()), op=Sub(), right=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='globals', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]))), If(test=Name(id='keys', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_module', ctx=Load()), args=[DictComp(key=Name(id='k', ctx=Load()), value=Subscript(value=Attribute(value=Name(id='ctx', ctx=Load()), attr='parent', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Name(id='keys', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_module', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load()))], decorator_list=[Name(id='internalcode', ctx=Load())], returns=Constant(value='TemplateModule')), AsyncFunctionDef(name='_get_default_module_async', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Context', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='ctx', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='keys', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='ctx', ctx=Load()), attr='globals_keys', ctx=Load()), op=Sub(), right=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='globals', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]))), If(test=Name(id='keys', ctx=Load()), body=[Return(value=Await(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_module_async', ctx=Load()), args=[DictComp(key=Name(id='k', ctx=Load()), value=Subscript(value=Attribute(value=Name(id='ctx', ctx=Load()), attr='parent', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Name(id='keys', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Store())], value=Await(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_module_async', ctx=Load()), args=[], keywords=[])))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load()))], decorator_list=[], returns=Constant(value='TemplateModule')), FunctionDef(name='module', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="The template as module.  This is used for imports in the\n        template runtime but is also useful if one wants to access\n        exported template variables from the Python layer:\n\n        >>> t = Template('{% macro foo() %}42{% endmacro %}23')\n        >>> str(t.module)\n        '23'\n        >>> t.module.foo() == u'42'\n        True\n\n        This attribute is not available if async mode is enabled.\n        ")), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_default_module', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Constant(value='TemplateModule')), FunctionDef(name='get_corresponding_lineno', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lineno', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the source line number of a line number in the\n        generated bytecode as they are not in sync.\n        ')), For(target=Tuple(elts=[Name(id='template_line', ctx=Store()), Name(id='code_line', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='debug_info', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='code_line', ctx=Load()), ops=[LtE()], comparators=[Name(id='lineno', ctx=Load())]), body=[Return(value=Name(id='template_line', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=1))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='is_up_to_date', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='If this variable is `False` there is a newer version available.')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_uptodate', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=True))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_uptodate', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='debug_info', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The debug info mapping.')), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_debug_info', ctx=Load()), body=[Return(value=ListComp(elt=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='int', ctx=Load()), Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='=')], keywords=[])], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_debug_info', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='&')], keywords=[]), ifs=[], is_async=0)]))], orelse=[]), Return(value=List(elts=[], ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=JoinedStr(values=[Constant(value='memory:'), FormattedValue(value=Call(func=Name(id='id', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), conversion=-1, format_spec=JoinedStr(values=[Constant(value='x')]))]))], orelse=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], keywords=[]))]), Return(value=JoinedStr(values=[Constant(value='<'), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='>')]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='TemplateModule', bases=[], keywords=[], body=[Expr(value=Constant(value='Represents an imported template.  All the exported names of the\n    template are available as attributes on this object.  Additionally\n    converting it into a string renders the contents.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='template', annotation=Name(id='Template', ctx=Load())), arg(arg='context', annotation=Name(id='Context', ctx=Load())), arg(arg='body_stream', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='body_stream', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Attribute(value=Attribute(value=Name(id='context', ctx=Load()), attr='environment', ctx=Load()), attr='is_async', ctx=Load()), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='Async mode requires a body stream to be passed to a template module. Use the async methods of the API you are using.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='body_stream', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='template', ctx=Load()), attr='root_render_func', ctx=Load()), args=[Name(id='context', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_body_stream', ctx=Store())], value=Name(id='body_stream', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Name(id='context', ctx=Load()), attr='get_exported', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Store())], value=Attribute(value=Name(id='template', ctx=Load()), attr='name', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__html__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Markup', ctx=Load()), args=[Call(func=Name(id='concat', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_body_stream', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='Markup', ctx=Load())), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='concat', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_body_stream', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=JoinedStr(values=[Constant(value='memory:'), FormattedValue(value=Call(func=Name(id='id', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), conversion=-1, format_spec=JoinedStr(values=[Constant(value='x')]))]))], orelse=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load())], keywords=[]))]), Return(value=JoinedStr(values=[Constant(value='<'), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='>')]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='TemplateExpression', bases=[], keywords=[], body=[Expr(value=Constant(value='The :meth:`jinja2.Environment.compile_expression` method returns an\n    instance of this object.  It encapsulates the expression-like access\n    to the template with an expression it wraps.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='template', annotation=Name(id='Template', ctx=Load())), arg(arg='undefined_to_none', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_template', ctx=Store())], value=Name(id='template', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_undefined_to_none', ctx=Store())], value=Name(id='undefined_to_none', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Assign(targets=[Name(id='context', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_template', ctx=Load()), attr='new_context', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[])), Expr(value=Call(func=Name(id='consume', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_template', ctx=Load()), attr='root_render_func', ctx=Load()), args=[Name(id='context', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='rv', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='context', ctx=Load()), attr='vars', ctx=Load()), slice=Constant(value='result'), ctx=Load())), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_undefined_to_none', ctx=Load()), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='rv', ctx=Load()), Name(id='Undefined', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Constant(value=None))], orelse=[]), Return(value=Name(id='rv', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='TemplateStream', bases=[], keywords=[], body=[Expr(value=Constant(value='A template stream works pretty much like an ordinary python generator\n    but it can buffer multiple items to reduce the number of total iterations.\n    Per default the output is unbuffered which means that for every unbuffered\n    instruction in the template one string is yielded.\n\n    If buffering is enabled with a buffer size of 5, five items are combined\n    into a new string.  This is mainly useful if you are streaming\n    big templates to a client via WSGI which flushes after each iteration.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='gen', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gen', ctx=Store())], value=Name(id='gen', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='disable_buffering', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='dump', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fp', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='IO', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='encoding', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='errors', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value='strict')]), body=[Expr(value=Constant(value="Dump the complete stream into a file or file-like object.\n        Per default strings are written, if you want to encode\n        before writing specify an `encoding`.\n\n        Example usage::\n\n            Template('Hello {{ name }}!').stream(name='foo').dump('hello.html')\n        ")), Assign(targets=[Name(id='close', ctx=Store())], value=Constant(value=False)), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='fp', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='encoding', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='encoding', ctx=Store())], value=Constant(value='utf-8'))], orelse=[]), Assign(targets=[Name(id='fp', ctx=Store())], value=Call(func=Name(id='open', ctx=Load()), args=[Name(id='fp', ctx=Load()), Constant(value='wb')], keywords=[])), Assign(targets=[Name(id='close', ctx=Store())], value=Constant(value=True))], orelse=[]), Try(body=[If(test=Compare(left=Name(id='encoding', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='iterable', ctx=Store())], value=GeneratorExp(elt=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='encode', ctx=Load()), args=[Name(id='encoding', ctx=Load()), Name(id='errors', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[], is_async=0)]))], orelse=[Assign(targets=[Name(id='iterable', ctx=Store())], value=Name(id='self', ctx=Load()))]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='fp', ctx=Load()), Constant(value='writelines')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='fp', ctx=Load()), attr='writelines', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]))], orelse=[For(target=Name(id='item', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='fp', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[])])], handlers=[], orelse=[], finalbody=[If(test=Name(id='close', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='fp', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[])])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='disable_buffering', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Disable the output buffering.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_next', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='next', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_gen', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='buffered', ctx=Store())], value=Constant(value=False))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_buffered_generator', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='size', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='buf', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='c_size', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='push', ctx=Store())], value=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load())), While(test=Constant(value=True), body=[Try(body=[While(test=Compare(left=Name(id='c_size', ctx=Load()), ops=[Lt()], comparators=[Name(id='size', ctx=Load())]), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gen', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='push', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])), If(test=Name(id='c', ctx=Load()), body=[AugAssign(target=Name(id='c_size', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[])], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Name(id='c_size', ctx=Load())), body=[Return()], orelse=[])])], orelse=[], finalbody=[]), Expr(value=Yield(value=Call(func=Name(id='concat', ctx=Load()), args=[Name(id='buf', ctx=Load())], keywords=[]))), Delete(targets=[Subscript(value=Name(id='buf', ctx=Load()), slice=Slice(), ctx=Del())]), Assign(targets=[Name(id='c_size', ctx=Store())], value=Constant(value=0))], orelse=[])], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='enable_buffering', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='size', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=5)]), body=[Expr(value=Constant(value='Enable buffering.  Buffer `size` items before yielding them.')), If(test=Compare(left=Name(id='size', ctx=Load()), ops=[LtE()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='buffer size too small')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='buffered', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_next', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='next', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_buffered_generator', ctx=Load()), args=[Name(id='size', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='TemplateStream')), FunctionDef(name='__next__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_next', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='Environment', ctx=Load()), attr='template_class', ctx=Store())], value=Name(id='Template', ctx=Load()))], type_ignores=[])