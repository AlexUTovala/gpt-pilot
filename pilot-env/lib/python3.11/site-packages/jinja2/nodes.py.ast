Module(body=[Expr(value=Constant(value='AST nodes generated by the parser for the compiler. Also provides\nsome node tree helper functions used by the parser and compiler in order\nto normalize nodes.\n')), Import(names=[alias(name='inspect')]), Import(names=[alias(name='operator')]), Import(names=[alias(name='typing', asname='t')]), ImportFrom(module='collections', names=[alias(name='deque')], level=0), ImportFrom(module='markupsafe', names=[alias(name='Markup')], level=0), ImportFrom(module='utils', names=[alias(name='_PassArg')], level=1), If(test=Attribute(value=Name(id='t', ctx=Load()), attr='TYPE_CHECKING', ctx=Load()), body=[Import(names=[alias(name='typing_extensions', asname='te')]), ImportFrom(module='environment', names=[alias(name='Environment')], level=1)], orelse=[]), Assign(targets=[Name(id='_NodeBound', ctx=Store())], value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='_NodeBound')], keywords=[keyword(arg='bound', value=Constant(value='Node'))])), AnnAssign(target=Name(id='_binop_to_func', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[Constant(value='*'), Constant(value='/'), Constant(value='//'), Constant(value='**'), Constant(value='%'), Constant(value='+'), Constant(value='-')], values=[Attribute(value=Name(id='operator', ctx=Load()), attr='mul', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='truediv', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='floordiv', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='pow', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='mod', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='add', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='sub', ctx=Load())]), simple=1), AnnAssign(target=Name(id='_uaop_to_func', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[Constant(value='not'), Constant(value='+'), Constant(value='-')], values=[Attribute(value=Name(id='operator', ctx=Load()), attr='not_', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='pos', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='neg', ctx=Load())]), simple=1), AnnAssign(target=Name(id='_cmpop_to_func', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[Constant(value='eq'), Constant(value='ne'), Constant(value='gt'), Constant(value='gteq'), Constant(value='lt'), Constant(value='lteq'), Constant(value='in'), Constant(value='notin')], values=[Attribute(value=Name(id='operator', ctx=Load()), attr='eq', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='ne', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='gt', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='ge', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='lt', ctx=Load()), Attribute(value=Name(id='operator', ctx=Load()), attr='le', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Name(id='a', ctx=Load()), ops=[In()], comparators=[Name(id='b', ctx=Load())])), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Name(id='a', ctx=Load()), ops=[NotIn()], comparators=[Name(id='b', ctx=Load())]))]), simple=1), ClassDef(name='Impossible', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised if the node could not perform a requested action.'))], decorator_list=[]), ClassDef(name='NodeType', bases=[Name(id='type', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A metaclass for nodes that handles the field and attribute\n    inheritance.  fields and attributes from the parent class are\n    automatically forwarded to the child.')), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='mcs'), arg(arg='name'), arg(arg='bases'), arg(arg='d')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='attr', ctx=Store()), iter=Tuple(elts=[Constant(value='fields'), Constant(value='attributes')], ctx=Load()), body=[Assign(targets=[Name(id='storage', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='storage', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[IfExp(test=Name(id='bases', ctx=Load()), body=Subscript(value=Name(id='bases', ctx=Load()), slice=Constant(value=0), ctx=Load()), orelse=Name(id='object', ctx=Load())), Name(id='attr', ctx=Load()), Tuple(elts=[], ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='storage', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='d', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='attr', ctx=Load()), Tuple(elts=[], ctx=Load())], keywords=[])], keywords=[])), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bases', ctx=Load())], keywords=[]), ops=[LtE()], comparators=[Constant(value=1)]), msg=Constant(value='multiple inheritance not allowed')), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='storage', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='storage', ctx=Load())], keywords=[])], keywords=[])]), msg=Constant(value='layout conflict')), Assign(targets=[Subscript(value=Name(id='d', ctx=Load()), slice=Name(id='attr', ctx=Load()), ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='storage', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='d', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='abstract'), Constant(value=False)], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='type', ctx=Load()), attr='__new__', ctx=Load()), args=[Name(id='mcs', ctx=Load()), Name(id='name', ctx=Load()), Name(id='bases', ctx=Load()), Name(id='d', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='EvalContext', bases=[], keywords=[], body=[Expr(value=Constant(value='Holds evaluation time information.  Custom attributes can be attached\n    to it in extensions.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='template_name', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Store())], value=Name(id='environment', ctx=Load())), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='environment', ctx=Load()), attr='autoescape', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='autoescape', ctx=Store())], value=Call(func=Attribute(value=Name(id='environment', ctx=Load()), attr='autoescape', ctx=Load()), args=[Name(id='template_name', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='autoescape', ctx=Store())], value=Attribute(value=Name(id='environment', ctx=Load()), attr='autoescape', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='volatile', ctx=Store())], value=Constant(value=False))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='save', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='revert', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='old', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='old', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), FunctionDef(name='get_eval_context', args=arguments(posonlyargs=[], args=[arg(arg='node', annotation=Constant(value='Node')), arg(arg='ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='ctx', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Attribute(value=Name(id='node', ctx=Load()), attr='environment', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='if no eval context is passed, the node must have an attached environment.')], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='EvalContext', ctx=Load()), args=[Attribute(value=Name(id='node', ctx=Load()), attr='environment', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='ctx', ctx=Load()))], decorator_list=[], returns=Name(id='EvalContext', ctx=Load())), ClassDef(name='Node', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='NodeType', ctx=Load()))], body=[Expr(value=Constant(value='Baseclass for all Jinja nodes.  There are a number of nodes available\n    of different types.  There are four major types:\n\n    -   :class:`Stmt`: statements\n    -   :class:`Expr`: expressions\n    -   :class:`Helper`: helper nodes\n    -   :class:`Template`: the outermost wrapper node\n\n    All nodes have fields and attributes.  Fields may be other nodes, lists,\n    or arbitrary values.  Fields are passed to the constructor as regular\n    positional arguments, attributes as keyword arguments.  Each node has\n    two attributes: `lineno` (the line number of the node) and `environment`.\n    The `environment` attribute is set at the end of the parsing process for\n    all nodes automatically.\n    ')), AnnAssign(target=Name(id='fields', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), value=Tuple(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='attributes', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), value=Tuple(elts=[Constant(value='lineno'), Constant(value='environment')], ctx=Load()), simple=1), Assign(targets=[Name(id='abstract', ctx=Store())], value=Constant(value=True)), AnnAssign(target=Name(id='lineno', ctx=Store()), annotation=Name(id='int', ctx=Load()), simple=1), AnnAssign(target=Name(id='environment', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Constant(value='Environment'), ctx=Load()), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='fields', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='attributes', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='abstract', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='abstract nodes are not instantiable')], keywords=[]))], orelse=[]), If(test=Name(id='fields', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='fields', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='fields', ctx=Load())], keywords=[])]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='fields', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=114), Constant(value=' takes 0 arguments')])], keywords=[]))], orelse=[]), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=114), Constant(value=' takes 0 or '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='fields', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' argument'), FormattedValue(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='fields', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=1)]), body=Constant(value='s'), orelse=Constant(value='')), conversion=-1)])], keywords=[]))], orelse=[]), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='arg', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='fields', ctx=Load()), Name(id='fields', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load()), Name(id='arg', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), For(target=Name(id='attr', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='attributes', ctx=Load()), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='attr', ctx=Load()), Call(func=Attribute(value=Name(id='attributes', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='attr', ctx=Load()), Constant(value=None)], keywords=[])], keywords=[]))], orelse=[]), If(test=Name(id='attributes', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='unknown attribute '), FormattedValue(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Name(id='attributes', ctx=Load())], keywords=[])], keywords=[]), conversion=114)])], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='iter_fields', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exclude', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Container', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='only', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Container', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="This method iterates over all fields that are defined and yields\n        ``(key, value)`` tuples.  Per default all fields are returned, but\n        it's possible to limit that to some fields by providing the `only`\n        parameter or to exclude some using the `exclude` parameter.  Both\n        should be sets or tuples of field names.\n        ")), For(target=Name(id='name', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='fields', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Compare(left=Name(id='exclude', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='only', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), BoolOp(op=And(), values=[Compare(left=Name(id='exclude', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='exclude', ctx=Load())])]), BoolOp(op=And(), values=[Compare(left=Name(id='only', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Name(id='only', ctx=Load())])])]), body=[Try(body=[Expr(value=Yield(value=Tuple(elts=[Name(id='name', ctx=Load()), Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])], ctx=Load())))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='iter_child_nodes', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exclude', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Container', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='only', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Container', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Iterates over all direct child nodes of the node.  This iterates\n        over all fields and yields the values of they are nodes.  If the value\n        of a field is a list all the nodes in that list are returned.\n        ')), For(target=Tuple(elts=[Name(id='_', ctx=Store()), Name(id='item', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iter_fields', ctx=Load()), args=[Name(id='exclude', ctx=Load()), Name(id='only', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='item', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[For(target=Name(id='n', ctx=Store()), iter=Name(id='item', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='Node', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='n', ctx=Load())))], orelse=[])], orelse=[])], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='item', ctx=Load()), Name(id='Node', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='item', ctx=Load())))], orelse=[])])], orelse=[])], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Constant(value='Node'), ctx=Load())), FunctionDef(name='find', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='node_type', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='_NodeBound', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find the first node of a given type.  If no such node exists the\n        return value is `None`.\n        ')), For(target=Name(id='result', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='find_all', ctx=Load()), args=[Name(id='node_type', ctx=Load())], keywords=[]), body=[Return(value=Name(id='result', ctx=Load()))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='_NodeBound', ctx=Load()), ctx=Load())), FunctionDef(name='find_all', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='node_type', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='_NodeBound', ctx=Load()), ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Type', ctx=Load()), slice=Name(id='_NodeBound', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find all the nodes of a given type.  If the type is a tuple,\n        the check is performed for any of the tuple items.\n        ')), For(target=Name(id='child', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iter_child_nodes', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='child', ctx=Load()), Name(id='node_type', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='child', ctx=Load())))], orelse=[]), Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='child', ctx=Load()), attr='find_all', ctx=Load()), args=[Name(id='node_type', ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Name(id='_NodeBound', ctx=Load()), ctx=Load())), FunctionDef(name='set_ctx', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ctx', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Reset the context of a node and all child nodes.  Per default the\n        parser will all generate nodes that have a 'load' context as it's the\n        most common one.  This method is used in the parser to set assignment\n        targets and other nodes to a store context.\n        ")), Assign(targets=[Name(id='todo', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load())], ctx=Load())], keywords=[])), While(test=Name(id='todo', ctx=Load()), body=[Assign(targets=[Name(id='node', ctx=Store())], value=Call(func=Attribute(value=Name(id='todo', ctx=Load()), attr='popleft', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Constant(value='ctx'), ops=[In()], comparators=[Attribute(value=Name(id='node', ctx=Load()), attr='fields', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='node', ctx=Load()), attr='ctx', ctx=Store())], value=Name(id='ctx', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='todo', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='node', ctx=Load()), attr='iter_child_nodes', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='Node')), FunctionDef(name='set_lineno', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lineno', annotation=Name(id='int', ctx=Load())), arg(arg='override', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Set the line numbers of the node and children.')), Assign(targets=[Name(id='todo', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load())], ctx=Load())], keywords=[])), While(test=Name(id='todo', ctx=Load()), body=[Assign(targets=[Name(id='node', ctx=Store())], value=Call(func=Attribute(value=Name(id='todo', ctx=Load()), attr='popleft', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Constant(value='lineno'), ops=[In()], comparators=[Attribute(value=Name(id='node', ctx=Load()), attr='attributes', ctx=Load())]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='node', ctx=Load()), attr='lineno', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Name(id='override', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='node', ctx=Load()), attr='lineno', ctx=Store())], value=Name(id='lineno', ctx=Load()))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='todo', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='node', ctx=Load()), attr='iter_child_nodes', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='Node')), FunctionDef(name='set_environment', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='environment', annotation=Constant(value='Environment'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Set the environment for all nodes.')), Assign(targets=[Name(id='todo', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load())], ctx=Load())], keywords=[])), While(test=Name(id='todo', ctx=Load()), body=[Assign(targets=[Name(id='node', ctx=Store())], value=Call(func=Attribute(value=Name(id='todo', ctx=Load()), attr='popleft', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='node', ctx=Load()), attr='environment', ctx=Store())], value=Name(id='environment', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='todo', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='node', ctx=Load()), attr='iter_child_nodes', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='Node')), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])]), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Compare(left=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iter_fields', ctx=Load()), args=[], keywords=[])], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='iter_fields', ctx=Load()), args=[], keywords=[])], keywords=[])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), Assign(targets=[Name(id='__hash__', ctx=Store())], value=Attribute(value=Name(id='object', ctx=Load()), attr='__hash__', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='args_str', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1), Constant(value='='), FormattedValue(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='a', ctx=Load()), Constant(value=None)], keywords=[]), conversion=114)]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='fields', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value='('), FormattedValue(value=Name(id='args_str', ctx=Load()), conversion=-1), Constant(value=')')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='dump', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='_dump', args=arguments(posonlyargs=[], args=[arg(arg='node', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Node', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Name(id='Node', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='repr', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])], keywords=[])), Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[Constant(value='nodes.'), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value='(')])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='node', ctx=Load()), attr='fields', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value=')')], keywords=[])), Return()], orelse=[]), For(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='field', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='node', ctx=Load()), attr='fields', ctx=Load())], keywords=[]), body=[If(test=Name(id='idx', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value=', ')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='node', ctx=Load()), Name(id='field', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='[')], keywords=[])), For(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), body=[If(test=Name(id='idx', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value=', ')], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='_dump', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value=']')], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='_dump', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='buf', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value=')')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), AnnAssign(target=Name(id='buf', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Expr(value=Call(func=Name(id='_dump', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='buf', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='Stmt', bases=[Name(id='Node', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Base node for all statements.')), Assign(targets=[Name(id='abstract', ctx=Store())], value=Constant(value=True))], decorator_list=[]), ClassDef(name='Helper', bases=[Name(id='Node', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Nodes that exist in a specific context only.')), Assign(targets=[Name(id='abstract', ctx=Store())], value=Constant(value=True))], decorator_list=[]), ClassDef(name='Template', bases=[Name(id='Node', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Node that represents a template.  This must be the outermost node that\n    is passed to the compiler.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='body')], ctx=Load())), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='Output', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A node that holds multiple expressions which are then printed out.\n    This is used both for the `print` statement and the regular template data.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='nodes')], ctx=Load())), AnnAssign(target=Name(id='nodes', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Constant(value='Expr'), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='Extends', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Represents an extends statement.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='template')], ctx=Load())), AnnAssign(target=Name(id='template', ctx=Store()), annotation=Constant(value='Expr'), simple=1)], decorator_list=[]), ClassDef(name='For', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The for loop.  `target` is the target for the iteration (usually a\n    :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list\n    of nodes that are used as loop-body, and `else_` a list of nodes for the\n    `else` block.  If no else node exists it has to be an empty list.\n\n    For filtered nodes an expression can be stored as `test`, otherwise `None`.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='target'), Constant(value='iter'), Constant(value='body'), Constant(value='else_'), Constant(value='test'), Constant(value='recursive')], ctx=Load())), AnnAssign(target=Name(id='target', ctx=Store()), annotation=Name(id='Node', ctx=Load()), simple=1), AnnAssign(target=Name(id='iter', ctx=Store()), annotation=Name(id='Node', ctx=Load()), simple=1), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='else_', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='test', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='recursive', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='If', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='If `test` is true, `body` is rendered, else `else_`.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='test'), Constant(value='body'), Constant(value='elif_'), Constant(value='else_')], ctx=Load())), AnnAssign(target=Name(id='test', ctx=Store()), annotation=Name(id='Node', ctx=Load()), simple=1), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='elif_', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Constant(value='If'), ctx=Load()), simple=1), AnnAssign(target=Name(id='else_', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='Macro', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A macro definition.  `name` is the name of the macro, `args` a list of\n    arguments and `defaults` a list of defaults if there are any.  `body` is\n    a list of nodes for the macro body.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='name'), Constant(value='args'), Constant(value='defaults'), Constant(value='body')], ctx=Load())), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='args', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Constant(value='Name'), ctx=Load()), simple=1), AnnAssign(target=Name(id='defaults', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Constant(value='Expr'), ctx=Load()), simple=1), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='CallBlock', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Like a macro without a name but a call instead.  `call` is called with\n    the unnamed macro as `caller` argument this node holds.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='call'), Constant(value='args'), Constant(value='defaults'), Constant(value='body')], ctx=Load())), AnnAssign(target=Name(id='call', ctx=Store()), annotation=Constant(value='Call'), simple=1), AnnAssign(target=Name(id='args', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Constant(value='Name'), ctx=Load()), simple=1), AnnAssign(target=Name(id='defaults', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Constant(value='Expr'), ctx=Load()), simple=1), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='FilterBlock', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Node for filter sections.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='body'), Constant(value='filter')], ctx=Load())), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='filter', ctx=Store()), annotation=Constant(value='Filter'), simple=1)], decorator_list=[]), ClassDef(name='With', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Specific node for with statements.  In older versions of Jinja the\n    with statement was implemented on the base of the `Scope` node instead.\n\n    .. versionadded:: 2.9.3\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='targets'), Constant(value='values'), Constant(value='body')], ctx=Load())), AnnAssign(target=Name(id='targets', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Constant(value='Expr'), ctx=Load()), simple=1), AnnAssign(target=Name(id='values', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Constant(value='Expr'), ctx=Load()), simple=1), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='Block', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A node that represents a block.\n\n    .. versionchanged:: 3.0.0\n        the `required` field was added.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='name'), Constant(value='body'), Constant(value='scoped'), Constant(value='required')], ctx=Load())), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='scoped', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), AnnAssign(target=Name(id='required', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='Include', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A node that represents the include tag.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='template'), Constant(value='with_context'), Constant(value='ignore_missing')], ctx=Load())), AnnAssign(target=Name(id='template', ctx=Store()), annotation=Constant(value='Expr'), simple=1), AnnAssign(target=Name(id='with_context', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), AnnAssign(target=Name(id='ignore_missing', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='Import', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A node that represents the import tag.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='template'), Constant(value='target'), Constant(value='with_context')], ctx=Load())), AnnAssign(target=Name(id='template', ctx=Store()), annotation=Constant(value='Expr'), simple=1), AnnAssign(target=Name(id='target', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='with_context', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='FromImport', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="A node that represents the from import tag.  It's important to not\n    pass unsafe names to the name attribute.  The compiler translates the\n    attribute lookups directly into getattr calls and does *not* use the\n    subscript callback of the interface.  As exported variables may not\n    start with double underscores (which the parser asserts) this is not a\n    problem for regular Jinja code, but if this node is used in an extension\n    extra care must be taken.\n\n    The list of names may contain tuples if aliases are wanted.\n    ")), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='template'), Constant(value='names'), Constant(value='with_context')], ctx=Load())), AnnAssign(target=Name(id='template', ctx=Store()), annotation=Constant(value='Expr'), simple=1), AnnAssign(target=Name(id='names', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='with_context', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='ExprStmt', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A statement that evaluates an expression and discards the result.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='node')], ctx=Load())), AnnAssign(target=Name(id='node', ctx=Store()), annotation=Name(id='Node', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='Assign', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Assigns an expression to a target.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='target'), Constant(value='node')], ctx=Load())), AnnAssign(target=Name(id='target', ctx=Store()), annotation=Constant(value='Expr'), simple=1), AnnAssign(target=Name(id='node', ctx=Store()), annotation=Name(id='Node', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='AssignBlock', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Assigns a block to a target.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='target'), Constant(value='filter'), Constant(value='body')], ctx=Load())), AnnAssign(target=Name(id='target', ctx=Store()), annotation=Constant(value='Expr'), simple=1), AnnAssign(target=Name(id='filter', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Constant(value='Filter'), ctx=Load()), simple=1), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='Expr', bases=[Name(id='Node', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Baseclass for all expressions.')), Assign(targets=[Name(id='abstract', ctx=Store())], value=Constant(value=True)), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return the value of the expression as constant or raise\n        :exc:`Impossible` if this was not possible.\n\n        An :class:`EvalContext` can be provided, if none is given\n        a default context is created which requires the nodes to have\n        an attached environment.\n\n        .. versionchanged:: 2.4\n           the `eval_ctx` parameter was added.\n        ')), Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), FunctionDef(name='can_assign', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Check if it's possible to assign something to this node.")), Return(value=Constant(value=False))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='BinExpr', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Baseclass for all binary expressions.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='left'), Constant(value='right')], ctx=Load())), AnnAssign(target=Name(id='left', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='right', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='operator', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), Assign(targets=[Name(id='abstract', ctx=Store())], value=Constant(value=True)), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='sandboxed', ctx=Load()), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='operator', ctx=Load()), ops=[In()], comparators=[Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='intercepted_binops', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='f', ctx=Store())], value=Subscript(value=Name(id='_binop_to_func', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='operator', ctx=Load()), ctx=Load())), Try(body=[Return(value=Call(func=Name(id='f', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='left', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='right', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='UnaryExpr', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Baseclass for all unary expressions.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='node')], ctx=Load())), AnnAssign(target=Name(id='node', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='operator', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), Assign(targets=[Name(id='abstract', ctx=Store())], value=Constant(value=True)), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='sandboxed', ctx=Load()), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='operator', ctx=Load()), ops=[In()], comparators=[Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='intercepted_unops', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='f', ctx=Store())], value=Subscript(value=Name(id='_uaop_to_func', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='operator', ctx=Load()), ctx=Load())), Try(body=[Return(value=Call(func=Name(id='f', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='node', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='Name', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Looks up a name or stores a value in a name.\n    The `ctx` of the node can be one of the following values:\n\n    -   `store`: store a value in the name\n    -   `load`: load that name\n    -   `param`: like `store` but if the name was defined as function parameter.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='name'), Constant(value='ctx')], ctx=Load())), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='ctx', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), FunctionDef(name='can_assign', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Constant(value='true'), Constant(value='false'), Constant(value='none'), Constant(value='True'), Constant(value='False'), Constant(value='None')])]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='NSRef', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Reference to a namespace value assignment')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='name'), Constant(value='attr')], ctx=Load())), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='attr', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), FunctionDef(name='can_assign', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='Literal', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Baseclass for literals.')), Assign(targets=[Name(id='abstract', ctx=Store())], value=Constant(value=True))], decorator_list=[]), ClassDef(name='Const', bases=[Name(id='Literal', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='All constant values.  The parser will return this node for simple\n    constants such as ``42`` or ``"foo"`` but it can be used to store more\n    complex values such as lists too.  Only constants with a safe\n    representation (objects where ``eval(repr(x)) == x`` is true).\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='value')], ctx=Load())), AnnAssign(target=Name(id='value', ctx=Store()), annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), FunctionDef(name='from_untrusted', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), arg(arg='lineno', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='environment', annotation=Constant(value='t.Optional[Environment]'))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Return a const object if the value is representable as\n        constant value in the generated code, otherwise it will raise\n        an `Impossible` exception.\n        ')), ImportFrom(module='compiler', names=[alias(name='has_safe_repr')], level=1), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='has_safe_repr', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[keyword(arg='lineno', value=Name(id='lineno', ctx=Load())), keyword(arg='environment', value=Name(id='environment', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='Const'))], decorator_list=[]), ClassDef(name='TemplateData', bases=[Name(id='Literal', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A constant template string.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='data')], ctx=Load())), AnnAssign(target=Name(id='data', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='volatile', ctx=Load()), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='autoescape', ctx=Load()), body=[Return(value=Call(func=Name(id='Markup', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='data', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='Tuple', bases=[Name(id='Literal', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='For loop unpacking and some other things like multiple arguments\n    for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple\n    is used for loading the names or storing.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='items'), Constant(value='ctx')], ctx=Load())), AnnAssign(target=Name(id='items', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='ctx', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='can_assign', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='item', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='item', ctx=Load()), attr='can_assign', ctx=Load()), args=[], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[])], orelse=[]), Return(value=Constant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='List', bases=[Name(id='Literal', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Any list literal such as ``[1, 2, 3]``')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='items')], ctx=Load())), AnnAssign(target=Name(id='items', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Return(value=ListComp(elt=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='Dict', bases=[Name(id='Literal', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of\n    :class:`Pair` nodes.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='items')], ctx=Load())), AnnAssign(target=Name(id='items', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Constant(value='Pair'), ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='dict', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='items', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='Pair', bases=[Name(id='Helper', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A key, value pair for dicts.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='key'), Constant(value='value')], ctx=Load())), AnnAssign(target=Name(id='key', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='value', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='key', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])], ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='Keyword', bases=[Name(id='Helper', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A key, value pair for keyword arguments where key is a string.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='key'), Constant(value='value')], ctx=Load())), AnnAssign(target=Name(id='key', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='value', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='key', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])], ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='CondExpr', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A conditional expression (inline if expression).  (``{{\n    foo if bar else baz }}``)\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='test'), Constant(value='expr1'), Constant(value='expr2')], ctx=Load())), AnnAssign(target=Name(id='test', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='expr1', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='expr2', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='test', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr1', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr2', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr2', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), FunctionDef(name='args_as_const', args=arguments(posonlyargs=[], args=[arg(arg='node', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='_FilterTestCommon'), Constant(value='Call')], ctx=Load()), ctx=Load())), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='args', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='node', ctx=Load()), attr='args', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='kwargs', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='node', ctx=Load()), attr='kwargs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='node', ctx=Load()), attr='dyn_args', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='args', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='node', ctx=Load()), attr='dyn_args', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='node', ctx=Load()), attr='dyn_kwargs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='node', ctx=Load()), attr='dyn_kwargs', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='_FilterTestCommon', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='node'), Constant(value='name'), Constant(value='args'), Constant(value='kwargs'), Constant(value='dyn_args'), Constant(value='dyn_kwargs')], ctx=Load())), AnnAssign(target=Name(id='node', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='args', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='kwargs', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Pair', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='dyn_args', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='dyn_kwargs', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), Assign(targets=[Name(id='abstract', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='_is_filter', ctx=Store())], value=Constant(value=True)), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='volatile', ctx=Load()), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_is_filter', ctx=Load()), body=[Assign(targets=[Name(id='env_map', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='filters', ctx=Load()))], orelse=[Assign(targets=[Name(id='env_map', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='tests', ctx=Load()))]), Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Attribute(value=Name(id='env_map', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='pass_arg', ctx=Store())], value=Call(func=Attribute(value=Name(id='_PassArg', ctx=Load()), attr='from_obj', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='func', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='pass_arg', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='_PassArg', ctx=Load()), attr='context', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='is_async', ctx=Load()), BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='jinja_async_variant'), Constant(value=False)], keywords=[]), ops=[Is()], comparators=[Constant(value=True)]), Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='iscoroutinefunction', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])])]), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='args', ctx=Store()), Name(id='kwargs', ctx=Store())], ctx=Store())], value=Call(func=Name(id='args_as_const', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='args', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='node', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='pass_arg', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='_PassArg', ctx=Load()), attr='eval_context', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='args', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Name(id='eval_ctx', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='pass_arg', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='_PassArg', ctx=Load()), attr='environment', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='args', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load())], keywords=[]))], orelse=[])]), Try(body=[Return(value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='Filter', bases=[Name(id='_FilterTestCommon', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Apply a filter to an expression. ``name`` is the name of the\n    filter, the other fields are the same as :class:`Call`.\n\n    If ``node`` is ``None``, the filter is being used in a filter block\n    and is applied to the content of the block.\n    ')), AnnAssign(target=Name(id='node', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='node', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='as_const', ctx=Load()), args=[], keywords=[keyword(arg='eval_ctx', value=Name(id='eval_ctx', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='Test', bases=[Name(id='_FilterTestCommon', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Apply a test to an expression. ``name`` is the name of the test,\n    the other field are the same as :class:`Call`.\n\n    .. versionchanged:: 3.0\n        ``as_const`` shares the same logic for filters and tests. Tests\n        check for volatile, async, and ``@pass_context`` etc.\n        decorators.\n    ')), Assign(targets=[Name(id='_is_filter', ctx=Store())], value=Constant(value=False))], decorator_list=[]), ClassDef(name='Call', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Calls an expression.  `args` is a list of arguments, `kwargs` a list\n    of keyword arguments (list of :class:`Keyword` nodes), and `dyn_args`\n    and `dyn_kwargs` has to be either `None` or a node that is used as\n    node for dynamic positional (``*args``) or keyword (``**kwargs``)\n    arguments.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='node'), Constant(value='args'), Constant(value='kwargs'), Constant(value='dyn_args'), Constant(value='dyn_kwargs')], ctx=Load())), AnnAssign(target=Name(id='node', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='args', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='kwargs', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Keyword', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='dyn_args', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='dyn_kwargs', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='Getitem', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Get an attribute or item from an expression and prefer the item.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='node'), Constant(value='arg'), Constant(value='ctx')], ctx=Load())), AnnAssign(target=Name(id='node', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='arg', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='ctx', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ctx', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='load')]), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Try(body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='getitem', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='node', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='arg', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='Getattr', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Get an attribute or item from an expression that is a ascii-only\n    bytestring and prefer the attribute.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='node'), Constant(value='attr'), Constant(value='ctx')], ctx=Load())), AnnAssign(target=Name(id='node', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='attr', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='ctx', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ctx', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='load')]), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Try(body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='getattr', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='node', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='attr', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='Slice', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Represents a slice object.  This must only be used as argument for\n    :class:`Subscript`.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='start'), Constant(value='stop'), Constant(value='step')], ctx=Load())), AnnAssign(target=Name(id='start', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='stop', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='step', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), FunctionDef(name='const', args=arguments(posonlyargs=[], args=[arg(arg='obj', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='obj', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='obj', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load())), Return(value=Call(func=Name(id='slice', ctx=Load()), args=[Call(func=Name(id='const', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='start', ctx=Load())], keywords=[]), Call(func=Name(id='const', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='stop', ctx=Load())], keywords=[]), Call(func=Name(id='const', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='step', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='slice', ctx=Load()))], decorator_list=[]), ClassDef(name='Concat', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Concatenates the list of expressions provided after converting\n    them to strings.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='nodes')], ctx=Load())), AnnAssign(target=Name(id='nodes', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Expr', ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='nodes', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='Compare', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Compares an expression with some other expressions.  `ops` must be a\n    list of :class:`Operand`\\s.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='expr'), Constant(value='ops')], ctx=Load())), AnnAssign(target=Name(id='expr', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='ops', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Constant(value='Operand'), ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store()), Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])), Try(body=[For(target=Name(id='op', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='ops', ctx=Load()), body=[Assign(targets=[Name(id='new_value', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='op', ctx=Load()), attr='expr', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Subscript(value=Name(id='_cmpop_to_func', ctx=Load()), slice=Attribute(value=Name(id='op', ctx=Load()), attr='op', ctx=Load()), ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='new_value', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='result', ctx=Load())), body=[Return(value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='value', ctx=Store())], value=Name(id='new_value', ctx=Load()))], orelse=[])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='Operand', bases=[Name(id='Helper', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Holds an operator and an expression.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='op'), Constant(value='expr')], ctx=Load())), AnnAssign(target=Name(id='op', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='expr', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='Mul', bases=[Name(id='BinExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Multiplies the left with the right node.')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='*'))], decorator_list=[]), ClassDef(name='Div', bases=[Name(id='BinExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Divides the left by the right node.')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='/'))], decorator_list=[]), ClassDef(name='FloorDiv', bases=[Name(id='BinExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Divides the left by the right node and converts the\n    result into an integer by truncating.\n    ')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='//'))], decorator_list=[]), ClassDef(name='Add', bases=[Name(id='BinExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Add the left to the right node.')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='+'))], decorator_list=[]), ClassDef(name='Sub', bases=[Name(id='BinExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Subtract the right from the left node.')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='-'))], decorator_list=[]), ClassDef(name='Mod', bases=[Name(id='BinExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Left modulo right.')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='%'))], decorator_list=[]), ClassDef(name='Pow', bases=[Name(id='BinExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Left to the power of right.')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='**'))], decorator_list=[]), ClassDef(name='And', bases=[Name(id='BinExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Short circuited AND.')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='and')), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Return(value=BoolOp(op=And(), values=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='left', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='right', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='Or', bases=[Name(id='BinExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Short circuited OR.')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='or')), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Return(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='left', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='right', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='Not', bases=[Name(id='UnaryExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Negate the expression.')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='not'))], decorator_list=[]), ClassDef(name='Neg', bases=[Name(id='UnaryExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Make the expression negative.')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='-'))], decorator_list=[]), ClassDef(name='Pos', bases=[Name(id='UnaryExpr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Make the expression positive (noop for most expressions)')), Assign(targets=[Name(id='operator', ctx=Store())], value=Constant(value='+'))], decorator_list=[]), ClassDef(name='EnvironmentAttribute', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Loads an attribute from the environment object.  This is useful for\n    extensions that want to call a callback stored on the environment.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='name')], ctx=Load())), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='ExtensionAttribute', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Returns the attribute of an extension bound to the environment.\n    The identifier is the identifier of the :class:`Extension`.\n\n    This node is usually constructed by calling the\n    :meth:`~jinja2.ext.Extension.attr` method on an extension.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='identifier'), Constant(value='name')], ctx=Load())), AnnAssign(target=Name(id='identifier', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='ImportedName', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="If created with an import name the import name is returned on node\n    access.  For example ``ImportedName('cgi.escape')`` returns the `escape`\n    function from the cgi module on evaluation.  Imports are optimized by the\n    compiler so there is no need to assign them to local variables.\n    ")), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='importname')], ctx=Load())), AnnAssign(target=Name(id='importname', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='InternalName', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='An internal name in the compiler.  You cannot create these nodes\n    yourself but the parser provides a\n    :meth:`~jinja2.parser.Parser.free_identifier` method that creates\n    a new identifier for you.  This identifier is not available from the\n    template and is not treated specially by the compiler.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='name')], ctx=Load())), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="Can't create internal names.  Use the `free_identifier` method on a parser.")], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='MarkSafe', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Mark the wrapped expression as safe (wrap it as `Markup`).')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='expr')], ctx=Load())), AnnAssign(target=Name(id='expr', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='Markup', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='Markup', ctx=Load()))], decorator_list=[]), ClassDef(name='MarkSafeIfAutoescape', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Mark the wrapped expression as safe (wrap it as `Markup`) but\n    only if autoescaping is active.\n\n    .. versionadded:: 2.5\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='expr')], ctx=Load())), AnnAssign(target=Name(id='expr', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), FunctionDef(name='as_const', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='eval_ctx', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='EvalContext', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='eval_ctx', ctx=Store())], value=Call(func=Name(id='get_eval_context', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='eval_ctx', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='volatile', ctx=Load()), body=[Raise(exc=Call(func=Name(id='Impossible', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='as_const', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='autoescape', ctx=Load()), body=[Return(value=Call(func=Name(id='Markup', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='expr', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Markup', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='ContextReference', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Returns the current template context.  It can be used like a\n    :class:`Name` node, with a ``'load'`` ctx and will return the\n    current :class:`~jinja2.runtime.Context` object.\n\n    Here an example that assigns the current template name to a\n    variable named `foo`::\n\n        Assign(Name('foo', ctx='store'),\n               Getattr(ContextReference(), 'name'))\n\n    This is basically equivalent to using the\n    :func:`~jinja2.pass_context` decorator when using the high-level\n    API, which causes a reference to the context to be passed as the\n    first argument to a function.\n    "))], decorator_list=[]), ClassDef(name='DerivedContextReference', bases=[Name(id='Expr', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Return the current template context including locals. Behaves\n    exactly like :class:`ContextReference`, but includes local\n    variables, such as from a ``for`` loop.\n\n    .. versionadded:: 2.11\n    '))], decorator_list=[]), ClassDef(name='Continue', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Continue a loop.'))], decorator_list=[]), ClassDef(name='Break', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Break a loop.'))], decorator_list=[]), ClassDef(name='Scope', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='An artificial scope.')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='body')], ctx=Load())), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='OverlayScope', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="An overlay scope for extensions.  This is a largely unoptimized scope\n    that however can be used to introduce completely arbitrary variables into\n    a sub scope from a dictionary or dictionary like object.  The `context`\n    field has to evaluate to a dictionary object.\n\n    Example usage::\n\n        OverlayScope(context=self.call_method('get_context'),\n                     body=[...])\n\n    .. versionadded:: 2.10\n    ")), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='context'), Constant(value='body')], ctx=Load())), AnnAssign(target=Name(id='context', ctx=Store()), annotation=Name(id='Expr', ctx=Load()), simple=1), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='EvalContextModifier', bases=[Name(id='Stmt', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Modifies the eval context.  For each option that should be modified,\n    a :class:`Keyword` has to be added to the :attr:`options` list.\n\n    Example to change the `autoescape` setting::\n\n        EvalContextModifier(options=[Keyword('autoescape', Const(True))])\n    ")), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='options')], ctx=Load())), AnnAssign(target=Name(id='options', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Keyword', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), ClassDef(name='ScopedEvalContextModifier', bases=[Name(id='EvalContextModifier', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Modifies the eval context and reverts it later.  Works exactly like\n    :class:`EvalContextModifier` but will only modify the\n    :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.\n    ')), Assign(targets=[Name(id='fields', ctx=Store())], value=Tuple(elts=[Constant(value='body')], ctx=Load())), AnnAssign(target=Name(id='body', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), FunctionDef(name='_failing_new', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="can't create custom node types")], keywords=[]))], decorator_list=[], returns=Constant(value='te.NoReturn')), Assign(targets=[Attribute(value=Name(id='NodeType', ctx=Load()), attr='__new__', ctx=Store())], value=Call(func=Name(id='staticmethod', ctx=Load()), args=[Name(id='_failing_new', ctx=Load())], keywords=[])), Delete(targets=[Name(id='_failing_new', ctx=Del())])], type_ignores=[])