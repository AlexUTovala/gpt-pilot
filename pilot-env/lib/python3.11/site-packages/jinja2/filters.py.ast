Module(body=[Expr(value=Constant(value='Built-in template filters used with the ``|`` operator.')), Import(names=[alias(name='math')]), Import(names=[alias(name='random')]), Import(names=[alias(name='re')]), Import(names=[alias(name='typing')]), Import(names=[alias(name='typing', asname='t')]), ImportFrom(module='collections', names=[alias(name='abc')], level=0), ImportFrom(module='itertools', names=[alias(name='chain')], level=0), ImportFrom(module='itertools', names=[alias(name='groupby')], level=0), ImportFrom(module='markupsafe', names=[alias(name='escape')], level=0), ImportFrom(module='markupsafe', names=[alias(name='Markup')], level=0), ImportFrom(module='markupsafe', names=[alias(name='soft_str')], level=0), ImportFrom(module='async_utils', names=[alias(name='async_variant')], level=1), ImportFrom(module='async_utils', names=[alias(name='auto_aiter')], level=1), ImportFrom(module='async_utils', names=[alias(name='auto_await')], level=1), ImportFrom(module='async_utils', names=[alias(name='auto_to_list')], level=1), ImportFrom(module='exceptions', names=[alias(name='FilterArgumentError')], level=1), ImportFrom(module='runtime', names=[alias(name='Undefined')], level=1), ImportFrom(module='utils', names=[alias(name='htmlsafe_json_dumps')], level=1), ImportFrom(module='utils', names=[alias(name='pass_context')], level=1), ImportFrom(module='utils', names=[alias(name='pass_environment')], level=1), ImportFrom(module='utils', names=[alias(name='pass_eval_context')], level=1), ImportFrom(module='utils', names=[alias(name='pformat')], level=1), ImportFrom(module='utils', names=[alias(name='url_quote')], level=1), ImportFrom(module='utils', names=[alias(name='urlize')], level=1), If(test=Attribute(value=Name(id='t', ctx=Load()), attr='TYPE_CHECKING', ctx=Load()), body=[Import(names=[alias(name='typing_extensions', asname='te')]), ImportFrom(module='environment', names=[alias(name='Environment')], level=1), ImportFrom(module='nodes', names=[alias(name='EvalContext')], level=1), ImportFrom(module='runtime', names=[alias(name='Context')], level=1), ImportFrom(module='sandbox', names=[alias(name='SandboxedEnvironment')], level=1), ClassDef(name='HasHTML', bases=[Attribute(value=Name(id='te', ctx=Load()), attr='Protocol', ctx=Load())], keywords=[], body=[FunctionDef(name='__html__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[])], orelse=[]), Assign(targets=[Name(id='F', ctx=Store())], value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='F')], keywords=[keyword(arg='bound', value=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))])), Assign(targets=[Name(id='K', ctx=Store())], value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='K')], keywords=[])), Assign(targets=[Name(id='V', ctx=Store())], value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='TypeVar', ctx=Load()), args=[Constant(value='V')], keywords=[])), FunctionDef(name='ignore_case', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='V', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='For use as a postprocessor for :func:`make_attrgetter`. Converts strings\n    to lowercase and returns other types as-is.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='V', ctx=Load()), Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='value', ctx=Load()))], decorator_list=[], returns=Name(id='V', ctx=Load())), FunctionDef(name='make_attrgetter', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='postprocess', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='default', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Returns a callable that looks up the given attribute from a\n    passed object with the rules of the environment.  Dots are allowed\n    to access attributes of attributes.  Integer parts in paths are\n    looked up as integers.\n    ')), Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Name(id='_prepare_attribute_parts', ctx=Load()), args=[Name(id='attribute', ctx=Load())], keywords=[])), FunctionDef(name='attrgetter', args=arguments(posonlyargs=[], args=[arg(arg='item', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='part', ctx=Store()), iter=Name(id='parts', ctx=Load()), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='environment', ctx=Load()), attr='getitem', ctx=Load()), args=[Name(id='item', ctx=Load()), Name(id='part', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='default', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='item', ctx=Load()), Name(id='Undefined', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Name(id='default', ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='postprocess', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Name(id='postprocess', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='item', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), Return(value=Name(id='attrgetter', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='make_multi_attrgetter', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='postprocess', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Returns a callable that looks up the given comma separated\n    attributes from a passed object with the rules of the environment.\n    Dots are allowed to access attributes of each attribute.  Integer\n    parts in paths are looked up as integers.\n\n    The value returned by the returned callable is a list of extracted\n    attribute values.\n\n    Examples of attribute: "attr1,attr2", "attr1.inner1.0,attr2.inner2.0", etc.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='attribute', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[AnnAssign(target=Name(id='split', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Sequence', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='attribute', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',')], keywords=[]), simple=1)], orelse=[Assign(targets=[Name(id='split', ctx=Store())], value=List(elts=[Name(id='attribute', ctx=Load())], ctx=Load()))]), Assign(targets=[Name(id='parts', ctx=Store())], value=ListComp(elt=Call(func=Name(id='_prepare_attribute_parts', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='split', ctx=Load()), ifs=[], is_async=0)])), FunctionDef(name='attrgetter', args=arguments(posonlyargs=[], args=[arg(arg='item', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='items', ctx=Store())], value=BinOp(left=List(elts=[Constant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]))), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='attribute_part', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='item_i', ctx=Store())], value=Name(id='item', ctx=Load())), For(target=Name(id='part', ctx=Store()), iter=Name(id='attribute_part', ctx=Load()), body=[Assign(targets=[Name(id='item_i', ctx=Store())], value=Call(func=Attribute(value=Name(id='environment', ctx=Load()), attr='getitem', ctx=Load()), args=[Name(id='item_i', ctx=Load()), Name(id='part', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='postprocess', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='item_i', ctx=Store())], value=Call(func=Name(id='postprocess', ctx=Load()), args=[Name(id='item_i', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='items', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store())], value=Name(id='item_i', ctx=Load()))], orelse=[]), Return(value=Name(id='items', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load())), Return(value=Name(id='attrgetter', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_prepare_attribute_parts', args=arguments(posonlyargs=[], args=[arg(arg='attr', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='attr', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='attr', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Return(value=ListComp(elt=IfExp(test=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[]), body=Call(func=Name(id='int', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), orelse=Name(id='x', ctx=Load())), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='attr', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]), ifs=[], is_async=0)]))], orelse=[]), Return(value=List(elts=[Name(id='attr', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='do_forceescape', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Constant(value='t.Union[str, HasHTML]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Enforce HTML escaping.  This will probably double escape variables.')), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='value', ctx=Load()), Constant(value='__html__')], keywords=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='cast', ctx=Load()), args=[Constant(value='HasHTML'), Name(id='value', ctx=Load())], keywords=[]), attr='__html__', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='escape', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='Markup', ctx=Load())), FunctionDef(name='do_urlencode', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Quote data for use in a URL path or query using UTF-8.\n\n    Basic wrapper around :func:`urllib.parse.quote` when given a\n    string, or :func:`urllib.parse.urlencode` for a dict or iterable.\n\n    :param value: Data to quote. A string will be quoted directly. A\n        dict or iterable of ``(key, value)`` pairs will be joined as a\n        query string.\n\n    When given a string, "/" is not quoted. HTTP servers treat "/" and\n    "%2F" equivalently in paths. If you need quoted slashes, use the\n    ``|replace("/", "%2F")`` filter.\n\n    .. versionadded:: 2.7\n    ')), If(test=BoolOp(op=Or(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='abc', ctx=Load()), attr='Iterable', ctx=Load())], keywords=[]))]), body=[Return(value=Call(func=Name(id='url_quote', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[AnnAssign(target=Name(id='items', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), simple=1)], orelse=[Assign(targets=[Name(id='items', ctx=Store())], value=Name(id='value', ctx=Load()))]), Return(value=Call(func=Attribute(value=Constant(value='&'), attr='join', ctx=Load()), args=[GeneratorExp(elt=JoinedStr(values=[FormattedValue(value=Call(func=Name(id='url_quote', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[keyword(arg='for_qs', value=Constant(value=True))]), conversion=-1), Constant(value='='), FormattedValue(value=Call(func=Name(id='url_quote', ctx=Load()), args=[Name(id='v', ctx=Load())], keywords=[keyword(arg='for_qs', value=Constant(value=True))]), conversion=-1)]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Name(id='items', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_replace', args=arguments(posonlyargs=[], args=[arg(arg='eval_ctx', annotation=Constant(value='EvalContext')), arg(arg='s', annotation=Name(id='str', ctx=Load())), arg(arg='old', annotation=Name(id='str', ctx=Load())), arg(arg='new', annotation=Name(id='str', ctx=Load())), arg(arg='count', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return a copy of the value with all occurrences of a substring\n    replaced with a new one. The first argument is the substring\n    that should be replaced, the second is the replacement string.\n    If the optional third argument ``count`` is given, only the first\n    ``count`` occurrences are replaced:\n\n    .. sourcecode:: jinja\n\n        {{ "Hello World"|replace("Hello", "Goodbye") }}\n            -> Goodbye World\n\n        {{ "aaaaargh"|replace("a", "d\'oh, ", 2) }}\n            -> d\'oh, d\'oh, aaargh\n    ')), If(test=Compare(left=Name(id='count', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='count', ctx=Store())], value=UnaryOp(op=USub(), operand=Constant(value=1)))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='autoescape', ctx=Load())), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), attr='replace', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='old', ctx=Load())], keywords=[]), Call(func=Name(id='str', ctx=Load()), args=[Name(id='new', ctx=Load())], keywords=[]), Name(id='count', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=Or(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='old', ctx=Load()), Constant(value='__html__')], keywords=[]), BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='new', ctx=Load()), Constant(value='__html__')], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='s', ctx=Load()), Constant(value='__html__')], keywords=[]))])]), body=[Assign(targets=[Name(id='s', ctx=Store())], value=Call(func=Name(id='escape', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='s', ctx=Store())], value=Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]))]), Return(value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='replace', ctx=Load()), args=[Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='old', ctx=Load())], keywords=[]), Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='new', ctx=Load())], keywords=[]), Name(id='count', ctx=Load())], keywords=[]))], decorator_list=[Name(id='pass_eval_context', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_upper', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Convert a value to uppercase.')), Return(value=Call(func=Attribute(value=Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), attr='upper', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_lower', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Convert a value to lowercase.')), Return(value=Call(func=Attribute(value=Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_items', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='K', ctx=Load()), Name(id='V', ctx=Load())], ctx=Load()), ctx=Load()), Name(id='Undefined', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return an iterator over the ``(key, value)`` items of a mapping.\n\n    ``x|items`` is the same as ``x.items()``, except if ``x`` is\n    undefined an empty iterator is returned.\n\n    This filter is useful if you expect the template to be rendered with\n    an implementation of Jinja in another programming language that does\n    not have a ``.items()`` method on its mapping type.\n\n    .. code-block:: html+jinja\n\n        <dl>\n        {% for key, value in my_dict|items %}\n            <dt>{{ key }}\n            <dd>{{ value }}\n        {% endfor %}\n        </dl>\n\n    .. versionadded:: 3.1\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='Undefined', ctx=Load())], keywords=[]), body=[Return()], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='abc', ctx=Load()), attr='Mapping', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Can only get item pairs from a mapping.')], keywords=[]))], orelse=[]), Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='K', ctx=Load()), Name(id='V', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='do_xmlattr', args=arguments(posonlyargs=[], args=[arg(arg='eval_ctx', annotation=Constant(value='EvalContext')), arg(arg='d', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='autospace', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Create an SGML/XML attribute string based on the items in a dict.\n    All values that are neither `none` nor `undefined` are automatically\n    escaped:\n\n    .. sourcecode:: html+jinja\n\n        <ul{{ {\'class\': \'my_list\', \'missing\': none,\n                \'id\': \'list-%d\'|format(variable)}|xmlattr }}>\n        ...\n        </ul>\n\n    Results in something like this:\n\n    .. sourcecode:: html\n\n        <ul class="my_list" id="list-42">\n        ...\n        </ul>\n\n    As you can see it automatically prepends a space in front of the item\n    if the filter returned something unless the second parameter is false.\n    ')), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[GeneratorExp(elt=JoinedStr(values=[FormattedValue(value=Call(func=Name(id='escape', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]), conversion=-1), Constant(value='="'), FormattedValue(value=Call(func=Name(id='escape', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), conversion=-1), Constant(value='"')]), generators=[comprehension(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='d', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[BoolOp(op=And(), values=[Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='Undefined', ctx=Load())], keywords=[]))])], is_async=0)])], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='autospace', ctx=Load()), Name(id='rv', ctx=Load())]), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=BinOp(left=Constant(value=' '), op=Add(), right=Name(id='rv', ctx=Load())))], orelse=[]), If(test=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='autoescape', ctx=Load()), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Name(id='Markup', ctx=Load()), args=[Name(id='rv', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='rv', ctx=Load()))], decorator_list=[Name(id='pass_eval_context', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_capitalize', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Capitalize a value. The first character will be uppercase, all others\n    lowercase.\n    ')), Return(value=Call(func=Attribute(value=Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), attr='capitalize', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), Assign(targets=[Name(id='_word_beginning_split_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='([-\\s({\\[<]+)')], keywords=[])), FunctionDef(name='do_title', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a titlecased version of the value. I.e. words will start with\n    uppercase letters, all remaining characters are lowercase.\n    ')), Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[ListComp(elt=BinOp(left=Call(func=Attribute(value=Subscript(value=Name(id='item', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Attribute(value=Subscript(value=Name(id='item', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Call(func=Attribute(value=Name(id='_word_beginning_split_re', ctx=Load()), attr='split', ctx=Load()), args=[Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[])], keywords=[]), ifs=[Name(id='item', ctx=Load())], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_dictsort', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='K', ctx=Load()), Name(id='V', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='case_sensitive', annotation=Name(id='bool', ctx=Load())), arg(arg='by', annotation=Constant(value='te.Literal["key", "value"]')), arg(arg='reverse', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value='key'), Constant(value=False)]), body=[Expr(value=Constant(value="Sort a dict and yield (key, value) pairs. Python dicts may not\n    be in the order you want to display them in, so sort them first.\n\n    .. sourcecode:: jinja\n\n        {% for key, value in mydict|dictsort %}\n            sort the dict by key, case insensitive\n\n        {% for key, value in mydict|dictsort(reverse=true) %}\n            sort the dict by key, case insensitive, reverse order\n\n        {% for key, value in mydict|dictsort(true) %}\n            sort the dict by key, case sensitive\n\n        {% for key, value in mydict|dictsort(false, 'value') %}\n            sort the dict by value, case insensitive\n    ")), If(test=Compare(left=Name(id='by', ctx=Load()), ops=[Eq()], comparators=[Constant(value='key')]), body=[Assign(targets=[Name(id='pos', ctx=Store())], value=Constant(value=0))], orelse=[If(test=Compare(left=Name(id='by', ctx=Load()), ops=[Eq()], comparators=[Constant(value='value')]), body=[Assign(targets=[Name(id='pos', ctx=Store())], value=Constant(value=1))], orelse=[Raise(exc=Call(func=Name(id='FilterArgumentError', ctx=Load()), args=[Constant(value='You can only sort by either "key" or "value"')], keywords=[]))])]), FunctionDef(name='sort_func', args=arguments(posonlyargs=[], args=[arg(arg='item', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Subscript(value=Name(id='item', ctx=Load()), slice=Name(id='pos', ctx=Load()), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='case_sensitive', ctx=Load())), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='ignore_case', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='value', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='sort_func', ctx=Load())), keyword(arg='reverse', value=Name(id='reverse', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='K', ctx=Load()), Name(id='V', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='do_sort', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='value', annotation=Constant(value='t.Iterable[V]')), arg(arg='reverse', annotation=Name(id='bool', ctx=Load())), arg(arg='case_sensitive', annotation=Name(id='bool', ctx=Load())), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='Sort an iterable using Python\'s :func:`sorted`.\n\n    .. sourcecode:: jinja\n\n        {% for city in cities|sort %}\n            ...\n        {% endfor %}\n\n    :param reverse: Sort descending instead of ascending.\n    :param case_sensitive: When sorting strings, sort upper and lower\n        case separately.\n    :param attribute: When sorting objects or dicts, an attribute or\n        key to sort by. Can use dot notation like ``"address.city"``.\n        Can be a list of attributes like ``"age,name"``.\n\n    The sort is stable, it does not change the relative order of\n    elements that compare equal. This makes it is possible to chain\n    sorts on different attributes and ordering.\n\n    .. sourcecode:: jinja\n\n        {% for user in users|sort(attribute="name")\n            |sort(reverse=true, attribute="age") %}\n            ...\n        {% endfor %}\n\n    As a shortcut to chaining when the direction is the same for all\n    attributes, pass a comma separate list of attributes.\n\n    .. sourcecode:: jinja\n\n        {% for user in users|sort(attribute="age,name") %}\n            ...\n        {% endfor %}\n\n    .. versionchanged:: 2.11.0\n        The ``attribute`` parameter can be a comma separated list of\n        attributes, e.g. ``"age,name"``.\n\n    .. versionchanged:: 2.6\n       The ``attribute`` parameter was added.\n    ')), Assign(targets=[Name(id='key_func', ctx=Store())], value=Call(func=Name(id='make_multi_attrgetter', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[keyword(arg='postprocess', value=IfExp(test=UnaryOp(op=Not(), operand=Name(id='case_sensitive', ctx=Load())), body=Name(id='ignore_case', ctx=Load()), orelse=Constant(value=None)))])), Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[keyword(arg='key', value=Name(id='key_func', ctx=Load())), keyword(arg='reverse', value=Name(id='reverse', ctx=Load()))]))], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Constant(value='t.List[V]')), FunctionDef(name='do_unique', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='value', annotation=Constant(value='t.Iterable[V]')), arg(arg='case_sensitive', annotation=Name(id='bool', ctx=Load())), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value="Returns a list of unique items from the given iterable.\n\n    .. sourcecode:: jinja\n\n        {{ ['foo', 'bar', 'foobar', 'FooBar']|unique|list }}\n            -> ['foo', 'bar', 'foobar']\n\n    The unique items are yielded in the same order as their first occurrence in\n    the iterable passed to the filter.\n\n    :param case_sensitive: Treat upper and lower case strings as distinct.\n    :param attribute: Filter objects with unique values for this attribute.\n    ")), Assign(targets=[Name(id='getter', ctx=Store())], value=Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[keyword(arg='postprocess', value=IfExp(test=UnaryOp(op=Not(), operand=Name(id='case_sensitive', ctx=Load())), body=Name(id='ignore_case', ctx=Load()), orelse=Constant(value=None)))])), Assign(targets=[Name(id='seen', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Name(id='item', ctx=Store()), iter=Name(id='value', ctx=Load()), body=[Assign(targets=[Name(id='key', ctx=Store())], value=Call(func=Name(id='getter', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='key', ctx=Load()), ops=[NotIn()], comparators=[Name(id='seen', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[])), Expr(value=Yield(value=Name(id='item', ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Constant(value='t.Iterator[V]')), FunctionDef(name='_min_or_max', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='value', annotation=Constant(value='t.Iterable[V]')), arg(arg='func', annotation=Constant(value='t.Callable[..., V]')), arg(arg='case_sensitive', annotation=Name(id='bool', ctx=Load())), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='first', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='environment', ctx=Load()), attr='undefined', ctx=Load()), args=[Constant(value='No aggregated item, sequence was empty.')], keywords=[]))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='key_func', ctx=Store())], value=Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[keyword(arg='postprocess', value=IfExp(test=UnaryOp(op=Not(), operand=Name(id='case_sensitive', ctx=Load())), body=Name(id='ignore_case', ctx=Load()), orelse=Constant(value=None)))])), Return(value=Call(func=Name(id='func', ctx=Load()), args=[Call(func=Name(id='chain', ctx=Load()), args=[List(elts=[Name(id='first', ctx=Load())], ctx=Load()), Name(id='it', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Name(id='key_func', ctx=Load()))]))], decorator_list=[], returns=Constant(value='t.Union[V, Undefined]')), FunctionDef(name='do_min', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='value', annotation=Constant(value='t.Iterable[V]')), arg(arg='case_sensitive', annotation=Name(id='bool', ctx=Load())), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='Return the smallest item from the sequence.\n\n    .. sourcecode:: jinja\n\n        {{ [1, 2, 3]|min }}\n            -> 1\n\n    :param case_sensitive: Treat upper and lower case strings as distinct.\n    :param attribute: Get the object with the min value of this attribute.\n    ')), Return(value=Call(func=Name(id='_min_or_max', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='value', ctx=Load()), Name(id='min', ctx=Load()), Name(id='case_sensitive', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]))], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Constant(value='t.Union[V, Undefined]')), FunctionDef(name='do_max', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='value', annotation=Constant(value='t.Iterable[V]')), arg(arg='case_sensitive', annotation=Name(id='bool', ctx=Load())), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='Return the largest item from the sequence.\n\n    .. sourcecode:: jinja\n\n        {{ [1, 2, 3]|max }}\n            -> 3\n\n    :param case_sensitive: Treat upper and lower case strings as distinct.\n    :param attribute: Get the object with the max value of this attribute.\n    ')), Return(value=Call(func=Name(id='_min_or_max', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='value', ctx=Load()), Name(id='max', ctx=Load()), Name(id='case_sensitive', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]))], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Constant(value='t.Union[V, Undefined]')), FunctionDef(name='do_default', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='V', ctx=Load())), arg(arg='default_value', annotation=Name(id='V', ctx=Load())), arg(arg='boolean', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=False)]), body=[Expr(value=Constant(value="If the value is undefined it will return the passed default value,\n    otherwise the value of the variable:\n\n    .. sourcecode:: jinja\n\n        {{ my_variable|default('my_variable is not defined') }}\n\n    This will output the value of ``my_variable`` if the variable was\n    defined, otherwise ``'my_variable is not defined'``. If you want\n    to use default with variables that evaluate to false you have to\n    set the second parameter to `true`:\n\n    .. sourcecode:: jinja\n\n        {{ ''|default('the string was empty', true) }}\n\n    .. versionchanged:: 2.11\n       It's now possible to configure the :class:`~jinja2.Environment` with\n       :class:`~jinja2.ChainableUndefined` to make the `default` filter work\n       on nested elements and attributes that may contain undefined values\n       in the chain without getting an :exc:`~jinja2.UndefinedError`.\n    ")), If(test=BoolOp(op=Or(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='Undefined', ctx=Load())], keywords=[]), BoolOp(op=And(), values=[Name(id='boolean', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='value', ctx=Load()))])]), body=[Return(value=Name(id='default_value', ctx=Load()))], orelse=[]), Return(value=Name(id='value', ctx=Load()))], decorator_list=[], returns=Name(id='V', ctx=Load())), FunctionDef(name='sync_do_join', args=arguments(posonlyargs=[], args=[arg(arg='eval_ctx', annotation=Constant(value='EvalContext')), arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())), arg(arg='d', annotation=Name(id='str', ctx=Load())), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=None)]), body=[Expr(value=Constant(value="Return a string which is the concatenation of the strings in the\n    sequence. The separator between elements is an empty string per\n    default, you can define it with the optional parameter:\n\n    .. sourcecode:: jinja\n\n        {{ [1, 2, 3]|join('|') }}\n            -> 1|2|3\n\n        {{ [1, 2, 3]|join }}\n            -> 123\n\n    It is also possible to join certain attributes of an object:\n\n    .. sourcecode:: jinja\n\n        {{ users|join(', ', attribute='username') }}\n\n    .. versionadded:: 2.6\n       The `attribute` parameter was added.\n    ")), If(test=Compare(left=Name(id='attribute', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]), Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='autoescape', ctx=Load())), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='d', ctx=Load())], keywords=[]), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='d', ctx=Load()), Constant(value='__html__')], keywords=[])), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Assign(targets=[Name(id='do_escape', ctx=Store())], value=Constant(value=False)), For(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='item', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='item', ctx=Load()), Constant(value='__html__')], keywords=[]), body=[Assign(targets=[Name(id='do_escape', ctx=Store())], value=Constant(value=True))], orelse=[Assign(targets=[Subscript(value=Name(id='value', ctx=Load()), slice=Name(id='idx', ctx=Load()), ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))])], orelse=[]), If(test=Name(id='do_escape', ctx=Load()), body=[Assign(targets=[Name(id='d', ctx=Store())], value=Call(func=Name(id='escape', ctx=Load()), args=[Name(id='d', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='d', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='d', ctx=Load())], keywords=[]))]), Return(value=Call(func=Attribute(value=Name(id='d', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='d', ctx=Load())], keywords=[]), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='soft_str', ctx=Load()), Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='pass_eval_context', ctx=Load())], returns=Name(id='str', ctx=Load())), AsyncFunctionDef(name='do_join', args=arguments(posonlyargs=[], args=[arg(arg='eval_ctx', annotation=Constant(value='EvalContext')), arg(arg='value', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='AsyncIterable', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='d', annotation=Name(id='str', ctx=Load())), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=None)]), body=[Return(value=Call(func=Name(id='sync_do_join', ctx=Load()), args=[Name(id='eval_ctx', ctx=Load()), Await(value=Call(func=Name(id='auto_to_list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Name(id='d', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_join', ctx=Load())], keywords=[])], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_center', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='width', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=80)]), body=[Expr(value=Constant(value='Centers the value in a field of a given width.')), Return(value=Call(func=Attribute(value=Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), attr='center', ctx=Load()), args=[Name(id='width', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='sync_do_first', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='seq', annotation=Constant(value='t.Iterable[V]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the first item of a sequence.')), Try(body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='environment', ctx=Load()), attr='undefined', ctx=Load()), args=[Constant(value='No first item, sequence was empty.')], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Constant(value='t.Union[V, Undefined]')), AsyncFunctionDef(name='do_first', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='seq', annotation=Constant(value='t.Union[t.AsyncIterable[V], t.Iterable[V]]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Await(value=Call(func=Attribute(value=Call(func=Name(id='auto_aiter', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[]), attr='__anext__', ctx=Load()), args=[], keywords=[])))], handlers=[ExceptHandler(type=Name(id='StopAsyncIteration', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='environment', ctx=Load()), attr='undefined', ctx=Load()), args=[Constant(value='No first item, sequence was empty.')], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_first', ctx=Load())], keywords=[])], returns=Constant(value='t.Union[V, Undefined]')), FunctionDef(name='do_last', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='seq', annotation=Constant(value='t.Reversible[V]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the last item of a sequence.\n\n    Note: Does not work with generators. You may want to explicitly\n    convert it to a list:\n\n    .. sourcecode:: jinja\n\n        {{ data | selectattr('name', '==', 'Jinja') | list | last }}\n    ")), Try(body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='environment', ctx=Load()), attr='undefined', ctx=Load()), args=[Constant(value='No last item, sequence was empty.')], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Constant(value='t.Union[V, Undefined]')), FunctionDef(name='do_random', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='seq', annotation=Constant(value='t.Sequence[V]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a random item from the sequence.')), Try(body=[Return(value=Call(func=Attribute(value=Name(id='random', ctx=Load()), attr='choice', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='context', ctx=Load()), attr='environment', ctx=Load()), attr='undefined', ctx=Load()), args=[Constant(value='No random item, sequence was empty.')], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[Name(id='pass_context', ctx=Load())], returns=Constant(value='t.Union[V, Undefined]')), FunctionDef(name='do_filesizeformat', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='binary', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value="Format the value like a 'human-readable' file size (i.e. 13 kB,\n    4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega,\n    Giga, etc.), if the second parameter is set to `True` the binary\n    prefixes are used (Mebi, Gibi).\n    ")), Assign(targets=[Name(id='bytes', ctx=Store())], value=Call(func=Name(id='float', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Assign(targets=[Name(id='base', ctx=Store())], value=IfExp(test=Name(id='binary', ctx=Load()), body=Constant(value=1024), orelse=Constant(value=1000))), Assign(targets=[Name(id='prefixes', ctx=Store())], value=List(elts=[IfExp(test=Name(id='binary', ctx=Load()), body=Constant(value='KiB'), orelse=Constant(value='kB')), IfExp(test=Name(id='binary', ctx=Load()), body=Constant(value='MiB'), orelse=Constant(value='MB')), IfExp(test=Name(id='binary', ctx=Load()), body=Constant(value='GiB'), orelse=Constant(value='GB')), IfExp(test=Name(id='binary', ctx=Load()), body=Constant(value='TiB'), orelse=Constant(value='TB')), IfExp(test=Name(id='binary', ctx=Load()), body=Constant(value='PiB'), orelse=Constant(value='PB')), IfExp(test=Name(id='binary', ctx=Load()), body=Constant(value='EiB'), orelse=Constant(value='EB')), IfExp(test=Name(id='binary', ctx=Load()), body=Constant(value='ZiB'), orelse=Constant(value='ZB')), IfExp(test=Name(id='binary', ctx=Load()), body=Constant(value='YiB'), orelse=Constant(value='YB'))], ctx=Load())), If(test=Compare(left=Name(id='bytes', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Constant(value='1 Byte'))], orelse=[If(test=Compare(left=Name(id='bytes', ctx=Load()), ops=[Lt()], comparators=[Name(id='base', ctx=Load())]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='bytes', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' Bytes')]))], orelse=[For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='prefix', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='prefixes', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='unit', ctx=Store())], value=BinOp(left=Name(id='base', ctx=Load()), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=2)))), If(test=Compare(left=Name(id='bytes', ctx=Load()), ops=[Lt()], comparators=[Name(id='unit', ctx=Load())]), body=[Return(value=JoinedStr(values=[FormattedValue(value=BinOp(left=BinOp(left=Name(id='base', ctx=Load()), op=Mult(), right=Name(id='bytes', ctx=Load())), op=Div(), right=Name(id='unit', ctx=Load())), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.1f')])), Constant(value=' '), FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1)]))], orelse=[])], orelse=[]), Return(value=JoinedStr(values=[FormattedValue(value=BinOp(left=BinOp(left=Name(id='base', ctx=Load()), op=Mult(), right=Name(id='bytes', ctx=Load())), op=Div(), right=Name(id='unit', ctx=Load())), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.1f')])), Constant(value=' '), FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1)]))])])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_pprint', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Pretty print a variable. Useful for debugging.')), Return(value=Call(func=Name(id='pformat', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), Assign(targets=[Name(id='_uri_scheme_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^([\\w.+-]{2,}:(/){0,2})$')], keywords=[])), FunctionDef(name='do_urlize', args=arguments(posonlyargs=[], args=[arg(arg='eval_ctx', annotation=Constant(value='EvalContext')), arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='trim_url_limit', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='nofollow', annotation=Name(id='bool', ctx=Load())), arg(arg='target', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='rel', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='extra_schemes', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Convert URLs in text into clickable links.\n\n    This may not recognize links in some situations. Usually, a more\n    comprehensive formatter, such as a Markdown library, is a better\n    choice.\n\n    Works on ``http://``, ``https://``, ``www.``, ``mailto:``, and email\n    addresses. Links with trailing punctuation (periods, commas, closing\n    parentheses) and leading punctuation (opening parentheses) are\n    recognized excluding the punctuation. Email addresses that include\n    header fields are not recognized (for example,\n    ``mailto:address@example.com?cc=copy@example.com``).\n\n    :param value: Original text containing URLs to link.\n    :param trim_url_limit: Shorten displayed URL values to this length.\n    :param nofollow: Add the ``rel=nofollow`` attribute to links.\n    :param target: Add the ``target`` attribute to links.\n    :param rel: Add the ``rel`` attribute to links.\n    :param extra_schemes: Recognize URLs that start with these schemes\n        in addition to the default behavior. Defaults to\n        ``env.policies["urlize.extra_schemes"]``, which defaults to no\n        extra schemes.\n\n    .. versionchanged:: 3.0\n        The ``extra_schemes`` parameter was added.\n\n    .. versionchanged:: 3.0\n        Generate ``https://`` links for URLs without a scheme.\n\n    .. versionchanged:: 3.0\n        The parsing rules were updated. Recognize email addresses with\n        or without the ``mailto:`` scheme. Validate IP addresses. Ignore\n        parentheses and brackets in more cases.\n\n    .. versionchanged:: 2.8\n       The ``target`` parameter was added.\n    ')), Assign(targets=[Name(id='policies', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='policies', ctx=Load())), Assign(targets=[Name(id='rel_parts', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=BoolOp(op=Or(), values=[Name(id='rel', ctx=Load()), Constant(value='')]), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Name(id='nofollow', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='rel_parts', ctx=Load()), attr='add', ctx=Load()), args=[Constant(value='nofollow')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='rel_parts', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=BoolOp(op=Or(), values=[Subscript(value=Name(id='policies', ctx=Load()), slice=Constant(value='urlize.rel'), ctx=Load()), Constant(value='')]), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='rel', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='rel_parts', ctx=Load())], keywords=[])], keywords=[]), Constant(value=None)])), If(test=Compare(left=Name(id='target', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='target', ctx=Store())], value=Subscript(value=Name(id='policies', ctx=Load()), slice=Constant(value='urlize.target'), ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='extra_schemes', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='extra_schemes', ctx=Store())], value=BoolOp(op=Or(), values=[Subscript(value=Name(id='policies', ctx=Load()), slice=Constant(value='urlize.extra_schemes'), ctx=Load()), Tuple(elts=[], ctx=Load())]))], orelse=[]), For(target=Name(id='scheme', ctx=Store()), iter=Name(id='extra_schemes', ctx=Load()), body=[If(test=Compare(left=Call(func=Attribute(value=Name(id='_uri_scheme_re', ctx=Load()), attr='fullmatch', ctx=Load()), args=[Name(id='scheme', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='FilterArgumentError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='scheme', ctx=Load()), conversion=114), Constant(value=' is not a valid URI scheme prefix.')])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Name(id='urlize', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[keyword(arg='trim_url_limit', value=Name(id='trim_url_limit', ctx=Load())), keyword(arg='rel', value=Name(id='rel', ctx=Load())), keyword(arg='target', value=Name(id='target', ctx=Load())), keyword(arg='extra_schemes', value=Name(id='extra_schemes', ctx=Load()))])), If(test=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='autoescape', ctx=Load()), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Name(id='Markup', ctx=Load()), args=[Name(id='rv', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='rv', ctx=Load()))], decorator_list=[Name(id='pass_eval_context', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_indent', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Name(id='str', ctx=Load())), arg(arg='width', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='first', annotation=Name(id='bool', ctx=Load())), arg(arg='blank', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=4), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value="Return a copy of the string with each line indented by 4 spaces. The\n    first line and blank lines are not indented by default.\n\n    :param width: Number of spaces, or a string, to indent by.\n    :param first: Don't skip indenting the first line.\n    :param blank: Don't skip indenting empty lines.\n\n    .. versionchanged:: 3.0\n        ``width`` can be a string.\n\n    .. versionchanged:: 2.10\n        Blank lines are not indented by default.\n\n        Rename the ``indentfirst`` argument to ``first``.\n    ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='width', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='indention', ctx=Store())], value=Name(id='width', ctx=Load()))], orelse=[Assign(targets=[Name(id='indention', ctx=Store())], value=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='width', ctx=Load())))]), Assign(targets=[Name(id='newline', ctx=Store())], value=Constant(value='\n')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='Markup', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='indention', ctx=Store())], value=Call(func=Name(id='Markup', ctx=Load()), args=[Name(id='indention', ctx=Load())], keywords=[])), Assign(targets=[Name(id='newline', ctx=Store())], value=Call(func=Name(id='Markup', ctx=Load()), args=[Name(id='newline', ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Name(id='s', ctx=Store()), op=Add(), value=Name(id='newline', ctx=Load())), If(test=Name(id='blank', ctx=Load()), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=Name(id='newline', ctx=Load()), op=Add(), right=Name(id='indention', ctx=Load())), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value=0)], keywords=[])), If(test=Name(id='lines', ctx=Load()), body=[AugAssign(target=Name(id='rv', ctx=Store()), op=Add(), value=BinOp(left=Name(id='newline', ctx=Load()), op=Add(), right=Call(func=Attribute(value=Name(id='newline', ctx=Load()), attr='join', ctx=Load()), args=[GeneratorExp(elt=IfExp(test=Name(id='line', ctx=Load()), body=BinOp(left=Name(id='indention', ctx=Load()), op=Add(), right=Name(id='line', ctx=Load())), orelse=Name(id='line', ctx=Load())), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))], orelse=[])]), If(test=Name(id='first', ctx=Load()), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=BinOp(left=Name(id='indention', ctx=Load()), op=Add(), right=Name(id='rv', ctx=Load())))], orelse=[]), Return(value=Name(id='rv', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_truncate', args=arguments(posonlyargs=[], args=[arg(arg='env', annotation=Constant(value='Environment')), arg(arg='s', annotation=Name(id='str', ctx=Load())), arg(arg='length', annotation=Name(id='int', ctx=Load())), arg(arg='killwords', annotation=Name(id='bool', ctx=Load())), arg(arg='end', annotation=Name(id='str', ctx=Load())), arg(arg='leeway', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=255), Constant(value=False), Constant(value='...'), Constant(value=None)]), body=[Expr(value=Constant(value='Return a truncated copy of the string. The length is specified\n    with the first parameter which defaults to ``255``. If the second\n    parameter is ``true`` the filter will cut the text at length. Otherwise\n    it will discard the last word. If the text was in fact\n    truncated it will append an ellipsis sign (``"..."``). If you want a\n    different ellipsis sign than ``"..."`` you can specify it using the\n    third parameter. Strings that only exceed the length by the tolerance\n    margin given in the fourth parameter will not be truncated.\n\n    .. sourcecode:: jinja\n\n        {{ "foo bar baz qux"|truncate(9) }}\n            -> "foo..."\n        {{ "foo bar baz qux"|truncate(9, True) }}\n            -> "foo ba..."\n        {{ "foo bar baz qux"|truncate(11) }}\n            -> "foo bar baz qux"\n        {{ "foo bar baz qux"|truncate(11, False, \'...\', 0) }}\n            -> "foo bar..."\n\n    The default leeway on newer Jinja versions is 5 and was 0 before but\n    can be reconfigured globally.\n    ')), If(test=Compare(left=Name(id='leeway', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='leeway', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='env', ctx=Load()), attr='policies', ctx=Load()), slice=Constant(value='truncate.leeway'), ctx=Load()))], orelse=[]), Assert(test=Compare(left=Name(id='length', ctx=Load()), ops=[GtE()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='end', ctx=Load())], keywords=[])]), msg=JoinedStr(values=[Constant(value='expected length >= '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='end', ctx=Load())], keywords=[]), conversion=-1), Constant(value=', got '), FormattedValue(value=Name(id='length', ctx=Load()), conversion=-1)])), Assert(test=Compare(left=Name(id='leeway', ctx=Load()), ops=[GtE()], comparators=[Constant(value=0)]), msg=JoinedStr(values=[Constant(value='expected leeway >= 0, got '), FormattedValue(value=Name(id='leeway', ctx=Load()), conversion=-1)])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), ops=[LtE()], comparators=[BinOp(left=Name(id='length', ctx=Load()), op=Add(), right=Name(id='leeway', ctx=Load()))]), body=[Return(value=Name(id='s', ctx=Load()))], orelse=[]), If(test=Name(id='killwords', ctx=Load()), body=[Return(value=BinOp(left=Subscript(value=Name(id='s', ctx=Load()), slice=Slice(upper=BinOp(left=Name(id='length', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='end', ctx=Load())], keywords=[]))), ctx=Load()), op=Add(), right=Name(id='end', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Name(id='s', ctx=Load()), slice=Slice(upper=BinOp(left=Name(id='length', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='end', ctx=Load())], keywords=[]))), ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value=' '), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load())), Return(value=BinOp(left=Name(id='result', ctx=Load()), op=Add(), right=Name(id='end', ctx=Load())))], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_wordwrap', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='s', annotation=Name(id='str', ctx=Load())), arg(arg='width', annotation=Name(id='int', ctx=Load())), arg(arg='break_long_words', annotation=Name(id='bool', ctx=Load())), arg(arg='wrapstring', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='break_on_hyphens', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=79), Constant(value=True), Constant(value=None), Constant(value=True)]), body=[Expr(value=Constant(value='Wrap a string to the given width. Existing newlines are treated\n    as paragraphs to be wrapped separately.\n\n    :param s: Original text to wrap.\n    :param width: Maximum length of wrapped lines.\n    :param break_long_words: If a word is longer than ``width``, break\n        it across lines.\n    :param break_on_hyphens: If a word contains hyphens, it may be split\n        across lines.\n    :param wrapstring: String to join each wrapped line. Defaults to\n        :attr:`Environment.newline_sequence`.\n\n    .. versionchanged:: 2.11\n        Existing newlines are treated as paragraphs wrapped separately.\n\n    .. versionchanged:: 2.11\n        Added the ``break_on_hyphens`` parameter.\n\n    .. versionchanged:: 2.7\n        Added the ``wrapstring`` parameter.\n    ')), Import(names=[alias(name='textwrap')]), If(test=Compare(left=Name(id='wrapstring', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='wrapstring', ctx=Store())], value=Attribute(value=Name(id='environment', ctx=Load()), attr='newline_sequence', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='wrapstring', ctx=Load()), attr='join', ctx=Load()), args=[ListComp(elt=Call(func=Attribute(value=Name(id='wrapstring', ctx=Load()), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='textwrap', ctx=Load()), attr='wrap', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[keyword(arg='width', value=Name(id='width', ctx=Load())), keyword(arg='expand_tabs', value=Constant(value=False)), keyword(arg='replace_whitespace', value=Constant(value=False)), keyword(arg='break_long_words', value=Name(id='break_long_words', ctx=Load())), keyword(arg='break_on_hyphens', value=Name(id='break_on_hyphens', ctx=Load()))])], keywords=[]), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Name(id='str', ctx=Load())), Assign(targets=[Name(id='_word_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\\w+')], keywords=[])), FunctionDef(name='do_wordcount', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Count the words in that string.')), Return(value=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='_word_re', ctx=Load()), attr='findall', ctx=Load()), args=[Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='do_int', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), arg(arg='default', annotation=Name(id='int', ctx=Load())), arg(arg='base', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=10)]), body=[Expr(value=Constant(value="Convert the value into an integer. If the\n    conversion doesn't work it will return ``0``. You can\n    override this default using the first parameter. You\n    can also override the default base (10) in the second\n    parameter, which handles input with prefixes such as\n    0b, 0o and 0x for bases 2, 8 and 16 respectively.\n    The base is ignored for decimal numbers and non-string values.\n    ")), Try(body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='base', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TypeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Try(body=[Return(value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='float', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TypeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Return(value=Name(id='default', ctx=Load()))])], orelse=[], finalbody=[])])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='do_float', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), arg(arg='default', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0.0)]), body=[Expr(value=Constant(value="Convert the value into a floating point number. If the\n    conversion doesn't work it will return ``0.0``. You can\n    override this default using the first parameter.\n    ")), Try(body=[Return(value=Call(func=Name(id='float', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TypeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Return(value=Name(id='default', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='do_format', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='str', ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Apply the given values to a `printf-style`_ format string, like\n    ``string % values``.\n\n    .. sourcecode:: jinja\n\n        {{ "%s, %s!"|format(greeting, name) }}\n        Hello, World!\n\n    In most cases it should be more convenient and efficient to use the\n    ``%`` operator or :meth:`str.format`.\n\n    .. code-block:: text\n\n        {{ "%s, %s!" % (greeting, name) }}\n        {{ "{}, {}!".format(greeting, name) }}\n\n    .. _printf-style: https://docs.python.org/library/stdtypes.html\n        #printf-style-string-formatting\n    ')), If(test=BoolOp(op=And(), values=[Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='FilterArgumentError', ctx=Load()), args=[Constant(value="can't handle positional and keyword arguments at the same time")], keywords=[]))], orelse=[]), Return(value=BinOp(left=Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), op=Mod(), right=BoolOp(op=Or(), values=[Name(id='kwargs', ctx=Load()), Name(id='args', ctx=Load())])))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_trim', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='chars', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Strip leading and trailing characters, by default whitespace.')), Return(value=Call(func=Attribute(value=Call(func=Name(id='soft_str', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), attr='strip', ctx=Load()), args=[Name(id='chars', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_striptags', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Constant(value='t.Union[str, HasHTML]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Strip SGML/XML tags and replace adjacent whitespace by one space.')), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='value', ctx=Load()), Constant(value='__html__')], keywords=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='cast', ctx=Load()), args=[Constant(value='HasHTML'), Name(id='value', ctx=Load())], keywords=[]), attr='__html__', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='Markup', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[]), attr='striptags', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='sync_do_slice', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Constant(value='t.Collection[V]')), arg(arg='slices', annotation=Name(id='int', ctx=Load())), arg(arg='fill_with', annotation=Constant(value='t.Optional[V]'))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Slice an iterator and return a list of lists containing\n    those items. Useful if you want to create a div containing\n    three ul tags that represent columns:\n\n    .. sourcecode:: html+jinja\n\n        <div class="columnwrapper">\n          {%- for column in items|slice(3) %}\n            <ul class="column-{{ loop.index }}">\n            {%- for item in column %}\n              <li>{{ item }}</li>\n            {%- endfor %}\n            </ul>\n          {%- endfor %}\n        </div>\n\n    If you pass it a second argument it\'s used to fill missing\n    values on the last iteration.\n    ')), Assign(targets=[Name(id='seq', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Assign(targets=[Name(id='length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[])), Assign(targets=[Name(id='items_per_slice', ctx=Store())], value=BinOp(left=Name(id='length', ctx=Load()), op=FloorDiv(), right=Name(id='slices', ctx=Load()))), Assign(targets=[Name(id='slices_with_extra', ctx=Store())], value=BinOp(left=Name(id='length', ctx=Load()), op=Mod(), right=Name(id='slices', ctx=Load()))), Assign(targets=[Name(id='offset', ctx=Store())], value=Constant(value=0)), For(target=Name(id='slice_number', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='slices', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=BinOp(left=Name(id='offset', ctx=Load()), op=Add(), right=BinOp(left=Name(id='slice_number', ctx=Load()), op=Mult(), right=Name(id='items_per_slice', ctx=Load())))), If(test=Compare(left=Name(id='slice_number', ctx=Load()), ops=[Lt()], comparators=[Name(id='slices_with_extra', ctx=Load())]), body=[AugAssign(target=Name(id='offset', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Assign(targets=[Name(id='end', ctx=Store())], value=BinOp(left=Name(id='offset', ctx=Load()), op=Add(), right=BinOp(left=BinOp(left=Name(id='slice_number', ctx=Load()), op=Add(), right=Constant(value=1)), op=Mult(), right=Name(id='items_per_slice', ctx=Load())))), Assign(targets=[Name(id='tmp', ctx=Store())], value=Subscript(value=Name(id='seq', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='end', ctx=Load())), ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='fill_with', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='slice_number', ctx=Load()), ops=[GtE()], comparators=[Name(id='slices_with_extra', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='tmp', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='fill_with', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Yield(value=Name(id='tmp', ctx=Load())))], orelse=[])], decorator_list=[], returns=Constant(value='t.Iterator[t.List[V]]')), AsyncFunctionDef(name='do_slice', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Constant(value='t.Union[t.AsyncIterable[V], t.Iterable[V]]')), arg(arg='slices', annotation=Name(id='int', ctx=Load())), arg(arg='fill_with', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='sync_do_slice', ctx=Load()), args=[Await(value=Call(func=Name(id='auto_to_list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Name(id='slices', ctx=Load()), Name(id='fill_with', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_slice', ctx=Load())], keywords=[])], returns=Constant(value='t.Iterator[t.List[V]]')), FunctionDef(name='do_batch', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Constant(value='t.Iterable[V]')), arg(arg='linecount', annotation=Name(id='int', ctx=Load())), arg(arg='fill_with', annotation=Constant(value='t.Optional[V]'))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="\n    A filter that batches items. It works pretty much like `slice`\n    just the other way round. It returns a list of lists with the\n    given number of items. If you provide a second parameter this\n    is used to fill up missing items. See this example:\n\n    .. sourcecode:: html+jinja\n\n        <table>\n        {%- for row in items|batch(3, '&nbsp;') %}\n          <tr>\n          {%- for column in row %}\n            <td>{{ column }}</td>\n          {%- endfor %}\n          </tr>\n        {%- endfor %}\n        </table>\n    ")), AnnAssign(target=Name(id='tmp', ctx=Store()), annotation=Constant(value='t.List[V]'), value=List(elts=[], ctx=Load()), simple=1), For(target=Name(id='item', ctx=Store()), iter=Name(id='value', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='tmp', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Name(id='linecount', ctx=Load())]), body=[Expr(value=Yield(value=Name(id='tmp', ctx=Load()))), Assign(targets=[Name(id='tmp', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='tmp', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='tmp', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='fill_with', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='tmp', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Name(id='linecount', ctx=Load())])]), body=[AugAssign(target=Name(id='tmp', ctx=Store()), op=Add(), value=BinOp(left=List(elts=[Name(id='fill_with', ctx=Load())], ctx=Load()), op=Mult(), right=BinOp(left=Name(id='linecount', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='tmp', ctx=Load())], keywords=[]))))], orelse=[]), Expr(value=Yield(value=Name(id='tmp', ctx=Load())))], orelse=[])], decorator_list=[], returns=Constant(value='t.Iterator[t.List[V]]')), FunctionDef(name='do_round', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='float', ctx=Load())), arg(arg='precision', annotation=Name(id='int', ctx=Load())), arg(arg='method', annotation=Constant(value='te.Literal["common", "ceil", "floor"]'))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value='common')]), body=[Expr(value=Constant(value="Round the number to a given precision. The first\n    parameter specifies the precision (default is ``0``), the\n    second the rounding method:\n\n    - ``'common'`` rounds either up or down\n    - ``'ceil'`` always rounds up\n    - ``'floor'`` always rounds down\n\n    If you don't specify a method ``'common'`` is used.\n\n    .. sourcecode:: jinja\n\n        {{ 42.55|round }}\n            -> 43.0\n        {{ 42.55|round(1, 'floor') }}\n            -> 42.5\n\n    Note that even if rounded to 0 precision, a float is returned.  If\n    you need a real integer, pipe it through `int`:\n\n    .. sourcecode:: jinja\n\n        {{ 42.55|round|int }}\n            -> 43\n    ")), If(test=Compare(left=Name(id='method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Constant(value='common'), Constant(value='ceil'), Constant(value='floor')])]), body=[Raise(exc=Call(func=Name(id='FilterArgumentError', ctx=Load()), args=[Constant(value='method must be common, ceil or floor')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='method', ctx=Load()), ops=[Eq()], comparators=[Constant(value='common')]), body=[Return(value=Call(func=Name(id='round', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='precision', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='math', ctx=Load()), Name(id='method', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), BinOp(left=Call(func=Name(id='func', ctx=Load()), args=[BinOp(left=Name(id='value', ctx=Load()), op=Mult(), right=BinOp(left=Constant(value=10), op=Pow(), right=Name(id='precision', ctx=Load())))], keywords=[]), op=Div(), right=BinOp(left=Constant(value=10), op=Pow(), right=Name(id='precision', ctx=Load())))], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load())), ClassDef(name='_GroupTuple', bases=[Attribute(value=Name(id='t', ctx=Load()), attr='NamedTuple', ctx=Load())], keywords=[], body=[AnnAssign(target=Name(id='grouper', ctx=Store()), annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), simple=1), AnnAssign(target=Name(id='list', ctx=Store()), annotation=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), simple=1), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='tuple', ctx=Load()), attr='__repr__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='tuple', ctx=Load()), attr='__str__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), FunctionDef(name='sync_do_groupby', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='value', annotation=Constant(value='t.Iterable[V]')), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='default', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load())), arg(arg='case_sensitive', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Group a sequence of objects by an attribute using Python\'s\n    :func:`itertools.groupby`. The attribute can use dot notation for\n    nested access, like ``"address.city"``. Unlike Python\'s ``groupby``,\n    the values are sorted first so only one group is returned for each\n    unique value.\n\n    For example, a list of ``User`` objects with a ``city`` attribute\n    can be rendered in groups. In this example, ``grouper`` refers to\n    the ``city`` value of the group.\n\n    .. sourcecode:: html+jinja\n\n        <ul>{% for city, items in users|groupby("city") %}\n          <li>{{ city }}\n            <ul>{% for user in items %}\n              <li>{{ user.name }}\n            {% endfor %}</ul>\n          </li>\n        {% endfor %}</ul>\n\n    ``groupby`` yields namedtuples of ``(grouper, list)``, which\n    can be used instead of the tuple unpacking above. ``grouper`` is the\n    value of the attribute, and ``list`` is the items with that value.\n\n    .. sourcecode:: html+jinja\n\n        <ul>{% for group in users|groupby("city") %}\n          <li>{{ group.grouper }}: {{ group.list|join(", ") }}\n        {% endfor %}</ul>\n\n    You can specify a ``default`` value to use if an object in the list\n    does not have the given attribute.\n\n    .. sourcecode:: jinja\n\n        <ul>{% for city, items in users|groupby("city", default="NY") %}\n          <li>{{ city }}: {{ items|map(attribute="name")|join(", ") }}</li>\n        {% endfor %}</ul>\n\n    Like the :func:`~jinja-filters.sort` filter, sorting and grouping is\n    case-insensitive by default. The ``key`` for each group will have\n    the case of the first item in that group of values. For example, if\n    a list of users has cities ``["CA", "NY", "ca"]``, the "CA" group\n    will have two values. This can be disabled by passing\n    ``case_sensitive=True``.\n\n    .. versionchanged:: 3.1\n        Added the ``case_sensitive`` parameter. Sorting and grouping is\n        case-insensitive by default, matching other filters that do\n        comparisons.\n\n    .. versionchanged:: 3.0\n        Added the ``default`` parameter.\n\n    .. versionchanged:: 2.6\n        The attribute supports dot notation for nested access.\n    ')), Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[keyword(arg='postprocess', value=IfExp(test=UnaryOp(op=Not(), operand=Name(id='case_sensitive', ctx=Load())), body=Name(id='ignore_case', ctx=Load()), orelse=Constant(value=None))), keyword(arg='default', value=Name(id='default', ctx=Load()))])), Assign(targets=[Name(id='out', ctx=Store())], value=ListComp(elt=Call(func=Name(id='_GroupTuple', ctx=Load()), args=[Name(id='key', ctx=Load()), Call(func=Name(id='list', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='values', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='groupby', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[keyword(arg='key', value=Name(id='expr', ctx=Load()))]), Name(id='expr', ctx=Load())], keywords=[]), ifs=[], is_async=0)])), If(test=UnaryOp(op=Not(), operand=Name(id='case_sensitive', ctx=Load())), body=[Assign(targets=[Name(id='output_expr', ctx=Store())], value=Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[keyword(arg='default', value=Name(id='default', ctx=Load()))])), Assign(targets=[Name(id='out', ctx=Store())], value=ListComp(elt=Call(func=Name(id='_GroupTuple', ctx=Load()), args=[Call(func=Name(id='output_expr', ctx=Load()), args=[Subscript(value=Name(id='values', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), Name(id='values', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='_', ctx=Store()), Name(id='values', ctx=Store())], ctx=Store()), iter=Name(id='out', ctx=Load()), ifs=[], is_async=0)]))], orelse=[]), Return(value=Name(id='out', ctx=Load()))], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Constant(value='t.List[_GroupTuple]')), AsyncFunctionDef(name='do_groupby', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='value', annotation=Constant(value='t.Union[t.AsyncIterable[V], t.Iterable[V]]')), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='default', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load())), arg(arg='case_sensitive', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[keyword(arg='postprocess', value=IfExp(test=UnaryOp(op=Not(), operand=Name(id='case_sensitive', ctx=Load())), body=Name(id='ignore_case', ctx=Load()), orelse=Constant(value=None))), keyword(arg='default', value=Name(id='default', ctx=Load()))])), Assign(targets=[Name(id='out', ctx=Store())], value=ListComp(elt=Call(func=Name(id='_GroupTuple', ctx=Load()), args=[Name(id='key', ctx=Load()), Await(value=Call(func=Name(id='auto_to_list', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]))], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='values', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='groupby', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Await(value=Call(func=Name(id='auto_to_list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], keywords=[keyword(arg='key', value=Name(id='expr', ctx=Load()))]), Name(id='expr', ctx=Load())], keywords=[]), ifs=[], is_async=0)])), If(test=UnaryOp(op=Not(), operand=Name(id='case_sensitive', ctx=Load())), body=[Assign(targets=[Name(id='output_expr', ctx=Store())], value=Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[keyword(arg='default', value=Name(id='default', ctx=Load()))])), Assign(targets=[Name(id='out', ctx=Store())], value=ListComp(elt=Call(func=Name(id='_GroupTuple', ctx=Load()), args=[Call(func=Name(id='output_expr', ctx=Load()), args=[Subscript(value=Name(id='values', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), Name(id='values', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='_', ctx=Store()), Name(id='values', ctx=Store())], ctx=Store()), iter=Name(id='out', ctx=Load()), ifs=[], is_async=0)]))], orelse=[]), Return(value=Name(id='out', ctx=Load()))], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_groupby', ctx=Load())], keywords=[])], returns=Constant(value='t.List[_GroupTuple]')), FunctionDef(name='sync_do_sum', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='iterable', annotation=Constant(value='t.Iterable[V]')), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='start', annotation=Name(id='V', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=0)]), body=[Expr(value=Constant(value="Returns the sum of a sequence of numbers plus the value of parameter\n    'start' (which defaults to 0).  When the sequence is empty it returns\n    start.\n\n    It is also possible to sum up only certain attributes:\n\n    .. sourcecode:: jinja\n\n        Total: {{ items|sum(attribute='price') }}\n\n    .. versionchanged:: 2.6\n       The ``attribute`` parameter was added to allow summing up over\n       attributes.  Also the ``start`` parameter was moved on to the right.\n    ")), If(test=Compare(left=Name(id='attribute', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='iterable', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]), Name(id='iterable', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='sum', ctx=Load()), args=[Name(id='iterable', ctx=Load()), Name(id='start', ctx=Load())], keywords=[]))], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Name(id='V', ctx=Load())), AsyncFunctionDef(name='do_sum', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='iterable', annotation=Constant(value='t.Union[t.AsyncIterable[V], t.Iterable[V]]')), arg(arg='attribute', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='start', annotation=Name(id='V', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=0)]), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Name(id='start', ctx=Load())), If(test=Compare(left=Name(id='attribute', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Name(id='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[]))], orelse=[FunctionDef(name='func', args=arguments(posonlyargs=[], args=[arg(arg='x', annotation=Name(id='V', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='x', ctx=Load()))], decorator_list=[], returns=Name(id='V', ctx=Load()))]), AsyncFor(target=Name(id='item', ctx=Store()), iter=Call(func=Name(id='auto_aiter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='rv', ctx=Store()), op=Add(), value=Call(func=Name(id='func', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='rv', ctx=Load()))], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_sum', ctx=Load())], keywords=[])], returns=Name(id='V', ctx=Load())), FunctionDef(name='sync_do_list', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Constant(value='t.Iterable[V]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Convert the value into a list.  If it was a string the returned list\n    will be a list of characters.\n    ')), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='t.List[V]')), AsyncFunctionDef(name='do_list', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Constant(value='t.Union[t.AsyncIterable[V], t.Iterable[V]]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Await(value=Call(func=Name(id='auto_to_list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])))], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_list', ctx=Load())], keywords=[])], returns=Constant(value='t.List[V]')), FunctionDef(name='do_mark_safe', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Mark the value as safe which means that in an environment with automatic\n    escaping enabled this variable will not be escaped.\n    ')), Return(value=Call(func=Name(id='Markup', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Markup', ctx=Load())), FunctionDef(name='do_mark_unsafe', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Mark a value as unsafe.  This is the reverse operation for :func:`safe`.')), Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_reverse', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='do_reverse', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Constant(value='t.Iterable[V]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())], returns=Constant(value='t.Iterable[V]')), FunctionDef(name='do_reverse', args=arguments(posonlyargs=[], args=[arg(arg='value', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='V', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Reverse the object or return an iterator that iterates over it the other\n    way round.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Return(value=Subscript(value=Name(id='value', ctx=Load()), slice=Slice(step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], orelse=[]), Try(body=[Return(value=Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='reverse', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='rv', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='FilterArgumentError', ctx=Load()), args=[Constant(value='argument must be iterable')], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])])], orelse=[], finalbody=[])], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='V', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='do_attr', args=arguments(posonlyargs=[], args=[arg(arg='environment', annotation=Constant(value='Environment')), arg(arg='obj', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get an attribute of an object.  ``foo|attr("bar")`` works like\n    ``foo.bar`` just that always an attribute is returned and items are not\n    looked up.\n\n    See :ref:`Notes on subscriptions <notes-on-subscriptions>` for more details.\n    ')), Try(body=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='UnicodeError', ctx=Load()), body=[Pass()])], orelse=[Try(body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[If(test=Attribute(value=Name(id='environment', ctx=Load()), attr='sandboxed', ctx=Load()), body=[Assign(targets=[Name(id='environment', ctx=Store())], value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='cast', ctx=Load()), args=[Constant(value='SandboxedEnvironment'), Name(id='environment', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='environment', ctx=Load()), attr='is_safe_attribute', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], keywords=[])), body=[Return(value=Call(func=Attribute(value=Name(id='environment', ctx=Load()), attr='unsafe_undefined', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='value', ctx=Load()))], finalbody=[])], finalbody=[]), Return(value=Call(func=Attribute(value=Name(id='environment', ctx=Load()), attr='undefined', ctx=Load()), args=[], keywords=[keyword(arg='obj', value=Name(id='obj', ctx=Load())), keyword(arg='name', value=Name(id='name', ctx=Load()))]))], decorator_list=[Name(id='pass_environment', ctx=Load())], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Undefined', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='sync_do_map', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())), FunctionDef(name='sync_do_map', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load()))], kwonlyargs=[arg(arg='attribute', annotation=Name(id='str', ctx=Load())), arg(arg='default', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=Ellipsis), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())), FunctionDef(name='sync_do_map', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Applies a filter on a sequence of objects or looks up an attribute.\n    This is useful when dealing with lists of objects but you are really\n    only interested in a certain value of it.\n\n    The basic usage is mapping on an attribute.  Imagine you have a list\n    of users but you are only interested in a list of usernames:\n\n    .. sourcecode:: jinja\n\n        Users on this page: {{ users|map(attribute=\'username\')|join(\', \') }}\n\n    You can specify a ``default`` value to use if an object in the list\n    does not have the given attribute.\n\n    .. sourcecode:: jinja\n\n        {{ users|map(attribute="username", default="Anonymous")|join(", ") }}\n\n    Alternatively you can let it invoke a filter by passing the name of the\n    filter and the arguments afterwards.  A good example would be applying a\n    text conversion filter on a sequence:\n\n    .. sourcecode:: jinja\n\n        Users on this page: {{ titles|map(\'lower\')|join(\', \') }}\n\n    Similar to a generator comprehension such as:\n\n    .. code-block:: python\n\n        (u.username for u in users)\n        (getattr(u, "username", "Anonymous") for u in users)\n        (do_lower(x) for x in titles)\n\n    .. versionchanged:: 2.11.0\n        Added the ``default`` parameter.\n\n    .. versionadded:: 2.7\n    ')), If(test=Name(id='value', ctx=Load()), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='prepare_map', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[])), For(target=Name(id='item', ctx=Store()), iter=Name(id='value', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Name(id='func', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])))], orelse=[])], orelse=[])], decorator_list=[Name(id='pass_context', ctx=Load())], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())), FunctionDef(name='do_map', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='AsyncIterable', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())), FunctionDef(name='do_map', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='AsyncIterable', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='attribute', annotation=Name(id='str', ctx=Load())), arg(arg='default', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=Ellipsis), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Attribute(value=Name(id='typing', ctx=Load()), attr='overload', ctx=Load())], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())), AsyncFunctionDef(name='do_map', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='AsyncIterable', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Iterable', ctx=Load())], ctx=Load()), ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[If(test=Name(id='value', ctx=Load()), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='prepare_map', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[])), AsyncFor(target=Name(id='item', ctx=Store()), iter=Call(func=Name(id='auto_aiter', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Await(value=Call(func=Name(id='auto_await', ctx=Load()), args=[Call(func=Name(id='func', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])], keywords=[]))))], orelse=[])], orelse=[])], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_map', ctx=Load())], keywords=[])], returns=Attribute(value=Name(id='t', ctx=Load()), attr='AsyncIterable', ctx=Load())), FunctionDef(name='sync_do_select', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Constant(value='t.Iterable[V]'))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Filters a sequence of objects by applying a test to each object,\n    and only selecting the objects with the test succeeding.\n\n    If no test is specified, each object will be evaluated as a boolean.\n\n    Example usage:\n\n    .. sourcecode:: jinja\n\n        {{ numbers|select("odd") }}\n        {{ numbers|select("odd") }}\n        {{ numbers|select("divisibleby", 3) }}\n        {{ numbers|select("lessthan", 42) }}\n        {{ strings|select("equalto", "mystring") }}\n\n    Similar to a generator comprehension such as:\n\n    .. code-block:: python\n\n        (n for n in numbers if test_odd(n))\n        (n for n in numbers if test_divisibleby(n, 3))\n\n    .. versionadded:: 2.7\n    ')), Return(value=Call(func=Name(id='select_or_reject', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='value', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='x', ctx=Load())), Constant(value=False)], keywords=[]))], decorator_list=[Name(id='pass_context', ctx=Load())], returns=Constant(value='t.Iterator[V]')), AsyncFunctionDef(name='do_select', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Constant(value='t.Union[t.AsyncIterable[V], t.Iterable[V]]'))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Return(value=Call(func=Name(id='async_select_or_reject', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='value', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='x', ctx=Load())), Constant(value=False)], keywords=[]))], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_select', ctx=Load())], keywords=[])], returns=Constant(value='t.AsyncIterator[V]')), FunctionDef(name='sync_do_reject', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Constant(value='t.Iterable[V]'))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Filters a sequence of objects by applying a test to each object,\n    and rejecting the objects with the test succeeding.\n\n    If no test is specified, each object will be evaluated as a boolean.\n\n    Example usage:\n\n    .. sourcecode:: jinja\n\n        {{ numbers|reject("odd") }}\n\n    Similar to a generator comprehension such as:\n\n    .. code-block:: python\n\n        (n for n in numbers if not test_odd(n))\n\n    .. versionadded:: 2.7\n    ')), Return(value=Call(func=Name(id='select_or_reject', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='value', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=UnaryOp(op=Not(), operand=Name(id='x', ctx=Load()))), Constant(value=False)], keywords=[]))], decorator_list=[Name(id='pass_context', ctx=Load())], returns=Constant(value='t.Iterator[V]')), AsyncFunctionDef(name='do_reject', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Constant(value='t.Union[t.AsyncIterable[V], t.Iterable[V]]'))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Return(value=Call(func=Name(id='async_select_or_reject', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='value', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=UnaryOp(op=Not(), operand=Name(id='x', ctx=Load()))), Constant(value=False)], keywords=[]))], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_reject', ctx=Load())], keywords=[])], returns=Constant(value='t.AsyncIterator[V]')), FunctionDef(name='sync_do_selectattr', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Constant(value='t.Iterable[V]'))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Filters a sequence of objects by applying a test to the specified\n    attribute of each object, and only selecting the objects with the\n    test succeeding.\n\n    If no test is specified, the attribute\'s value will be evaluated as\n    a boolean.\n\n    Example usage:\n\n    .. sourcecode:: jinja\n\n        {{ users|selectattr("is_active") }}\n        {{ users|selectattr("email", "none") }}\n\n    Similar to a generator comprehension such as:\n\n    .. code-block:: python\n\n        (u for user in users if user.is_active)\n        (u for user in users if test_none(user.email))\n\n    .. versionadded:: 2.7\n    ')), Return(value=Call(func=Name(id='select_or_reject', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='value', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='x', ctx=Load())), Constant(value=True)], keywords=[]))], decorator_list=[Name(id='pass_context', ctx=Load())], returns=Constant(value='t.Iterator[V]')), AsyncFunctionDef(name='do_selectattr', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Constant(value='t.Union[t.AsyncIterable[V], t.Iterable[V]]'))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Return(value=Call(func=Name(id='async_select_or_reject', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='value', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='x', ctx=Load())), Constant(value=True)], keywords=[]))], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_selectattr', ctx=Load())], keywords=[])], returns=Constant(value='t.AsyncIterator[V]')), FunctionDef(name='sync_do_rejectattr', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Constant(value='t.Iterable[V]'))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Filters a sequence of objects by applying a test to the specified\n    attribute of each object, and rejecting the objects with the test\n    succeeding.\n\n    If no test is specified, the attribute\'s value will be evaluated as\n    a boolean.\n\n    .. sourcecode:: jinja\n\n        {{ users|rejectattr("is_active") }}\n        {{ users|rejectattr("email", "none") }}\n\n    Similar to a generator comprehension such as:\n\n    .. code-block:: python\n\n        (u for user in users if not user.is_active)\n        (u for user in users if not test_none(user.email))\n\n    .. versionadded:: 2.7\n    ')), Return(value=Call(func=Name(id='select_or_reject', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='value', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=UnaryOp(op=Not(), operand=Name(id='x', ctx=Load()))), Constant(value=True)], keywords=[]))], decorator_list=[Name(id='pass_context', ctx=Load())], returns=Constant(value='t.Iterator[V]')), AsyncFunctionDef(name='do_rejectattr', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Constant(value='t.Union[t.AsyncIterable[V], t.Iterable[V]]'))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Return(value=Call(func=Name(id='async_select_or_reject', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='value', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=UnaryOp(op=Not(), operand=Name(id='x', ctx=Load()))), Constant(value=True)], keywords=[]))], decorator_list=[Call(func=Name(id='async_variant', ctx=Load()), args=[Name(id='sync_do_rejectattr', ctx=Load())], keywords=[])], returns=Constant(value='t.AsyncIterator[V]')), FunctionDef(name='do_tojson', args=arguments(posonlyargs=[], args=[arg(arg='eval_ctx', annotation=Constant(value='EvalContext')), arg(arg='value', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), arg(arg='indent', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Serialize an object to a string of JSON, and mark it safe to\n    render in HTML. This filter is only for use in HTML documents.\n\n    The returned string is safe to render in HTML documents and\n    ``<script>`` tags. The exception is in HTML attributes that are\n    double quoted; either use single quotes or the ``|forceescape``\n    filter.\n\n    :param value: The object to serialize to JSON.\n    :param indent: The ``indent`` parameter passed to ``dumps``, for\n        pretty-printing the value.\n\n    .. versionadded:: 2.9\n    ')), Assign(targets=[Name(id='policies', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='eval_ctx', ctx=Load()), attr='environment', ctx=Load()), attr='policies', ctx=Load())), Assign(targets=[Name(id='dumps', ctx=Store())], value=Subscript(value=Name(id='policies', ctx=Load()), slice=Constant(value='json.dumps_function'), ctx=Load())), Assign(targets=[Name(id='kwargs', ctx=Store())], value=Subscript(value=Name(id='policies', ctx=Load()), slice=Constant(value='json.dumps_kwargs'), ctx=Load())), If(test=Compare(left=Name(id='indent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='kwargs', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='indent'), ctx=Store())], value=Name(id='indent', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='htmlsafe_json_dumps', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[keyword(arg='dumps', value=Name(id='dumps', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[Name(id='pass_eval_context', ctx=Load())], returns=Name(id='Markup', ctx=Load())), FunctionDef(name='prepare_map', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='args', ctx=Load())), Compare(left=Constant(value='attribute'), ops=[In()], comparators=[Name(id='kwargs', ctx=Load())])]), body=[Assign(targets=[Name(id='attribute', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='attribute')], keywords=[])), Assign(targets=[Name(id='default', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='default'), Constant(value=None)], keywords=[])), If(test=Name(id='kwargs', ctx=Load()), body=[Raise(exc=Call(func=Name(id='FilterArgumentError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Unexpected keyword argument '), FormattedValue(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[])], keywords=[]), conversion=114)])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Attribute(value=Name(id='context', ctx=Load()), attr='environment', ctx=Load()), Name(id='attribute', ctx=Load())], keywords=[keyword(arg='default', value=Name(id='default', ctx=Load()))]))], orelse=[Try(body=[Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='args', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='LookupError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='FilterArgumentError', ctx=Load()), args=[Constant(value='map requires a filter argument')], keywords=[]), cause=Constant(value=None))])], orelse=[], finalbody=[]), FunctionDef(name='func', args=arguments(posonlyargs=[], args=[arg(arg='item', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='context', ctx=Load()), attr='environment', ctx=Load()), attr='call_filter', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='item', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[keyword(arg='context', value=Name(id='context', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))]), Return(value=Name(id='func', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='prepare_select_or_reject', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='modfunc', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='lookup_attr', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Name(id='lookup_attr', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='attr', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='LookupError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='FilterArgumentError', ctx=Load()), args=[Constant(value='Missing parameter for attribute name')], keywords=[]), cause=Constant(value=None))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='transfunc', ctx=Store())], value=Call(func=Name(id='make_attrgetter', ctx=Load()), args=[Attribute(value=Name(id='context', ctx=Load()), attr='environment', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[])), Assign(targets=[Name(id='off', ctx=Store())], value=Constant(value=1))], orelse=[Assign(targets=[Name(id='off', ctx=Store())], value=Constant(value=0)), FunctionDef(name='transfunc', args=arguments(posonlyargs=[], args=[arg(arg='x', annotation=Name(id='V', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='x', ctx=Load()))], decorator_list=[], returns=Name(id='V', ctx=Load()))]), Try(body=[Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Name(id='off', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='args', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=BinOp(left=Constant(value=1), op=Add(), right=Name(id='off', ctx=Load()))), ctx=Load())), FunctionDef(name='func', args=arguments(posonlyargs=[], args=[arg(arg='item', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='context', ctx=Load()), attr='environment', ctx=Load()), attr='call_test', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='item', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='LookupError', ctx=Load()), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Name(id='bool', ctx=Load()))])], orelse=[], finalbody=[]), Return(value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='item')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='modfunc', ctx=Load()), args=[Call(func=Name(id='func', ctx=Load()), args=[Call(func=Name(id='transfunc', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])], keywords=[])], keywords=[])))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='select_or_reject', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Constant(value='t.Iterable[V]')), arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='modfunc', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='lookup_attr', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Name(id='value', ctx=Load()), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='prepare_select_or_reject', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Name(id='modfunc', ctx=Load()), Name(id='lookup_attr', ctx=Load())], keywords=[])), For(target=Name(id='item', ctx=Store()), iter=Name(id='value', ctx=Load()), body=[If(test=Call(func=Name(id='func', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='item', ctx=Load())))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value='t.Iterator[V]')), AsyncFunctionDef(name='async_select_or_reject', args=arguments(posonlyargs=[], args=[arg(arg='context', annotation=Constant(value='Context')), arg(arg='value', annotation=Constant(value='t.Union[t.AsyncIterable[V], t.Iterable[V]]')), arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Tuple', ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='modfunc', annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='lookup_attr', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Name(id='value', ctx=Load()), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='prepare_select_or_reject', ctx=Load()), args=[Name(id='context', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load()), Name(id='modfunc', ctx=Load()), Name(id='lookup_attr', ctx=Load())], keywords=[])), AsyncFor(target=Name(id='item', ctx=Store()), iter=Call(func=Name(id='auto_aiter', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='func', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='item', ctx=Load())))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value='t.AsyncIterator[V]')), Assign(targets=[Name(id='FILTERS', ctx=Store())], value=Dict(keys=[Constant(value='abs'), Constant(value='attr'), Constant(value='batch'), Constant(value='capitalize'), Constant(value='center'), Constant(value='count'), Constant(value='d'), Constant(value='default'), Constant(value='dictsort'), Constant(value='e'), Constant(value='escape'), Constant(value='filesizeformat'), Constant(value='first'), Constant(value='float'), Constant(value='forceescape'), Constant(value='format'), Constant(value='groupby'), Constant(value='indent'), Constant(value='int'), Constant(value='join'), Constant(value='last'), Constant(value='length'), Constant(value='list'), Constant(value='lower'), Constant(value='items'), Constant(value='map'), Constant(value='min'), Constant(value='max'), Constant(value='pprint'), Constant(value='random'), Constant(value='reject'), Constant(value='rejectattr'), Constant(value='replace'), Constant(value='reverse'), Constant(value='round'), Constant(value='safe'), Constant(value='select'), Constant(value='selectattr'), Constant(value='slice'), Constant(value='sort'), Constant(value='string'), Constant(value='striptags'), Constant(value='sum'), Constant(value='title'), Constant(value='trim'), Constant(value='truncate'), Constant(value='unique'), Constant(value='upper'), Constant(value='urlencode'), Constant(value='urlize'), Constant(value='wordcount'), Constant(value='wordwrap'), Constant(value='xmlattr'), Constant(value='tojson')], values=[Name(id='abs', ctx=Load()), Name(id='do_attr', ctx=Load()), Name(id='do_batch', ctx=Load()), Name(id='do_capitalize', ctx=Load()), Name(id='do_center', ctx=Load()), Name(id='len', ctx=Load()), Name(id='do_default', ctx=Load()), Name(id='do_default', ctx=Load()), Name(id='do_dictsort', ctx=Load()), Name(id='escape', ctx=Load()), Name(id='escape', ctx=Load()), Name(id='do_filesizeformat', ctx=Load()), Name(id='do_first', ctx=Load()), Name(id='do_float', ctx=Load()), Name(id='do_forceescape', ctx=Load()), Name(id='do_format', ctx=Load()), Name(id='do_groupby', ctx=Load()), Name(id='do_indent', ctx=Load()), Name(id='do_int', ctx=Load()), Name(id='do_join', ctx=Load()), Name(id='do_last', ctx=Load()), Name(id='len', ctx=Load()), Name(id='do_list', ctx=Load()), Name(id='do_lower', ctx=Load()), Name(id='do_items', ctx=Load()), Name(id='do_map', ctx=Load()), Name(id='do_min', ctx=Load()), Name(id='do_max', ctx=Load()), Name(id='do_pprint', ctx=Load()), Name(id='do_random', ctx=Load()), Name(id='do_reject', ctx=Load()), Name(id='do_rejectattr', ctx=Load()), Name(id='do_replace', ctx=Load()), Name(id='do_reverse', ctx=Load()), Name(id='do_round', ctx=Load()), Name(id='do_mark_safe', ctx=Load()), Name(id='do_select', ctx=Load()), Name(id='do_selectattr', ctx=Load()), Name(id='do_slice', ctx=Load()), Name(id='do_sort', ctx=Load()), Name(id='soft_str', ctx=Load()), Name(id='do_striptags', ctx=Load()), Name(id='do_sum', ctx=Load()), Name(id='do_title', ctx=Load()), Name(id='do_trim', ctx=Load()), Name(id='do_truncate', ctx=Load()), Name(id='do_unique', ctx=Load()), Name(id='do_upper', ctx=Load()), Name(id='do_urlencode', ctx=Load()), Name(id='do_urlize', ctx=Load()), Name(id='do_wordcount', ctx=Load()), Name(id='do_wordwrap', ctx=Load()), Name(id='do_xmlattr', ctx=Load()), Name(id='do_tojson', ctx=Load())]))], type_ignores=[])