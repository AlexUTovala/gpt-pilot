Module(body=[Expr(value=Constant(value='Functions that expose information about templates that might be\ninteresting for introspection.\n')), Import(names=[alias(name='typing', asname='t')]), ImportFrom(names=[alias(name='nodes')], level=1), ImportFrom(module='compiler', names=[alias(name='CodeGenerator')], level=1), ImportFrom(module='compiler', names=[alias(name='Frame')], level=1), If(test=Attribute(value=Name(id='t', ctx=Load()), attr='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='environment', names=[alias(name='Environment')], level=1)], orelse=[]), ClassDef(name='TrackingCodeGenerator', bases=[Name(id='CodeGenerator', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='We abuse the code generator for introspection.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='environment', annotation=Constant(value='Environment'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='environment', ctx=Load()), Constant(value='<introspection>'), Constant(value='<introspection>')], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='undeclared_identifiers', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='write', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Don't write."))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='enter_frame', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='frame', annotation=Name(id='Frame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remember all undeclared identifiers.')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='enter_frame', ctx=Load()), args=[Name(id='frame', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='_', ctx=Store()), Tuple(elts=[Name(id='action', ctx=Store()), Name(id='param', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='frame', ctx=Load()), attr='symbols', ctx=Load()), attr='loads', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='action', ctx=Load()), ops=[Eq()], comparators=[Constant(value='resolve')]), Compare(left=Name(id='param', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='environment', ctx=Load()), attr='globals', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='undeclared_identifiers', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='param', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), FunctionDef(name='find_undeclared_variables', args=arguments(posonlyargs=[], args=[arg(arg='ast', annotation=Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Returns a set of all variables in the AST that will be looked up from\n    the context at runtime.  Because at compile time it's not known which\n    variables will be used depending on the path the execution takes at\n    runtime, all variables are returned.\n\n    >>> from jinja2 import Environment, meta\n    >>> env = Environment()\n    >>> ast = env.parse('{% set foo = 42 %}{{ bar + foo }}')\n    >>> meta.find_undeclared_variables(ast) == {'bar'}\n    True\n\n    .. admonition:: Implementation\n\n       Internally the code generator is used for finding undeclared variables.\n       This is good to know because the code generator might raise a\n       :exc:`TemplateAssertionError` during compilation and as a matter of\n       fact this function can currently raise that exception as well.\n    ")), Assign(targets=[Name(id='codegen', ctx=Store())], value=Call(func=Name(id='TrackingCodeGenerator', ctx=Load()), args=[Attribute(value=Name(id='ast', ctx=Load()), attr='environment', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='codegen', ctx=Load()), attr='visit', ctx=Load()), args=[Name(id='ast', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='codegen', ctx=Load()), attr='undeclared_identifiers', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='_ref_types', ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Extends', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='FromImport', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Import', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Include', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='_RefType', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Extends', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='FromImport', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Import', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Include', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='find_referenced_templates', args=arguments(posonlyargs=[], args=[arg(arg='ast', annotation=Attribute(value=Name(id='nodes', ctx=Load()), attr='Template', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Finds all the referenced templates from the AST.  This will return an\n    iterator over all the hardcoded template extensions, inclusions and\n    imports.  If dynamic inheritance or inclusion is used, `None` will be\n    yielded.\n\n    >>> from jinja2 import Environment, meta\n    >>> env = Environment()\n    >>> ast = env.parse(\'{% extends "layout.html" %}{% include helper %}\')\n    >>> list(meta.find_referenced_templates(ast))\n    [\'layout.html\', None]\n\n    This function is useful for dependency tracking.  For example if you want\n    to rebuild parts of the website after a layout template has changed.\n    ')), AnnAssign(target=Name(id='template_name', ctx=Store()), annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()), simple=1), For(target=Name(id='node', ctx=Store()), iter=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='find_all', ctx=Load()), args=[Name(id='_ref_types', ctx=Load())], keywords=[]), body=[AnnAssign(target=Name(id='template', ctx=Store()), annotation=Attribute(value=Name(id='nodes', ctx=Load()), attr='Expr', ctx=Load()), value=Attribute(value=Name(id='node', ctx=Load()), attr='template', ctx=Load()), simple=1), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='template', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Const', ctx=Load())], keywords=[])), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='template', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Tuple', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='List', ctx=Load())], ctx=Load())], keywords=[]), body=[For(target=Name(id='template_name', ctx=Store()), iter=Attribute(value=Name(id='template', ctx=Load()), attr='items', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='template_name', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Const', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='template_name', ctx=Load()), attr='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Attribute(value=Name(id='template_name', ctx=Load()), attr='value', ctx=Load())))], orelse=[])], orelse=[Expr(value=Yield(value=Constant(value=None)))])], orelse=[])], orelse=[Expr(value=Yield(value=Constant(value=None)))]), Continue()], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='template', ctx=Load()), attr='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Attribute(value=Name(id='template', ctx=Load()), attr='value', ctx=Load())))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Include', ctx=Load())], keywords=[]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='template', ctx=Load()), attr='value', ctx=Load()), Tuple(elts=[Name(id='tuple', ctx=Load()), Name(id='list', ctx=Load())], ctx=Load())], keywords=[])]), body=[For(target=Name(id='template_name', ctx=Store()), iter=Attribute(value=Name(id='template', ctx=Load()), attr='value', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='template_name', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='template_name', ctx=Load())))], orelse=[])], orelse=[])], orelse=[Expr(value=Yield(value=Constant(value=None)))])])], orelse=[])], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Iterator', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], type_ignores=[])