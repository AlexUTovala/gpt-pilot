Module(body=[Expr(value=Constant(value='API for traversing the AST nodes. Implemented by the compiler and\nmeta introspection.\n')), Import(names=[alias(name='typing', asname='t')]), ImportFrom(module='nodes', names=[alias(name='Node')], level=1), If(test=Attribute(value=Name(id='t', ctx=Load()), attr='TYPE_CHECKING', ctx=Load()), body=[Import(names=[alias(name='typing_extensions', asname='te')]), ClassDef(name='VisitCallable', bases=[Attribute(value=Name(id='te', ctx=Load()), attr='Protocol', ctx=Load())], keywords=[], body=[FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='node', annotation=Name(id='Node', ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[])], orelse=[]), ClassDef(name='NodeVisitor', bases=[], keywords=[], body=[Expr(value=Constant(value="Walks the abstract syntax tree and call visitor functions for every\n    node found.  The visitor functions may return values which will be\n    forwarded by the `visit` method.\n\n    Per default the visitor functions for the nodes are ``'visit_'`` +\n    class name of the node.  So a `TryFinally` node visit function would\n    be `visit_TryFinally`.  This behavior can be changed by overriding\n    the `get_visitor` function.  If no visitor function exists for a node\n    (return value `None`) the `generic_visit` visitor is used instead.\n    ")), FunctionDef(name='get_visitor', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='node', annotation=Name(id='Node', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the visitor function for this node or `None` if no visitor\n        exists for this node.  In that case the generic visit function is\n        used instead.\n        ')), Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), JoinedStr(values=[Constant(value='visit_'), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1)]), Constant(value=None)], keywords=[]))], decorator_list=[], returns=Constant(value='t.Optional[VisitCallable]')), FunctionDef(name='visit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='node', annotation=Name(id='Node', ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Visit a node.')), Assign(targets=[Name(id='f', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_visitor', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='f', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='f', ctx=Load()), args=[Name(id='node', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='generic_visit', ctx=Load()), args=[Name(id='node', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), FunctionDef(name='generic_visit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='node', annotation=Name(id='Node', ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Called if no explicit visitor function exists for a node.')), For(target=Name(id='child_node', ctx=Store()), iter=Call(func=Attribute(value=Name(id='node', ctx=Load()), attr='iter_child_nodes', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='visit', ctx=Load()), args=[Name(id='child_node', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[])], decorator_list=[], returns=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load()))], decorator_list=[]), ClassDef(name='NodeTransformer', bases=[Name(id='NodeVisitor', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Walks the abstract syntax tree and allows modifications of nodes.\n\n    The `NodeTransformer` will walk the AST and use the return value of the\n    visitor functions to replace or remove the old node.  If the return\n    value of the visitor function is `None` the node will be removed\n    from the previous location otherwise it's replaced with the return\n    value.  The return value may be the original node in which case no\n    replacement takes place.\n    ")), FunctionDef(name='generic_visit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='node', annotation=Name(id='Node', ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[For(target=Tuple(elts=[Name(id='field', ctx=Store()), Name(id='old_value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='node', ctx=Load()), attr='iter_fields', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='old_value', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='new_values', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='value', ctx=Store()), iter=Name(id='old_value', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='Node', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='visit', ctx=Load()), args=[Name(id='value', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Continue()], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='Node', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='new_values', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Continue()], orelse=[])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='new_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='old_value', ctx=Load()), slice=Slice(), ctx=Store())], value=Name(id='new_values', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='old_value', ctx=Load()), Name(id='Node', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='new_node', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='visit', ctx=Load()), args=[Name(id='old_value', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), If(test=Compare(left=Name(id='new_node', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='delattr', ctx=Load()), args=[Name(id='node', ctx=Load()), Name(id='field', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='node', ctx=Load()), Name(id='field', ctx=Load()), Name(id='new_node', ctx=Load())], keywords=[]))])], orelse=[])])], orelse=[]), Return(value=Name(id='node', ctx=Load()))], decorator_list=[], returns=Name(id='Node', ctx=Load())), FunctionDef(name='visit_list', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='node', annotation=Name(id='Node', ctx=Load()))], vararg=arg(arg='args', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Attribute(value=Name(id='t', ctx=Load()), attr='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='As transformers may return lists in some places this method\n        can be used to enforce a list as return value.\n        ')), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='visit', ctx=Load()), args=[Name(id='node', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='rv', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), body=[Return(value=List(elts=[Name(id='rv', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='rv', ctx=Load()))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='t', ctx=Load()), attr='List', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])