Module(body=[Expr(value=Constant(value="Implementation of the JSON adaptation objects\n\nThis module exists to avoid a circular import problem: pyscopg2.extras depends\non psycopg2.extension, so I can't create the default JSON typecasters in\nextensions importing register_json from extras.\n")), Import(names=[alias(name='json')]), ImportFrom(module='psycopg2._psycopg', names=[alias(name='ISQLQuote'), alias(name='QuotedString')], level=0), ImportFrom(module='psycopg2._psycopg', names=[alias(name='new_type'), alias(name='new_array_type'), alias(name='register_type')], level=0), Assign(targets=[Name(id='JSON_OID', ctx=Store())], value=Constant(value=114)), Assign(targets=[Name(id='JSONARRAY_OID', ctx=Store())], value=Constant(value=199)), Assign(targets=[Name(id='JSONB_OID', ctx=Store())], value=Constant(value=3802)), Assign(targets=[Name(id='JSONBARRAY_OID', ctx=Store())], value=Constant(value=3807)), ClassDef(name='Json', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    An `~psycopg2.extensions.ISQLQuote` wrapper to adapt a Python object to\n    :sql:`json` data type.\n\n    `!Json` can be used to wrap any object supported by the provided *dumps*\n    function. If none is provided, the standard :py:func:`json.dumps()` is\n    used.\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='adapted'), arg(arg='dumps')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='adapted', ctx=Store())], value=Name(id='adapted', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_conn', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_dumps', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='dumps', ctx=Load()), Attribute(value=Name(id='json', ctx=Load()), attr='dumps', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__conform__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='proto')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='proto', ctx=Load()), ops=[Is()], comparators=[Name(id='ISQLQuote', ctx=Load())]), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='dumps', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Serialize *obj* in JSON format.\n\n        The default is to call `!json.dumps()` or the *dumps* function\n        provided in the constructor. You can override this method to create a\n        customized JSON wrapper.\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_dumps', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='prepare', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='conn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_conn', ctx=Store())], value=Name(id='conn', ctx=Load()))], decorator_list=[]), FunctionDef(name='getquoted', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='s', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='dumps', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='adapted', ctx=Load())], keywords=[])), Assign(targets=[Name(id='qs', ctx=Store())], value=Call(func=Name(id='QuotedString', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_conn', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qs', ctx=Load()), attr='prepare', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_conn', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='qs', ctx=Load()), attr='getquoted', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getquoted', ctx=Load()), args=[], keywords=[]), attr='decode', ctx=Load()), args=[Constant(value='ascii'), Constant(value='replace')], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='register_json', args=arguments(posonlyargs=[], args=[arg(arg='conn_or_curs'), arg(arg='globally'), arg(arg='loads'), arg(arg='oid'), arg(arg='array_oid'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='json')]), body=[Expr(value=Constant(value='Create and register typecasters converting :sql:`json` type to Python objects.\n\n    :param conn_or_curs: a connection or cursor used to find the :sql:`json`\n        and :sql:`json[]` oids; the typecasters are registered in a scope\n        limited to this object, unless *globally* is set to `!True`. It can be\n        `!None` if the oids are provided\n    :param globally: if `!False` register the typecasters only on\n        *conn_or_curs*, otherwise register them globally\n    :param loads: the function used to parse the data into a Python object. If\n        `!None` use `!json.loads()`, where `!json` is the module chosen\n        according to the Python version (see above)\n    :param oid: the OID of the :sql:`json` type if known; If not, it will be\n        queried on *conn_or_curs*\n    :param array_oid: the OID of the :sql:`json[]` array type if known;\n        if not, it will be queried on *conn_or_curs*\n    :param name: the name of the data type to look for in *conn_or_curs*\n\n    The connection or cursor passed to the function will be used to query the\n    database and look for the OID of the :sql:`json` type (or an alternative\n    type if *name* if provided). No query is performed if *oid* and *array_oid*\n    are provided.  Raise `~psycopg2.ProgrammingError` if the type is not found.\n\n    ')), If(test=Compare(left=Name(id='oid', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Tuple(elts=[Name(id='oid', ctx=Store()), Name(id='array_oid', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_get_json_oids', ctx=Load()), args=[Name(id='conn_or_curs', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='JSON', ctx=Store()), Name(id='JSONARRAY', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_create_json_typecasters', ctx=Load()), args=[Name(id='oid', ctx=Load()), Name(id='array_oid', ctx=Load())], keywords=[keyword(arg='loads', value=Name(id='loads', ctx=Load())), keyword(arg='name', value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]))])), Expr(value=Call(func=Name(id='register_type', ctx=Load()), args=[Name(id='JSON', ctx=Load()), BoolOp(op=Or(), values=[BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='globally', ctx=Load())), Name(id='conn_or_curs', ctx=Load())]), Constant(value=None)])], keywords=[])), If(test=Compare(left=Name(id='JSONARRAY', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='register_type', ctx=Load()), args=[Name(id='JSONARRAY', ctx=Load()), BoolOp(op=Or(), values=[BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='globally', ctx=Load())), Name(id='conn_or_curs', ctx=Load())]), Constant(value=None)])], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='JSON', ctx=Load()), Name(id='JSONARRAY', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='register_default_json', args=arguments(posonlyargs=[], args=[arg(arg='conn_or_curs'), arg(arg='globally'), arg(arg='loads')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='\n    Create and register :sql:`json` typecasters for PostgreSQL 9.2 and following.\n\n    Since PostgreSQL 9.2 :sql:`json` is a builtin type, hence its oid is known\n    and fixed. This function allows specifying a customized *loads* function\n    for the default :sql:`json` type without querying the database.\n    All the parameters have the same meaning of `register_json()`.\n    ')), Return(value=Call(func=Name(id='register_json', ctx=Load()), args=[], keywords=[keyword(arg='conn_or_curs', value=Name(id='conn_or_curs', ctx=Load())), keyword(arg='globally', value=Name(id='globally', ctx=Load())), keyword(arg='loads', value=Name(id='loads', ctx=Load())), keyword(arg='oid', value=Name(id='JSON_OID', ctx=Load())), keyword(arg='array_oid', value=Name(id='JSONARRAY_OID', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='register_default_jsonb', args=arguments(posonlyargs=[], args=[arg(arg='conn_or_curs'), arg(arg='globally'), arg(arg='loads')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='\n    Create and register :sql:`jsonb` typecasters for PostgreSQL 9.4 and following.\n\n    As in `register_default_json()`, the function allows to register a\n    customized *loads* function for the :sql:`jsonb` type at its known oid for\n    PostgreSQL 9.4 and following versions.  All the parameters have the same\n    meaning of `register_json()`.\n    ')), Return(value=Call(func=Name(id='register_json', ctx=Load()), args=[], keywords=[keyword(arg='conn_or_curs', value=Name(id='conn_or_curs', ctx=Load())), keyword(arg='globally', value=Name(id='globally', ctx=Load())), keyword(arg='loads', value=Name(id='loads', ctx=Load())), keyword(arg='oid', value=Name(id='JSONB_OID', ctx=Load())), keyword(arg='array_oid', value=Name(id='JSONBARRAY_OID', ctx=Load())), keyword(arg='name', value=Constant(value='jsonb'))]))], decorator_list=[]), FunctionDef(name='_create_json_typecasters', args=arguments(posonlyargs=[], args=[arg(arg='oid'), arg(arg='array_oid'), arg(arg='loads'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value='JSON')]), body=[Expr(value=Constant(value='Create typecasters for json data type.')), If(test=Compare(left=Name(id='loads', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='loads', ctx=Store())], value=Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()))], orelse=[]), FunctionDef(name='typecast_json', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='cur')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='s', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Return(value=Call(func=Name(id='loads', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='JSON', ctx=Store())], value=Call(func=Name(id='new_type', ctx=Load()), args=[Tuple(elts=[Name(id='oid', ctx=Load())], ctx=Load()), Name(id='name', ctx=Load()), Name(id='typecast_json', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='array_oid', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='JSONARRAY', ctx=Store())], value=Call(func=Name(id='new_array_type', ctx=Load()), args=[Tuple(elts=[Name(id='array_oid', ctx=Load())], ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='ARRAY')]), Name(id='JSON', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='JSONARRAY', ctx=Store())], value=Constant(value=None))]), Return(value=Tuple(elts=[Name(id='JSON', ctx=Load()), Name(id='JSONARRAY', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_get_json_oids', args=arguments(posonlyargs=[], args=[arg(arg='conn_or_curs'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='json')]), body=[ImportFrom(module='psycopg2.extensions', names=[alias(name='STATUS_IN_TRANSACTION')], level=0), ImportFrom(module='psycopg2.extras', names=[alias(name='_solve_conn_curs')], level=0), Assign(targets=[Tuple(elts=[Name(id='conn', ctx=Store()), Name(id='curs', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_solve_conn_curs', ctx=Load()), args=[Name(id='conn_or_curs', ctx=Load())], keywords=[])), Assign(targets=[Name(id='conn_status', ctx=Store())], value=Attribute(value=Name(id='conn', ctx=Load()), attr='status', ctx=Load())), Assign(targets=[Name(id='typarray', ctx=Store())], value=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Compare(left=Attribute(value=Attribute(value=Name(id='conn', ctx=Load()), attr='info', ctx=Load()), attr='server_version', ctx=Load()), ops=[GtE()], comparators=[Constant(value=80300)]), Constant(value='typarray')]), Constant(value='NULL')])), Expr(value=Call(func=Attribute(value=Name(id='curs', ctx=Load()), attr='execute', ctx=Load()), args=[BinOp(left=Constant(value='SELECT t.oid, %s FROM pg_type t WHERE t.typname = %%s;'), op=Mod(), right=Name(id='typarray', ctx=Load())), Tuple(elts=[Name(id='name', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Name(id='curs', ctx=Load()), attr='fetchone', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='conn_status', ctx=Load()), ops=[NotEq()], comparators=[Name(id='STATUS_IN_TRANSACTION', ctx=Load())]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='conn', ctx=Load()), attr='autocommit', ctx=Load()))]), body=[Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='rollback', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='r', ctx=Load())), body=[Raise(exc=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='ProgrammingError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value=' data type not found')])], keywords=[]))], orelse=[]), Return(value=Name(id='r', ctx=Load()))], decorator_list=[])], type_ignores=[])