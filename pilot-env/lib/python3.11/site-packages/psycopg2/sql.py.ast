Module(body=[Expr(value=Constant(value='SQL composition utility module\n')), Import(names=[alias(name='string')]), ImportFrom(module='psycopg2', names=[alias(name='extensions', asname='ext')], level=0), Assign(targets=[Name(id='_formatter', ctx=Store())], value=Call(func=Attribute(value=Name(id='string', ctx=Load()), attr='Formatter', ctx=Load()), args=[], keywords=[])), ClassDef(name='Composable', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Abstract base class for objects that can be used to compose an SQL string.\n\n    `!Composable` objects can be passed directly to `~cursor.execute()`,\n    `~cursor.executemany()`, `~cursor.copy_expert()` in place of the query\n    string.\n\n    `!Composable` objects can be joined using the ``+`` operator: the result\n    will be a `Composed` instance containing the objects joined. The operator\n    ``*`` is also supported with an integer argument: the result is a\n    `!Composed` instance containing the left argument repeated as many times as\n    requested.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='wrapped')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Store())], value=Name(id='wrapped', ctx=Load()))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='('), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), conversion=114), Constant(value=')')]))], decorator_list=[]), FunctionDef(name='as_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='context')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the string value of the object.\n\n        :param context: the context to evaluate the string into.\n        :type context: `connection` or `cursor`\n\n        The method is automatically invoked by `~cursor.execute()`,\n        `~cursor.executemany()`, `~cursor.copy_expert()` if a `!Composable` is\n        passed instead of the query string.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[]), FunctionDef(name='__add__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Composed', ctx=Load())], keywords=[]), body=[Return(value=BinOp(left=Call(func=Name(id='Composed', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load())], ctx=Load())], keywords=[]), op=Add(), right=Name(id='other', ctx=Load())))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Composable', ctx=Load())], keywords=[]), body=[Return(value=BinOp(left=Call(func=Name(id='Composed', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load())], ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='Composed', ctx=Load()), args=[List(elts=[Name(id='other', ctx=Load())], ctx=Load())], keywords=[])))], orelse=[Return(value=Name(id='NotImplemented', ctx=Load()))])], decorator_list=[]), FunctionDef(name='__mul__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Composed', ctx=Load()), args=[BinOp(left=List(elts=[Name(id='self', ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='_wrapped', ctx=Load())])]))], decorator_list=[]), FunctionDef(name='__ne__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__eq__', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])))], decorator_list=[])], decorator_list=[]), ClassDef(name='Composed', bases=[Name(id='Composable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A `Composable` object made of a sequence of `!Composable`.\n\n    The object is usually created using `!Composable` operators and methods.\n    However it is possible to create a `!Composed` directly specifying a\n    sequence of `!Composable` as arguments.\n\n    Example::\n\n        >>> comp = sql.Composed(\n        ...     [sql.SQL("insert into "), sql.Identifier("table")])\n        >>> print(comp.as_string(conn))\n        insert into "table"\n\n    `!Composed` objects are iterable (so they can be used in `SQL.join` for\n    instance).\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='seq')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='wrapped', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Name(id='seq', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='i', ctx=Load()), Name(id='Composable', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Composed elements must be Composable, got '), FormattedValue(value=Name(id='i', ctx=Load()), conversion=114), Constant(value=' instead')])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='wrapped', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='wrapped', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='seq', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The list of the content of the `!Composed`.')), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='as_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='context')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='i', ctx=Load()), attr='as_string', ctx=Load()), args=[Name(id='context', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='rv', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__add__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Composed', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='Composed', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), op=Add(), right=Attribute(value=Name(id='other', ctx=Load()), attr='_wrapped', ctx=Load()))], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Composable', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='Composed', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), op=Add(), right=List(elts=[Name(id='other', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[Return(value=Name(id='NotImplemented', ctx=Load()))])], decorator_list=[]), FunctionDef(name='join', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='joiner')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a new `!Composed` interposing the *joiner* with the `!Composed` items.\n\n        The *joiner* must be a `SQL` or a string which will be interpreted as\n        an `SQL`.\n\n        Example::\n\n            >>> fields = sql.Identifier(\'foo\') + sql.Identifier(\'bar\')  # a Composed\n            >>> print(fields.join(\', \').as_string(conn))\n            "foo", "bar"\n\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='joiner', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='joiner', ctx=Store())], value=Call(func=Name(id='SQL', ctx=Load()), args=[Name(id='joiner', ctx=Load())], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='joiner', ctx=Load()), Name(id='SQL', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Composed.join() argument must be a string or an SQL')], keywords=[]))], orelse=[])]), Return(value=Call(func=Attribute(value=Name(id='joiner', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='SQL', bases=[Name(id='Composable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A `Composable` representing a snippet of SQL statement.\n\n    `!SQL` exposes `join()` and `format()` methods useful to create a template\n    where to merge variable parts of a query (for instance field or table\n    names).\n\n    The *string* doesn\'t undergo any form of escaping, so it is not suitable to\n    represent variable identifiers or values: you should only use it to pass\n    constant strings representing templates or snippets of SQL statements; use\n    other objects such as `Identifier` or `Literal` to represent variable\n    parts.\n\n    Example::\n\n        >>> query = sql.SQL("select {0} from {1}").format(\n        ...    sql.SQL(\', \').join([sql.Identifier(\'foo\'), sql.Identifier(\'bar\')]),\n        ...    sql.Identifier(\'table\'))\n        >>> print(query.as_string(conn))\n        select "foo", "bar" from "table"\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='string')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='string', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='SQL values must be strings')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='string', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='string', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The string wrapped by the `!SQL` object.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='as_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='context')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()))], decorator_list=[]), FunctionDef(name='format', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='\n        Merge `Composable` objects into a template.\n\n        :param `Composable` args: parameters to replace to numbered\n            (``{0}``, ``{1}``) or auto-numbered (``{}``) placeholders\n        :param `Composable` kwargs: parameters to replace to named (``{name}``)\n            placeholders\n        :return: the union of the `!SQL` string with placeholders replaced\n        :rtype: `Composed`\n\n        The method is similar to the Python `str.format()` method: the string\n        template supports auto-numbered (``{}``), numbered (``{0}``,\n        ``{1}``...), and named placeholders (``{name}``), with positional\n        arguments replacing the numbered placeholders and keywords replacing\n        the named ones. However placeholder modifiers (``{0!r}``, ``{0:<10}``)\n        are not supported. Only `!Composable` objects can be passed to the\n        template.\n\n        Example::\n\n            >>> print(sql.SQL("select * from {} where {} = %s")\n            ...     .format(sql.Identifier(\'people\'), sql.Identifier(\'id\'))\n            ...     .as_string(conn))\n            select * from "people" where "id" = %s\n\n            >>> print(sql.SQL("select * from {tbl} where {pkey} = %s")\n            ...     .format(tbl=sql.Identifier(\'people\'), pkey=sql.Identifier(\'id\'))\n            ...     .as_string(conn))\n            select * from "people" where "id" = %s\n\n        ')), Assign(targets=[Name(id='rv', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='autonum', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='pre', ctx=Store()), Name(id='name', ctx=Store()), Name(id='spec', ctx=Store()), Name(id='conv', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='_formatter', ctx=Load()), attr='parse', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load())], keywords=[]), body=[If(test=Name(id='spec', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='no format specification supported by SQL')], keywords=[]))], orelse=[]), If(test=Name(id='conv', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='no format conversion supported by SQL')], keywords=[]))], orelse=[]), If(test=Name(id='pre', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='SQL', ctx=Load()), args=[Name(id='pre', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Continue()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[]), body=[If(test=Name(id='autonum', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot switch from automatic field numbering to manual')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='args', ctx=Load()), slice=Call(func=Name(id='int', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), ctx=Load())], keywords=[])), Assign(targets=[Name(id='autonum', ctx=Store())], value=Constant(value=None))], orelse=[If(test=UnaryOp(op=Not(), operand=Name(id='name', ctx=Load())), body=[If(test=Compare(left=Name(id='autonum', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot switch from manual field numbering to automatic')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='args', ctx=Load()), slice=Name(id='autonum', ctx=Load()), ctx=Load())], keywords=[])), AugAssign(target=Name(id='autonum', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load())], keywords=[]))])])], orelse=[]), Return(value=Call(func=Name(id='Composed', ctx=Load()), args=[Name(id='rv', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='join', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='seq')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Join a sequence of `Composable`.\n\n        :param seq: the elements to join.\n        :type seq: iterable of `!Composable`\n\n        Use the `!SQL` object\'s *string* to separate the elements in *seq*.\n        Note that `Composed` objects are iterable too, so they can be used as\n        argument for this method.\n\n        Example::\n\n            >>> snip = sql.SQL(\', \').join(\n            ...     sql.Identifier(n) for n in [\'foo\', \'bar\', \'baz\'])\n            >>> print(snip.as_string(conn))\n            "foo", "bar", "baz"\n        ')), Assign(targets=[Name(id='rv', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='seq', ctx=Load())], keywords=[])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='next', ctx=Load()), args=[Name(id='it', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Pass()])], orelse=[For(target=Name(id='i', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]))], orelse=[])], finalbody=[]), Return(value=Call(func=Name(id='Composed', ctx=Load()), args=[Name(id='rv', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Identifier', bases=[Name(id='Composable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A `Composable` representing an SQL identifier or a dot-separated sequence.\n\n    Identifiers usually represent names of database objects, such as tables or\n    fields. PostgreSQL identifiers follow `different rules`__ than SQL string\n    literals for escaping (e.g. they use double quotes instead of single).\n\n    .. __: https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#         SQL-SYNTAX-IDENTIFIERS\n\n    Example::\n\n        >>> t1 = sql.Identifier("foo")\n        >>> t2 = sql.Identifier("ba\'r")\n        >>> t3 = sql.Identifier(\'ba"z\')\n        >>> print(sql.SQL(\', \').join([t1, t2, t3]).as_string(conn))\n        "foo", "ba\'r", "ba""z"\n\n    Multiple strings can be passed to the object to represent a qualified name,\n    i.e. a dot-separated sequence of identifiers.\n\n    Example::\n\n        >>> query = sql.SQL("select {} from {}").format(\n        ...     sql.Identifier("table", "field"),\n        ...     sql.Identifier("schema", "table"))\n        >>> print(query.as_string(conn))\n        select "table"."field" from "schema"."table"\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='strings'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='strings', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Identifier cannot be empty')], keywords=[]))], orelse=[]), For(target=Name(id='s', ctx=Store()), iter=Name(id='strings', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='SQL identifier parts must be strings')], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='strings', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='strings', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='A tuple with the strings wrapped by the `Identifier`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='string', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The string wrapped by the `Identifier`.\n        ')), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Constant(value='the Identifier wraps more than one than one string')], keywords=[]))])], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='('), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='repr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load())], keywords=[])], keywords=[]), conversion=-1), Constant(value=')')]))], decorator_list=[]), FunctionDef(name='as_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='context')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='ext', ctx=Load()), attr='quote_ident', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='context', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='s', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Literal', bases=[Name(id='Composable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A `Composable` representing an SQL value to include in a query.\n\n    Usually you will want to include placeholders in the query and pass values\n    as `~cursor.execute()` arguments. If however you really really need to\n    include a literal value in the query you can use this object.\n\n    The string returned by `!as_string()` follows the normal :ref:`adaptation\n    rules <python-types-adaptation>` for Python objects.\n\n    Example::\n\n        >>> s1 = sql.Literal("foo")\n        >>> s2 = sql.Literal("ba\'r")\n        >>> s3 = sql.Literal(42)\n        >>> print(sql.SQL(\', \').join([s1, s2, s3]).as_string(conn))\n        \'foo\', \'ba\'\'r\', 42\n\n    ')), FunctionDef(name='wrapped', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The object wrapped by the `!Literal`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='as_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='context')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='context', ctx=Load()), Attribute(value=Name(id='ext', ctx=Load()), attr='connection', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Name(id='context', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='context', ctx=Load()), Attribute(value=Name(id='ext', ctx=Load()), attr='cursor', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Attribute(value=Name(id='context', ctx=Load()), attr='connection', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='context must be a connection or a cursor')], keywords=[]))])]), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Attribute(value=Name(id='ext', ctx=Load()), attr='adapt', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='a', ctx=Load()), Constant(value='prepare')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='a', ctx=Load()), attr='prepare', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Attribute(value=Name(id='a', ctx=Load()), attr='getquoted', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='rv', ctx=Load()), Name(id='bytes', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='decode', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='ext', ctx=Load()), attr='encodings', ctx=Load()), slice=Attribute(value=Name(id='conn', ctx=Load()), attr='encoding', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='rv', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='Placeholder', bases=[Name(id='Composable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A `Composable` representing a placeholder for query parameters.\n\n    If the name is specified, generate a named placeholder (e.g. ``%(name)s``),\n    otherwise generate a positional placeholder (e.g. ``%s``).\n\n    The object is useful to generate SQL queries with a variable number of\n    arguments.\n\n    Examples::\n\n        >>> names = [\'foo\', \'bar\', \'baz\']\n\n        >>> q1 = sql.SQL("insert into table ({}) values ({})").format(\n        ...     sql.SQL(\', \').join(map(sql.Identifier, names)),\n        ...     sql.SQL(\', \').join(sql.Placeholder() * len(names)))\n        >>> print(q1.as_string(conn))\n        insert into table ("foo", "bar", "baz") values (%s, %s, %s)\n\n        >>> q2 = sql.SQL("insert into table ({}) values ({})").format(\n        ...     sql.SQL(\', \').join(map(sql.Identifier, names)),\n        ...     sql.SQL(\', \').join(map(sql.Placeholder, names)))\n        >>> print(q2.as_string(conn))\n        insert into table ("foo", "bar", "baz") values (%(foo)s, %(bar)s, %(baz)s)\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Constant(value=')'), ops=[In()], comparators=[Name(id='name', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='invalid name: '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[])], orelse=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='expected string or None as name, got '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The name of the `!Placeholder`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='()')]))], orelse=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='('), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), conversion=114), Constant(value=')')]))])], decorator_list=[]), FunctionDef(name='as_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='context')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=JoinedStr(values=[Constant(value='%('), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_wrapped', ctx=Load()), conversion=-1), Constant(value=')s')]))], orelse=[Return(value=Constant(value='%s'))])], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='NULL', ctx=Store())], value=Call(func=Name(id='SQL', ctx=Load()), args=[Constant(value='NULL')], keywords=[])), Assign(targets=[Name(id='DEFAULT', ctx=Store())], value=Call(func=Name(id='SQL', ctx=Load()), args=[Constant(value='DEFAULT')], keywords=[]))], type_ignores=[])