Module(body=[Expr(value=Constant(value='Utilities for truncating assertion output.\n\nCurrent default behaviour is to truncate assertion explanations at\n~8 terminal lines, unless running in "-vv" mode or running on CI.\n')), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='_pytest.assertion', names=[alias(name='util')], level=0), ImportFrom(module='_pytest.nodes', names=[alias(name='Item')], level=0), Assign(targets=[Name(id='DEFAULT_MAX_LINES', ctx=Store())], value=Constant(value=8)), Assign(targets=[Name(id='DEFAULT_MAX_CHARS', ctx=Store())], value=BinOp(left=Constant(value=8), op=Mult(), right=Constant(value=80))), Assign(targets=[Name(id='USAGE_MSG', ctx=Store())], value=Constant(value="use '-vv' to show")), FunctionDef(name='truncate_if_required', args=arguments(posonlyargs=[], args=[arg(arg='explanation', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='item', annotation=Name(id='Item', ctx=Load())), arg(arg='max_length', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Truncate this assertion explanation if the given test item is eligible.')), If(test=Call(func=Name(id='_should_truncate_item', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='_truncate_explanation', ctx=Load()), args=[Name(id='explanation', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='explanation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_should_truncate_item', args=arguments(posonlyargs=[], args=[arg(arg='item', annotation=Name(id='Item', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether or not this test item is eligible for truncation.')), Assign(targets=[Name(id='verbose', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='item', ctx=Load()), attr='config', ctx=Load()), attr='option', ctx=Load()), attr='verbose', ctx=Load())), Return(value=BoolOp(op=And(), values=[Compare(left=Name(id='verbose', ctx=Load()), ops=[Lt()], comparators=[Constant(value=2)]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='util', ctx=Load()), attr='running_on_ci', ctx=Load()), args=[], keywords=[]))]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_truncate_explanation', args=arguments(posonlyargs=[], args=[arg(arg='input_lines', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='max_lines', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='max_chars', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Truncate given list of strings that makes up the assertion explanation.\n\n    Truncates to either 8 lines, or 640 characters - whichever the input reaches\n    first, taking the truncation explanation into account. The remaining lines\n    will be replaced by a usage message.\n    ')), If(test=Compare(left=Name(id='max_lines', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='max_lines', ctx=Store())], value=Name(id='DEFAULT_MAX_LINES', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='max_chars', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='max_chars', ctx=Store())], value=Name(id='DEFAULT_MAX_CHARS', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='input_char_count', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='input_lines', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='tolerable_max_chars', ctx=Store())], value=BinOp(left=Name(id='max_chars', ctx=Load()), op=Add(), right=Constant(value=70))), Assign(targets=[Name(id='tolerable_max_lines', ctx=Store())], value=BinOp(left=Name(id='max_lines', ctx=Load()), op=Add(), right=Constant(value=2))), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='input_lines', ctx=Load())], keywords=[]), ops=[LtE()], comparators=[Name(id='tolerable_max_lines', ctx=Load())]), Compare(left=Name(id='input_char_count', ctx=Load()), ops=[LtE()], comparators=[Name(id='tolerable_max_chars', ctx=Load())])]), body=[Return(value=Name(id='input_lines', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='truncated_explanation', ctx=Store())], value=Subscript(value=Name(id='input_lines', ctx=Load()), slice=Slice(upper=Name(id='max_lines', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='truncated_char', ctx=Store())], value=Constant(value=True)), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='truncated_explanation', ctx=Load())], keywords=[])], keywords=[]), ops=[Gt()], comparators=[Name(id='tolerable_max_chars', ctx=Load())]), body=[Assign(targets=[Name(id='truncated_explanation', ctx=Store())], value=Call(func=Name(id='_truncate_by_char_count', ctx=Load()), args=[Name(id='truncated_explanation', ctx=Load()), Name(id='max_chars', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='truncated_char', ctx=Store())], value=Constant(value=False))]), Assign(targets=[Name(id='truncated_line_count', ctx=Store())], value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='input_lines', ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='truncated_explanation', ctx=Load())], keywords=[]))), If(test=Subscript(value=Name(id='truncated_explanation', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='truncated_explanation', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Store())], value=BinOp(left=Subscript(value=Name(id='truncated_explanation', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), op=Add(), right=Constant(value='...'))), If(test=Name(id='truncated_char', ctx=Load()), body=[AugAssign(target=Name(id='truncated_line_count', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[Assign(targets=[Subscript(value=Name(id='truncated_explanation', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Store())], value=Constant(value='...'))]), Return(value=BinOp(left=Name(id='truncated_explanation', ctx=Load()), op=Add(), right=List(elts=[Constant(value=''), JoinedStr(values=[Constant(value='...Full output truncated ('), FormattedValue(value=Name(id='truncated_line_count', ctx=Load()), conversion=-1), Constant(value=' line'), FormattedValue(value=IfExp(test=Compare(left=Name(id='truncated_line_count', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=Constant(value=''), orelse=Constant(value='s')), conversion=-1), Constant(value=' hidden), '), FormattedValue(value=Name(id='USAGE_MSG', ctx=Load()), conversion=-1)])], ctx=Load())))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_truncate_by_char_count', args=arguments(posonlyargs=[], args=[arg(arg='input_lines', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='max_chars', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='iterated_char_count', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='iterated_index', ctx=Store()), Name(id='input_line', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='input_lines', ctx=Load())], keywords=[]), body=[If(test=Compare(left=BinOp(left=Name(id='iterated_char_count', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='input_line', ctx=Load())], keywords=[])), ops=[Gt()], comparators=[Name(id='max_chars', ctx=Load())]), body=[Break()], orelse=[]), AugAssign(target=Name(id='iterated_char_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='input_line', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='truncated_result', ctx=Store())], value=Subscript(value=Name(id='input_lines', ctx=Load()), slice=Slice(upper=Name(id='iterated_index', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='final_line', ctx=Store())], value=Subscript(value=Name(id='input_lines', ctx=Load()), slice=Name(id='iterated_index', ctx=Load()), ctx=Load())), If(test=Name(id='final_line', ctx=Load()), body=[Assign(targets=[Name(id='final_line_truncate_point', ctx=Store())], value=BinOp(left=Name(id='max_chars', ctx=Load()), op=Sub(), right=Name(id='iterated_char_count', ctx=Load()))), Assign(targets=[Name(id='final_line', ctx=Store())], value=Subscript(value=Name(id='final_line', ctx=Load()), slice=Slice(upper=Name(id='final_line_truncate_point', ctx=Load())), ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='truncated_result', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='final_line', ctx=Load())], keywords=[])), Return(value=Name(id='truncated_result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], type_ignores=[])