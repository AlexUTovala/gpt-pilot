Module(body=[Import(names=[alias(name='argparse')]), Import(names=[alias(name='os')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='warnings')]), ImportFrom(module='gettext', names=[alias(name='gettext')], level=0), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='cast')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Mapping')], level=0), ImportFrom(module='typing', names=[alias(name='NoReturn')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), Import(names=[alias(name='_pytest._io')]), ImportFrom(module='_pytest.compat', names=[alias(name='final')], level=0), ImportFrom(module='_pytest.config.exceptions', names=[alias(name='UsageError')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='ARGUMENT_PERCENT_DEFAULT')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='ARGUMENT_TYPE_STR')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='ARGUMENT_TYPE_STR_CHOICE')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='check_ispytest')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='typing_extensions', names=[alias(name='Literal')], level=0)], orelse=[]), Assign(targets=[Name(id='FILE_OR_DIR', ctx=Store())], value=Constant(value='file_or_dir')), ClassDef(name='Parser', bases=[], keywords=[], body=[Expr(value=Constant(value="Parser for command line arguments and ini-file values.\n\n    :ivar extra_info: Dict of generic param -> value to display in case\n        there's an error processing the command line arguments.\n    ")), AnnAssign(target=Name(id='prog', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='usage', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='processopt', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Constant(value='Argument')], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='_ispytest', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Name(id='check_ispytest', ctx=Load()), args=[Name(id='_ispytest', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_anonymous', ctx=Store())], value=Call(func=Name(id='OptionGroup', ctx=Load()), args=[Constant(value='Custom options')], keywords=[keyword(arg='parser', value=Name(id='self', ctx=Load())), keyword(arg='_ispytest', value=Constant(value=True))])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_groups', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='OptionGroup', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_processopt', ctx=Store())], value=Name(id='processopt', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_usage', ctx=Store())], value=Name(id='usage', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_inidict', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_ininames', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='extra_info', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='processoption', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='option', annotation=Constant(value='Argument'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_processopt', ctx=Load()), body=[If(test=Attribute(value=Name(id='option', ctx=Load()), attr='dest', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_processopt', ctx=Load()), args=[Name(id='option', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='getgroup', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='description', annotation=Name(id='str', ctx=Load())), arg(arg='after', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=None)]), body=[Expr(value=Constant(value='Get (or create) a named option Group.\n\n        :param name: Name of the option group.\n        :param description: Long description for --help output.\n        :param after: Name of another group, used for ordering --help output.\n        :returns: The option group.\n\n        The returned group object has an ``addoption`` method with the same\n        signature as :func:`parser.addoption <pytest.Parser.addoption>` but\n        will be shown in the respective group in the output of\n        ``pytest --help``.\n        ')), For(target=Name(id='group', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_groups', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='group', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Name(id='name', ctx=Load())]), body=[Return(value=Name(id='group', ctx=Load()))], orelse=[])], orelse=[]), Assign(targets=[Name(id='group', ctx=Store())], value=Call(func=Name(id='OptionGroup', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='description', ctx=Load())], keywords=[keyword(arg='parser', value=Name(id='self', ctx=Load())), keyword(arg='_ispytest', value=Constant(value=True))])), Assign(targets=[Name(id='i', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grp', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_groups', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Attribute(value=Name(id='grp', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Name(id='after', ctx=Load())]), body=[Break()], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_groups', ctx=Load()), attr='insert', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), Name(id='group', ctx=Load())], keywords=[])), Return(value=Name(id='group', ctx=Load()))], decorator_list=[], returns=Constant(value='OptionGroup')), FunctionDef(name='addoption', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='opts', annotation=Name(id='str', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='attrs', annotation=Name(id='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Register a command line option.\n\n        :param opts:\n            Option names, can be short or long options.\n        :param attrs:\n            Same attributes as the argparse library\'s :py:func:`add_argument()\n            <argparse.ArgumentParser.add_argument>` function accepts.\n\n        After command line parsing, options are available on the pytest config\n        object via ``config.option.NAME`` where ``NAME`` is usually set\n        by passing a ``dest`` attribute, for example\n        ``addoption("--long", dest="NAME", ...)``.\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_anonymous', ctx=Load()), attr='addoption', ctx=Load()), args=[Starred(value=Name(id='opts', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='attrs', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='parse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='args', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='namespace', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='argparse', ctx=Load()), attr='Namespace', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[ImportFrom(module='_pytest._argcomplete', names=[alias(name='try_argcomplete')], level=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optparser', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_getparser', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='try_argcomplete', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optparser', ctx=Load())], keywords=[])), Assign(targets=[Name(id='strargs', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='fspath', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='args', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optparser', ctx=Load()), attr='parse_args', ctx=Load()), args=[Name(id='strargs', ctx=Load())], keywords=[keyword(arg='namespace', value=Name(id='namespace', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='argparse', ctx=Load()), attr='Namespace', ctx=Load())), FunctionDef(name='_getparser', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='_pytest._argcomplete', names=[alias(name='filescompleter')], level=0), Assign(targets=[Name(id='optparser', ctx=Store())], value=Call(func=Name(id='MyOptionParser', ctx=Load()), args=[Name(id='self', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='extra_info', ctx=Load())], keywords=[keyword(arg='prog', value=Attribute(value=Name(id='self', ctx=Load()), attr='prog', ctx=Load()))])), Assign(targets=[Name(id='groups', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_groups', ctx=Load()), op=Add(), right=List(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='_anonymous', ctx=Load())], ctx=Load()))), For(target=Name(id='group', ctx=Store()), iter=Name(id='groups', ctx=Load()), body=[If(test=Attribute(value=Name(id='group', ctx=Load()), attr='options', ctx=Load()), body=[Assign(targets=[Name(id='desc', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='group', ctx=Load()), attr='description', ctx=Load()), Attribute(value=Name(id='group', ctx=Load()), attr='name', ctx=Load())])), Assign(targets=[Name(id='arggroup', ctx=Store())], value=Call(func=Attribute(value=Name(id='optparser', ctx=Load()), attr='add_argument_group', ctx=Load()), args=[Name(id='desc', ctx=Load())], keywords=[])), For(target=Name(id='option', ctx=Store()), iter=Attribute(value=Name(id='group', ctx=Load()), attr='options', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='option', ctx=Load()), attr='names', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Attribute(value=Name(id='option', ctx=Load()), attr='attrs', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='arggroup', ctx=Load()), attr='add_argument', ctx=Load()), args=[Starred(value=Name(id='n', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='a', ctx=Load()))]))], orelse=[])], orelse=[])], orelse=[]), Assign(targets=[Name(id='file_or_dir_arg', ctx=Store())], value=Call(func=Attribute(value=Name(id='optparser', ctx=Load()), attr='add_argument', ctx=Load()), args=[Name(id='FILE_OR_DIR', ctx=Load())], keywords=[keyword(arg='nargs', value=Constant(value='*'))])), Assign(targets=[Attribute(value=Name(id='file_or_dir_arg', ctx=Load()), attr='completer', ctx=Store())], value=Name(id='filescompleter', ctx=Load())), Return(value=Name(id='optparser', ctx=Load()))], decorator_list=[], returns=Constant(value='MyOptionParser')), FunctionDef(name='parse_setoption', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='args', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='option', annotation=Attribute(value=Name(id='argparse', ctx=Load()), attr='Namespace', ctx=Load())), arg(arg='namespace', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='argparse', ctx=Load()), attr='Namespace', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='parsedoption', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[keyword(arg='namespace', value=Name(id='namespace', ctx=Load()))])), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='parsedoption', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='option', ctx=Load()), Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='cast', ctx=Load()), args=[Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='parsedoption', ctx=Load()), Name(id='FILE_OR_DIR', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='parse_known_args', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='args', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='namespace', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='argparse', ctx=Load()), attr='Namespace', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Parse the known arguments at this point.\n\n        :returns: An argparse namespace object.\n        ')), Return(value=Subscript(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parse_known_and_unknown_args', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[keyword(arg='namespace', value=Name(id='namespace', ctx=Load()))]), slice=Constant(value=0), ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='argparse', ctx=Load()), attr='Namespace', ctx=Load())), FunctionDef(name='parse_known_and_unknown_args', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='args', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='namespace', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='argparse', ctx=Load()), attr='Namespace', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Parse the known arguments at this point, and also return the\n        remaining unknown arguments.\n\n        :returns:\n            A tuple containing an argparse namespace object for the known\n            arguments, and a list of the unknown arguments.\n        ')), Assign(targets=[Name(id='optparser', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_getparser', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='strargs', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='fspath', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='args', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Attribute(value=Name(id='optparser', ctx=Load()), attr='parse_known_args', ctx=Load()), args=[Name(id='strargs', ctx=Load())], keywords=[keyword(arg='namespace', value=Name(id='namespace', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='argparse', ctx=Load()), attr='Namespace', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='addini', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='help', annotation=Name(id='str', ctx=Load())), arg(arg='type', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value="Literal['string', 'paths', 'pathlist', 'args', 'linelist', 'bool']"), ctx=Load())), arg(arg='default', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Register an ini-file option.\n\n        :param name:\n            Name of the ini-variable.\n        :param type:\n            Type of the variable. Can be:\n\n                * ``string``: a string\n                * ``bool``: a boolean\n                * ``args``: a list of strings, separated as in a shell\n                * ``linelist``: a list of strings, separated by line breaks\n                * ``paths``: a list of :class:`pathlib.Path`, separated as in a shell\n                * ``pathlist``: a list of ``py.path``, separated as in a shell\n\n            .. versionadded:: 7.0\n                The ``paths`` variable type.\n\n            Defaults to ``string`` if ``None`` or not passed.\n        :param default:\n            Default value if no ini-file option exists but is queried.\n\n        The value of ini-variables can be retrieved via a call to\n        :py:func:`config.getini(name) <pytest.Config.getini>`.\n        ')), Assert(test=Compare(left=Name(id='type', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value=None), Constant(value='string'), Constant(value='paths'), Constant(value='pathlist'), Constant(value='args'), Constant(value='linelist'), Constant(value='bool')], ctx=Load())])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_inidict', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Tuple(elts=[Name(id='help', ctx=Load()), Name(id='type', ctx=Load()), Name(id='default', ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ininames', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[Name(id='final', ctx=Load())]), ClassDef(name='ArgumentError', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised if an Argument instance is created with invalid or\n    inconsistent arguments.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='msg', annotation=Name(id='str', ctx=Load())), arg(arg='option', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='Argument'), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Store())], value=Name(id='msg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='option_id', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='option', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='option_id', ctx=Load()), body=[Return(value=JoinedStr(values=[Constant(value='option '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='option_id', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Load()), conversion=-1)]))], orelse=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Load()))])], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='Argument', bases=[], keywords=[], body=[Expr(value=Constant(value="Class that mimics the necessary behaviour of optparse.Option.\n\n    It's currently a least effort implementation and ignoring choices\n    and integer prefixes.\n\n    https://docs.python.org/3/library/optparse.html#optparse-standard-option-types\n    ")), Assign(targets=[Name(id='_typ_map', ctx=Store())], value=Dict(keys=[Constant(value='int'), Constant(value='string'), Constant(value='float'), Constant(value='complex')], values=[Name(id='int', ctx=Load()), Name(id='str', ctx=Load()), Name(id='float', ctx=Load()), Name(id='complex', ctx=Load())])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='names', annotation=Name(id='str', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='attrs', annotation=Name(id='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Store params in private vars for use in add_argument.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_attrs', ctx=Store())], value=Name(id='attrs', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_short_opts', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_long_opts', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), If(test=Compare(left=Constant(value='%default'), ops=[In()], comparators=[BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='help')], keywords=[]), Constant(value='')])]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='ARGUMENT_PERCENT_DEFAULT', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=3))]))], orelse=[]), Try(body=[Assign(targets=[Name(id='typ', ctx=Store())], value=Subscript(value=Name(id='attrs', ctx=Load()), slice=Constant(value='type'), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Pass()])], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='typ', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='typ', ctx=Load()), ops=[Eq()], comparators=[Constant(value='choice')]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ARGUMENT_TYPE_STR_CHOICE', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='typ', value=Name(id='typ', ctx=Load())), keyword(arg='names', value=Name(id='names', ctx=Load()))])], keywords=[keyword(arg='stacklevel', value=Constant(value=4))])), Assign(targets=[Subscript(value=Name(id='attrs', ctx=Load()), slice=Constant(value='type'), ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='attrs', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ARGUMENT_TYPE_STR', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='typ', value=Name(id='typ', ctx=Load())), keyword(arg='names', value=Name(id='names', ctx=Load()))])], keywords=[keyword(arg='stacklevel', value=Constant(value=4))])), Assign(targets=[Subscript(value=Name(id='attrs', ctx=Load()), slice=Constant(value='type'), ctx=Store())], value=Subscript(value=Attribute(value=Name(id='Argument', ctx=Load()), attr='_typ_map', ctx=Load()), slice=Name(id='typ', ctx=Load()), ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Store())], value=Subscript(value=Name(id='attrs', ctx=Load()), slice=Constant(value='type'), ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Store())], value=Name(id='typ', ctx=Load()))])], finalbody=[]), Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='default', ctx=Store())], value=Subscript(value=Name(id='attrs', ctx=Load()), slice=Constant(value='default'), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_set_opt_strings', ctx=Load()), args=[Name(id='names', ctx=Load())], keywords=[])), AnnAssign(target=Name(id='dest', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='dest')], keywords=[]), simple=1), If(test=Name(id='dest', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dest', ctx=Store())], value=Name(id='dest', ctx=Load()))], orelse=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_long_opts', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dest', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_long_opts', ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Slice(lower=Constant(value=2)), ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='_')], keywords=[]))], orelse=[Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dest', ctx=Store())], value=Subscript(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_short_opts', ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), name='e', body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dest', ctx=Store())], value=Constant(value='???')), Raise(exc=Call(func=Name(id='ArgumentError', ctx=Load()), args=[Constant(value='need a long or short option'), Name(id='self', ctx=Load())], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])])])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='names', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_short_opts', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_long_opts', ctx=Load())))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='attrs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Attribute(value=Constant(value='default dest help'), attr='split', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='attrs', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dest', ctx=Load())], keywords=[])), For(target=Name(id='attr', ctx=Store()), iter=Name(id='attrs', ctx=Load()), body=[Try(body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_attrs', ctx=Load()), slice=Name(id='attr', ctx=Load()), ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_attrs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='help')], keywords=[]), body=[Assign(targets=[Name(id='a', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_attrs', ctx=Load()), slice=Constant(value='help'), ctx=Load())), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Attribute(value=Name(id='a', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='%default'), Constant(value='%(default)s')], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_attrs', ctx=Load()), slice=Constant(value='help'), ctx=Store())], value=Name(id='a', ctx=Load()))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_attrs', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_set_opt_strings', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='opts', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Directly from optparse.\n\n        Might not be necessary as this is passed to argparse later on.\n        ')), For(target=Name(id='opt', ctx=Store()), iter=Name(id='opts', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='opt', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=2)]), body=[Raise(exc=Call(func=Name(id='ArgumentError', ctx=Load()), args=[BinOp(left=Constant(value='invalid option string %r: must be at least two characters long'), op=Mod(), right=Name(id='opt', ctx=Load())), Name(id='self', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='opt', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), body=[If(test=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='opt', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Constant(value='-')]), Compare(left=Subscript(value=Name(id='opt', ctx=Load()), slice=Constant(value=1), ctx=Load()), ops=[NotEq()], comparators=[Constant(value='-')])])), body=[Raise(exc=Call(func=Name(id='ArgumentError', ctx=Load()), args=[BinOp(left=Constant(value='invalid short option string %r: must be of the form -x, (x any non-dash char)'), op=Mod(), right=Name(id='opt', ctx=Load())), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_short_opts', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='opt', ctx=Load())], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='opt', ctx=Load()), slice=Slice(lower=Constant(value=0), upper=Constant(value=2)), ctx=Load()), ops=[Eq()], comparators=[Constant(value='--')]), Compare(left=Subscript(value=Name(id='opt', ctx=Load()), slice=Constant(value=2), ctx=Load()), ops=[NotEq()], comparators=[Constant(value='-')])])), body=[Raise(exc=Call(func=Name(id='ArgumentError', ctx=Load()), args=[BinOp(left=Constant(value='invalid long option string %r: must start with --, followed by non-dash'), op=Mod(), right=Name(id='opt', ctx=Load())), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_long_opts', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='opt', ctx=Load())], keywords=[]))])])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='args', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_short_opts', ctx=Load()), body=[AugAssign(target=Name(id='args', ctx=Store()), op=Add(), value=List(elts=[BinOp(left=Constant(value='_short_opts: '), op=Add(), right=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_short_opts', ctx=Load())], keywords=[]))], ctx=Load()))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_long_opts', ctx=Load()), body=[AugAssign(target=Name(id='args', ctx=Store()), op=Add(), value=List(elts=[BinOp(left=Constant(value='_long_opts: '), op=Add(), right=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_long_opts', ctx=Load())], keywords=[]))], ctx=Load()))], orelse=[]), AugAssign(target=Name(id='args', ctx=Store()), op=Add(), value=List(elts=[BinOp(left=Constant(value='dest: '), op=Add(), right=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='dest', ctx=Load())], keywords=[]))], ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='type')], keywords=[]), body=[AugAssign(target=Name(id='args', ctx=Store()), op=Add(), value=List(elts=[BinOp(left=Constant(value='type: '), op=Add(), right=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Load())], keywords=[]))], ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='default')], keywords=[]), body=[AugAssign(target=Name(id='args', ctx=Store()), op=Add(), value=List(elts=[BinOp(left=Constant(value='default: '), op=Add(), right=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='default', ctx=Load())], keywords=[]))], ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='Argument({})'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='OptionGroup', bases=[], keywords=[], body=[Expr(value=Constant(value='A group of options shown in its own section.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='description', annotation=Name(id='str', ctx=Load())), arg(arg='parser', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Parser', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='_ispytest', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value=''), Constant(value=None)]), body=[Expr(value=Call(func=Name(id='check_ispytest', ctx=Load()), args=[Name(id='_ispytest', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='description', ctx=Store())], value=Name(id='description', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Argument', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parser', ctx=Store())], value=Name(id='parser', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='addoption', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='opts', annotation=Name(id='str', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='attrs', annotation=Name(id='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value="Add an option to this group.\n\n        If a shortened version of a long option is specified, it will\n        be suppressed in the help. ``addoption('--twowords', '--two-words')``\n        results in help showing ``--two-words`` only, but ``--twowords`` gets\n        accepted **and** the automatic destination is in ``args.twowords``.\n\n        :param opts:\n            Option names, can be short or long options.\n        :param attrs:\n            Same attributes as the argparse library's :py:func:`add_argument()\n            <argparse.ArgumentParser.add_argument>` function accepts.\n        ")), Assign(targets=[Name(id='conflict', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='opts', ctx=Load())], keywords=[]), attr='intersection', ctx=Load()), args=[GeneratorExp(elt=Name(id='name', ctx=Load()), generators=[comprehension(target=Name(id='opt', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Load()), ifs=[], is_async=0), comprehension(target=Name(id='name', ctx=Store()), iter=Call(func=Attribute(value=Name(id='opt', ctx=Load()), attr='names', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])), If(test=Name(id='conflict', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='option names %s already added'), op=Mod(), right=Name(id='conflict', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='option', ctx=Store())], value=Call(func=Name(id='Argument', ctx=Load()), args=[Starred(value=Name(id='opts', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='attrs', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_addoption_instance', ctx=Load()), args=[Name(id='option', ctx=Load())], keywords=[keyword(arg='shortupper', value=Constant(value=False))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_addoption', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='opts', annotation=Name(id='str', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='attrs', annotation=Name(id='Any', ctx=Load())), defaults=[]), body=[Assign(targets=[Name(id='option', ctx=Store())], value=Call(func=Name(id='Argument', ctx=Load()), args=[Starred(value=Name(id='opts', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='attrs', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_addoption_instance', ctx=Load()), args=[Name(id='option', ctx=Load())], keywords=[keyword(arg='shortupper', value=Constant(value=True))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_addoption_instance', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='option', annotation=Constant(value='Argument')), arg(arg='shortupper', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='shortupper', ctx=Load())), body=[For(target=Name(id='opt', ctx=Store()), iter=Attribute(value=Name(id='option', ctx=Load()), attr='_short_opts', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='opt', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Constant(value='-')]), Call(func=Attribute(value=Subscript(value=Name(id='opt', ctx=Load()), slice=Constant(value=1), ctx=Load()), attr='islower', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='lowercase shortoptions reserved')], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='parser', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parser', ctx=Load()), attr='processoption', ctx=Load()), args=[Name(id='option', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='option', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='MyOptionParser', bases=[Attribute(value=Name(id='argparse', ctx=Load()), attr='ArgumentParser', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parser', annotation=Name(id='Parser', ctx=Load())), arg(arg='extra_info', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='prog', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_parser', ctx=Store())], value=Name(id='parser', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='prog', value=Name(id='prog', ctx=Load())), keyword(arg='usage', value=Attribute(value=Name(id='parser', ctx=Load()), attr='_usage', ctx=Load())), keyword(arg='add_help', value=Constant(value=False)), keyword(arg='formatter_class', value=Name(id='DropShorterLongHelpFormatter', ctx=Load())), keyword(arg='allow_abbrev', value=Constant(value=False))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='extra_info', ctx=Store())], value=IfExp(test=Name(id='extra_info', ctx=Load()), body=Name(id='extra_info', ctx=Load()), orelse=Dict(keys=[], values=[])))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='error', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='message', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Transform argparse error message into UsageError.')), Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='prog', ctx=Load()), conversion=-1), Constant(value=': error: '), FormattedValue(value=Name(id='message', ctx=Load()), conversion=-1)])), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_parser', ctx=Load()), Constant(value='_config_source_hint')], keywords=[]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='msg', ctx=Load()), conversion=-1), Constant(value=' ('), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_parser', ctx=Load()), attr='_config_source_hint', ctx=Load()), conversion=-1), Constant(value=')')]))], orelse=[]), Raise(exc=Call(func=Name(id='UsageError', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='format_usage', ctx=Load()), args=[], keywords=[]), op=Add(), right=Name(id='msg', ctx=Load()))], keywords=[]))], decorator_list=[], returns=Name(id='NoReturn', ctx=Load())), FunctionDef(name='parse_args', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='args', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='namespace', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='argparse', ctx=Load()), attr='Namespace', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Allow splitting of positional arguments.')), Assign(targets=[Tuple(elts=[Name(id='parsed', ctx=Store()), Name(id='unrecognized', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parse_known_args', ctx=Load()), args=[Name(id='args', ctx=Load()), Name(id='namespace', ctx=Load())], keywords=[])), If(test=Name(id='unrecognized', ctx=Load()), body=[For(target=Name(id='arg', ctx=Store()), iter=Name(id='unrecognized', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Name(id='arg', ctx=Load()), Compare(left=Subscript(value=Name(id='arg', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Constant(value='-')])]), body=[Assign(targets=[Name(id='lines', ctx=Store())], value=List(elts=[BinOp(left=Constant(value='unrecognized arguments: %s'), op=Mod(), right=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Name(id='unrecognized', ctx=Load())], keywords=[]))], ctx=Load())), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='extra_info', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[Constant(value='  '), FormattedValue(value=Name(id='k', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='v', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='error', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='parsed', ctx=Load()), Name(id='FILE_OR_DIR', ctx=Load())], keywords=[]), attr='extend', ctx=Load()), args=[Name(id='unrecognized', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='parsed', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='argparse', ctx=Load()), attr='Namespace', ctx=Load())), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[Lt()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=9)], ctx=Load())]), body=[FunctionDef(name='_parse_optional', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='arg_string', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='arg_string', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Subscript(value=Name(id='arg_string', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='prefix_chars', ctx=Load())])), body=[Return(value=Constant(value=None))], orelse=[]), If(test=Compare(left=Name(id='arg_string', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_option_string_actions', ctx=Load())]), body=[Assign(targets=[Name(id='action', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_option_string_actions', ctx=Load()), slice=Name(id='arg_string', ctx=Load()), ctx=Load())), Return(value=Tuple(elts=[Name(id='action', ctx=Load()), Name(id='arg_string', ctx=Load()), Constant(value=None)], ctx=Load()))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='arg_string', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Constant(value=None))], orelse=[]), If(test=Compare(left=Constant(value='='), ops=[In()], comparators=[Name(id='arg_string', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='option_string', ctx=Store()), Name(id='explicit_arg', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='arg_string', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='='), Constant(value=1)], keywords=[])), If(test=Compare(left=Name(id='option_string', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_option_string_actions', ctx=Load())]), body=[Assign(targets=[Name(id='action', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_option_string_actions', ctx=Load()), slice=Name(id='option_string', ctx=Load()), ctx=Load())), Return(value=Tuple(elts=[Name(id='action', ctx=Load()), Name(id='option_string', ctx=Load()), Name(id='explicit_arg', ctx=Load())], ctx=Load()))], orelse=[])], orelse=[]), If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='allow_abbrev', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='arg_string', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='--')], keywords=[]))]), body=[Assign(targets=[Name(id='option_tuples', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_option_tuples', ctx=Load()), args=[Name(id='arg_string', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='option_tuples', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Name(id='gettext', ctx=Load()), args=[Constant(value='ambiguous option: %(option)s could match %(matches)s')], keywords=[])), Assign(targets=[Name(id='options', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Name(id='option', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='_', ctx=Store()), Name(id='option', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store()), iter=Name(id='option_tuples', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='error', ctx=Load()), args=[BinOp(left=Name(id='msg', ctx=Load()), op=Mod(), right=Dict(keys=[Constant(value='option'), Constant(value='matches')], values=[Name(id='arg_string', ctx=Load()), Name(id='options', ctx=Load())]))], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='option_tuples', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Tuple(elts=[Name(id='option_tuple', ctx=Store())], ctx=Store())], value=Name(id='option_tuples', ctx=Load())), Return(value=Name(id='option_tuple', ctx=Load()))], orelse=[])])], orelse=[]), If(test=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_negative_number_matcher', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='arg_string', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_has_negative_number_optionals', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[])], orelse=[]), If(test=Compare(left=Constant(value=' '), ops=[In()], comparators=[Name(id='arg_string', ctx=Load())]), body=[Return(value=Constant(value=None))], orelse=[]), Return(value=Tuple(elts=[Constant(value=None), Name(id='arg_string', ctx=Load()), Constant(value=None)], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='argparse', ctx=Load()), attr='Action', ctx=Load()), ctx=Load()), Name(id='str', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], orelse=[])], decorator_list=[]), ClassDef(name='DropShorterLongHelpFormatter', bases=[Attribute(value=Name(id='argparse', ctx=Load()), attr='HelpFormatter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Shorten help for long options that differ only in extra hyphens.\n\n    - Collapse **long** options that are the same except for extra hyphens.\n    - Shortcut if there are only two options and one of them is a short one.\n    - Cache result on the action object as this is called at least 2 times.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Name(id='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[]), body=[If(test=Compare(left=Constant(value='width'), ops=[NotIn()], comparators=[Name(id='kwargs', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='width'), ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='_pytest', ctx=Load()), attr='_io', ctx=Load()), attr='get_terminal_width', ctx=Load()), args=[], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_format_action_invocation', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='action', annotation=Attribute(value=Name(id='argparse', ctx=Load()), attr='Action', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='orgstr', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='_format_action_invocation', ctx=Load()), args=[Name(id='action', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='orgstr', ctx=Load()), Compare(left=Subscript(value=Name(id='orgstr', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[NotEq()], comparators=[Constant(value='-')])]), body=[Return(value=Name(id='orgstr', ctx=Load()))], orelse=[]), AnnAssign(target=Name(id='res', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='action', ctx=Load()), Constant(value='_formatted_action_invocation'), Constant(value=None)], keywords=[]), simple=1), If(test=Name(id='res', ctx=Load()), body=[Return(value=Name(id='res', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='options', ctx=Store())], value=Call(func=Attribute(value=Name(id='orgstr', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=', ')], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='options', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='options', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='options', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)])])]), body=[Assign(targets=[Attribute(value=Name(id='action', ctx=Load()), attr='_formatted_action_invocation', ctx=Store())], value=Name(id='orgstr', ctx=Load())), Return(value=Name(id='orgstr', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='return_list', ctx=Store())], value=List(elts=[], ctx=Load())), AnnAssign(target=Name(id='short_long', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), For(target=Name(id='option', ctx=Store()), iter=Name(id='options', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='option', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), Compare(left=Subscript(value=Name(id='option', ctx=Load()), slice=Constant(value=2), ctx=Load()), ops=[Eq()], comparators=[Constant(value=' ')])]), body=[Continue()], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='option', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='--')], keywords=[])), body=[Raise(exc=Call(func=Name(id='ArgumentError', ctx=Load()), args=[BinOp(left=Constant(value='long optional argument without "--": [%s]'), op=Mod(), right=Name(id='option', ctx=Load())), Name(id='option', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='xxoption', ctx=Store())], value=Subscript(value=Name(id='option', ctx=Load()), slice=Slice(lower=Constant(value=2)), ctx=Load())), Assign(targets=[Name(id='shortened', ctx=Store())], value=Call(func=Attribute(value=Name(id='xxoption', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='')], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='shortened', ctx=Load()), ops=[NotIn()], comparators=[Name(id='short_long', ctx=Load())]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='short_long', ctx=Load()), slice=Name(id='shortened', ctx=Load()), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='xxoption', ctx=Load())], keywords=[])])]), body=[Assign(targets=[Subscript(value=Name(id='short_long', ctx=Load()), slice=Name(id='shortened', ctx=Load()), ctx=Store())], value=Name(id='xxoption', ctx=Load()))], orelse=[])], orelse=[]), For(target=Name(id='option', ctx=Store()), iter=Name(id='options', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='option', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), Compare(left=Subscript(value=Name(id='option', ctx=Load()), slice=Constant(value=2), ctx=Load()), ops=[Eq()], comparators=[Constant(value=' ')])]), body=[Expr(value=Call(func=Attribute(value=Name(id='return_list', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='option', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Name(id='option', ctx=Load()), slice=Slice(lower=Constant(value=2)), ctx=Load()), ops=[Eq()], comparators=[Call(func=Attribute(value=Name(id='short_long', ctx=Load()), attr='get', ctx=Load()), args=[Call(func=Attribute(value=Name(id='option', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='')], keywords=[])], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='return_list', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='option', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=' '), Constant(value='='), Constant(value=1)], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='formatted_action_invocation', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='return_list', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='action', ctx=Load()), attr='_formatted_action_invocation', ctx=Store())], value=Name(id='formatted_action_invocation', ctx=Load())), Return(value=Name(id='formatted_action_invocation', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_split_lines', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text'), arg(arg='width')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Wrap lines after splitting on original newlines.\n\n        This allows to have explicit line breaks in the help text.\n        ')), Import(names=[alias(name='textwrap')]), Assign(targets=[Name(id='lines', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='textwrap', ctx=Load()), attr='wrap', ctx=Load()), args=[Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), Name(id='width', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='lines', ctx=Load()))], decorator_list=[])], decorator_list=[])], type_ignores=[])