Module(body=[Expr(value=Constant(value='Record warnings during test function execution.')), Import(names=[alias(name='re')]), Import(names=[alias(name='warnings')]), ImportFrom(module='pprint', names=[alias(name='pformat')], level=0), ImportFrom(module='types', names=[alias(name='TracebackType')], level=0), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='Generator')], level=0), ImportFrom(module='typing', names=[alias(name='Iterator')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Pattern')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='Type')], level=0), ImportFrom(module='typing', names=[alias(name='TypeVar')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='final')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='overload')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='check_ispytest')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='WARNS_NONE_ARG')], level=0), ImportFrom(module='_pytest.fixtures', names=[alias(name='fixture')], level=0), ImportFrom(module='_pytest.outcomes', names=[alias(name='fail')], level=0), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='T')], keywords=[])), FunctionDef(name='recwarn', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a :class:`WarningsRecorder` instance that records all warnings emitted by test functions.\n\n    See https://docs.pytest.org/en/latest/how-to/capture-warnings.html for information\n    on warning categories.\n    ')), Assign(targets=[Name(id='wrec', ctx=Store())], value=Call(func=Name(id='WarningsRecorder', ctx=Load()), args=[], keywords=[keyword(arg='_ispytest', value=Constant(value=True))])), With(items=[withitem(context_expr=Name(id='wrec', ctx=Load()))], body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='simplefilter', ctx=Load()), args=[Constant(value='default')], keywords=[])), Expr(value=Yield(value=Name(id='wrec', ctx=Load())))])], decorator_list=[Name(id='fixture', ctx=Load())], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Constant(value='WarningsRecorder'), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), FunctionDef(name='deprecated_call', args=arguments(posonlyargs=[], args=[], kwonlyargs=[arg(arg='match', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Pattern', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=Ellipsis)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Constant(value='WarningsRecorder')), FunctionDef(name='deprecated_call', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='T', ctx=Load())], ctx=Load()), ctx=Load()))], vararg=arg(arg='args', annotation=Name(id='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Name(id='T', ctx=Load())), FunctionDef(name='deprecated_call', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], vararg=arg(arg='args', annotation=Name(id='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Assert that code produces a ``DeprecationWarning`` or ``PendingDeprecationWarning``.\n\n    This function can be used as a context manager::\n\n        >>> import warnings\n        >>> def api_call_v2():\n        ...     warnings.warn('use v3 of this api', DeprecationWarning)\n        ...     return 200\n\n        >>> import pytest\n        >>> with pytest.deprecated_call():\n        ...    assert api_call_v2() == 200\n\n    It can also be used by passing a function and ``*args`` and ``**kwargs``,\n    in which case it will ensure calling ``func(*args, **kwargs)`` produces one of\n    the warnings types above. The return value is the return value of the function.\n\n    In the context manager form you may use the keyword argument ``match`` to assert\n    that the warning matches a text or regex.\n\n    The context manager produces a list of :class:`warnings.WarningMessage` objects,\n    one for each warning raised.\n    ")), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), If(test=Compare(left=Name(id='func', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='args', ctx=Store())], value=BinOp(left=Tuple(elts=[Name(id='func', ctx=Load())], ctx=Load()), op=Add(), right=Name(id='args', ctx=Load())))], orelse=[]), Return(value=Call(func=Name(id='warns', ctx=Load()), args=[Tuple(elts=[Name(id='DeprecationWarning', ctx=Load()), Name(id='PendingDeprecationWarning', ctx=Load())], ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='WarningsRecorder'), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='warns', args=arguments(posonlyargs=[], args=[arg(arg='expected_warning', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='Warning', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='Warning', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='match', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Pattern', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=Ellipsis)], defaults=[Constant(value=Ellipsis)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Constant(value='WarningsChecker')), FunctionDef(name='warns', args=arguments(posonlyargs=[], args=[arg(arg='expected_warning', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='Warning', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='Warning', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='func', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='T', ctx=Load())], ctx=Load()), ctx=Load()))], vararg=arg(arg='args', annotation=Name(id='Any', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Name(id='T', ctx=Load())), FunctionDef(name='warns', args=arguments(posonlyargs=[], args=[arg(arg='expected_warning', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='Warning', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='Warning', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], vararg=arg(arg='args', annotation=Name(id='Any', ctx=Load())), kwonlyargs=[arg(arg='match', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Pattern', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[Name(id='Warning', ctx=Load())]), body=[Expr(value=Constant(value='Assert that code raises a particular class of warning.\n\n    Specifically, the parameter ``expected_warning`` can be a warning class or sequence\n    of warning classes, and the code inside the ``with`` block must issue at least one\n    warning of that class or classes.\n\n    This helper produces a list of :class:`warnings.WarningMessage` objects, one for\n    each warning raised (regardless of whether it is an ``expected_warning`` or not).\n\n    This function can be used as a context manager, which will capture all the raised\n    warnings inside it::\n\n        >>> import pytest\n        >>> with pytest.warns(RuntimeWarning):\n        ...    warnings.warn("my warning", RuntimeWarning)\n\n    In the context manager form you may use the keyword argument ``match`` to assert\n    that the warning matches a text or regex::\n\n        >>> with pytest.warns(UserWarning, match=\'must be 0 or None\'):\n        ...     warnings.warn("value must be 0 or None", UserWarning)\n\n        >>> with pytest.warns(UserWarning, match=r\'must be \\d+$\'):\n        ...     warnings.warn("value must be 42", UserWarning)\n\n        >>> with pytest.warns(UserWarning, match=r\'must be \\d+$\'):\n        ...     warnings.warn("this is not here", UserWarning)\n        Traceback (most recent call last):\n          ...\n        Failed: DID NOT WARN. No warnings of type ...UserWarning... were emitted...\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref` it is possible to parametrize tests\n    such that some runs raise a warning and others do not.\n\n    This could be achieved in the same way as with exceptions, see\n    :ref:`parametrizing_conditional_raising` for an example.\n\n    ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), If(test=UnaryOp(op=Not(), operand=Name(id='args', ctx=Load())), body=[If(test=Name(id='kwargs', ctx=Load()), body=[Assign(targets=[Name(id='argnames', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[])], keywords=[])), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Unexpected keyword arguments passed to pytest.warns: '), FormattedValue(value=Name(id='argnames', ctx=Load()), conversion=-1), Constant(value='\nUse context-manager form instead?')])], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='WarningsChecker', ctx=Load()), args=[Name(id='expected_warning', ctx=Load())], keywords=[keyword(arg='match_expr', value=Name(id='match', ctx=Load())), keyword(arg='_ispytest', value=Constant(value=True))]))], orelse=[Assign(targets=[Name(id='func', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='func', ctx=Load()), conversion=114), Constant(value=' object (type: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), conversion=-1), Constant(value=') must be callable')])], keywords=[]))], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='WarningsChecker', ctx=Load()), args=[Name(id='expected_warning', ctx=Load())], keywords=[keyword(arg='_ispytest', value=Constant(value=True))]))], body=[Return(value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))])])], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='WarningsChecker'), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='WarningsRecorder', bases=[Attribute(value=Name(id='warnings', ctx=Load()), attr='catch_warnings', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A context manager to record raised warnings.\n\n    Each recorded warning is an instance of :class:`warnings.WarningMessage`.\n\n    Adapted from `warnings.catch_warnings`.\n\n    .. note::\n        ``DeprecationWarning`` and ``PendingDeprecationWarning`` are treated\n        differently; see :ref:`ensuring_function_triggers`.\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[arg(arg='_ispytest', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[]), body=[Expr(value=Call(func=Name(id='check_ispytest', ctx=Load()), args=[Name(id='_ispytest', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='record', value=Constant(value=True))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_entered', ctx=Store())], value=Constant(value=False)), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_list', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Attribute(value=Name(id='warnings', ctx=Load()), attr='WarningMessage', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='list', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The list of recorded warnings.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_list', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='warnings.WarningMessage'), ctx=Load())), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='i', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get a recorded warning by index.')), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_list', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()))], decorator_list=[], returns=Constant(value='warnings.WarningMessage')), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterate through the recorded warnings.')), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_list', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Constant(value='warnings.WarningMessage'), ctx=Load())), FunctionDef(name='__len__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The number of recorded warnings.')), Return(value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_list', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='pop', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls', annotation=Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='Warning', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='Warning', ctx=Load())]), body=[Expr(value=Constant(value='Pop the first recorded warning, raise exception if not exists.')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='w', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_list', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Name(id='w', ctx=Load()), attr='category', ctx=Load()), Name(id='cls', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_list', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='cls', ctx=Load()), conversion=114), Constant(value=' not found in warning list')])], keywords=[]))], decorator_list=[], returns=Constant(value='warnings.WarningMessage')), FunctionDef(name='clear', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Clear the list of recorded warnings.')), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_list', ctx=Load()), slice=Slice(), ctx=Store())], value=List(elts=[], ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_entered', ctx=Load()), body=[Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot enter '), FormattedValue(value=Name(id='self', ctx=Load()), conversion=114), Constant(value=' twice')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='_list', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__enter__', ctx=Load()), args=[], keywords=[])), Assert(test=Compare(left=Name(id='_list', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_list', ctx=Store())], value=Name(id='_list', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='simplefilter', ctx=Load()), args=[Constant(value='always')], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='WarningsRecorder')), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exc_type', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='exc_val', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load())), arg(arg='exc_tb', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='TracebackType', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_entered', ctx=Load())), body=[Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot exit '), FormattedValue(value=Name(id='self', ctx=Load()), conversion=114), Constant(value=' without entering first')])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__exit__', ctx=Load()), args=[Name(id='exc_type', ctx=Load()), Name(id='exc_val', ctx=Load()), Name(id='exc_tb', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_entered', ctx=Store())], value=Constant(value=False))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='WarningsChecker', bases=[Name(id='WarningsRecorder', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expected_warning', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='Warning', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='Warning', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='match_expr', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Pattern', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='_ispytest', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Name(id='Warning', ctx=Load()), Constant(value=None)]), body=[Expr(value=Call(func=Name(id='check_ispytest', ctx=Load()), args=[Name(id='_ispytest', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='_ispytest', value=Constant(value=True))])), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='exceptions must be derived from Warning, not %s')), If(test=Compare(left=Name(id='expected_warning', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='WARNS_NONE_ARG', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=4))])), Assign(targets=[Name(id='expected_warning_tup', ctx=Store())], value=Constant(value=None))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='expected_warning', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), body=[For(target=Name(id='exc', ctx=Store()), iter=Name(id='expected_warning', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='issubclass', ctx=Load()), args=[Name(id='exc', ctx=Load()), Name(id='Warning', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Name(id='msg', ctx=Load()), op=Mod(), right=Call(func=Name(id='type', ctx=Load()), args=[Name(id='exc', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='expected_warning_tup', ctx=Store())], value=Name(id='expected_warning', ctx=Load()))], orelse=[If(test=Call(func=Name(id='issubclass', ctx=Load()), args=[Name(id='expected_warning', ctx=Load()), Name(id='Warning', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='expected_warning_tup', ctx=Store())], value=Tuple(elts=[Name(id='expected_warning', ctx=Load())], ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Name(id='msg', ctx=Load()), op=Mod(), right=Call(func=Name(id='type', ctx=Load()), args=[Name(id='expected_warning', ctx=Load())], keywords=[]))], keywords=[]))])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expected_warning', ctx=Store())], value=Name(id='expected_warning_tup', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='match_expr', ctx=Store())], value=Name(id='match_expr', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exc_type', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='exc_val', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load())), arg(arg='exc_tb', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='TracebackType', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__exit__', ctx=Load()), args=[Name(id='exc_type', ctx=Load()), Name(id='exc_val', ctx=Load()), Name(id='exc_tb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), FunctionDef(name='found_str', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='pformat', ctx=Load()), args=[ListComp(elt=Attribute(value=Name(id='record', ctx=Load()), attr='message', ctx=Load()), generators=[comprehension(target=Name(id='record', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[], is_async=0)])], keywords=[keyword(arg='indent', value=Constant(value=2))]))], decorator_list=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='exc_type', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='exc_val', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='exc_tb', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expected_warning', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='category', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='expected_warning', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='r', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[JoinedStr(values=[Constant(value='DID NOT WARN. No warnings of type '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='expected_warning', ctx=Load()), conversion=-1), Constant(value=' were emitted.\nThe list of emitted warnings is: '), FormattedValue(value=Call(func=Name(id='found_str', ctx=Load()), args=[], keywords=[]), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='match_expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[For(target=Name(id='r', ctx=Store()), iter=Name(id='self', ctx=Load()), body=[If(test=Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='category', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='expected_warning', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='match_expr', ctx=Load())], keywords=[]), attr='search', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='message', ctx=Load())], keywords=[])], keywords=[]), body=[Break()], orelse=[])], orelse=[])], orelse=[Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[JoinedStr(values=[Constant(value='DID NOT WARN. No warnings of type '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='expected_warning', ctx=Load()), conversion=-1), Constant(value=' matching the regex were emitted.\n Regex: '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='match_expr', ctx=Load()), conversion=-1), Constant(value='\n Emitted warnings: '), FormattedValue(value=Call(func=Name(id='found_str', ctx=Load()), args=[], keywords=[]), conversion=-1)])], keywords=[]))])], orelse=[])])], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[Name(id='final', ctx=Load())])], type_ignores=[])