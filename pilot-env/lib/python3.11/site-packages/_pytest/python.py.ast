Module(body=[Expr(value=Constant(value='Python test discovery, setup and run of test functions.')), Import(names=[alias(name='dataclasses')]), Import(names=[alias(name='enum')]), Import(names=[alias(name='fnmatch')]), Import(names=[alias(name='inspect')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='os')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='types')]), Import(names=[alias(name='warnings')]), ImportFrom(module='collections', names=[alias(name='Counter')], level=0), ImportFrom(module='collections', names=[alias(name='defaultdict')], level=0), ImportFrom(module='functools', names=[alias(name='partial')], level=0), ImportFrom(module='pathlib', names=[alias(name='Path')], level=0), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='Generator')], level=0), ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='Iterator')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Mapping')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Pattern')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='Set')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), Import(names=[alias(name='_pytest')]), ImportFrom(module='_pytest', names=[alias(name='fixtures')], level=0), ImportFrom(module='_pytest', names=[alias(name='nodes')], level=0), ImportFrom(module='_pytest._code', names=[alias(name='filter_traceback')], level=0), ImportFrom(module='_pytest._code', names=[alias(name='getfslineno')], level=0), ImportFrom(module='_pytest._code.code', names=[alias(name='ExceptionInfo')], level=0), ImportFrom(module='_pytest._code.code', names=[alias(name='TerminalRepr')], level=0), ImportFrom(module='_pytest._code.code', names=[alias(name='Traceback')], level=0), ImportFrom(module='_pytest._io', names=[alias(name='TerminalWriter')], level=0), ImportFrom(module='_pytest._io.saferepr', names=[alias(name='saferepr')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='ascii_escaped')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='assert_never')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='final')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='get_default_arg_names')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='get_real_func')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='getimfunc')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='getlocation')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='is_async_function')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='is_generator')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='LEGACY_PATH')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='NOTSET')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='safe_getattr')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='safe_isclass')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='STRING_TYPES')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='Config')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='ExitCode')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='hookimpl')], level=0), ImportFrom(module='_pytest.config.argparsing', names=[alias(name='Parser')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='check_ispytest')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='INSTANCE_COLLECTOR')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='NOSE_SUPPORT_METHOD')], level=0), ImportFrom(module='_pytest.fixtures', names=[alias(name='FuncFixtureInfo')], level=0), ImportFrom(module='_pytest.main', names=[alias(name='Session')], level=0), ImportFrom(module='_pytest.mark', names=[alias(name='MARK_GEN')], level=0), ImportFrom(module='_pytest.mark', names=[alias(name='ParameterSet')], level=0), ImportFrom(module='_pytest.mark.structures', names=[alias(name='get_unpacked_marks')], level=0), ImportFrom(module='_pytest.mark.structures', names=[alias(name='Mark')], level=0), ImportFrom(module='_pytest.mark.structures', names=[alias(name='MarkDecorator')], level=0), ImportFrom(module='_pytest.mark.structures', names=[alias(name='normalize_mark_list')], level=0), ImportFrom(module='_pytest.outcomes', names=[alias(name='fail')], level=0), ImportFrom(module='_pytest.outcomes', names=[alias(name='skip')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='bestrelpath')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='fnmatch_ex')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='import_path')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='ImportPathMismatchError')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='parts')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='visit')], level=0), ImportFrom(module='_pytest.scope', names=[alias(name='Scope')], level=0), ImportFrom(module='_pytest.warning_types', names=[alias(name='PytestCollectionWarning')], level=0), ImportFrom(module='_pytest.warning_types', names=[alias(name='PytestReturnNotNoneWarning')], level=0), ImportFrom(module='_pytest.warning_types', names=[alias(name='PytestUnhandledCoroutineWarning')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='typing_extensions', names=[alias(name='Literal')], level=0), ImportFrom(module='_pytest.scope', names=[alias(name='_ScopeName')], level=0)], orelse=[]), Assign(targets=[Name(id='_PYTEST_DIR', ctx=Store())], value=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='_pytest', ctx=Load()), attr='__file__', ctx=Load())], keywords=[]), attr='parent', ctx=Load())), FunctionDef(name='pytest_addoption', args=arguments(posonlyargs=[], args=[arg(arg='parser', annotation=Name(id='Parser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='group', ctx=Store())], value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='getgroup', ctx=Load()), args=[Constant(value='general')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='addoption', ctx=Load()), args=[Constant(value='--fixtures'), Constant(value='--funcargs')], keywords=[keyword(arg='action', value=Constant(value='store_true')), keyword(arg='dest', value=Constant(value='showfixtures')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value="Show available fixtures, sorted by plugin appearance (fixtures with leading '_' are only shown with '-v')"))])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='addoption', ctx=Load()), args=[Constant(value='--fixtures-per-test')], keywords=[keyword(arg='action', value=Constant(value='store_true')), keyword(arg='dest', value=Constant(value='show_fixtures_per_test')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Show fixtures per test'))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='addini', ctx=Load()), args=[Constant(value='python_files')], keywords=[keyword(arg='type', value=Constant(value='args')), keyword(arg='default', value=List(elts=[Constant(value='test_*.py'), Constant(value='*_test.py')], ctx=Load())), keyword(arg='help', value=Constant(value='Glob-style file patterns for Python test module discovery'))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='addini', ctx=Load()), args=[Constant(value='python_classes')], keywords=[keyword(arg='type', value=Constant(value='args')), keyword(arg='default', value=List(elts=[Constant(value='Test')], ctx=Load())), keyword(arg='help', value=Constant(value='Prefixes or glob names for Python test class discovery'))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='addini', ctx=Load()), args=[Constant(value='python_functions')], keywords=[keyword(arg='type', value=Constant(value='args')), keyword(arg='default', value=List(elts=[Constant(value='test')], ctx=Load())), keyword(arg='help', value=Constant(value='Prefixes or glob names for Python test function and method discovery'))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='addini', ctx=Load()), args=[Constant(value='disable_test_id_escaping_and_forfeit_all_rights_to_community_support')], keywords=[keyword(arg='type', value=Constant(value='bool')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Disable string escape non-ASCII characters, might cause unwanted side effects(use at your own risk)'))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='pytest_cmdline_main', args=arguments(posonlyargs=[], args=[arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='option', ctx=Load()), attr='showfixtures', ctx=Load()), body=[Expr(value=Call(func=Name(id='showfixtures', ctx=Load()), args=[Name(id='config', ctx=Load())], keywords=[])), Return(value=Constant(value=0))], orelse=[]), If(test=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='option', ctx=Load()), attr='show_fixtures_per_test', ctx=Load()), body=[Expr(value=Call(func=Name(id='show_fixtures_per_test', ctx=Load()), args=[Name(id='config', ctx=Load())], keywords=[])), Return(value=Constant(value=0))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='ExitCode', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='pytest_generate_tests', args=arguments(posonlyargs=[], args=[arg(arg='metafunc', annotation=Constant(value='Metafunc'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='marker', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='metafunc', ctx=Load()), attr='definition', ctx=Load()), attr='iter_markers', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Constant(value='parametrize'))]), body=[Expr(value=Call(func=Attribute(value=Name(id='metafunc', ctx=Load()), attr='parametrize', ctx=Load()), args=[Starred(value=Attribute(value=Name(id='marker', ctx=Load()), attr='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Attribute(value=Name(id='marker', ctx=Load()), attr='kwargs', ctx=Load())), keyword(arg='_param_mark', value=Name(id='marker', ctx=Load()))]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='pytest_configure', args=arguments(posonlyargs=[], args=[arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='addinivalue_line', ctx=Load()), args=[Constant(value='markers'), Constant(value="parametrize(argnames, argvalues): call a test function multiple times passing in different arguments in turn. argvalues generally needs to be a list of values if argnames specifies only one name or a list of tuples of values if argnames specifies multiple names. Example: @parametrize('arg1', [1,2]) would lead to two calls of the decorated test function, one with arg1=1 and another with arg1=2.see https://docs.pytest.org/en/stable/how-to/parametrize.html for more info and examples.")], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='addinivalue_line', ctx=Load()), args=[Constant(value='markers'), Constant(value='usefixtures(fixturename1, fixturename2, ...): mark tests as needing all of the specified fixtures. see https://docs.pytest.org/en/stable/explanation/fixtures.html#usefixtures ')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='async_warn_and_skip', args=arguments(posonlyargs=[], args=[arg(arg='nodeid', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='async def functions are not natively supported and have been skipped.\n')), AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=Constant(value='You need to install a suitable plugin for your async framework, for example:\n')), AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=Constant(value='  - anyio\n')), AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=Constant(value='  - pytest-asyncio\n')), AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=Constant(value='  - pytest-tornasync\n')), AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=Constant(value='  - pytest-trio\n')), AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=Constant(value='  - pytest-twisted')), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Name(id='PytestUnhandledCoroutineWarning', ctx=Load()), args=[Call(func=Attribute(value=Name(id='msg', ctx=Load()), attr='format', ctx=Load()), args=[Name(id='nodeid', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='skip', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=Constant(value='async def function and no async plugin installed (see warnings)'))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='pytest_pyfunc_call', args=arguments(posonlyargs=[], args=[arg(arg='pyfuncitem', annotation=Constant(value='Function'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='testfunction', ctx=Store())], value=Attribute(value=Name(id='pyfuncitem', ctx=Load()), attr='obj', ctx=Load())), If(test=Call(func=Name(id='is_async_function', ctx=Load()), args=[Name(id='testfunction', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='async_warn_and_skip', ctx=Load()), args=[Attribute(value=Name(id='pyfuncitem', ctx=Load()), attr='nodeid', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='funcargs', ctx=Store())], value=Attribute(value=Name(id='pyfuncitem', ctx=Load()), attr='funcargs', ctx=Load())), Assign(targets=[Name(id='testargs', ctx=Store())], value=DictComp(key=Name(id='arg', ctx=Load()), value=Subscript(value=Name(id='funcargs', ctx=Load()), slice=Name(id='arg', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='arg', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='pyfuncitem', ctx=Load()), attr='_fixtureinfo', ctx=Load()), attr='argnames', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='testfunction', ctx=Load()), args=[], keywords=[keyword(value=Name(id='testargs', ctx=Load()))])), If(test=BoolOp(op=Or(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='result', ctx=Load()), Constant(value='__await__')], keywords=[]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='result', ctx=Load()), Constant(value='__aiter__')], keywords=[])]), body=[Expr(value=Call(func=Name(id='async_warn_and_skip', ctx=Load()), args=[Attribute(value=Name(id='pyfuncitem', ctx=Load()), attr='nodeid', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='result', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Name(id='PytestReturnNotNoneWarning', ctx=Load()), args=[JoinedStr(values=[Constant(value='Expected None, but '), FormattedValue(value=Attribute(value=Name(id='pyfuncitem', ctx=Load()), attr='nodeid', ctx=Load()), conversion=-1), Constant(value=' returned '), FormattedValue(value=Name(id='result', ctx=Load()), conversion=114), Constant(value=', which will be an error in a future version of pytest.  Did you mean to use `assert` instead of `return`?')])], keywords=[])], keywords=[]))], orelse=[])]), Return(value=Constant(value=True))], decorator_list=[Call(func=Name(id='hookimpl', ctx=Load()), args=[], keywords=[keyword(arg='trylast', value=Constant(value=True))])], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load())), FunctionDef(name='pytest_collect_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path', annotation=Name(id='Path', ctx=Load())), arg(arg='parent', annotation=Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='file_path', ctx=Load()), attr='suffix', ctx=Load()), ops=[Eq()], comparators=[Constant(value='.py')]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='parent', ctx=Load()), attr='session', ctx=Load()), attr='isinitpath', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='path_matches_patterns', ctx=Load()), args=[Name(id='file_path', ctx=Load()), BinOp(left=Call(func=Attribute(value=Attribute(value=Name(id='parent', ctx=Load()), attr='config', ctx=Load()), attr='getini', ctx=Load()), args=[Constant(value='python_files')], keywords=[]), op=Add(), right=List(elts=[Constant(value='__init__.py')], ctx=Load()))], keywords=[])), body=[Return(value=Constant(value=None))], orelse=[])], orelse=[]), Assign(targets=[Name(id='ihook', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='parent', ctx=Load()), attr='session', ctx=Load()), attr='gethookproxy', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), AnnAssign(target=Name(id='module', ctx=Store()), annotation=Name(id='Module', ctx=Load()), value=Call(func=Attribute(value=Name(id='ihook', ctx=Load()), attr='pytest_pycollect_makemodule', ctx=Load()), args=[], keywords=[keyword(arg='module_path', value=Name(id='file_path', ctx=Load())), keyword(arg='parent', value=Name(id='parent', ctx=Load()))]), simple=1), Return(value=Name(id='module', ctx=Load()))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='Module'), ctx=Load())), FunctionDef(name='path_matches_patterns', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='Path', ctx=Load())), arg(arg='patterns', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return whether path matches any of the patterns in the list of globs given.')), Return(value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='fnmatch_ex', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='pattern', ctx=Store()), iter=Name(id='patterns', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='pytest_pycollect_makemodule', args=arguments(posonlyargs=[], args=[arg(arg='module_path', annotation=Name(id='Path', ctx=Load())), arg(arg='parent')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='module_path', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__init__.py')]), body=[AnnAssign(target=Name(id='pkg', ctx=Store()), annotation=Name(id='Package', ctx=Load()), value=Call(func=Attribute(value=Name(id='Package', ctx=Load()), attr='from_parent', ctx=Load()), args=[Name(id='parent', ctx=Load())], keywords=[keyword(arg='path', value=Name(id='module_path', ctx=Load()))]), simple=1), Return(value=Name(id='pkg', ctx=Load()))], orelse=[]), AnnAssign(target=Name(id='mod', ctx=Store()), annotation=Name(id='Module', ctx=Load()), value=Call(func=Attribute(value=Name(id='Module', ctx=Load()), attr='from_parent', ctx=Load()), args=[Name(id='parent', ctx=Load())], keywords=[keyword(arg='path', value=Name(id='module_path', ctx=Load()))]), simple=1), Return(value=Name(id='mod', ctx=Load()))], decorator_list=[], returns=Constant(value='Module')), FunctionDef(name='pytest_pycollect_makeitem', args=arguments(posonlyargs=[], args=[arg(arg='collector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='Module'), Constant(value='Class')], ctx=Load()), ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='obj', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='collector', ctx=Load()), Tuple(elts=[Name(id='Class', ctx=Load()), Name(id='Module', ctx=Load())], ctx=Load())], keywords=[]), msg=Call(func=Name(id='type', ctx=Load()), args=[Name(id='collector', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='safe_isclass', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='collector', ctx=Load()), attr='istestclass', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]), body=[AnnAssign(target=Name(id='klass', ctx=Store()), annotation=Name(id='Class', ctx=Load()), value=Call(func=Attribute(value=Name(id='Class', ctx=Load()), attr='from_parent', ctx=Load()), args=[Name(id='collector', ctx=Load())], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='obj', value=Name(id='obj', ctx=Load()))]), simple=1), Return(value=Name(id='klass', ctx=Load()))], orelse=[])], orelse=[If(test=Call(func=Attribute(value=Name(id='collector', ctx=Load()), attr='istestfunction', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='obj', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Constant(value='__func__'), Name(id='obj', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='isfunction', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='isfunction', ctx=Load()), args=[Call(func=Name(id='get_real_func', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[])], keywords=[])])), body=[Assign(targets=[Tuple(elts=[Name(id='filename', ctx=Store()), Name(id='lineno', ctx=Store())], ctx=Store())], value=Call(func=Name(id='getfslineno', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn_explicit', ctx=Load()), args=[], keywords=[keyword(arg='message', value=Call(func=Name(id='PytestCollectionWarning', ctx=Load()), args=[BinOp(left=Constant(value='cannot collect %r because it is not a function.'), op=Mod(), right=Name(id='name', ctx=Load()))], keywords=[])), keyword(arg='category', value=Constant(value=None)), keyword(arg='filename', value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[])), keyword(arg='lineno', value=BinOp(left=Name(id='lineno', ctx=Load()), op=Add(), right=Constant(value=1)))]))], orelse=[If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Constant(value='__test__'), Constant(value=True)], keywords=[]), body=[If(test=Call(func=Name(id='is_generator', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]), body=[AnnAssign(target=Name(id='res', ctx=Store()), annotation=Name(id='Function', ctx=Load()), value=Call(func=Attribute(value=Name(id='Function', ctx=Load()), attr='from_parent', ctx=Load()), args=[Name(id='collector', ctx=Load())], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load()))]), simple=1), Assign(targets=[Name(id='reason', ctx=Store())], value=Call(func=Attribute(value=Constant(value='yield tests were removed in pytest 4.0 - {name} will be ignored'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='add_marker', ctx=Load()), args=[Call(func=Attribute(value=Name(id='MARK_GEN', ctx=Load()), attr='xfail', ctx=Load()), args=[], keywords=[keyword(arg='run', value=Constant(value=False)), keyword(arg='reason', value=Name(id='reason', ctx=Load()))])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Name(id='PytestCollectionWarning', ctx=Load()), args=[Name(id='reason', ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='res', ctx=Load()))], orelse=[Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='collector', ctx=Load()), attr='_genfunctions', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='obj', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[])])], orelse=[])]), Return(value=Constant(value=None))], decorator_list=[Call(func=Name(id='hookimpl', ctx=Load()), args=[], keywords=[keyword(arg='trylast', value=Constant(value=True))])], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value=None), Attribute(value=Name(id='nodes', ctx=Load()), attr='Item', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Item', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='PyobjMixin', bases=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Node', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='this mix-in inherits from Node to carry over the typing information\n\n    as its intended to always mix in before a node\n    its position in the mro is unaffected')), Assign(targets=[Name(id='_ALLOW_MARKERS', ctx=Store())], value=Constant(value=True)), FunctionDef(name='module', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Python module object this node was collected from (can be None).')), Assign(targets=[Name(id='node', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getparent', ctx=Load()), args=[Name(id='Module', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Name(id='node', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='node', ctx=Load()), attr='obj', ctx=Load()), orelse=Constant(value=None)))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='cls', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Python class object this node was collected from (can be None).')), Assign(targets=[Name(id='node', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getparent', ctx=Load()), args=[Name(id='Class', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Name(id='node', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='node', ctx=Load()), attr='obj', ctx=Load()), orelse=Constant(value=None)))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='instance', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Python instance object the function is bound to.\n\n        Returns None if not a test method, e.g. for a standalone test function,\n        a staticmethod, a class or a module.\n        ')), Assign(targets=[Name(id='node', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getparent', ctx=Load()), args=[Name(id='Function', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Name(id='node', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='node', ctx=Load()), attr='obj', ctx=Load()), Constant(value='__self__'), Constant(value=None)], keywords=[]), orelse=Constant(value=None)))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='obj', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Underlying Python object.')), Assign(targets=[Name(id='obj', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='_obj'), Constant(value=None)], keywords=[])), If(test=Compare(left=Name(id='obj', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_obj', ctx=Store()), Name(id='obj', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_getobj', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_ALLOW_MARKERS', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='own_markers', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Name(id='get_unpacked_marks', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='keywords', ctx=Load()), attr='update', ctx=Load()), args=[GeneratorExp(elt=Tuple(elts=[Attribute(value=Name(id='mark', ctx=Load()), attr='name', ctx=Load()), Name(id='mark', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='mark', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='own_markers', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='obj', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='obj', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_obj', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='obj', ctx=Load()), attr='setter', ctx=Load())]), FunctionDef(name='_getobj', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the underlying Python object. May be overwritten by subclasses.')), Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='obj', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), attr='obj', ctx=Load())), Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='getmodpath', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='stopatmodule', annotation=Name(id='bool', ctx=Load())), arg(arg='includemodule', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=False)]), body=[Expr(value=Constant(value='Return Python path relative to the containing module.')), Assign(targets=[Name(id='chain', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='listchain', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='reverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='parts', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='node', ctx=Store()), iter=Name(id='chain', ctx=Load()), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='node', ctx=Load()), attr='name', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Name(id='Module', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), If(test=Name(id='stopatmodule', ctx=Load()), body=[If(test=Name(id='includemodule', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='parts', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[]), Break()], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='parts', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='parts', ctx=Load()), attr='reverse', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='reportinfo', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='obj', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())), Assign(targets=[Name(id='compat_co_firstlineno', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Constant(value='compat_co_firstlineno'), Constant(value=None)], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='compat_co_firstlineno', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Attribute(value=Name(id='obj', ctx=Load()), attr='__module__', ctx=Load()), ctx=Load()), attr='__file__', ctx=Load())), Assert(test=Compare(left=Name(id='file_path', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), If(test=Call(func=Attribute(value=Name(id='file_path', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.pyc')], keywords=[]), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Subscript(value=Name(id='file_path', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], orelse=[]), AnnAssign(target=Name(id='path', ctx=Store()), annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='os.PathLike[str]'), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), value=Name(id='file_path', ctx=Load()), simple=1), Assign(targets=[Name(id='lineno', ctx=Store())], value=Name(id='compat_co_firstlineno', ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='path', ctx=Store()), Name(id='lineno', ctx=Store())], ctx=Store())], value=Call(func=Name(id='getfslineno', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='modpath', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getmodpath', ctx=Load()), args=[], keywords=[])), Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='lineno', ctx=Load()), Name(id='int', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='path', ctx=Load()), Name(id='lineno', ctx=Load()), Name(id='modpath', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='os.PathLike[str]'), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='_EmptyClass', bases=[], keywords=[], body=[Pass()], decorator_list=[]), Assign(targets=[Name(id='IGNORED_ATTRIBUTES', ctx=Store())], value=Call(func=Attribute(value=Name(id='frozenset', ctx=Load()), attr='union', ctx=Load()), args=[Call(func=Name(id='frozenset', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='dir', ctx=Load()), args=[Call(func=Attribute(value=Name(id='types', ctx=Load()), attr='ModuleType', ctx=Load()), args=[Constant(value='empty_module')], keywords=[])], keywords=[]), Set(elts=[Constant(value='__builtins__'), Constant(value='__file__'), Constant(value='__cached__')]), Call(func=Name(id='dir', ctx=Load()), args=[Name(id='_EmptyClass', ctx=Load())], keywords=[]), Call(func=Name(id='dir', ctx=Load()), args=[Call(func=Name(id='_EmptyClass', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Delete(targets=[Name(id='_EmptyClass', ctx=Del())]), ClassDef(name='PyCollector', bases=[Name(id='PyobjMixin', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load())], keywords=[], body=[FunctionDef(name='funcnamefilter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_matches_prefix_or_glob_option', ctx=Load()), args=[Constant(value='python_functions'), Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='isnosetest', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Look for the __test__ attribute, which is applied by the\n        @nose.tools.istest decorator.\n        ')), Return(value=Compare(left=Call(func=Name(id='safe_getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Constant(value='__test__'), Constant(value=False)], keywords=[]), ops=[Is()], comparators=[Constant(value=True)]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='classnamefilter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_matches_prefix_or_glob_option', ctx=Load()), args=[Constant(value='python_classes'), Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='istestfunction', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj', annotation=Name(id='object', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='funcnamefilter', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='isnosetest', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[])]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='obj', ctx=Load()), Tuple(elts=[Name(id='staticmethod', ctx=Load()), Name(id='classmethod', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='obj', ctx=Store())], value=Call(func=Name(id='safe_getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Constant(value='__func__'), Constant(value=False)], keywords=[]))], orelse=[]), Return(value=BoolOp(op=And(), values=[Call(func=Name(id='callable', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='fixtures', ctx=Load()), attr='getfixturemarker', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Constant(value=None)])]))], orelse=[Return(value=Constant(value=False))])], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='istestclass', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='obj', annotation=Name(id='object', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='classnamefilter', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='isnosetest', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_matches_prefix_or_glob_option', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='option_name', annotation=Name(id='str', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if the given name matches the prefix or glob-pattern defined\n        in ini configuration.')), For(target=Name(id='option', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getini', ctx=Load()), args=[Name(id='option_name', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='option', ctx=Load())], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Constant(value='*'), ops=[In()], comparators=[Name(id='option', ctx=Load())]), Compare(left=Constant(value='?'), ops=[In()], comparators=[Name(id='option', ctx=Load())]), Compare(left=Constant(value='['), ops=[In()], comparators=[Name(id='option', ctx=Load())])]), Call(func=Attribute(value=Name(id='fnmatch', ctx=Load()), attr='fnmatch', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='option', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=True))], orelse=[])])], orelse=[]), Return(value=Constant(value=False))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='collect', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Constant(value='__test__'), Constant(value=True)], keywords=[])), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='dicts', ctx=Store())], value=List(elts=[Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Constant(value='__dict__'), Dict(keys=[], values=[])], keywords=[])], ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Name(id='type', ctx=Load())], keywords=[]), body=[For(target=Name(id='basecls', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__mro__', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='dicts', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='basecls', ctx=Load()), attr='__dict__', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), AnnAssign(target=Name(id='seen', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), AnnAssign(target=Name(id='dict_values', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Item', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='ihook', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='ihook', ctx=Load())), For(target=Name(id='dic', ctx=Store()), iter=Name(id='dicts', ctx=Load()), body=[AnnAssign(target=Name(id='values', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Item', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='obj', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='dic', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Name(id='IGNORED_ATTRIBUTES', ctx=Load())]), body=[Continue()], orelse=[]), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Name(id='seen', ctx=Load())]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Name(id='ihook', ctx=Load()), attr='pytest_pycollect_makeitem', ctx=Load()), args=[], keywords=[keyword(arg='collector', value=Name(id='self', ctx=Load())), keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='obj', value=Name(id='obj', ctx=Load()))])), If(test=Compare(left=Name(id='res', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Continue()], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='res', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='values', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='res', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='res', ctx=Load())], keywords=[]))])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='dict_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='values', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='dict_values', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Item', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='_genfunctions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='funcobj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='modulecol', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getparent', ctx=Load()), args=[Name(id='Module', ctx=Load())], keywords=[])), Assert(test=Compare(left=Name(id='modulecol', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='module', ctx=Store())], value=Attribute(value=Name(id='modulecol', ctx=Load()), attr='obj', ctx=Load())), Assign(targets=[Name(id='clscol', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getparent', ctx=Load()), args=[Name(id='Class', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cls', ctx=Store())], value=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Name(id='clscol', ctx=Load()), Attribute(value=Name(id='clscol', ctx=Load()), attr='obj', ctx=Load())]), Constant(value=None)])), Assign(targets=[Name(id='definition', ctx=Store())], value=Call(func=Attribute(value=Name(id='FunctionDefinition', ctx=Load()), attr='from_parent', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='callobj', value=Name(id='funcobj', ctx=Load()))])), Assign(targets=[Name(id='fixtureinfo', ctx=Store())], value=Attribute(value=Name(id='definition', ctx=Load()), attr='_fixtureinfo', ctx=Load())), Assign(targets=[Name(id='metafunc', ctx=Store())], value=Call(func=Name(id='Metafunc', ctx=Load()), args=[], keywords=[keyword(arg='definition', value=Name(id='definition', ctx=Load())), keyword(arg='fixtureinfo', value=Name(id='fixtureinfo', ctx=Load())), keyword(arg='config', value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load())), keyword(arg='cls', value=Name(id='cls', ctx=Load())), keyword(arg='module', value=Name(id='module', ctx=Load())), keyword(arg='_ispytest', value=Constant(value=True))])), Assign(targets=[Name(id='methods', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='module', ctx=Load()), Constant(value='pytest_generate_tests')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='methods', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='module', ctx=Load()), attr='pytest_generate_tests', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='cls', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='pytest_generate_tests')], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='methods', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Call(func=Name(id='cls', ctx=Load()), args=[], keywords=[]), attr='pytest_generate_tests', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ihook', ctx=Load()), attr='pytest_generate_tests', ctx=Load()), attr='call_extra', ctx=Load()), args=[Name(id='methods', ctx=Load()), Call(func=Name(id='dict', ctx=Load()), args=[], keywords=[keyword(arg='metafunc', value=Name(id='metafunc', ctx=Load()))])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='metafunc', ctx=Load()), attr='_calls', ctx=Load())), body=[Expr(value=Yield(value=Call(func=Attribute(value=Name(id='Function', ctx=Load()), attr='from_parent', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='fixtureinfo', value=Name(id='fixtureinfo', ctx=Load()))])))], orelse=[Assign(targets=[Name(id='fm', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='_fixturemanager', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='fixtures', ctx=Load()), attr='add_funcarg_pseudo_fixture_def', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='metafunc', ctx=Load()), Name(id='fm', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='fixtureinfo', ctx=Load()), attr='prune_dependency_tree', ctx=Load()), args=[], keywords=[])), For(target=Name(id='callspec', ctx=Store()), iter=Attribute(value=Name(id='metafunc', ctx=Load()), attr='_calls', ctx=Load()), body=[Assign(targets=[Name(id='subname', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='['), FormattedValue(value=Attribute(value=Name(id='callspec', ctx=Load()), attr='id', ctx=Load()), conversion=-1), Constant(value=']')])), Expr(value=Yield(value=Call(func=Attribute(value=Name(id='Function', ctx=Load()), attr='from_parent', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(arg='name', value=Name(id='subname', ctx=Load())), keyword(arg='callspec', value=Name(id='callspec', ctx=Load())), keyword(arg='fixtureinfo', value=Name(id='fixtureinfo', ctx=Load())), keyword(arg='keywords', value=Dict(keys=[Attribute(value=Name(id='callspec', ctx=Load()), attr='id', ctx=Load())], values=[Constant(value=True)])), keyword(arg='originalname', value=Name(id='name', ctx=Load()))])))], orelse=[])])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Constant(value='Function'), ctx=Load()))], decorator_list=[]), ClassDef(name='Module', bases=[Attribute(value=Name(id='nodes', ctx=Load()), attr='File', ctx=Load()), Name(id='PyCollector', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Collector for test classes and functions in a Python module.')), FunctionDef(name='_getobj', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_importtestmodule', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='collect', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_inject_setup_module_fixture', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_inject_setup_function_fixture', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='_fixturemanager', ctx=Load()), attr='parsefactories', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='collect', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Item', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='_inject_setup_module_fixture', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Inject a hidden autouse, module scoped fixture into the collected module object\n        that invokes setUpModule/tearDownModule if either or both are available.\n\n        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n        other fixtures (#517).\n        ')), Assign(targets=[Name(id='has_nose', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='pluginmanager', ctx=Load()), attr='has_plugin', ctx=Load()), args=[Constant(value='nose')], keywords=[])), Assign(targets=[Name(id='setup_module', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Constant(value='setUpModule'), Constant(value='setup_module')], ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='setup_module', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Name(id='has_nose', ctx=Load())]), body=[Assign(targets=[Name(id='setup_module', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Constant(value='setup')], ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='setup_module', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='setup_module', ctx=Store())], value=Constant(value=None))], orelse=[])], orelse=[]), Assign(targets=[Name(id='teardown_module', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Constant(value='tearDownModule'), Constant(value='teardown_module')], ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='teardown_module', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Name(id='has_nose', ctx=Load())]), body=[Assign(targets=[Name(id='teardown_module', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Constant(value='teardown')], ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='teardown_module', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='teardown_module', ctx=Store())], value=Constant(value=None))], orelse=[])], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='setup_module', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='teardown_module', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Return()], orelse=[]), FunctionDef(name='xunit_setup_module_fixture', args=arguments(posonlyargs=[], args=[arg(arg='request')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='setup_module', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='_call_with_optional_argument', ctx=Load()), args=[Name(id='setup_module', ctx=Load()), Attribute(value=Name(id='request', ctx=Load()), attr='module', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Yield()), If(test=Compare(left=Name(id='teardown_module', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='_call_with_optional_argument', ctx=Load()), args=[Name(id='teardown_module', ctx=Load()), Attribute(value=Name(id='request', ctx=Load()), attr='module', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[Call(func=Attribute(value=Name(id='fixtures', ctx=Load()), attr='fixture', ctx=Load()), args=[], keywords=[keyword(arg='autouse', value=Constant(value=True)), keyword(arg='scope', value=Constant(value='module')), keyword(arg='name', value=JoinedStr(values=[Constant(value='_xunit_setup_module_fixture_'), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1)]))])], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Constant(value=None), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__pytest_setup_module', ctx=Store())], value=Name(id='xunit_setup_module_fixture', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_inject_setup_function_fixture', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Inject a hidden autouse, function scoped fixture into the collected module object\n        that invokes setup_function/teardown_function if either or both are available.\n\n        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n        other fixtures (#517).\n        ')), Assign(targets=[Name(id='setup_function', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Constant(value='setup_function')], ctx=Load())], keywords=[])), Assign(targets=[Name(id='teardown_function', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Constant(value='teardown_function')], ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='setup_function', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='teardown_function', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Return()], orelse=[]), FunctionDef(name='xunit_setup_function_fixture', args=arguments(posonlyargs=[], args=[arg(arg='request')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='request', ctx=Load()), attr='instance', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield()), Return()], orelse=[]), If(test=Compare(left=Name(id='setup_function', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='_call_with_optional_argument', ctx=Load()), args=[Name(id='setup_function', ctx=Load()), Attribute(value=Name(id='request', ctx=Load()), attr='function', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Yield()), If(test=Compare(left=Name(id='teardown_function', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='_call_with_optional_argument', ctx=Load()), args=[Name(id='teardown_function', ctx=Load()), Attribute(value=Name(id='request', ctx=Load()), attr='function', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[Call(func=Attribute(value=Name(id='fixtures', ctx=Load()), attr='fixture', ctx=Load()), args=[], keywords=[keyword(arg='autouse', value=Constant(value=True)), keyword(arg='scope', value=Constant(value='function')), keyword(arg='name', value=JoinedStr(values=[Constant(value='_xunit_setup_function_fixture_'), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1)]))])], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Constant(value=None), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__pytest_setup_function', ctx=Store())], value=Name(id='xunit_setup_function_fixture', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_importtestmodule', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='importmode', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='--import-mode')], keywords=[])), Try(body=[Assign(targets=[Name(id='mod', ctx=Store())], value=Call(func=Name(id='import_path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[keyword(arg='mode', value=Name(id='importmode', ctx=Load())), keyword(arg='root', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='rootpath', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='SyntaxError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='CollectError', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='ExceptionInfo', ctx=Load()), attr='from_current', ctx=Load()), args=[], keywords=[]), attr='getrepr', ctx=Load()), args=[], keywords=[keyword(arg='style', value=Constant(value='short'))])], keywords=[]), cause=Name(id='e', ctx=Load()))]), ExceptHandler(type=Name(id='ImportPathMismatchError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='CollectError', ctx=Load()), args=[BinOp(left=Constant(value='import file mismatch:\nimported module %r has this __file__ attribute:\n  %s\nwhich is not the same as the test file we want to collect:\n  %s\nHINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules'), op=Mod(), right=Attribute(value=Name(id='e', ctx=Load()), attr='args', ctx=Load()))], keywords=[]), cause=Name(id='e', ctx=Load()))]), ExceptHandler(type=Name(id='ImportError', ctx=Load()), name='e', body=[Assign(targets=[Name(id='exc_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExceptionInfo', ctx=Load()), attr='from_current', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='verbose')], keywords=[]), ops=[Lt()], comparators=[Constant(value=2)]), body=[Assign(targets=[Attribute(value=Name(id='exc_info', ctx=Load()), attr='traceback', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='exc_info', ctx=Load()), attr='traceback', ctx=Load()), attr='filter', ctx=Load()), args=[Name(id='filter_traceback', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='exc_repr', ctx=Store())], value=IfExp(test=Attribute(value=Name(id='exc_info', ctx=Load()), attr='traceback', ctx=Load()), body=Call(func=Attribute(value=Name(id='exc_info', ctx=Load()), attr='getrepr', ctx=Load()), args=[], keywords=[keyword(arg='style', value=Constant(value='short'))]), orelse=Call(func=Attribute(value=Name(id='exc_info', ctx=Load()), attr='exconly', ctx=Load()), args=[], keywords=[]))), Assign(targets=[Name(id='formatted_tb', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='exc_repr', ctx=Load())], keywords=[])), Raise(exc=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='CollectError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="ImportError while importing test module '{path}'.\nHint: make sure your test modules/packages have valid Python names.\nTraceback:\n{traceback}"), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='path', value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())), keyword(arg='traceback', value=Name(id='formatted_tb', ctx=Load()))])], keywords=[]), cause=Name(id='e', ctx=Load()))]), ExceptHandler(type=Attribute(value=Name(id='skip', ctx=Load()), attr='Exception', ctx=Load()), name='e', body=[If(test=Attribute(value=Name(id='e', ctx=Load()), attr='allow_module_level', ctx=Load()), body=[Raise()], orelse=[]), Raise(exc=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='CollectError', ctx=Load()), args=[Constant(value="Using pytest.skip outside of a test will skip the entire module. If that's your intention, pass `allow_module_level=True`. If you want to skip a specific test or an entire class, use the @pytest.mark.skip or @pytest.mark.skipif decorators.")], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='pluginmanager', ctx=Load()), attr='consider_module', ctx=Load()), args=[Name(id='mod', ctx=Load())], keywords=[])), Return(value=Name(id='mod', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='Package', bases=[Name(id='Module', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Collector for files and directories in a Python packages -- directories\n    with an `__init__.py` file.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fspath', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='LEGACY_PATH', ctx=Load()), ctx=Load())), arg(arg='parent', annotation=Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load())), arg(arg='config'), arg(arg='session'), arg(arg='nodeid'), arg(arg='path', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Assign(targets=[Name(id='session', ctx=Store())], value=Attribute(value=Name(id='parent', ctx=Load()), attr='session', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='nodes', ctx=Load()), attr='FSCollector', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(arg='fspath', value=Name(id='fspath', ctx=Load())), keyword(arg='path', value=Name(id='path', ctx=Load())), keyword(arg='parent', value=Name(id='parent', ctx=Load())), keyword(arg='config', value=Name(id='config', ctx=Load())), keyword(arg='session', value=Name(id='session', ctx=Load())), keyword(arg='nodeid', value=Name(id='nodeid', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='parent', ctx=Load()), attr='name', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='setup', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='setup_module', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Constant(value='setUpModule'), Constant(value='setup_module')], ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='setup_module', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='_call_with_optional_argument', ctx=Load()), args=[Name(id='setup_module', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='teardown_module', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Constant(value='tearDownModule'), Constant(value='teardown_module')], ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='teardown_module', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='_call_with_optional_argument', ctx=Load()), Name(id='teardown_module', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='addfinalizer', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_recurse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='direntry', annotation=Constant(value='os.DirEntry[str]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='direntry', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__pycache__')]), body=[Return(value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='fspath', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='direntry', ctx=Load()), attr='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ihook', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='gethookproxy', ctx=Load()), args=[Attribute(value=Name(id='fspath', ctx=Load()), attr='parent', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='ihook', ctx=Load()), attr='pytest_ignore_collect', ctx=Load()), args=[], keywords=[keyword(arg='collection_path', value=Name(id='fspath', ctx=Load())), keyword(arg='config', value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()))]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Constant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_collectfile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fspath', annotation=Name(id='Path', ctx=Load())), arg(arg='handle_dupes', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assert(test=Call(func=Attribute(value=Name(id='fspath', ctx=Load()), attr='is_file', ctx=Load()), args=[], keywords=[]), msg=Call(func=Attribute(value=Constant(value='{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})'), attr='format', ctx=Load()), args=[Name(id='fspath', ctx=Load()), Call(func=Attribute(value=Name(id='fspath', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='fspath', ctx=Load()), attr='exists', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='fspath', ctx=Load()), attr='is_symlink', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='ihook', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='gethookproxy', ctx=Load()), args=[Name(id='fspath', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='isinitpath', ctx=Load()), args=[Name(id='fspath', ctx=Load())], keywords=[])), body=[If(test=Call(func=Attribute(value=Name(id='ihook', ctx=Load()), attr='pytest_ignore_collect', ctx=Load()), args=[], keywords=[keyword(arg='collection_path', value=Name(id='fspath', ctx=Load())), keyword(arg='config', value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()))]), body=[Return(value=Tuple(elts=[], ctx=Load()))], orelse=[])], orelse=[]), If(test=Name(id='handle_dupes', ctx=Load()), body=[Assign(targets=[Name(id='keepduplicates', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='keepduplicates')], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='keepduplicates', ctx=Load())), body=[Assign(targets=[Name(id='duplicate_paths', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='pluginmanager', ctx=Load()), attr='_duplicatepaths', ctx=Load())), If(test=Compare(left=Name(id='fspath', ctx=Load()), ops=[In()], comparators=[Name(id='duplicate_paths', ctx=Load())]), body=[Return(value=Tuple(elts=[], ctx=Load()))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='duplicate_paths', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='fspath', ctx=Load())], keywords=[]))])], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='ihook', ctx=Load()), attr='pytest_collect_file', ctx=Load()), args=[], keywords=[keyword(arg='file_path', value=Name(id='fspath', ctx=Load())), keyword(arg='parent', value=Name(id='self', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load()), ctx=Load())), FunctionDef(name='collect', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='this_path', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='parent', ctx=Load())), If(test=Call(func=Name(id='path_matches_patterns', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getini', ctx=Load()), args=[Constant(value='python_files')], keywords=[])], keywords=[]), body=[Expr(value=Yield(value=Call(func=Attribute(value=Name(id='Module', ctx=Load()), attr='from_parent', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(arg='path', value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()))])))], orelse=[]), AnnAssign(target=Name(id='pkg_prefixes', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), For(target=Name(id='direntry', ctx=Store()), iter=Call(func=Name(id='visit', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='this_path', ctx=Load())], keywords=[])], keywords=[keyword(arg='recurse', value=Attribute(value=Name(id='self', ctx=Load()), attr='_recurse', ctx=Load()))]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='direntry', ctx=Load()), attr='path', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='direntry', ctx=Load()), attr='is_file', ctx=Load()), args=[], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='direntry', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__init__.py')]), Compare(left=Attribute(value=Name(id='path', ctx=Load()), attr='parent', ctx=Load()), ops=[Eq()], comparators=[Name(id='this_path', ctx=Load())])]), body=[Continue()], orelse=[])], orelse=[]), Assign(targets=[Name(id='parts_', ctx=Store())], value=Call(func=Name(id='parts', ctx=Load()), args=[Attribute(value=Name(id='direntry', ctx=Load()), attr='path', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='str', ctx=Load()), args=[Name(id='pkg_prefix', ctx=Load())], keywords=[]), ops=[In()], comparators=[Name(id='parts_', ctx=Load())]), Compare(left=BinOp(left=Name(id='pkg_prefix', ctx=Load()), op=Div(), right=Constant(value='__init__.py')), ops=[NotEq()], comparators=[Name(id='path', ctx=Load())])]), generators=[comprehension(target=Name(id='pkg_prefix', ctx=Store()), iter=Name(id='pkg_prefixes', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Continue()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='direntry', ctx=Load()), attr='is_file', ctx=Load()), args=[], keywords=[]), body=[Expr(value=YieldFrom(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_collectfile', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='direntry', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[])), body=[Continue()], orelse=[If(test=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Constant(value='__init__.py')], keywords=[]), attr='is_file', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='pkg_prefixes', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], orelse=[])])])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Item', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='_call_with_optional_argument', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='arg')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Call the given function with the given argument if func accepts one argument, otherwise\n    calls func without arguments.')), Assign(targets=[Name(id='arg_count', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='func', ctx=Load()), attr='__code__', ctx=Load()), attr='co_argcount', ctx=Load())), If(test=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='ismethod', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='arg_count', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[]), If(test=Name(id='arg_count', ctx=Load()), body=[Expr(value=Call(func=Name(id='func', ctx=Load()), args=[Name(id='arg', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[]))])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_get_first_non_fixture_func', args=arguments(posonlyargs=[], args=[arg(arg='obj', annotation=Name(id='object', ctx=Load())), arg(arg='names', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the attribute from the given object to be used as a setup/teardown\n    xunit-style function, but only if not marked as a fixture to avoid calling it twice.\n    ')), For(target=Name(id='name', ctx=Store()), iter=Name(id='names', ctx=Load()), body=[AnnAssign(target=Name(id='meth', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='name', ctx=Load()), Constant(value=None)], keywords=[]), simple=1), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='meth', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Call(func=Attribute(value=Name(id='fixtures', ctx=Load()), attr='getfixturemarker', ctx=Load()), args=[Name(id='meth', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Constant(value=None)])]), body=[Return(value=Name(id='meth', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load())), ClassDef(name='Class', bases=[Name(id='PyCollector', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Collector for test methods (and nested classes) in a Python class.')), FunctionDef(name='from_parent', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='parent')], kwonlyargs=[arg(arg='name'), arg(arg='obj')], kw_defaults=[None, Constant(value=None)], kwarg=arg(arg='kw'), defaults=[]), body=[Expr(value=Constant(value='The public constructor.')), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='from_parent', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='parent', value=Name(id='parent', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='newinstance', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='collect', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='safe_getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Constant(value='__test__'), Constant(value=True)], keywords=[])), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='hasinit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())], keywords=[]), body=[Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Name(id='PytestCollectionWarning', ctx=Load()), args=[BinOp(left=Constant(value='cannot collect test class %r because it has a __init__ constructor (from: %s)'), op=Mod(), right=Tuple(elts=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__name__', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), attr='nodeid', ctx=Load())], ctx=Load()))], keywords=[])], keywords=[])), Return(value=List(elts=[], ctx=Load()))], orelse=[If(test=Call(func=Name(id='hasnew', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())], keywords=[]), body=[Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Name(id='PytestCollectionWarning', ctx=Load()), args=[BinOp(left=Constant(value='cannot collect test class %r because it has a __new__ constructor (from: %s)'), op=Mod(), right=Tuple(elts=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__name__', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), attr='nodeid', ctx=Load())], ctx=Load()))], keywords=[])], keywords=[])), Return(value=List(elts=[], ctx=Load()))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_inject_setup_class_fixture', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_inject_setup_method_fixture', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='_fixturemanager', ctx=Load()), attr='parsefactories', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='newinstance', ctx=Load()), args=[], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='nodeid', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='collect', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='nodes', ctx=Load()), attr='Item', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Collector', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='_inject_setup_class_fixture', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Inject a hidden autouse, class scoped fixture into the collected class object\n        that invokes setup_class/teardown_class if either or both are available.\n\n        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n        other fixtures (#517).\n        ')), Assign(targets=[Name(id='setup_class', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Constant(value='setup_class')], ctx=Load())], keywords=[])), Assign(targets=[Name(id='teardown_class', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Constant(value='teardown_class')], ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='setup_class', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='teardown_class', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Return()], orelse=[]), FunctionDef(name='xunit_setup_class_fixture', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='setup_class', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='getimfunc', ctx=Load()), args=[Name(id='setup_class', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_call_with_optional_argument', ctx=Load()), args=[Name(id='func', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Yield()), If(test=Compare(left=Name(id='teardown_class', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='getimfunc', ctx=Load()), args=[Name(id='teardown_class', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_call_with_optional_argument', ctx=Load()), args=[Name(id='func', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[Call(func=Attribute(value=Name(id='fixtures', ctx=Load()), attr='fixture', ctx=Load()), args=[], keywords=[keyword(arg='autouse', value=Constant(value=True)), keyword(arg='scope', value=Constant(value='class')), keyword(arg='name', value=JoinedStr(values=[Constant(value='_xunit_setup_class_fixture_'), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__qualname__', ctx=Load()), conversion=-1)]))])], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Constant(value=None), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__pytest_setup_class', ctx=Store())], value=Name(id='xunit_setup_class_fixture', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_inject_setup_method_fixture', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Inject a hidden autouse, function scoped fixture into the collected class object\n        that invokes setup_method/teardown_method if either or both are available.\n\n        Using a fixture to invoke these methods ensures we play nicely and unsurprisingly with\n        other fixtures (#517).\n        ')), Assign(targets=[Name(id='has_nose', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='pluginmanager', ctx=Load()), attr='has_plugin', ctx=Load()), args=[Constant(value='nose')], keywords=[])), Assign(targets=[Name(id='setup_name', ctx=Store())], value=Constant(value='setup_method')), Assign(targets=[Name(id='setup_method', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Name(id='setup_name', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='emit_nose_setup_warning', ctx=Store())], value=Constant(value=False)), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='setup_method', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Name(id='has_nose', ctx=Load())]), body=[Assign(targets=[Name(id='setup_name', ctx=Store())], value=Constant(value='setup')), Assign(targets=[Name(id='emit_nose_setup_warning', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='setup_method', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Name(id='setup_name', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='teardown_name', ctx=Store())], value=Constant(value='teardown_method')), Assign(targets=[Name(id='teardown_method', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Name(id='teardown_name', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='emit_nose_teardown_warning', ctx=Store())], value=Constant(value=False)), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='teardown_method', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Name(id='has_nose', ctx=Load())]), body=[Assign(targets=[Name(id='teardown_name', ctx=Store())], value=Constant(value='teardown')), Assign(targets=[Name(id='emit_nose_teardown_warning', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='teardown_method', ctx=Store())], value=Call(func=Name(id='_get_first_non_fixture_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Tuple(elts=[Name(id='teardown_name', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='setup_method', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='teardown_method', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Return()], orelse=[]), FunctionDef(name='xunit_setup_method_fixture', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='request')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='method', ctx=Store())], value=Attribute(value=Name(id='request', ctx=Load()), attr='function', ctx=Load())), If(test=Compare(left=Name(id='setup_method', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='setup_name', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_call_with_optional_argument', ctx=Load()), args=[Name(id='func', ctx=Load()), Name(id='method', ctx=Load())], keywords=[])), If(test=Name(id='emit_nose_setup_warning', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Name(id='NOSE_SUPPORT_METHOD', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='nodeid', value=Attribute(value=Attribute(value=Name(id='request', ctx=Load()), attr='node', ctx=Load()), attr='nodeid', ctx=Load())), keyword(arg='method', value=Constant(value='setup'))])], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))], orelse=[])], orelse=[]), Expr(value=Yield()), If(test=Compare(left=Name(id='teardown_method', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='teardown_name', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_call_with_optional_argument', ctx=Load()), args=[Name(id='func', ctx=Load()), Name(id='method', ctx=Load())], keywords=[])), If(test=Name(id='emit_nose_teardown_warning', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Name(id='NOSE_SUPPORT_METHOD', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='nodeid', value=Attribute(value=Attribute(value=Name(id='request', ctx=Load()), attr='node', ctx=Load()), attr='nodeid', ctx=Load())), keyword(arg='method', value=Constant(value='teardown'))])], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))], orelse=[])], orelse=[])], decorator_list=[Call(func=Attribute(value=Name(id='fixtures', ctx=Load()), attr='fixture', ctx=Load()), args=[], keywords=[keyword(arg='autouse', value=Constant(value=True)), keyword(arg='scope', value=Constant(value='function')), keyword(arg='name', value=JoinedStr(values=[Constant(value='_xunit_setup_method_fixture_'), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__qualname__', ctx=Load()), conversion=-1)]))])], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Constant(value=None), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__pytest_setup_method', ctx=Store())], value=Name(id='xunit_setup_method_fixture', ctx=Load()))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='InstanceDummy', bases=[], keywords=[], body=[Expr(value=Constant(value='Instance used to be a node type between Class and Function. It has been\n    removed in pytest 7.0. Some plugins exist which reference `pytest.Instance`\n    only to ignore it; this dummy class keeps them working. This will be removed\n    in pytest 8.'))], decorator_list=[]), FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='Instance')]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='INSTANCE_COLLECTOR', ctx=Load()), Constant(value=2)], keywords=[])), Return(value=Name(id='InstanceDummy', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='module '), FormattedValue(value=Name(id='__name__', ctx=Load()), conversion=-1), Constant(value=' has no attribute '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1)])], keywords=[]))], decorator_list=[], returns=Name(id='object', ctx=Load())), FunctionDef(name='hasinit', args=arguments(posonlyargs=[], args=[arg(arg='obj', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='init', ctx=Store()), annotation=Name(id='object', ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Constant(value='__init__'), Constant(value=None)], keywords=[]), simple=1), If(test=Name(id='init', ctx=Load()), body=[Return(value=Compare(left=Name(id='init', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='object', ctx=Load()), attr='__init__', ctx=Load())]))], orelse=[]), Return(value=Constant(value=False))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='hasnew', args=arguments(posonlyargs=[], args=[arg(arg='obj', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='new', ctx=Store()), annotation=Name(id='object', ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Constant(value='__new__'), Constant(value=None)], keywords=[]), simple=1), If(test=Name(id='new', ctx=Load()), body=[Return(value=Compare(left=Name(id='new', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='object', ctx=Load()), attr='__new__', ctx=Load())]))], orelse=[]), Return(value=Constant(value=False))], decorator_list=[], returns=Name(id='bool', ctx=Load())), ClassDef(name='IdMaker', bases=[], keywords=[], body=[Expr(value=Constant(value='Make IDs for a parametrization.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='argnames'), Constant(value='parametersets'), Constant(value='idfn'), Constant(value='ids'), Constant(value='config'), Constant(value='nodeid'), Constant(value='func_name')], ctx=Load())), AnnAssign(target=Name(id='argnames', ctx=Store()), annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='parametersets', ctx=Store()), annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='ParameterSet', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='idfn', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Any', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='ids', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='config', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Config', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='nodeid', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='func_name', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='make_unique_parameterset_ids', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Make a unique identifier for each ParameterSet, that may be used to\n        identify the parametrization in a node ID.\n\n        Format is <prm_1_token>-...-<prm_n_token>[counter], where prm_x_token is\n        - user-provided id, if given\n        - else an id derived from the value, applicable for certain types\n        - else <argname><parameterset index>\n        The counter suffix is appended only in case a string wouldn't be unique\n        otherwise.\n        ")), Assign(targets=[Name(id='resolved_ids', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_resolve_ids', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='resolved_ids', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='resolved_ids', ctx=Load())], keywords=[])], keywords=[])]), body=[Assign(targets=[Name(id='id_counts', ctx=Store())], value=Call(func=Name(id='Counter', ctx=Load()), args=[Name(id='resolved_ids', ctx=Load())], keywords=[])), AnnAssign(target=Name(id='id_suffixes', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='defaultdict', ctx=Load()), args=[Name(id='int', ctx=Load())], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='id', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='resolved_ids', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='id_counts', ctx=Load()), slice=Name(id='id', ctx=Load()), ctx=Load()), ops=[Gt()], comparators=[Constant(value=1)]), body=[Assign(targets=[Subscript(value=Name(id='resolved_ids', ctx=Load()), slice=Name(id='index', ctx=Load()), ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='id', ctx=Load()), conversion=-1), FormattedValue(value=Subscript(value=Name(id='id_suffixes', ctx=Load()), slice=Name(id='id', ctx=Load()), ctx=Load()), conversion=-1)])), AugAssign(target=Subscript(value=Name(id='id_suffixes', ctx=Load()), slice=Name(id='id', ctx=Load()), ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='resolved_ids', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_resolve_ids', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Resolve IDs for all ParameterSets (may contain duplicates).')), For(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='parameterset', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='parametersets', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Attribute(value=Name(id='parameterset', ctx=Load()), attr='id', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Attribute(value=Name(id='parameterset', ctx=Load()), attr='id', ctx=Load())))], orelse=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='ids', ctx=Load()), Compare(left=Name(id='idx', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ids', ctx=Load())], keywords=[])]), Compare(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='ids', ctx=Load()), slice=Name(id='idx', ctx=Load()), ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Expr(value=Yield(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_idval_from_value_required', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='ids', ctx=Load()), slice=Name(id='idx', ctx=Load()), ctx=Load()), Name(id='idx', ctx=Load())], keywords=[])))], orelse=[Expr(value=Yield(value=Call(func=Attribute(value=Constant(value='-'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_idval', ctx=Load()), args=[Name(id='val', ctx=Load()), Name(id='argname', ctx=Load()), Name(id='idx', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='val', ctx=Store()), Name(id='argname', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Name(id='parameterset', ctx=Load()), attr='values', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='argnames', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])))])])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_idval', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='val', annotation=Name(id='object', ctx=Load())), arg(arg='argname', annotation=Name(id='str', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Make an ID for a parameter in a ParameterSet.')), Assign(targets=[Name(id='idval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_idval_from_function', ctx=Load()), args=[Name(id='val', ctx=Load()), Name(id='argname', ctx=Load()), Name(id='idx', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='idval', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='idval', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='idval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_idval_from_hook', ctx=Load()), args=[Name(id='val', ctx=Load()), Name(id='argname', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='idval', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='idval', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='idval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_idval_from_value', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='idval', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='idval', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_idval_from_argname', ctx=Load()), args=[Name(id='argname', ctx=Load()), Name(id='idx', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_idval_from_function', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='val', annotation=Name(id='object', ctx=Load())), arg(arg='argname', annotation=Name(id='str', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Try to make an ID for a parameter in a ParameterSet using the\n        user-provided id callable, if given.')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='idfn', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Try(body=[Assign(targets=[Name(id='id', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='idfn', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='nodeid', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='nodeid', ctx=Load()), conversion=-1), Constant(value=': ')]), orelse=Constant(value=''))), Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value="error raised while trying to determine id of parameter '{}' at position {}")), Assign(targets=[Name(id='msg', ctx=Store())], value=BinOp(left=Name(id='prefix', ctx=Load()), op=Add(), right=Call(func=Attribute(value=Name(id='msg', ctx=Load()), attr='format', ctx=Load()), args=[Name(id='argname', ctx=Load()), Name(id='idx', ctx=Load())], keywords=[]))), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='id', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_idval_from_value', ctx=Load()), args=[Name(id='id', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_idval_from_hook', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='val', annotation=Name(id='object', ctx=Load())), arg(arg='argname', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Try to make an ID for a parameter in a ParameterSet by calling the\n        :hook:`pytest_make_parametrize_id` hook.')), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), body=[AnnAssign(target=Name(id='id', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='hook', ctx=Load()), attr='pytest_make_parametrize_id', ctx=Load()), args=[], keywords=[keyword(arg='config', value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load())), keyword(arg='val', value=Name(id='val', ctx=Load())), keyword(arg='argname', value=Name(id='argname', ctx=Load()))]), simple=1), Return(value=Name(id='id', ctx=Load()))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_idval_from_value', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='val', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Try to make an ID for a parameter in a ParameterSet from its value,\n        if the value type is supported.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='val', ctx=Load()), Name(id='STRING_TYPES', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='_ascii_escaped_by_config', ctx=Load()), args=[Name(id='val', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load())], keywords=[]))], orelse=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='val', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='val', ctx=Load()), Tuple(elts=[Name(id='float', ctx=Load()), Name(id='int', ctx=Load()), Name(id='bool', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())], keywords=[])]), body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='val', ctx=Load()), Name(id='Pattern', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='ascii_escaped', ctx=Load()), args=[Attribute(value=Name(id='val', ctx=Load()), attr='pattern', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='val', ctx=Load()), ops=[Is()], comparators=[Name(id='NOTSET', ctx=Load())]), body=[Pass()], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='val', ctx=Load()), Attribute(value=Name(id='enum', ctx=Load()), attr='Enum', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='val', ctx=Load()), Constant(value='__name__'), Constant(value=None)], keywords=[]), Name(id='str', ctx=Load())], keywords=[]), body=[AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='val', ctx=Load()), Constant(value='__name__')], keywords=[]), simple=1), Return(value=Name(id='name', ctx=Load()))], orelse=[])])])])])]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_idval_from_value_required', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='val', annotation=Name(id='object', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Like _idval_from_value(), but fails if the type is not supported.')), Assign(targets=[Name(id='id', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_idval_from_value', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='id', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='id', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='func_name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=JoinedStr(values=[Constant(value='In '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='func_name', ctx=Load()), conversion=-1), Constant(value=': ')]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='nodeid', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=JoinedStr(values=[Constant(value='In '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='nodeid', ctx=Load()), conversion=-1), Constant(value=': ')]))], orelse=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Constant(value=''))])]), Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), Constant(value='ids contains unsupported value '), FormattedValue(value=Call(func=Name(id='saferepr', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' (type: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[]), conversion=114), Constant(value=') at index '), FormattedValue(value=Name(id='idx', ctx=Load()), conversion=-1), Constant(value='. Supported types are: str, bytes, int, float, complex, bool, enum, regex or anything with a __name__.')])), Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[keyword(arg='pytrace', value=Constant(value=False))]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_idval_from_argname', args=arguments(posonlyargs=[], args=[arg(arg='argname', annotation=Name(id='str', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Make an ID for a parameter in a ParameterSet from the argument name\n        and the index of the ParameterSet.')), Return(value=BinOp(left=Call(func=Name(id='str', ctx=Load()), args=[Name(id='argname', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='idx', ctx=Load())], keywords=[])))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='str', ctx=Load()))], decorator_list=[Name(id='final', ctx=Load()), Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='dataclass', ctx=Load()), args=[], keywords=[keyword(arg='frozen', value=Constant(value=True))])]), ClassDef(name='CallSpec2', bases=[], keywords=[], body=[Expr(value=Constant(value="A planned parameterized invocation of a test function.\n\n    Calculated during collection for a given test function's Metafunc.\n    Once collection is over, each callspec is turned into a single Item\n    and stored in item.callspec.\n    ")), AnnAssign(target=Name(id='funcargs', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='field', ctx=Load()), args=[], keywords=[keyword(arg='default_factory', value=Name(id='dict', ctx=Load()))]), simple=1), AnnAssign(target=Name(id='params', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='field', ctx=Load()), args=[], keywords=[keyword(arg='default_factory', value=Name(id='dict', ctx=Load()))]), simple=1), AnnAssign(target=Name(id='indices', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='field', ctx=Load()), args=[], keywords=[keyword(arg='default_factory', value=Name(id='dict', ctx=Load()))]), simple=1), AnnAssign(target=Name(id='_arg2scope', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Scope', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='field', ctx=Load()), args=[], keywords=[keyword(arg='default_factory', value=Name(id='dict', ctx=Load()))]), simple=1), AnnAssign(target=Name(id='_idlist', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='field', ctx=Load()), args=[], keywords=[keyword(arg='default_factory', value=Name(id='list', ctx=Load()))]), simple=1), AnnAssign(target=Name(id='marks', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Mark', ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='field', ctx=Load()), args=[], keywords=[keyword(arg='default_factory', value=Name(id='list', ctx=Load()))]), simple=1), FunctionDef(name='setmulti', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[arg(arg='valtypes', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value="Literal['params', 'funcargs']")], ctx=Load()), ctx=Load())), arg(arg='argnames', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='valset', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load())), arg(arg='id', annotation=Name(id='str', ctx=Load())), arg(arg='marks', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Mark', ctx=Load()), Name(id='MarkDecorator', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='scope', annotation=Name(id='Scope', ctx=Load())), arg(arg='param_index', annotation=Name(id='int', ctx=Load()))], kw_defaults=[None, None, None, None, None, None, None], defaults=[]), body=[Assign(targets=[Name(id='funcargs', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='funcargs', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='params', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='params', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='indices', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='indices', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='arg2scope', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_arg2scope', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='arg', ctx=Store()), Name(id='val', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='argnames', ctx=Load()), Name(id='valset', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='arg', ctx=Load()), ops=[In()], comparators=[Name(id='params', ctx=Load())]), Compare(left=Name(id='arg', ctx=Load()), ops=[In()], comparators=[Name(id='funcargs', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='duplicate parametrization of '), FormattedValue(value=Name(id='arg', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='valtype_for_arg', ctx=Store())], value=Subscript(value=Name(id='valtypes', ctx=Load()), slice=Name(id='arg', ctx=Load()), ctx=Load())), If(test=Compare(left=Name(id='valtype_for_arg', ctx=Load()), ops=[Eq()], comparators=[Constant(value='params')]), body=[Assign(targets=[Subscript(value=Name(id='params', ctx=Load()), slice=Name(id='arg', ctx=Load()), ctx=Store())], value=Name(id='val', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='valtype_for_arg', ctx=Load()), ops=[Eq()], comparators=[Constant(value='funcargs')]), body=[Assign(targets=[Subscript(value=Name(id='funcargs', ctx=Load()), slice=Name(id='arg', ctx=Load()), ctx=Store())], value=Name(id='val', ctx=Load()))], orelse=[Expr(value=Call(func=Name(id='assert_never', ctx=Load()), args=[Name(id='valtype_for_arg', ctx=Load())], keywords=[]))])]), Assign(targets=[Subscript(value=Name(id='indices', ctx=Load()), slice=Name(id='arg', ctx=Load()), ctx=Store())], value=Name(id='param_index', ctx=Load())), Assign(targets=[Subscript(value=Name(id='arg2scope', ctx=Load()), slice=Name(id='arg', ctx=Load()), ctx=Store())], value=Name(id='scope', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='CallSpec2', ctx=Load()), args=[], keywords=[keyword(arg='funcargs', value=Name(id='funcargs', ctx=Load())), keyword(arg='params', value=Name(id='params', ctx=Load())), keyword(arg='indices', value=Name(id='indices', ctx=Load())), keyword(arg='_arg2scope', value=Name(id='arg2scope', ctx=Load())), keyword(arg='_idlist', value=List(elts=[Starred(value=Attribute(value=Name(id='self', ctx=Load()), attr='_idlist', ctx=Load()), ctx=Load()), Name(id='id', ctx=Load())], ctx=Load())), keyword(arg='marks', value=List(elts=[Starred(value=Attribute(value=Name(id='self', ctx=Load()), attr='marks', ctx=Load()), ctx=Load()), Starred(value=Call(func=Name(id='normalize_mark_list', ctx=Load()), args=[Name(id='marks', ctx=Load())], keywords=[]), ctx=Load())], ctx=Load()))]))], decorator_list=[], returns=Constant(value='CallSpec2')), FunctionDef(name='getparam', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='params', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='object', ctx=Load())), FunctionDef(name='id', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='-'), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_idlist', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))], decorator_list=[Name(id='final', ctx=Load()), Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='dataclass', ctx=Load()), args=[], keywords=[keyword(arg='frozen', value=Constant(value=True))])]), ClassDef(name='Metafunc', bases=[], keywords=[], body=[Expr(value=Constant(value='Objects passed to the :hook:`pytest_generate_tests` hook.\n\n    They help to inspect a test function and to generate tests according to\n    test configuration or values specified in the class or module where a\n    test function is defined.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='definition', annotation=Constant(value='FunctionDefinition')), arg(arg='fixtureinfo', annotation=Attribute(value=Name(id='fixtures', ctx=Load()), attr='FuncFixtureInfo', ctx=Load())), arg(arg='config', annotation=Name(id='Config', ctx=Load())), arg(arg='cls'), arg(arg='module')], kwonlyargs=[arg(arg='_ispytest', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Name(id='check_ispytest', ctx=Load()), args=[Name(id='_ispytest', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='definition', ctx=Store())], value=Name(id='definition', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Store())], value=Name(id='config', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='module', ctx=Store())], value=Name(id='module', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Store())], value=Attribute(value=Name(id='definition', ctx=Load()), attr='obj', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fixturenames', ctx=Store())], value=Attribute(value=Name(id='fixtureinfo', ctx=Load()), attr='names_closure', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='cls', ctx=Store())], value=Name(id='cls', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_arg2fixturedefs', ctx=Store())], value=Attribute(value=Name(id='fixtureinfo', ctx=Load()), attr='name2fixturedefs', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_calls', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='CallSpec2', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='parametrize', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='argnames', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='argvalues', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParameterSet', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='indirect', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='ids', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Any', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='scope', annotation=Constant(value='Optional[_ScopeName]'))], kwonlyargs=[arg(arg='_param_mark', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Mark', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], defaults=[Constant(value=False), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Add new invocations to the underlying test function using the list\n        of argvalues for the given argnames. Parametrization is performed\n        during the collection phase. If you need to setup expensive resources\n        see about setting indirect to do it rather than at test setup time.\n\n        Can be called multiple times per test function (but only on different\n        argument names), in which case each call parametrizes all previous\n        parametrizations, e.g.\n\n        ::\n\n            unparametrized:         t\n            parametrize ["x", "y"]: t[x], t[y]\n            parametrize [1, 2]:     t[x-1], t[x-2], t[y-1], t[y-2]\n\n        :param argnames:\n            A comma-separated string denoting one or more argument names, or\n            a list/tuple of argument strings.\n\n        :param argvalues:\n            The list of argvalues determines how often a test is invoked with\n            different argument values.\n\n            If only one argname was specified argvalues is a list of values.\n            If N argnames were specified, argvalues must be a list of\n            N-tuples, where each tuple-element specifies a value for its\n            respective argname.\n\n        :param indirect:\n            A list of arguments\' names (subset of argnames) or a boolean.\n            If True the list contains all names from the argnames. Each\n            argvalue corresponding to an argname in this list will\n            be passed as request.param to its respective argname fixture\n            function so that it can perform more expensive setups during the\n            setup phase of a test rather than at collection time.\n\n        :param ids:\n            Sequence of (or generator for) ids for ``argvalues``,\n            or a callable to return part of the id for each argvalue.\n\n            With sequences (and generators like ``itertools.count()``) the\n            returned ids should be of type ``string``, ``int``, ``float``,\n            ``bool``, or ``None``.\n            They are mapped to the corresponding index in ``argvalues``.\n            ``None`` means to use the auto-generated id.\n\n            If it is a callable it will be called for each entry in\n            ``argvalues``, and the return value is used as part of the\n            auto-generated id for the whole set (where parts are joined with\n            dashes ("-")).\n            This is useful to provide more specific ids for certain items, e.g.\n            dates.  Returning ``None`` will use an auto-generated id.\n\n            If no ids are provided they will be generated automatically from\n            the argvalues.\n\n        :param scope:\n            If specified it denotes the scope of the parameters.\n            The scope is used for grouping tests by parameter instances.\n            It will also override any fixture-function defined scope, allowing\n            to set a dynamic scope using test context or configuration.\n        ')), Assign(targets=[Tuple(elts=[Name(id='argnames', ctx=Store()), Name(id='parametersets', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='ParameterSet', ctx=Load()), attr='_for_parametrize', ctx=Load()), args=[Name(id='argnames', ctx=Load()), Name(id='argvalues', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load())], keywords=[keyword(arg='nodeid', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='definition', ctx=Load()), attr='nodeid', ctx=Load()))])), Delete(targets=[Name(id='argvalues', ctx=Del())]), If(test=Compare(left=Constant(value='request'), ops=[In()], comparators=[Name(id='argnames', ctx=Load())]), body=[Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[Constant(value="'request' is a reserved name and cannot be used in @pytest.mark.parametrize")], keywords=[keyword(arg='pytrace', value=Constant(value=False))]))], orelse=[]), If(test=Compare(left=Name(id='scope', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='scope_', ctx=Store())], value=Call(func=Attribute(value=Name(id='Scope', ctx=Load()), attr='from_user', ctx=Load()), args=[Name(id='scope', ctx=Load())], keywords=[keyword(arg='descr', value=JoinedStr(values=[Constant(value='parametrize() call in '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1)]))]))], orelse=[Assign(targets=[Name(id='scope_', ctx=Store())], value=Call(func=Name(id='_find_parametrized_scope', ctx=Load()), args=[Name(id='argnames', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_arg2fixturedefs', ctx=Load()), Name(id='indirect', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_if_using_arg_names', ctx=Load()), args=[Name(id='argnames', ctx=Load()), Name(id='indirect', ctx=Load())], keywords=[])), Assign(targets=[Name(id='arg_values_types', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_resolve_arg_value_types', ctx=Load()), args=[Name(id='argnames', ctx=Load()), Name(id='indirect', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='_param_mark', ctx=Load()), Attribute(value=Name(id='_param_mark', ctx=Load()), attr='_param_ids_from', ctx=Load())]), body=[Assign(targets=[Name(id='generated_ids', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='_param_mark', ctx=Load()), attr='_param_ids_from', ctx=Load()), attr='_param_ids_generated', ctx=Load())), If(test=Compare(left=Name(id='generated_ids', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='ids', ctx=Store())], value=Name(id='generated_ids', ctx=Load()))], orelse=[])], orelse=[]), Assign(targets=[Name(id='ids', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_resolve_parameter_set_ids', ctx=Load()), args=[Name(id='argnames', ctx=Load()), Name(id='ids', ctx=Load()), Name(id='parametersets', ctx=Load())], keywords=[keyword(arg='nodeid', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='definition', ctx=Load()), attr='nodeid', ctx=Load()))])), If(test=BoolOp(op=And(), values=[Name(id='_param_mark', ctx=Load()), Attribute(value=Name(id='_param_mark', ctx=Load()), attr='_param_ids_from', ctx=Load()), Compare(left=Name(id='generated_ids', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Expr(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__setattr__', ctx=Load()), args=[Attribute(value=Name(id='_param_mark', ctx=Load()), attr='_param_ids_from', ctx=Load()), Constant(value='_param_ids_generated'), Name(id='ids', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='newcalls', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='callspec', ctx=Store()), iter=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_calls', ctx=Load()), List(elts=[Call(func=Name(id='CallSpec2', ctx=Load()), args=[], keywords=[])], ctx=Load())]), body=[For(target=Tuple(elts=[Name(id='param_index', ctx=Store()), Tuple(elts=[Name(id='param_id', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ids', ctx=Load()), Name(id='parametersets', ctx=Load())], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='newcallspec', ctx=Store())], value=Call(func=Attribute(value=Name(id='callspec', ctx=Load()), attr='setmulti', ctx=Load()), args=[], keywords=[keyword(arg='valtypes', value=Name(id='arg_values_types', ctx=Load())), keyword(arg='argnames', value=Name(id='argnames', ctx=Load())), keyword(arg='valset', value=Attribute(value=Name(id='param_set', ctx=Load()), attr='values', ctx=Load())), keyword(arg='id', value=Name(id='param_id', ctx=Load())), keyword(arg='marks', value=Attribute(value=Name(id='param_set', ctx=Load()), attr='marks', ctx=Load())), keyword(arg='scope', value=Name(id='scope_', ctx=Load())), keyword(arg='param_index', value=Name(id='param_index', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='newcalls', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='newcallspec', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_calls', ctx=Store())], value=Name(id='newcalls', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_resolve_parameter_set_ids', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='argnames', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='ids', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Any', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='parametersets', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='ParameterSet', ctx=Load()), ctx=Load())), arg(arg='nodeid', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Resolve the actual ids for the given parameter sets.\n\n        :param argnames:\n            Argument names passed to ``parametrize()``.\n        :param ids:\n            The `ids` parameter of the ``parametrize()`` call (see docs).\n        :param parametersets:\n            The parameter sets, each containing a set of values corresponding\n            to ``argnames``.\n        :param nodeid str:\n            The nodeid of the definition item that generated this\n            parametrization.\n        :returns:\n            List with ids for each parameter set given.\n        ')), If(test=Compare(left=Name(id='ids', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='idfn', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='ids_', ctx=Store())], value=Constant(value=None))], orelse=[If(test=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='ids', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='idfn', ctx=Store())], value=Name(id='ids', ctx=Load())), Assign(targets=[Name(id='ids_', ctx=Store())], value=Constant(value=None))], orelse=[Assign(targets=[Name(id='idfn', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='ids_', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_ids', ctx=Load()), args=[Name(id='ids', ctx=Load()), Name(id='parametersets', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Load()), attr='__name__', ctx=Load())], keywords=[]))])]), Assign(targets=[Name(id='id_maker', ctx=Store())], value=Call(func=Name(id='IdMaker', ctx=Load()), args=[Name(id='argnames', ctx=Load()), Name(id='parametersets', ctx=Load()), Name(id='idfn', ctx=Load()), Name(id='ids_', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load())], keywords=[keyword(arg='nodeid', value=Name(id='nodeid', ctx=Load())), keyword(arg='func_name', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Load()), attr='__name__', ctx=Load()))])), Return(value=Call(func=Attribute(value=Name(id='id_maker', ctx=Load()), attr='make_unique_parameterset_ids', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_validate_ids', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ids', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='parametersets', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='ParameterSet', ctx=Load()), ctx=Load())), arg(arg='func_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='num_ids', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='ids', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Try(body=[Expr(value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='ids', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='ids must be a callable or an iterable')], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='num_ids', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parametersets', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_ids', ctx=Load()), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='parametersets', ctx=Load())], keywords=[])]), Compare(left=Name(id='num_ids', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)])]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='In {}: {} parameter sets specified, with different number of ids: {}')), Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[Call(func=Attribute(value=Name(id='msg', ctx=Load()), attr='format', ctx=Load()), args=[Name(id='func_name', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='parametersets', ctx=Load())], keywords=[]), Name(id='num_ids', ctx=Load())], keywords=[])], keywords=[keyword(arg='pytrace', value=Constant(value=False))]))], orelse=[]), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='islice', ctx=Load()), args=[Name(id='ids', ctx=Load()), Name(id='num_ids', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='_resolve_arg_value_types', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='argnames', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='indirect', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Resolve if each parametrized argument must be considered a\n        parameter to a fixture or a "funcarg" to the function, based on the\n        ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: List of argument names passed to ``parametrize()``.\n        :param indirect: Same as the ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * "params" if the argname should be the parameter of a fixture of the same name.\n            * "funcargs" if the argname should be a parameter to the parametrized test function.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='indirect', ctx=Load()), Name(id='bool', ctx=Load())], keywords=[]), body=[AnnAssign(target=Name(id='valtypes', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Literal', ctx=Load()), slice=Tuple(elts=[Constant(value='params'), Constant(value='funcargs')], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='dict', ctx=Load()), attr='fromkeys', ctx=Load()), args=[Name(id='argnames', ctx=Load()), IfExp(test=Name(id='indirect', ctx=Load()), body=Constant(value='params'), orelse=Constant(value='funcargs'))], keywords=[]), simple=1)], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='indirect', ctx=Load()), Name(id='Sequence', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='valtypes', ctx=Store())], value=Call(func=Attribute(value=Name(id='dict', ctx=Load()), attr='fromkeys', ctx=Load()), args=[Name(id='argnames', ctx=Load()), Constant(value='funcargs')], keywords=[])), For(target=Name(id='arg', ctx=Store()), iter=Name(id='indirect', ctx=Load()), body=[If(test=Compare(left=Name(id='arg', ctx=Load()), ops=[NotIn()], comparators=[Name(id='argnames', ctx=Load())]), body=[Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="In {}: indirect fixture '{}' doesn't exist"), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Load()), attr='__name__', ctx=Load()), Name(id='arg', ctx=Load())], keywords=[])], keywords=[keyword(arg='pytrace', value=Constant(value=False))]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='valtypes', ctx=Load()), slice=Name(id='arg', ctx=Load()), ctx=Store())], value=Constant(value='params'))], orelse=[])], orelse=[Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='In {func}: expected Sequence or boolean for indirect, got {type}'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='type', value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='indirect', ctx=Load())], keywords=[]), attr='__name__', ctx=Load())), keyword(arg='func', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Load()), attr='__name__', ctx=Load()))])], keywords=[keyword(arg='pytrace', value=Constant(value=False))]))])]), Return(value=Name(id='valtypes', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value="Literal['params', 'funcargs']")], ctx=Load()), ctx=Load())), FunctionDef(name='_validate_if_using_arg_names', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='argnames', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='indirect', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if all argnames are being used, by default values, or directly/indirectly.\n\n        :param List[str] argnames: List of argument names passed to ``parametrize()``.\n        :param indirect: Same as the ``indirect`` parameter of ``parametrize()``.\n        :raises ValueError: If validation fails.\n        ')), Assign(targets=[Name(id='default_arg_names', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Name(id='get_default_arg_names', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='func_name', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Load()), attr='__name__', ctx=Load())), For(target=Name(id='arg', ctx=Store()), iter=Name(id='argnames', ctx=Load()), body=[If(test=Compare(left=Name(id='arg', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='fixturenames', ctx=Load())]), body=[If(test=Compare(left=Name(id='arg', ctx=Load()), ops=[In()], comparators=[Name(id='default_arg_names', ctx=Load())]), body=[Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="In {}: function already takes an argument '{}' with a default value"), attr='format', ctx=Load()), args=[Name(id='func_name', ctx=Load()), Name(id='arg', ctx=Load())], keywords=[])], keywords=[keyword(arg='pytrace', value=Constant(value=False))]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='indirect', ctx=Load()), Name(id='Sequence', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=IfExp(test=Compare(left=Name(id='arg', ctx=Load()), ops=[In()], comparators=[Name(id='indirect', ctx=Load())]), body=Constant(value='fixture'), orelse=Constant(value='argument')))], orelse=[Assign(targets=[Name(id='name', ctx=Store())], value=IfExp(test=Name(id='indirect', ctx=Load()), body=Constant(value='fixture'), orelse=Constant(value='argument')))]), Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[JoinedStr(values=[Constant(value='In '), FormattedValue(value=Name(id='func_name', ctx=Load()), conversion=-1), Constant(value=': function uses no '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value=" '"), FormattedValue(value=Name(id='arg', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[keyword(arg='pytrace', value=Constant(value=False))]))])], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[Name(id='final', ctx=Load())]), FunctionDef(name='_find_parametrized_scope', args=arguments(posonlyargs=[], args=[arg(arg='argnames', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='arg2fixturedefs', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Attribute(value=Name(id='fixtures', ctx=Load()), attr='FixtureDef', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='indirect', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there\'s at least one direct argument, always use "function" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='indirect', ctx=Load()), Name(id='Sequence', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='all_arguments_are_fixtures', ctx=Store())], value=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indirect', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='argnames', ctx=Load())], keywords=[])]))], orelse=[Assign(targets=[Name(id='all_arguments_are_fixtures', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='indirect', ctx=Load())], keywords=[]))]), If(test=Name(id='all_arguments_are_fixtures', ctx=Load()), body=[Assign(targets=[Name(id='fixturedefs', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='arg2fixturedefs', ctx=Load()), Dict(keys=[], values=[])])), Assign(targets=[Name(id='used_scopes', ctx=Store())], value=ListComp(elt=Attribute(value=Subscript(value=Name(id='fixturedef', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='_scope', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='fixturedef', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='fixturedefs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Name(id='argnames', ctx=Load())])], is_async=0)])), Return(value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='used_scopes', ctx=Load())], keywords=[keyword(arg='default', value=Attribute(value=Name(id='Scope', ctx=Load()), attr='Function', ctx=Load()))]))], orelse=[]), Return(value=Attribute(value=Name(id='Scope', ctx=Load()), attr='Function', ctx=Load()))], decorator_list=[], returns=Name(id='Scope', ctx=Load())), FunctionDef(name='_ascii_escaped_by_config', args=arguments(posonlyargs=[], args=[arg(arg='val', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bytes', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='config', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Config', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='config', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='escape_option', ctx=Store())], value=Constant(value=False))], orelse=[Assign(targets=[Name(id='escape_option', ctx=Store())], value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='getini', ctx=Load()), args=[Constant(value='disable_test_id_escaping_and_forfeit_all_rights_to_community_support')], keywords=[]))]), Return(value=IfExp(test=Name(id='escape_option', ctx=Load()), body=Name(id='val', ctx=Load()), orelse=Call(func=Name(id='ascii_escaped', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[])))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_pretty_fixture_path', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='cwd', ctx=Store())], value=Call(func=Attribute(value=Name(id='Path', ctx=Load()), attr='cwd', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Call(func=Name(id='getlocation', ctx=Load()), args=[Name(id='func', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='cwd', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='prefix', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Constant(value='...'), Constant(value='_pytest')], keywords=[])), Try(body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='prefix', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='loc', ctx=Load()), attr='relative_to', ctx=Load()), args=[Name(id='_PYTEST_DIR', ctx=Load())], keywords=[]))], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=Call(func=Name(id='bestrelpath', ctx=Load()), args=[Name(id='cwd', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='show_fixtures_per_test', args=arguments(posonlyargs=[], args=[arg(arg='config')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='_pytest.main', names=[alias(name='wrap_session')], level=0), Return(value=Call(func=Name(id='wrap_session', ctx=Load()), args=[Name(id='config', ctx=Load()), Name(id='_show_fixtures_per_test', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_show_fixtures_per_test', args=arguments(posonlyargs=[], args=[arg(arg='config', annotation=Name(id='Config', ctx=Load())), arg(arg='session', annotation=Name(id='Session', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Import(names=[alias(name='_pytest.config')]), Expr(value=Call(func=Attribute(value=Name(id='session', ctx=Load()), attr='perform_collect', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='curdir', ctx=Store())], value=Call(func=Attribute(value=Name(id='Path', ctx=Load()), attr='cwd', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='tw', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='_pytest', ctx=Load()), attr='config', ctx=Load()), attr='create_terminal_writer', ctx=Load()), args=[Name(id='config', ctx=Load())], keywords=[])), Assign(targets=[Name(id='verbose', ctx=Store())], value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='getvalue', ctx=Load()), args=[Constant(value='verbose')], keywords=[])), FunctionDef(name='get_best_relpath', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Name(id='getlocation', ctx=Load()), args=[Name(id='func', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='curdir', ctx=Load())], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='bestrelpath', ctx=Load()), args=[Name(id='curdir', ctx=Load()), Call(func=Name(id='Path', ctx=Load()), args=[Name(id='loc', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='write_fixture', args=arguments(posonlyargs=[], args=[arg(arg='fixture_def', annotation=Subscript(value=Attribute(value=Name(id='fixtures', ctx=Load()), attr='FixtureDef', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='argname', ctx=Store())], value=Attribute(value=Name(id='fixture_def', ctx=Load()), attr='argname', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='verbose', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)]), Call(func=Attribute(value=Name(id='argname', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_')], keywords=[])]), body=[Return()], orelse=[]), Assign(targets=[Name(id='prettypath', ctx=Store())], value=Call(func=Name(id='_pretty_fixture_path', ctx=Load()), args=[Attribute(value=Name(id='fixture_def', ctx=Load()), attr='func', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='argname', ctx=Load()), conversion=-1)])], keywords=[keyword(arg='green', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value=' -- '), FormattedValue(value=Name(id='prettypath', ctx=Load()), conversion=-1)])], keywords=[keyword(arg='yellow', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='fixture_doc', ctx=Store())], value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='getdoc', ctx=Load()), args=[Attribute(value=Name(id='fixture_def', ctx=Load()), attr='func', ctx=Load())], keywords=[])), If(test=Name(id='fixture_doc', ctx=Load()), body=[Expr(value=Call(func=Name(id='write_docstring', ctx=Load()), args=[Name(id='tw', ctx=Load()), IfExp(test=Compare(left=Name(id='verbose', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)]), body=Subscript(value=Call(func=Attribute(value=Name(id='fixture_doc', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n\n')], keywords=[]), slice=Constant(value=0), ctx=Load()), orelse=Name(id='fixture_doc', ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='line', ctx=Load()), args=[Constant(value='    no docstring available')], keywords=[keyword(arg='red', value=Constant(value=True))]))])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='write_item', args=arguments(posonlyargs=[], args=[arg(arg='item', annotation=Attribute(value=Name(id='nodes', ctx=Load()), attr='Item', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='info', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='FuncFixtureInfo', ctx=Load()), ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='item', ctx=Load()), Constant(value='_fixtureinfo'), Constant(value=None)], keywords=[]), simple=1), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='info', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='info', ctx=Load()), attr='name2fixturedefs', ctx=Load()))]), body=[Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='line', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='sep', ctx=Load()), args=[Constant(value='-'), JoinedStr(values=[Constant(value='fixtures used by '), FormattedValue(value=Attribute(value=Name(id='item', ctx=Load()), attr='name', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='sep', ctx=Load()), args=[Constant(value='-'), JoinedStr(values=[Constant(value='('), FormattedValue(value=Call(func=Name(id='get_best_relpath', ctx=Load()), args=[Attribute(value=Name(id='item', ctx=Load()), attr='function', ctx=Load())], keywords=[]), conversion=-1), Constant(value=')')])], keywords=[])), For(target=Tuple(elts=[Name(id='_', ctx=Store()), Name(id='fixturedefs', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='info', ctx=Load()), attr='name2fixturedefs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Assert(test=Compare(left=Name(id='fixturedefs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), If(test=UnaryOp(op=Not(), operand=Name(id='fixturedefs', ctx=Load())), body=[Continue()], orelse=[]), Expr(value=Call(func=Name(id='write_fixture', ctx=Load()), args=[Subscript(value=Name(id='fixturedefs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), For(target=Name(id='session_item', ctx=Store()), iter=Attribute(value=Name(id='session', ctx=Load()), attr='items', ctx=Load()), body=[Expr(value=Call(func=Name(id='write_item', ctx=Load()), args=[Name(id='session_item', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='showfixtures', args=arguments(posonlyargs=[], args=[arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='_pytest.main', names=[alias(name='wrap_session')], level=0), Return(value=Call(func=Name(id='wrap_session', ctx=Load()), args=[Name(id='config', ctx=Load()), Name(id='_showfixtures_main', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='ExitCode', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_showfixtures_main', args=arguments(posonlyargs=[], args=[arg(arg='config', annotation=Name(id='Config', ctx=Load())), arg(arg='session', annotation=Name(id='Session', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Import(names=[alias(name='_pytest.config')]), Expr(value=Call(func=Attribute(value=Name(id='session', ctx=Load()), attr='perform_collect', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='curdir', ctx=Store())], value=Call(func=Attribute(value=Name(id='Path', ctx=Load()), attr='cwd', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='tw', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='_pytest', ctx=Load()), attr='config', ctx=Load()), attr='create_terminal_writer', ctx=Load()), args=[Name(id='config', ctx=Load())], keywords=[])), Assign(targets=[Name(id='verbose', ctx=Store())], value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='getvalue', ctx=Load()), args=[Constant(value='verbose')], keywords=[])), Assign(targets=[Name(id='fm', ctx=Store())], value=Attribute(value=Name(id='session', ctx=Load()), attr='_fixturemanager', ctx=Load())), Assign(targets=[Name(id='available', ctx=Store())], value=List(elts=[], ctx=Load())), AnnAssign(target=Name(id='seen', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='argname', ctx=Store()), Name(id='fixturedefs', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='fm', ctx=Load()), attr='_arg2fixturedefs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assert(test=Compare(left=Name(id='fixturedefs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), If(test=UnaryOp(op=Not(), operand=Name(id='fixturedefs', ctx=Load())), body=[Continue()], orelse=[]), For(target=Name(id='fixturedef', ctx=Store()), iter=Name(id='fixturedefs', ctx=Load()), body=[Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Name(id='getlocation', ctx=Load()), args=[Attribute(value=Name(id='fixturedef', ctx=Load()), attr='func', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='curdir', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Tuple(elts=[Attribute(value=Name(id='fixturedef', ctx=Load()), attr='argname', ctx=Load()), Name(id='loc', ctx=Load())], ctx=Load()), ops=[In()], comparators=[Name(id='seen', ctx=Load())]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Tuple(elts=[Attribute(value=Name(id='fixturedef', ctx=Load()), attr='argname', ctx=Load()), Name(id='loc', ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='available', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='fixturedef', ctx=Load()), attr='baseid', ctx=Load())], keywords=[]), Attribute(value=Attribute(value=Name(id='fixturedef', ctx=Load()), attr='func', ctx=Load()), attr='__module__', ctx=Load()), Call(func=Name(id='_pretty_fixture_path', ctx=Load()), args=[Attribute(value=Name(id='fixturedef', ctx=Load()), attr='func', ctx=Load())], keywords=[]), Attribute(value=Name(id='fixturedef', ctx=Load()), attr='argname', ctx=Load()), Name(id='fixturedef', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='available', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='currentmodule', ctx=Store())], value=Constant(value=None)), For(target=Tuple(elts=[Name(id='baseid', ctx=Store()), Name(id='module', ctx=Store()), Name(id='prettypath', ctx=Store()), Name(id='argname', ctx=Store()), Name(id='fixturedef', ctx=Store())], ctx=Store()), iter=Name(id='available', ctx=Load()), body=[If(test=Compare(left=Name(id='currentmodule', ctx=Load()), ops=[NotEq()], comparators=[Name(id='module', ctx=Load())]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='module', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_pytest.')], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='line', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='sep', ctx=Load()), args=[Constant(value='-'), JoinedStr(values=[Constant(value='fixtures defined from '), FormattedValue(value=Name(id='module', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='currentmodule', ctx=Store())], value=Name(id='module', ctx=Load()))], orelse=[])], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='verbose', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)]), Call(func=Attribute(value=Name(id='argname', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_')], keywords=[])]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='argname', ctx=Load()), conversion=-1)])], keywords=[keyword(arg='green', value=Constant(value=True))])), If(test=Compare(left=Attribute(value=Name(id='fixturedef', ctx=Load()), attr='scope', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='function')]), body=[Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='write', ctx=Load()), args=[BinOp(left=Constant(value=' [%s scope]'), op=Mod(), right=Attribute(value=Name(id='fixturedef', ctx=Load()), attr='scope', ctx=Load()))], keywords=[keyword(arg='cyan', value=Constant(value=True))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value=' -- '), FormattedValue(value=Name(id='prettypath', ctx=Load()), conversion=-1)])], keywords=[keyword(arg='yellow', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='doc', ctx=Store())], value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='getdoc', ctx=Load()), args=[Attribute(value=Name(id='fixturedef', ctx=Load()), attr='func', ctx=Load())], keywords=[])), If(test=Name(id='doc', ctx=Load()), body=[Expr(value=Call(func=Name(id='write_docstring', ctx=Load()), args=[Name(id='tw', ctx=Load()), IfExp(test=Compare(left=Name(id='verbose', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)]), body=Subscript(value=Call(func=Attribute(value=Name(id='doc', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n\n')], keywords=[]), slice=Constant(value=0), ctx=Load()), orelse=Name(id='doc', ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='line', ctx=Load()), args=[Constant(value='    no docstring available')], keywords=[keyword(arg='red', value=Constant(value=True))]))]), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='line', ctx=Load()), args=[], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='write_docstring', args=arguments(posonlyargs=[], args=[arg(arg='tw', annotation=Name(id='TerminalWriter', ctx=Load())), arg(arg='doc', annotation=Name(id='str', ctx=Load())), arg(arg='indent', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='    ')]), body=[For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='doc', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='line', ctx=Load()), args=[BinOp(left=Name(id='indent', ctx=Load()), op=Add(), right=Name(id='line', ctx=Load()))], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), ClassDef(name='Function', bases=[Name(id='PyobjMixin', ctx=Load()), Attribute(value=Name(id='nodes', ctx=Load()), attr='Item', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Item responsible for setting up and executing a Python test function.\n\n    :param name:\n        The full function name, including any decorations like those\n        added by parametrization (``my_func[my_param]``).\n    :param parent:\n        The parent Node.\n    :param config:\n        The pytest Config object.\n    :param callspec:\n        If given, this is function has been parametrized and the callspec contains\n        meta information about the parametrization.\n    :param callobj:\n        If given, the object which will be called when the Function is invoked,\n        otherwise the callobj will be obtained from ``parent`` using ``originalname``.\n    :param keywords:\n        Keywords bound to the function object for "-k" matching.\n    :param session:\n        The pytest Session object.\n    :param fixtureinfo:\n        Fixture information already resolved at this fixture node..\n    :param originalname:\n        The attribute name to use for accessing the underlying function object.\n        Defaults to ``name``. Set this if name is different from the original name,\n        for example when it contains decorations like those added by parametrization\n        (``my_func[my_param]``).\n    ')), Assign(targets=[Name(id='_ALLOW_MARKERS', ctx=Store())], value=Constant(value=False)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='parent'), arg(arg='config', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Config', ctx=Load()), ctx=Load())), arg(arg='callspec', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CallSpec2', ctx=Load()), ctx=Load())), arg(arg='callobj'), arg(arg='keywords', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='session', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Session', ctx=Load()), ctx=Load())), arg(arg='fixtureinfo', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='FuncFixtureInfo', ctx=Load()), ctx=Load())), arg(arg='originalname', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Name(id='NOTSET', ctx=Load()), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='parent', ctx=Load())], keywords=[keyword(arg='config', value=Name(id='config', ctx=Load())), keyword(arg='session', value=Name(id='session', ctx=Load()))])), If(test=Compare(left=Name(id='callobj', ctx=Load()), ops=[IsNot()], comparators=[Name(id='NOTSET', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Store())], value=Name(id='callobj', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='originalname', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='originalname', ctx=Load()), Name(id='name', ctx=Load())])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='own_markers', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Name(id='get_unpacked_marks', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())], keywords=[])], keywords=[])), If(test=Name(id='callspec', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callspec', ctx=Store())], value=Name(id='callspec', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='own_markers', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='callspec', ctx=Load()), attr='marks', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='keywords', ctx=Load()), attr='update', ctx=Load()), args=[GeneratorExp(elt=Tuple(elts=[Attribute(value=Name(id='mark', ctx=Load()), attr='name', ctx=Load()), Name(id='mark', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='mark', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='own_markers', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='keywords', ctx=Load()), attr='update', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), attr='__dict__', ctx=Load())], keywords=[])), If(test=Name(id='keywords', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='keywords', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='keywords', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='fixtureinfo', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='fixtureinfo', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='_fixturemanager', ctx=Load()), attr='getfixtureinfo', ctx=Load()), args=[Name(id='self', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='cls', ctx=Load())], keywords=[keyword(arg='funcargs', value=Constant(value=True))]))], orelse=[]), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_fixtureinfo', ctx=Store()), annotation=Name(id='FuncFixtureInfo', ctx=Load()), value=Name(id='fixtureinfo', ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fixturenames', ctx=Store())], value=Attribute(value=Name(id='fixtureinfo', ctx=Load()), attr='names_closure', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_initrequest', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='from_parent', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='parent')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Expr(value=Constant(value='The public constructor.')), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='from_parent', ctx=Load()), args=[], keywords=[keyword(arg='parent', value=Name(id='parent', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_initrequest', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='funcargs', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Store())], value=Call(func=Attribute(value=Name(id='fixtures', ctx=Load()), attr='FixtureRequest', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(arg='_ispytest', value=Constant(value=True))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='function', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Underlying python 'function' object.")), Return(value=Call(func=Name(id='getimfunc', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='_getobj', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), Name(id='Class', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='parent_obj', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), attr='newinstance', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='parent_obj', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), attr='obj', ctx=Load()))]), Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='parent_obj', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='originalname', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_pyfuncitem', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='(compatonly) for code expecting pytest-2.2 style request objects.')), Return(value=Name(id='self', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='runtest', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Execute the underlying test function.')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ihook', ctx=Load()), attr='pytest_pyfunc_call', ctx=Load()), args=[], keywords=[keyword(arg='pyfuncitem', value=Name(id='self', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='setup', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='_fillfixtures', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_traceback_filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='excinfo', annotation=Subscript(value=Name(id='ExceptionInfo', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='_obj')], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='fulltrace'), Constant(value=False)], keywords=[]))]), body=[Assign(targets=[Name(id='code', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='_pytest', ctx=Load()), attr='_code', ctx=Load()), attr='Code', ctx=Load()), attr='from_function', ctx=Load()), args=[Call(func=Name(id='get_real_func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='obj', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='path', ctx=Store()), Name(id='firstlineno', ctx=Store())], ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='code', ctx=Load()), attr='path', ctx=Load()), Attribute(value=Name(id='code', ctx=Load()), attr='firstlineno', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='traceback', ctx=Store())], value=Attribute(value=Name(id='excinfo', ctx=Load()), attr='traceback', ctx=Load())), Assign(targets=[Name(id='ntraceback', ctx=Store())], value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='cut', ctx=Load()), args=[], keywords=[keyword(arg='path', value=Name(id='path', ctx=Load())), keyword(arg='firstlineno', value=Name(id='firstlineno', ctx=Load()))])), If(test=Compare(left=Name(id='ntraceback', ctx=Load()), ops=[Eq()], comparators=[Name(id='traceback', ctx=Load())]), body=[Assign(targets=[Name(id='ntraceback', ctx=Store())], value=Call(func=Attribute(value=Name(id='ntraceback', ctx=Load()), attr='cut', ctx=Load()), args=[], keywords=[keyword(arg='path', value=Name(id='path', ctx=Load()))])), If(test=Compare(left=Name(id='ntraceback', ctx=Load()), ops=[Eq()], comparators=[Name(id='traceback', ctx=Load())]), body=[Assign(targets=[Name(id='ntraceback', ctx=Store())], value=Call(func=Attribute(value=Name(id='ntraceback', ctx=Load()), attr='filter', ctx=Load()), args=[Name(id='filter_traceback', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='ntraceback', ctx=Load())), body=[Assign(targets=[Name(id='ntraceback', ctx=Store())], value=Name(id='traceback', ctx=Load()))], orelse=[])], orelse=[])], orelse=[]), Assign(targets=[Name(id='ntraceback', ctx=Store())], value=Call(func=Attribute(value=Name(id='ntraceback', ctx=Load()), attr='filter', ctx=Load()), args=[Name(id='excinfo', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='tbstyle'), Constant(value='auto')], keywords=[]), ops=[Eq()], comparators=[Constant(value='auto')]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='ntraceback', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=2)]), body=[Assign(targets=[Name(id='ntraceback', ctx=Store())], value=Call(func=Name(id='Traceback', ctx=Load()), args=[GeneratorExp(elt=IfExp(test=BoolOp(op=Or(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='ntraceback', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))])]), body=Name(id='entry', ctx=Load()), orelse=Call(func=Attribute(value=Name(id='entry', ctx=Load()), attr='with_repr_style', ctx=Load()), args=[Constant(value='short')], keywords=[])), generators=[comprehension(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='entry', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='ntraceback', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='ntraceback', ctx=Load()))], orelse=[]), Return(value=Attribute(value=Name(id='excinfo', ctx=Load()), attr='traceback', ctx=Load()))], decorator_list=[], returns=Name(id='Traceback', ctx=Load())), FunctionDef(name='repr_failure', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='excinfo', annotation=Subscript(value=Name(id='ExceptionInfo', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='style', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='tbstyle'), Constant(value='auto')], keywords=[])), If(test=Compare(left=Name(id='style', ctx=Load()), ops=[Eq()], comparators=[Constant(value='auto')]), body=[Assign(targets=[Name(id='style', ctx=Store())], value=Constant(value='long'))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_repr_failure_py', ctx=Load()), args=[Name(id='excinfo', ctx=Load())], keywords=[keyword(arg='style', value=Name(id='style', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='TerminalRepr', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='FunctionDefinition', bases=[Name(id='Function', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='This class is a stop gap solution until we evolve to have actual function\n    definition nodes and manage to get rid of ``metafunc``.')), FunctionDef(name='runtest', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='function definitions are not supposed to be run as tests')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), Assign(targets=[Name(id='setup', ctx=Store())], value=Name(id='runtest', ctx=Load()))], decorator_list=[])], type_ignores=[])