Module(body=[Import(names=[alias(name='os')]), Import(names=[alias(name='warnings')]), ImportFrom(module='inspect', names=[alias(name='signature')], level=0), ImportFrom(module='pathlib', names=[alias(name='Path')], level=0), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='cast')], level=0), ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='Iterator')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='MutableMapping')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='overload')], level=0), ImportFrom(module='typing', names=[alias(name='Set')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='Type')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING')], level=0), ImportFrom(module='typing', names=[alias(name='TypeVar')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), Import(names=[alias(name='_pytest._code')]), ImportFrom(module='_pytest._code', names=[alias(name='getfslineno')], level=0), ImportFrom(module='_pytest._code.code', names=[alias(name='ExceptionInfo')], level=0), ImportFrom(module='_pytest._code.code', names=[alias(name='TerminalRepr')], level=0), ImportFrom(module='_pytest._code.code', names=[alias(name='Traceback')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='cached_property')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='LEGACY_PATH')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='Config')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='ConftestImportFailure')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='FSCOLLECTOR_GETHOOKPROXY_ISINITPATH')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='NODE_CTOR_FSPATH_ARG')], level=0), ImportFrom(module='_pytest.mark.structures', names=[alias(name='Mark')], level=0), ImportFrom(module='_pytest.mark.structures', names=[alias(name='MarkDecorator')], level=0), ImportFrom(module='_pytest.mark.structures', names=[alias(name='NodeKeywords')], level=0), ImportFrom(module='_pytest.outcomes', names=[alias(name='fail')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='absolutepath')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='commonpath')], level=0), ImportFrom(module='_pytest.stash', names=[alias(name='Stash')], level=0), ImportFrom(module='_pytest.warning_types', names=[alias(name='PytestWarning')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='_pytest.main', names=[alias(name='Session')], level=0), ImportFrom(module='_pytest._code.code', names=[alias(name='_TracebackStyle')], level=0)], orelse=[]), Assign(targets=[Name(id='SEP', ctx=Store())], value=Constant(value='/')), Assign(targets=[Name(id='tracebackcutdir', ctx=Store())], value=Attribute(value=Call(func=Name(id='Path', ctx=Load()), args=[Attribute(value=Name(id='_pytest', ctx=Load()), attr='__file__', ctx=Load())], keywords=[]), attr='parent', ctx=Load())), FunctionDef(name='iterparentnodeids', args=arguments(posonlyargs=[], args=[arg(arg='nodeid', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the parent node IDs of a given node ID, inclusive.\n\n    For the node ID\n\n        "testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source"\n\n    the result would be\n\n        ""\n        "testing"\n        "testing/code"\n        "testing/code/test_excinfo.py"\n        "testing/code/test_excinfo.py::TestFormattedExcinfo"\n        "testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source"\n\n    Note that / components are only considered until the first ::.\n    ')), Assign(targets=[Name(id='pos', ctx=Store())], value=Constant(value=0)), AnnAssign(target=Name(id='first_colons', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='nodeid', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='::')], keywords=[]), simple=1), If(test=Compare(left=Name(id='first_colons', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Assign(targets=[Name(id='first_colons', ctx=Store())], value=Constant(value=None))], orelse=[]), Expr(value=Yield(value=Constant(value=''))), While(test=Constant(value=True), body=[Assign(targets=[Name(id='at', ctx=Store())], value=Call(func=Attribute(value=Name(id='nodeid', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='SEP', ctx=Load()), Name(id='pos', ctx=Load()), Name(id='first_colons', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='at', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Break()], orelse=[]), If(test=Compare(left=Name(id='at', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Expr(value=Yield(value=Subscript(value=Name(id='nodeid', ctx=Load()), slice=Slice(upper=Name(id='at', ctx=Load())), ctx=Load())))], orelse=[]), Assign(targets=[Name(id='pos', ctx=Store())], value=BinOp(left=Name(id='at', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='SEP', ctx=Load())], keywords=[])))], orelse=[]), While(test=Constant(value=True), body=[Assign(targets=[Name(id='at', ctx=Store())], value=Call(func=Attribute(value=Name(id='nodeid', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='::'), Name(id='pos', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='at', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Break()], orelse=[]), If(test=Compare(left=Name(id='at', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Expr(value=Yield(value=Subscript(value=Name(id='nodeid', ctx=Load()), slice=Slice(upper=Name(id='at', ctx=Load())), ctx=Load())))], orelse=[]), Assign(targets=[Name(id='pos', ctx=Store())], value=BinOp(left=Name(id='at', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Constant(value='::')], keywords=[])))], orelse=[]), If(test=Name(id='nodeid', ctx=Load()), body=[Expr(value=Yield(value=Name(id='nodeid', ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_check_path', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='Path', ctx=Load())), arg(arg='fspath', annotation=Name(id='LEGACY_PATH', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='fspath', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='path', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Path('), FormattedValue(value=Name(id='fspath', ctx=Load()), conversion=114), Constant(value=') != '), FormattedValue(value=Name(id='path', ctx=Load()), conversion=114), Constant(value='\nif both path and fspath are given they need to be equal')])], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_imply_path', args=arguments(posonlyargs=[], args=[arg(arg='node_type', annotation=Subscript(value=Name(id='Type', ctx=Load()), slice=Constant(value='Node'), ctx=Load())), arg(arg='path', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load())), arg(arg='fspath', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='LEGACY_PATH', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='fspath', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Name(id='NODE_CTOR_FSPATH_ARG', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='node_type_name', value=Attribute(value=Name(id='node_type', ctx=Load()), attr='__name__', ctx=Load()))])], keywords=[keyword(arg='stacklevel', value=Constant(value=6))]))], orelse=[]), If(test=Compare(left=Name(id='path', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='fspath', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='_check_path', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='fspath', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='path', ctx=Load()))], orelse=[Assert(test=Compare(left=Name(id='fspath', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Return(value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='fspath', ctx=Load())], keywords=[]))])], decorator_list=[], returns=Name(id='Path', ctx=Load())), Assign(targets=[Name(id='_NodeType', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_NodeType')], keywords=[keyword(arg='bound', value=Constant(value='Node'))])), ClassDef(name='NodeMeta', bases=[Name(id='type', ctx=Load())], keywords=[], body=[FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='k'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Constant(value='Direct construction of {name} has been deprecated, please use {name}.from_parent.\nSee https://docs.pytest.org/en/stable/deprecations.html#node-construction-changed-to-node-from-parent for more details.'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='__module__', ctx=Load()), conversion=-1), Constant(value='.'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1)]))])), Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[keyword(arg='pytrace', value=Constant(value=False))]))], decorator_list=[]), FunctionDef(name='_create', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='k'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Try(body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__call__', ctx=Load()), args=[Starred(value=Name(id='k', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kw', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Assign(targets=[Name(id='sig', ctx=Store())], value=Call(func=Name(id='signature', ctx=Load()), args=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='__init__')], keywords=[])], keywords=[])), Assign(targets=[Name(id='known_kw', ctx=Store())], value=DictComp(key=Name(id='k', ctx=Load()), value=Name(id='v', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='kw', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Compare(left=Name(id='k', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='sig', ctx=Load()), attr='parameters', ctx=Load())])], is_async=0)])), ImportFrom(module='warning_types', names=[alias(name='PytestDeprecationWarning')], level=1), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Name(id='PytestDeprecationWarning', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' is not using a cooperative constructor and only takes '), FormattedValue(value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='known_kw', ctx=Load())], keywords=[]), conversion=-1), Constant(value='.\nSee https://docs.pytest.org/en/stable/deprecations.html#constructors-of-custom-pytest-node-subclasses-should-take-kwargs for more details.')])], keywords=[])], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__call__', ctx=Load()), args=[Starred(value=Name(id='k', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='known_kw', ctx=Load()))]))])], orelse=[], finalbody=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='Node', bases=[], keywords=[keyword(arg='metaclass', value=Name(id='NodeMeta', ctx=Load()))], body=[Expr(value=Constant(value="Base class of :class:`Collector` and :class:`Item`, the components of\n    the test collection tree.\n\n    ``Collector``\\'s are the internal nodes of the tree, and ``Item``\\'s are the\n    leaf nodes.\n    ")), AnnAssign(target=Name(id='fspath', ctx=Store()), annotation=Name(id='LEGACY_PATH', ctx=Load()), simple=1), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='name'), Constant(value='parent'), Constant(value='config'), Constant(value='session'), Constant(value='path'), Constant(value='_nodeid'), Constant(value='_store'), Constant(value='__dict__')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='parent', annotation=Constant(value='Optional[Node]')), arg(arg='config', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Config', ctx=Load()), ctx=Load())), arg(arg='session', annotation=Constant(value='Optional[Session]')), arg(arg='fspath', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='LEGACY_PATH', ctx=Load()), ctx=Load())), arg(arg='path', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load())), arg(arg='nodeid', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Name(id='name', ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Store())], value=Name(id='parent', ctx=Load())), If(test=Name(id='config', ctx=Load()), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Store()), annotation=Name(id='Config', ctx=Load()), value=Name(id='config', ctx=Load()), simple=0)], orelse=[If(test=UnaryOp(op=Not(), operand=Name(id='parent', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='config or parent must be provided')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Store())], value=Attribute(value=Name(id='parent', ctx=Load()), attr='config', ctx=Load()))]), If(test=Name(id='session', ctx=Load()), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Store()), annotation=Name(id='Session', ctx=Load()), value=Name(id='session', ctx=Load()), simple=0)], orelse=[If(test=UnaryOp(op=Not(), operand=Name(id='parent', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='session or parent must be provided')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Store())], value=Attribute(value=Name(id='parent', ctx=Load()), attr='session', ctx=Load()))]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='fspath', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='parent', ctx=Load()), Constant(value='path'), Constant(value=None)], keywords=[]))], orelse=[]), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Store()), annotation=Name(id='Path', ctx=Load()), value=Call(func=Name(id='_imply_path', ctx=Load()), args=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), Name(id='path', ctx=Load())], keywords=[keyword(arg='fspath', value=Name(id='fspath', ctx=Load()))]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='keywords', ctx=Store()), annotation=Subscript(value=Name(id='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='NodeKeywords', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='own_markers', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Mark', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='extra_keyword_matches', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=0), If(test=Compare(left=Name(id='nodeid', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assert(test=Compare(left=Constant(value='::()'), ops=[NotIn()], comparators=[Name(id='nodeid', ctx=Load())])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_nodeid', ctx=Store())], value=Name(id='nodeid', ctx=Load()))], orelse=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load())), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='nodeid or parent must be provided')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_nodeid', ctx=Store())], value=BinOp(left=BinOp(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), attr='nodeid', ctx=Load()), op=Add(), right=Constant(value='::')), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())))]), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='stash', ctx=Store()), annotation=Name(id='Stash', ctx=Load()), value=Call(func=Name(id='Stash', ctx=Load()), args=[], keywords=[]), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_store', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='stash', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='from_parent', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='parent', annotation=Constant(value='Node'))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Expr(value=Constant(value='Public constructor for Nodes.\n\n        This indirection got introduced in order to enable removing\n        the fragile logic from the node constructors.\n\n        Subclasses can use ``super().from_parent(...)`` when overriding the\n        construction.\n\n        :param parent: The parent node of this Node.\n        ')), If(test=Compare(left=Constant(value='config'), ops=[In()], comparators=[Name(id='kw', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='config is not a valid argument for from_parent')], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='session'), ops=[In()], comparators=[Name(id='kw', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='session is not a valid argument for from_parent')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_create', ctx=Load()), args=[], keywords=[keyword(arg='parent', value=Name(id='parent', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='ihook', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='fspath-sensitive hook proxy used to call pytest hooks.')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='gethookproxy', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<{} {}>'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='name'), Constant(value=None)], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='warn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='warning', annotation=Name(id='Warning', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Issue a warning for this Node.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed.\n\n        :param Warning warning:\n            The warning instance to issue.\n\n        :raises ValueError: If ``warning`` instance is not a subclass of Warning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning("some message"))\n            node.warn(UserWarning("some message"))\n\n        .. versionchanged:: 6.2\n            Any subclass of :class:`Warning` is now accepted, rather than only\n            :class:`PytestWarning <pytest.PytestWarning>` subclasses.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='warning', ctx=Load()), Name(id='Warning', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='warning must be an instance of Warning or subclass, got {!r}'), attr='format', ctx=Load()), args=[Name(id='warning', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='path', ctx=Store()), Name(id='lineno', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_fslocation_from_item', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Assert(test=Compare(left=Name(id='lineno', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn_explicit', ctx=Load()), args=[Name(id='warning', ctx=Load())], keywords=[keyword(arg='category', value=Constant(value=None)), keyword(arg='filename', value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), keyword(arg='lineno', value=BinOp(left=Name(id='lineno', ctx=Load()), op=Add(), right=Constant(value=1)))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='nodeid', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='A ::-separated string denoting its collection tree address.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_nodeid', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_nodeid', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='setup', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='teardown', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='listchain', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return list of all parent collectors up to self, starting from\n        the root of collection tree.\n\n        :returns: The nodes.\n        ')), Assign(targets=[Name(id='chain', ctx=Store())], value=List(elts=[], ctx=Load())), AnnAssign(target=Name(id='item', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), value=Name(id='self', ctx=Load()), simple=1), While(test=Compare(left=Name(id='item', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), Assign(targets=[Name(id='item', ctx=Store())], value=Attribute(value=Name(id='item', ctx=Load()), attr='parent', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='chain', ctx=Load()), attr='reverse', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='chain', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='Node'), ctx=Load())), FunctionDef(name='add_marker', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='marker', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='MarkDecorator', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='append', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Dynamically add a marker object to the node.\n\n        :param marker:\n            The marker.\n        :param append:\n            Whether to append the marker, or prepend it.\n        ')), ImportFrom(module='_pytest.mark', names=[alias(name='MARK_GEN')], level=0), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='marker', ctx=Load()), Name(id='MarkDecorator', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='marker_', ctx=Store())], value=Name(id='marker', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='marker', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='marker_', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='MARK_GEN', ctx=Load()), Name(id='marker', ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='is not a string or pytest.mark.* Marker')], keywords=[]))])]), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='keywords', ctx=Load()), slice=Attribute(value=Name(id='marker_', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Name(id='marker_', ctx=Load())), If(test=Name(id='append', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='own_markers', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='marker_', ctx=Load()), attr='mark', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='own_markers', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Attribute(value=Name(id='marker_', ctx=Load()), attr='mark', ctx=Load())], keywords=[]))])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='iter_markers', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of the markers of the node.\n        ')), Return(value=GeneratorExp(elt=Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=1), ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iter_markers_with_node', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load()))]), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Mark', ctx=Load()), ctx=Load())), FunctionDef(name='iter_markers_with_node', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of (node, mark) tuples.\n        ')), For(target=Name(id='node', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='listchain', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[For(target=Name(id='mark', ctx=Store()), iter=Attribute(value=Name(id='node', ctx=Load()), attr='own_markers', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='mark', ctx=Load()), Constant(value='name'), Constant(value=None)], keywords=[]), ops=[Eq()], comparators=[Name(id='name', ctx=Load())])]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='node', ctx=Load()), Name(id='mark', ctx=Load())], ctx=Load())))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Constant(value='Node'), Name(id='Mark', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='get_closest_marker', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Mark', ctx=Load()), ctx=Load())), FunctionDef(name='get_closest_marker', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='default', annotation=Name(id='Mark', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Name(id='Mark', ctx=Load())), FunctionDef(name='get_closest_marker', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='default', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Mark', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return the first marker matching the name, from closest (for\n        example function) to farther level (for example module level).\n\n        :param default: Fallback return value if no marker was found.\n        :param name: Name to filter by.\n        ')), Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iter_markers', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load()))]), Name(id='default', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Mark', ctx=Load()), ctx=Load())), FunctionDef(name='listextrakeywords', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a set of all extra keywords in self and any parents.')), AnnAssign(target=Name(id='extra_keywords', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), For(target=Name(id='item', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='listchain', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='extra_keywords', ctx=Load()), attr='update', ctx=Load()), args=[Attribute(value=Name(id='item', ctx=Load()), attr='extra_keyword_matches', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='extra_keywords', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='listnames', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=ListComp(elt=Attribute(value=Name(id='x', ctx=Load()), attr='name', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='listchain', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='addfinalizer', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fin', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Register a function to be called without arguments when this node is\n        finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='_setupstate', ctx=Load()), attr='addfinalizer', ctx=Load()), args=[Name(id='fin', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='getparent', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls', annotation=Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='_NodeType', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the next parent node (including self) which is an instance of\n        the given class.\n\n        :param cls: The node class to search for.\n        :returns: The node, if found.\n        ')), AnnAssign(target=Name(id='current', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load()), value=Name(id='self', ctx=Load()), simple=1), While(test=BoolOp(op=And(), values=[Name(id='current', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='current', ctx=Load()), Name(id='cls', ctx=Load())], keywords=[]))]), body=[Assign(targets=[Name(id='current', ctx=Store())], value=Attribute(value=Name(id='current', ctx=Load()), attr='parent', ctx=Load()))], orelse=[]), Assert(test=BoolOp(op=Or(), values=[Compare(left=Name(id='current', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='current', ctx=Load()), Name(id='cls', ctx=Load())], keywords=[])])), Return(value=Name(id='current', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_NodeType', ctx=Load()), ctx=Load())), FunctionDef(name='_traceback_filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='excinfo', annotation=Subscript(value=Name(id='ExceptionInfo', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='excinfo', ctx=Load()), attr='traceback', ctx=Load()))], decorator_list=[], returns=Name(id='Traceback', ctx=Load())), FunctionDef(name='_repr_failure_py', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='excinfo', annotation=Subscript(value=Name(id='ExceptionInfo', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load())), arg(arg='style', annotation=Constant(value='Optional[_TracebackStyle]'))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[ImportFrom(module='_pytest.fixtures', names=[alias(name='FixtureLookupError')], level=0), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='excinfo', ctx=Load()), attr='value', ctx=Load()), Name(id='ConftestImportFailure', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='excinfo', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExceptionInfo', ctx=Load()), attr='from_exc_info', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='excinfo', ctx=Load()), attr='value', ctx=Load()), attr='excinfo', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='excinfo', ctx=Load()), attr='value', ctx=Load()), Attribute(value=Name(id='fail', ctx=Load()), attr='Exception', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='excinfo', ctx=Load()), attr='value', ctx=Load()), attr='pytrace', ctx=Load())), body=[Assign(targets=[Name(id='style', ctx=Store())], value=Constant(value='value'))], orelse=[])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='excinfo', ctx=Load()), attr='value', ctx=Load()), Name(id='FixtureLookupError', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='excinfo', ctx=Load()), attr='value', ctx=Load()), attr='formatrepr', ctx=Load()), args=[], keywords=[]))], orelse=[]), AnnAssign(target=Name(id='tbfilter', ctx=Store()), annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Subscript(value=Name(id='ExceptionInfo', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load())], ctx=Load()), Name(id='Traceback', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), simple=1), If(test=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='fulltrace'), Constant(value=False)], keywords=[]), body=[Assign(targets=[Name(id='style', ctx=Store())], value=Constant(value='long')), Assign(targets=[Name(id='tbfilter', ctx=Store())], value=Constant(value=False))], orelse=[Assign(targets=[Name(id='tbfilter', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_traceback_filter', ctx=Load())), If(test=Compare(left=Name(id='style', ctx=Load()), ops=[Eq()], comparators=[Constant(value='auto')]), body=[Assign(targets=[Name(id='style', ctx=Store())], value=Constant(value='long'))], orelse=[])]), If(test=Compare(left=Name(id='style', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='tbstyle'), Constant(value='auto')], keywords=[]), ops=[Eq()], comparators=[Constant(value='short')]), body=[Assign(targets=[Name(id='style', ctx=Store())], value=Constant(value='short'))], orelse=[Assign(targets=[Name(id='style', ctx=Store())], value=Constant(value='long'))])], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='verbose'), Constant(value=0)], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='truncate_locals', ctx=Store())], value=Constant(value=False))], orelse=[Assign(targets=[Name(id='truncate_locals', ctx=Store())], value=Constant(value=True))]), Try(body=[Assign(targets=[Name(id='abspath', ctx=Store())], value=Compare(left=Call(func=Name(id='Path', ctx=Load()), args=[Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[])], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='invocation_params', ctx=Load()), attr='dir', ctx=Load())]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Assign(targets=[Name(id='abspath', ctx=Store())], value=Constant(value=True))])], orelse=[], finalbody=[]), Return(value=Call(func=Attribute(value=Name(id='excinfo', ctx=Load()), attr='getrepr', ctx=Load()), args=[], keywords=[keyword(arg='funcargs', value=Constant(value=True)), keyword(arg='abspath', value=Name(id='abspath', ctx=Load())), keyword(arg='showlocals', value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='showlocals'), Constant(value=False)], keywords=[])), keyword(arg='style', value=Name(id='style', ctx=Load())), keyword(arg='tbfilter', value=Name(id='tbfilter', ctx=Load())), keyword(arg='truncate_locals', value=Name(id='truncate_locals', ctx=Load()))]))], decorator_list=[], returns=Name(id='TerminalRepr', ctx=Load())), FunctionDef(name='repr_failure', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='excinfo', annotation=Subscript(value=Name(id='ExceptionInfo', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load())), arg(arg='style', annotation=Constant(value='Optional[_TracebackStyle]'))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return a representation of a collection or test failure.\n\n        .. seealso:: :ref:`non-python tests`\n\n        :param excinfo: Exception information for the failure.\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_repr_failure_py', ctx=Load()), args=[Name(id='excinfo', ctx=Load()), Name(id='style', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='TerminalRepr', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='get_fslocation_from_item', args=arguments(posonlyargs=[], args=[arg(arg='node', annotation=Constant(value='Node'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Try to extract the actual location from a node, depending on available attributes:\n\n    * "location": a pair (path, lineno)\n    * "obj": a Python object that the node wraps.\n    * "fspath": just a path\n\n    :rtype: A tuple of (str|Path, int) with filename and 0-based line number.\n    ')), AnnAssign(target=Name(id='location', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='node', ctx=Load()), Constant(value='location'), Constant(value=None)], keywords=[]), simple=1), If(test=Compare(left=Name(id='location', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Subscript(value=Name(id='location', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='obj', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='node', ctx=Load()), Constant(value='obj'), Constant(value=None)], keywords=[])), If(test=Compare(left=Name(id='obj', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='getfslineno', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='node', ctx=Load()), Constant(value='fspath'), Constant(value='unknown location')], keywords=[]), UnaryOp(op=USub(), operand=Constant(value=1))], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Path', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='Collector', bases=[Name(id='Node', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Base class of all collectors.\n\n    Collector create children through `collect()` and thus iteratively build\n    the collection tree.\n    ')), ClassDef(name='CollectError', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='An error during collection, contains a custom message.'))], decorator_list=[]), FunctionDef(name='collect', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Collect children (items and collectors) for this collector.')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value='abstract')], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='Item'), Constant(value='Collector')], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='repr_failure', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='excinfo', annotation=Subscript(value=Name(id='ExceptionInfo', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a representation of a collection failure.\n\n        :param excinfo: Exception information for the failure.\n        ')), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='excinfo', ctx=Load()), attr='value', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='CollectError', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='fulltrace'), Constant(value=False)], keywords=[]))]), body=[Assign(targets=[Name(id='exc', ctx=Store())], value=Attribute(value=Name(id='excinfo', ctx=Load()), attr='value', ctx=Load())), Return(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='exc', ctx=Load()), attr='args', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='tbstyle', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='tbstyle'), Constant(value='auto')], keywords=[])), If(test=Compare(left=Name(id='tbstyle', ctx=Load()), ops=[Eq()], comparators=[Constant(value='auto')]), body=[Assign(targets=[Name(id='tbstyle', ctx=Store())], value=Constant(value='short'))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_repr_failure_py', ctx=Load()), args=[Name(id='excinfo', ctx=Load())], keywords=[keyword(arg='style', value=Name(id='tbstyle', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='TerminalRepr', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_traceback_filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='excinfo', annotation=Subscript(value=Name(id='ExceptionInfo', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='path')], keywords=[]), body=[Assign(targets=[Name(id='traceback', ctx=Store())], value=Attribute(value=Name(id='excinfo', ctx=Load()), attr='traceback', ctx=Load())), Assign(targets=[Name(id='ntraceback', ctx=Store())], value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='cut', ctx=Load()), args=[], keywords=[keyword(arg='path', value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()))])), If(test=Compare(left=Name(id='ntraceback', ctx=Load()), ops=[Eq()], comparators=[Name(id='traceback', ctx=Load())]), body=[Assign(targets=[Name(id='ntraceback', ctx=Store())], value=Call(func=Attribute(value=Name(id='ntraceback', ctx=Load()), attr='cut', ctx=Load()), args=[], keywords=[keyword(arg='excludepath', value=Name(id='tracebackcutdir', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='excinfo', ctx=Load()), attr='traceback', ctx=Load()), attr='filter', ctx=Load()), args=[Name(id='excinfo', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='excinfo', ctx=Load()), attr='traceback', ctx=Load()))], decorator_list=[], returns=Name(id='Traceback', ctx=Load()))], decorator_list=[]), FunctionDef(name='_check_initialpaths_for_relpath', args=arguments(posonlyargs=[], args=[arg(arg='session', annotation=Constant(value='Session')), arg(arg='path', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='initial_path', ctx=Store()), iter=Attribute(value=Name(id='session', ctx=Load()), attr='_initialpaths', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='commonpath', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='initial_path', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Name(id='initial_path', ctx=Load())]), body=[Assign(targets=[Name(id='rel', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='relative_to', ctx=Load()), args=[Name(id='initial_path', ctx=Load())], keywords=[])], keywords=[])), Return(value=IfExp(test=Compare(left=Name(id='rel', ctx=Load()), ops=[Eq()], comparators=[Constant(value='.')]), body=Constant(value=''), orelse=Name(id='rel', ctx=Load())))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), ClassDef(name='FSCollector', bases=[Name(id='Collector', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Base class for filesystem collectors.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fspath', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='LEGACY_PATH', ctx=Load()), ctx=Load())), arg(arg='path_or_parent', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Path', ctx=Load()), Name(id='Node', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='path', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load())), arg(arg='name', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='parent', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Node', ctx=Load()), ctx=Load())), arg(arg='config', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Config', ctx=Load()), ctx=Load())), arg(arg='session', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='Session'), ctx=Load())), arg(arg='nodeid', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[If(test=Name(id='path_or_parent', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='path_or_parent', ctx=Load()), Name(id='Node', ctx=Load())], keywords=[]), body=[Assert(test=Compare(left=Name(id='parent', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='parent', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='FSCollector', ctx=Load()), Name(id='path_or_parent', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='path_or_parent', ctx=Load()), Name(id='Path', ctx=Load())], keywords=[]), body=[Assert(test=Compare(left=Name(id='path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='path', ctx=Store())], value=Name(id='path_or_parent', ctx=Load()))], orelse=[])])], orelse=[]), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='_imply_path', ctx=Load()), args=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), Name(id='path', ctx=Load())], keywords=[keyword(arg='fspath', value=Name(id='fspath', ctx=Load()))])), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='path', ctx=Load()), attr='name', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='parent', ctx=Load()), attr='path', ctx=Load()), ops=[NotEq()], comparators=[Name(id='path', ctx=Load())])]), body=[Try(body=[Assign(targets=[Name(id='rel', ctx=Store())], value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='relative_to', ctx=Load()), args=[Attribute(value=Name(id='parent', ctx=Load()), attr='path', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Pass()])], orelse=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='rel', ctx=Load())], keywords=[]))], finalbody=[]), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='replace', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), Name(id='SEP', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Store())], value=Name(id='path', ctx=Load())), If(test=Compare(left=Name(id='session', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assert(test=Compare(left=Name(id='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='session', ctx=Store())], value=Attribute(value=Name(id='parent', ctx=Load()), attr='session', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='nodeid', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Try(body=[Assign(targets=[Name(id='nodeid', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='relative_to', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='session', ctx=Load()), attr='config', ctx=Load()), attr='rootpath', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Assign(targets=[Name(id='nodeid', ctx=Store())], value=Call(func=Name(id='_check_initialpaths_for_relpath', ctx=Load()), args=[Name(id='session', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[Name(id='nodeid', ctx=Load()), Compare(left=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), ops=[NotEq()], comparators=[Name(id='SEP', ctx=Load())])]), body=[Assign(targets=[Name(id='nodeid', ctx=Store())], value=Call(func=Attribute(value=Name(id='nodeid', ctx=Load()), attr='replace', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), Name(id='SEP', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='parent', value=Name(id='parent', ctx=Load())), keyword(arg='config', value=Name(id='config', ctx=Load())), keyword(arg='session', value=Name(id='session', ctx=Load())), keyword(arg='nodeid', value=Name(id='nodeid', ctx=Load())), keyword(arg='path', value=Name(id='path', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='from_parent', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='parent')], kwonlyargs=[arg(arg='fspath', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='LEGACY_PATH', ctx=Load()), ctx=Load())), arg(arg='path', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None)], kwarg=arg(arg='kw'), defaults=[]), body=[Expr(value=Constant(value='The public constructor.')), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='from_parent', ctx=Load()), args=[], keywords=[keyword(arg='parent', value=Name(id='parent', ctx=Load())), keyword(arg='fspath', value=Name(id='fspath', ctx=Load())), keyword(arg='path', value=Name(id='path', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='gethookproxy', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fspath', annotation=Constant(value='os.PathLike[str]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='FSCOLLECTOR_GETHOOKPROXY_ISINITPATH', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='gethookproxy', ctx=Load()), args=[Name(id='fspath', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='isinitpath', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Name(id='FSCOLLECTOR_GETHOOKPROXY_ISINITPATH', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='isinitpath', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='File', bases=[Name(id='FSCollector', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Base class for collecting tests from a file.\n\n    :ref:`non-python tests`.\n    '))], decorator_list=[]), ClassDef(name='Item', bases=[Name(id='Node', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Base class of all test invocation items.\n\n    Note that for a single function there might be multiple test invocation items.\n    ')), Assign(targets=[Name(id='nextitem', ctx=Store())], value=Constant(value=None)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='parent'), arg(arg='config', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Config', ctx=Load()), ctx=Load())), arg(arg='session', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='Session'), ctx=Load())), arg(arg='nodeid', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='parent', ctx=Load())], keywords=[keyword(arg='config', value=Name(id='config', ctx=Load())), keyword(arg='session', value=Name(id='session', ctx=Load())), keyword(arg='nodeid', value=Name(id='nodeid', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_report_sections', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='user_properties', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_item_and_collector_diamond_inheritance', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_check_item_and_collector_diamond_inheritance', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Check if the current type inherits from both File and Collector\n        at the same time, emitting a warning accordingly (#8447).\n        ')), Assign(targets=[Name(id='cls', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Name(id='attr_name', ctx=Store())], value=Constant(value='_pytest_diamond_inheritance_warning_shown')), If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='attr_name', ctx=Load()), Constant(value=False)], keywords=[]), body=[Return()], orelse=[]), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='attr_name', ctx=Load()), Constant(value=True)], keywords=[])), Assign(targets=[Name(id='problems', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='base', ctx=Load()), attr='__name__', ctx=Load()), generators=[comprehension(target=Name(id='base', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load()), ifs=[Call(func=Name(id='issubclass', ctx=Load()), args=[Name(id='base', ctx=Load()), Name(id='Collector', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])), If(test=Name(id='problems', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value=' is an Item subclass and should not be a collector, however its bases '), FormattedValue(value=Name(id='problems', ctx=Load()), conversion=-1), Constant(value=' are collectors.\nPlease split the Collectors and the Item into separate node types.\nPytest Doc example: https://docs.pytest.org/en/latest/example/nonpython.html\nexample pull request on a plugin: https://github.com/asmeurer/pytest-flakes/pull/40/')]), Name(id='PytestWarning', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='runtest', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Run the test case for this item.\n\n        Must be implemented by subclasses.\n\n        .. seealso:: :ref:`non-python tests`\n        ')), Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value='runtest must be implemented by Item subclass')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='add_report_section', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='when', annotation=Name(id='str', ctx=Load())), arg(arg='key', annotation=Name(id='str', ctx=Load())), arg(arg='content', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add a new report section, similar to what\'s done internally to add\n        stdout and stderr captured output::\n\n            item.add_report_section("call", "stdout", "report section contents")\n\n        :param str when:\n            One of the possible capture states, ``"setup"``, ``"call"``, ``"teardown"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``"stdout"`` and\n            ``"stderr"`` internally.\n        :param str content:\n            The full contents as a string.\n        ')), If(test=Name(id='content', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_report_sections', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='when', ctx=Load()), Name(id='key', ctx=Load()), Name(id='content', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='reportinfo', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get location information for this item for test reports.\n\n        Returns a tuple with three elements:\n\n        - The path of the test (default ``self.path``)\n        - The 0-based line number of the test (default ``None``)\n        - A name of the test to be shown (default ``""``)\n\n        .. seealso:: :ref:`non-python tests`\n        ')), Return(value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), Constant(value=None), Constant(value='')], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='os.PathLike[str]'), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='location', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returns a tuple of ``(relfspath, lineno, testname)`` for this item\n        where ``relfspath`` is file path relative to ``config.rootpath``\n        and lineno is a 0-based line number.\n        ')), Assign(targets=[Name(id='location', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='reportinfo', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='absolutepath', ctx=Load()), args=[Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='fspath', ctx=Load()), args=[Subscript(value=Name(id='location', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='relfspath', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='session', ctx=Load()), attr='_node_location_to_relpath', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assert(test=Compare(left=Call(func=Name(id='type', ctx=Load()), args=[Subscript(value=Name(id='location', ctx=Load()), slice=Constant(value=2), ctx=Load())], keywords=[]), ops=[Is()], comparators=[Name(id='str', ctx=Load())])), Return(value=Tuple(elts=[Name(id='relfspath', ctx=Load()), Subscript(value=Name(id='location', ctx=Load()), slice=Constant(value=1), ctx=Load()), Subscript(value=Name(id='location', ctx=Load()), slice=Constant(value=2), ctx=Load())], ctx=Load()))], decorator_list=[Name(id='cached_property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])