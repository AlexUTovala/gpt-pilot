Module(body=[Expr(value=Constant(value='Monkeypatching and mocking functionality.')), Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='warnings')]), ImportFrom(module='contextlib', names=[alias(name='contextmanager')], level=0), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Generator')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Mapping')], level=0), ImportFrom(module='typing', names=[alias(name='MutableMapping')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='overload')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='TypeVar')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='final')], level=0), ImportFrom(module='_pytest.fixtures', names=[alias(name='fixture')], level=0), ImportFrom(module='_pytest.warning_types', names=[alias(name='PytestWarning')], level=0), Assign(targets=[Name(id='RE_IMPORT_ERROR_NAME', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^No module named (.*)$')], keywords=[])), Assign(targets=[Name(id='K', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='K')], keywords=[])), Assign(targets=[Name(id='V', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='V')], keywords=[])), FunctionDef(name='monkeypatch', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='A convenient fixture for monkey-patching.\n\n    The fixture provides these methods to modify objects, dictionaries, or\n    :data:`os.environ`:\n\n    * :meth:`monkeypatch.setattr(obj, name, value, raising=True) <pytest.MonkeyPatch.setattr>`\n    * :meth:`monkeypatch.delattr(obj, name, raising=True) <pytest.MonkeyPatch.delattr>`\n    * :meth:`monkeypatch.setitem(mapping, name, value) <pytest.MonkeyPatch.setitem>`\n    * :meth:`monkeypatch.delitem(obj, name, raising=True) <pytest.MonkeyPatch.delitem>`\n    * :meth:`monkeypatch.setenv(name, value, prepend=None) <pytest.MonkeyPatch.setenv>`\n    * :meth:`monkeypatch.delenv(name, raising=True) <pytest.MonkeyPatch.delenv>`\n    * :meth:`monkeypatch.syspath_prepend(path) <pytest.MonkeyPatch.syspath_prepend>`\n    * :meth:`monkeypatch.chdir(path) <pytest.MonkeyPatch.chdir>`\n    * :meth:`monkeypatch.context() <pytest.MonkeyPatch.context>`\n\n    All modifications will be undone after the requesting test function or\n    fixture has finished. The ``raising`` parameter determines if a :class:`KeyError`\n    or :class:`AttributeError` will be raised if the set/deletion operation does not have the\n    specified target.\n\n    To undo modifications done by the fixture in a contained scope,\n    use :meth:`context() <pytest.MonkeyPatch.context>`.\n    ')), Assign(targets=[Name(id='mpatch', ctx=Store())], value=Call(func=Name(id='MonkeyPatch', ctx=Load()), args=[], keywords=[])), Expr(value=Yield(value=Name(id='mpatch', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='mpatch', ctx=Load()), attr='undo', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='fixture', ctx=Load())], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Constant(value='MonkeyPatch'), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), FunctionDef(name='resolve', args=arguments(posonlyargs=[], args=[arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), Assign(targets=[Name(id='used', ctx=Store())], value=Call(func=Attribute(value=Name(id='parts', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value=0)], keywords=[])), AnnAssign(target=Name(id='found', ctx=Store()), annotation=Name(id='object', ctx=Load()), value=Call(func=Name(id='__import__', ctx=Load()), args=[Name(id='used', ctx=Load())], keywords=[]), simple=1), For(target=Name(id='part', ctx=Store()), iter=Name(id='parts', ctx=Load()), body=[AugAssign(target=Name(id='used', ctx=Store()), op=Add(), value=BinOp(left=Constant(value='.'), op=Add(), right=Name(id='part', ctx=Load()))), Try(body=[Assign(targets=[Name(id='found', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='found', ctx=Load()), Name(id='part', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[Continue()], finalbody=[]), Try(body=[Expr(value=Call(func=Name(id='__import__', ctx=Load()), args=[Name(id='used', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), name='ex', body=[Assign(targets=[Name(id='expected', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='ex', ctx=Load())], keywords=[]), attr='split', ctx=Load()), args=[], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), If(test=Compare(left=Name(id='expected', ctx=Load()), ops=[Eq()], comparators=[Name(id='used', ctx=Load())]), body=[Raise()], orelse=[Raise(exc=Call(func=Name(id='ImportError', ctx=Load()), args=[JoinedStr(values=[Constant(value='import error in '), FormattedValue(value=Name(id='used', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='ex', ctx=Load()), conversion=-1)])], keywords=[]), cause=Name(id='ex', ctx=Load()))])])], orelse=[], finalbody=[]), Assign(targets=[Name(id='found', ctx=Store())], value=Call(func=Name(id='annotated_getattr', ctx=Load()), args=[Name(id='found', ctx=Load()), Name(id='part', ctx=Load()), Name(id='used', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='found', ctx=Load()))], decorator_list=[], returns=Name(id='object', ctx=Load())), FunctionDef(name='annotated_getattr', args=arguments(posonlyargs=[], args=[arg(arg='obj', annotation=Name(id='object', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='ann', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='obj', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{!r} object at {} has no attribute {!r}'), attr='format', ctx=Load()), args=[Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), Name(id='ann', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[]), Return(value=Name(id='obj', ctx=Load()))], decorator_list=[], returns=Name(id='object', ctx=Load())), FunctionDef(name='derive_importpath', args=arguments(posonlyargs=[], args=[arg(arg='import_path', annotation=Name(id='str', ctx=Load())), arg(arg='raising', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='import_path', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), Compare(left=Constant(value='.'), ops=[NotIn()], comparators=[Name(id='import_path', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='must be absolute import path string, not '), FormattedValue(value=Name(id='import_path', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='module', ctx=Store()), Name(id='attr', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='import_path', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[])), Assign(targets=[Name(id='target', ctx=Store())], value=Call(func=Name(id='resolve', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[])), If(test=Name(id='raising', ctx=Load()), body=[Expr(value=Call(func=Name(id='annotated_getattr', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='attr', ctx=Load())], keywords=[keyword(arg='ann', value=Name(id='module', ctx=Load()))]))], orelse=[]), Return(value=Tuple(elts=[Name(id='attr', ctx=Load()), Name(id='target', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='Notset', bases=[], keywords=[], body=[FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='<notset>'))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='notset', ctx=Store())], value=Call(func=Name(id='Notset', ctx=Load()), args=[], keywords=[])), ClassDef(name='MonkeyPatch', bases=[], keywords=[], body=[Expr(value=Constant(value='Helper to conveniently monkeypatch attributes/items/environment\n    variables/syspath.\n\n    Returned by the :fixture:`monkeypatch` fixture.\n\n    .. versionchanged:: 6.2\n        Can now also be used directly as `pytest.MonkeyPatch()`, for when\n        the fixture is not available. In this case, use\n        :meth:`with MonkeyPatch.context() as mp: <context>` or remember to call\n        :meth:`undo` explicitly.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_setattr', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='object', ctx=Load()), Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_setitem', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='Any', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), Name(id='object', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_cwd', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_savesyspath', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='context', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Context manager that returns a new :class:`MonkeyPatch` object\n        which undoes any patching done inside the ``with`` block upon exit.\n\n        Example:\n\n        .. code-block:: python\n\n            import functools\n\n\n            def test_partial(monkeypatch):\n                with monkeypatch.context() as m:\n                    m.setattr(functools, "partial", 3)\n\n        Useful in situations where it is desired to undo some patches before the test ends,\n        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n        of this see :issue:`3290`).\n        ')), Assign(targets=[Name(id='m', ctx=Store())], value=Call(func=Name(id='cls', ctx=Load()), args=[], keywords=[])), Try(body=[Expr(value=Yield(value=Name(id='m', ctx=Load())))], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='m', ctx=Load()), attr='undo', ctx=Load()), args=[], keywords=[]))])], decorator_list=[Name(id='classmethod', ctx=Load()), Name(id='contextmanager', ctx=Load())], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Constant(value='MonkeyPatch'), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), FunctionDef(name='setattr', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='target', annotation=Name(id='str', ctx=Load())), arg(arg='name', annotation=Name(id='object', ctx=Load())), arg(arg='value', annotation=Name(id='Notset', ctx=Load())), arg(arg='raising', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=Ellipsis), Constant(value=Ellipsis)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='setattr', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='target', annotation=Name(id='object', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='object', ctx=Load())), arg(arg='raising', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=Ellipsis)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='setattr', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='target', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='name', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='object', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='value', annotation=Name(id='object', ctx=Load())), arg(arg='raising', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='notset', ctx=Load()), Constant(value=True)]), body=[Expr(value=Constant(value='\n        Set attribute value on target, memorizing the old value.\n\n        For example:\n\n        .. code-block:: python\n\n            import os\n\n            monkeypatch.setattr(os, "getcwd", lambda: "/")\n\n        The code above replaces the :func:`os.getcwd` function by a ``lambda`` which\n        always returns ``"/"``.\n\n        For convenience, you can specify a string as ``target`` which\n        will be interpreted as a dotted import path, with the last part\n        being the attribute name:\n\n        .. code-block:: python\n\n            monkeypatch.setattr("os.getcwd", lambda: "/")\n\n        Raises :class:`AttributeError` if the attribute does not exist, unless\n        ``raising`` is set to False.\n\n        **Where to patch**\n\n        ``monkeypatch.setattr`` works by (temporarily) changing the object that a name points to with another one.\n        There can be many names pointing to any individual object, so for patching to work you must ensure\n        that you patch the name used by the system under test.\n\n        See the section :ref:`Where to patch <python:where-to-patch>` in the :mod:`unittest.mock`\n        docs for a complete explanation, which is meant for :func:`unittest.mock.patch` but\n        applies to ``monkeypatch.setattr`` as well.\n        ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Import(names=[alias(name='inspect')]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='Notset', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='use setattr(target, name, value) or setattr(target, value) with target being a dotted import string')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='value', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='target', ctx=Store())], ctx=Store())], value=Call(func=Name(id='derive_importpath', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='raising', ctx=Load())], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='use setattr(target, name, value) with name being a string or setattr(target, value) with target being a dotted import string')], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='oldval', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='name', ctx=Load()), Name(id='notset', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='raising', ctx=Load()), Compare(left=Name(id='oldval', ctx=Load()), ops=[Is()], comparators=[Name(id='notset', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='target', ctx=Load()), conversion=114), Constant(value=' has no attribute '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='isclass', ctx=Load()), args=[Name(id='target', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='oldval', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='target', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='notset', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_setattr', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='target', ctx=Load()), Name(id='name', ctx=Load()), Name(id='oldval', ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='delattr', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='target', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='object', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='name', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Notset', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='raising', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='notset', ctx=Load()), Constant(value=True)]), body=[Expr(value=Constant(value='Delete attribute ``name`` from ``target``.\n\n        If no ``name`` is specified and ``target`` is a string\n        it will be interpreted as a dotted import path with the\n        last part being the attribute name.\n\n        Raises AttributeError it the attribute does not exist, unless\n        ``raising`` is set to False.\n        ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Import(names=[alias(name='inspect')]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='Notset', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='use delattr(target, name) or delattr(target) with target being a dotted import string')], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='target', ctx=Store())], ctx=Store())], value=Call(func=Name(id='derive_importpath', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='raising', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])), body=[If(test=Name(id='raising', ctx=Load()), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='oldval', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='name', ctx=Load()), Name(id='notset', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='isclass', ctx=Load()), args=[Name(id='target', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='oldval', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='target', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='notset', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_setattr', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='target', ctx=Load()), Name(id='name', ctx=Load()), Name(id='oldval', ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='delattr', ctx=Load()), args=[Name(id='target', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='setitem', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dic', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='K', ctx=Load()), Name(id='V', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='name', annotation=Name(id='K', ctx=Load())), arg(arg='value', annotation=Name(id='V', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Set dictionary entry ``name`` to value.')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_setitem', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='dic', ctx=Load()), Name(id='name', ctx=Load()), Call(func=Attribute(value=Name(id='dic', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='notset', ctx=Load())], keywords=[])], ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='dic', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='delitem', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dic', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='K', ctx=Load()), Name(id='V', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='name', annotation=Name(id='K', ctx=Load())), arg(arg='raising', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value="Delete ``name`` from dict.\n\n        Raises ``KeyError`` if it doesn't exist, unless ``raising`` is set to\n        False.\n        ")), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='dic', ctx=Load())]), body=[If(test=Name(id='raising', ctx=Load()), body=[Raise(exc=Call(func=Name(id='KeyError', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_setitem', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='dic', ctx=Load()), Name(id='name', ctx=Load()), Call(func=Attribute(value=Name(id='dic', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='notset', ctx=Load())], keywords=[])], ctx=Load())], keywords=[])), Delete(targets=[Subscript(value=Name(id='dic', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Del())])])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='setenv', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='str', ctx=Load())), arg(arg='prepend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Set environment variable ``name`` to ``value``.\n\n        If ``prepend`` is a character, read the current environment variable\n        value and prepend the ``value`` adjoined with the ``prepend``\n        character.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Name(id='PytestWarning', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Value of environment variable {name} type should be str, but got {value!r} (type: {type}); converted to str implicitly'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load())), keyword(arg='type', value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()))])], keywords=[])], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='prepend', ctx=Load()), Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load())])]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='prepend', ctx=Load())), op=Add(), right=Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load())))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='setitem', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='delenv', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='raising', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Delete ``name`` from the environment.\n\n        Raises ``KeyError`` if it does not exist, unless ``raising`` is set to\n        False.\n        ')), AnnAssign(target=Name(id='environ', ctx=Store()), annotation=Subscript(value=Name(id='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), simple=1), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='delitem', ctx=Load()), args=[Name(id='environ', ctx=Load()), Name(id='name', ctx=Load())], keywords=[keyword(arg='raising', value=Name(id='raising', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='syspath_prepend', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Prepend ``path`` to ``sys.path`` list of import locations.')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_savesyspath', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_savesyspath', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), slice=Slice(), ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Constant(value='pkg_resources'), ops=[In()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load())]), body=[ImportFrom(module='pkg_resources', names=[alias(name='fixup_namespace_packages')], level=0), Expr(value=Call(func=Name(id='fixup_namespace_packages', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), ImportFrom(module='importlib', names=[alias(name='invalidate_caches')], level=0), Expr(value=Call(func=Name(id='invalidate_caches', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='chdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Change the current working directory to the specified path.\n\n        :param path:\n            The path to change into.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_cwd', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cwd', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='chdir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='undo', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Undo previous changes.\n\n        This call consumes the undo stack. Calling it a second time has no\n        effect unless you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        .. note::\n            The same `monkeypatch` fixture is used across a\n            single test function invocation. If `monkeypatch` is used both by\n            the test function itself and one of the test fixtures,\n            calling `undo()` will undo all of the changes made in\n            both functions.\n\n            Prefer to use :meth:`context() <pytest.MonkeyPatch.context>` instead.\n        ')), For(target=Tuple(elts=[Name(id='obj', ctx=Store()), Name(id='name', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_setattr', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Name(id='notset', ctx=Load())]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='delattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_setattr', ctx=Load()), slice=Slice(), ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='dictionary', ctx=Store()), Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_setitem', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Name(id='notset', ctx=Load())]), body=[Try(body=[Delete(targets=[Subscript(value=Name(id='dictionary', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Del())])], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[Assign(targets=[Subscript(value=Name(id='dictionary', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load()))])], orelse=[]), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_setitem', ctx=Load()), slice=Slice(), ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_savesyspath', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), slice=Slice(), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_savesyspath', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_savesyspath', ctx=Store())], value=Constant(value=None))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_cwd', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='chdir', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_cwd', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cwd', ctx=Store())], value=Constant(value=None))], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[Name(id='final', ctx=Load())])], type_ignores=[])