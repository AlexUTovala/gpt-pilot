Module(body=[Expr(value=Constant(value='(Disabled by default) support for testing pytest and pytest plugins.\n\nPYTEST_DONT_REWRITE\n')), Import(names=[alias(name='collections.abc')]), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='gc')]), Import(names=[alias(name='importlib')]), Import(names=[alias(name='locale')]), Import(names=[alias(name='os')]), Import(names=[alias(name='platform')]), Import(names=[alias(name='re')]), Import(names=[alias(name='shutil')]), Import(names=[alias(name='subprocess')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='traceback')]), ImportFrom(module='fnmatch', names=[alias(name='fnmatch')], level=0), ImportFrom(module='io', names=[alias(name='StringIO')], level=0), ImportFrom(module='pathlib', names=[alias(name='Path')], level=0), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='Generator')], level=0), ImportFrom(module='typing', names=[alias(name='IO')], level=0), ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='overload')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='TextIO')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='Type')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), ImportFrom(module='weakref', names=[alias(name='WeakKeyDictionary')], level=0), ImportFrom(module='iniconfig', names=[alias(name='IniConfig')], level=0), ImportFrom(module='iniconfig', names=[alias(name='SectionWrapper')], level=0), ImportFrom(module='_pytest', names=[alias(name='timing')], level=0), ImportFrom(module='_pytest._code', names=[alias(name='Source')], level=0), ImportFrom(module='_pytest.capture', names=[alias(name='_get_multicapture')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='final')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='NOTSET')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='NotSetType')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='_PluggyPlugin')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='Config')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='ExitCode')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='hookimpl')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='main')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='PytestPluginManager')], level=0), ImportFrom(module='_pytest.config.argparsing', names=[alias(name='Parser')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='check_ispytest')], level=0), ImportFrom(module='_pytest.fixtures', names=[alias(name='fixture')], level=0), ImportFrom(module='_pytest.fixtures', names=[alias(name='FixtureRequest')], level=0), ImportFrom(module='_pytest.main', names=[alias(name='Session')], level=0), ImportFrom(module='_pytest.monkeypatch', names=[alias(name='MonkeyPatch')], level=0), ImportFrom(module='_pytest.nodes', names=[alias(name='Collector')], level=0), ImportFrom(module='_pytest.nodes', names=[alias(name='Item')], level=0), ImportFrom(module='_pytest.outcomes', names=[alias(name='fail')], level=0), ImportFrom(module='_pytest.outcomes', names=[alias(name='importorskip')], level=0), ImportFrom(module='_pytest.outcomes', names=[alias(name='skip')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='bestrelpath')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='copytree')], level=0), ImportFrom(module='_pytest.pathlib', names=[alias(name='make_numbered_dir')], level=0), ImportFrom(module='_pytest.reports', names=[alias(name='CollectReport')], level=0), ImportFrom(module='_pytest.reports', names=[alias(name='TestReport')], level=0), ImportFrom(module='_pytest.tmpdir', names=[alias(name='TempPathFactory')], level=0), ImportFrom(module='_pytest.warning_types', names=[alias(name='PytestWarning')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='typing_extensions', names=[alias(name='Final')], level=0), ImportFrom(module='typing_extensions', names=[alias(name='Literal')], level=0), Import(names=[alias(name='pexpect')])], orelse=[]), Assign(targets=[Name(id='pytest_plugins', ctx=Store())], value=List(elts=[Constant(value='pytester_assertions')], ctx=Load())), Assign(targets=[Name(id='IGNORE_PAM', ctx=Store())], value=List(elts=[Constant(value='/var/lib/sss/mc/passwd')], ctx=Load())), FunctionDef(name='pytest_addoption', args=arguments(posonlyargs=[], args=[arg(arg='parser', annotation=Name(id='Parser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='addoption', ctx=Load()), args=[Constant(value='--lsof')], keywords=[keyword(arg='action', value=Constant(value='store_true')), keyword(arg='dest', value=Constant(value='lsof')), keyword(arg='default', value=Constant(value=False)), keyword(arg='help', value=Constant(value='Run FD checks if lsof is available'))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='addoption', ctx=Load()), args=[Constant(value='--runpytest')], keywords=[keyword(arg='default', value=Constant(value='inprocess')), keyword(arg='dest', value=Constant(value='runpytest')), keyword(arg='choices', value=Tuple(elts=[Constant(value='inprocess'), Constant(value='subprocess')], ctx=Load())), keyword(arg='help', value=Constant(value="Run pytest sub runs in tests using an 'inprocess' or 'subprocess' (python -m main) method"))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='addini', ctx=Load()), args=[Constant(value='pytester_example_dir')], keywords=[keyword(arg='help', value=Constant(value='Directory to take the pytester example files from'))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='pytest_configure', args=arguments(posonlyargs=[], args=[arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='getvalue', ctx=Load()), args=[Constant(value='lsof')], keywords=[]), body=[Assign(targets=[Name(id='checker', ctx=Store())], value=Call(func=Name(id='LsofFdLeakChecker', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Attribute(value=Name(id='checker', ctx=Load()), attr='matching_platform', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='pluginmanager', ctx=Load()), attr='register', ctx=Load()), args=[Name(id='checker', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='addinivalue_line', ctx=Load()), args=[Constant(value='markers'), Constant(value='pytester_example_path(*path_segments): join the given path segments to `pytester_example_dir` for this test.')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), ClassDef(name='LsofFdLeakChecker', bases=[], keywords=[], body=[FunctionDef(name='get_open_files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='out', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='subprocess', ctx=Load()), attr='run', ctx=Load()), args=[Tuple(elts=[Constant(value='lsof'), Constant(value='-Ffn0'), Constant(value='-p'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getpid', ctx=Load()), args=[], keywords=[])], keywords=[])], ctx=Load())], keywords=[keyword(arg='stdout', value=Attribute(value=Name(id='subprocess', ctx=Load()), attr='PIPE', ctx=Load())), keyword(arg='stderr', value=Attribute(value=Name(id='subprocess', ctx=Load()), attr='DEVNULL', ctx=Load())), keyword(arg='check', value=Constant(value=True)), keyword(arg='text', value=Constant(value=True)), keyword(arg='encoding', value=Call(func=Attribute(value=Name(id='locale', ctx=Load()), attr='getpreferredencoding', ctx=Load()), args=[Constant(value=False)], keywords=[]))]), attr='stdout', ctx=Load())), FunctionDef(name='isopen', args=arguments(posonlyargs=[], args=[arg(arg='line', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='f')], keywords=[]), BoolOp(op=And(), values=[Compare(left=Constant(value='deleted'), ops=[NotIn()], comparators=[Name(id='line', ctx=Load())]), Compare(left=Constant(value='mem'), ops=[NotIn()], comparators=[Name(id='line', ctx=Load())]), Compare(left=Constant(value='txt'), ops=[NotIn()], comparators=[Name(id='line', ctx=Load())]), Compare(left=Constant(value='cwd'), ops=[NotIn()], comparators=[Name(id='line', ctx=Load())])])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), Assign(targets=[Name(id='open_files', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[]), body=[If(test=Call(func=Name(id='isopen', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='fields', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\x00')], keywords=[])), Assign(targets=[Name(id='fd', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='fields', ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())), Assign(targets=[Name(id='filename', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='fields', ctx=Load()), slice=Constant(value=1), ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())), If(test=Compare(left=Name(id='filename', ctx=Load()), ops=[In()], comparators=[Name(id='IGNORE_PAM', ctx=Load())]), body=[Continue()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='filename', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='/')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='open_files', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='fd', ctx=Load()), Name(id='filename', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='open_files', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='matching_platform', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='subprocess', ctx=Load()), attr='run', ctx=Load()), args=[Tuple(elts=[Constant(value='lsof'), Constant(value='-v')], ctx=Load())], keywords=[keyword(arg='check', value=Constant(value=True))]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='OSError', ctx=Load()), Attribute(value=Name(id='subprocess', ctx=Load()), attr='CalledProcessError', ctx=Load())], ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[Return(value=Constant(value=True))], finalbody=[])], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='pytest_runtest_protocol', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item', annotation=Name(id='Item', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='lines1', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_open_files', ctx=Load()), args=[], keywords=[])), Expr(value=Yield()), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='sys', ctx=Load()), Constant(value='pypy_version_info')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='gc', ctx=Load()), attr='collect', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='lines2', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_open_files', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='new_fds', ctx=Store())], value=BinOp(left=SetComp(elt=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Name(id='lines2', ctx=Load()), ifs=[], is_async=0)]), op=Sub(), right=SetComp(elt=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Name(id='lines1', ctx=Load()), ifs=[], is_async=0)]))), Assign(targets=[Name(id='leaked_files', ctx=Store())], value=ListComp(elt=Name(id='t', ctx=Load()), generators=[comprehension(target=Name(id='t', ctx=Store()), iter=Name(id='lines2', ctx=Load()), ifs=[Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[In()], comparators=[Name(id='new_fds', ctx=Load())])], is_async=0)])), If(test=Name(id='leaked_files', ctx=Load()), body=[Assign(targets=[Name(id='error', ctx=Store())], value=List(elts=[BinOp(left=Constant(value='***** %s FD leakage detected'), op=Mod(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='leaked_files', ctx=Load())], keywords=[])), Starred(value=GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Name(id='leaked_files', ctx=Load()), ifs=[], is_async=0)]), ctx=Load()), Constant(value='*** Before:'), Starred(value=GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Name(id='lines1', ctx=Load()), ifs=[], is_async=0)]), ctx=Load()), Constant(value='*** After:'), Starred(value=GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Name(id='lines2', ctx=Load()), ifs=[], is_async=0)]), ctx=Load()), BinOp(left=Constant(value='***** %s FD leakage detected'), op=Mod(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='leaked_files', ctx=Load())], keywords=[])), BinOp(left=Constant(value='*** function %s:%s: %s '), op=Mod(), right=Attribute(value=Name(id='item', ctx=Load()), attr='location', ctx=Load())), Constant(value='See issue #2366')], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='item', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Name(id='PytestWarning', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='error', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[])], decorator_list=[Call(func=Name(id='hookimpl', ctx=Load()), args=[], keywords=[keyword(arg='hookwrapper', value=Constant(value=True)), keyword(arg='tryfirst', value=Constant(value=True))])], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Constant(value=None), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='_pytest', args=arguments(posonlyargs=[], args=[arg(arg='request', annotation=Name(id='FixtureRequest', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a helper which offers a gethookrecorder(hook) method which\n    returns a HookRecorder instance which helps to make assertions about called\n    hooks.')), Return(value=Call(func=Name(id='PytestArg', ctx=Load()), args=[Name(id='request', ctx=Load())], keywords=[]))], decorator_list=[Name(id='fixture', ctx=Load())], returns=Constant(value='PytestArg')), ClassDef(name='PytestArg', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='request', annotation=Name(id='FixtureRequest', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Store())], value=Name(id='request', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='gethookrecorder', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='hook')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='hookrecorder', ctx=Store())], value=Call(func=Name(id='HookRecorder', ctx=Load()), args=[Attribute(value=Name(id='hook', ctx=Load()), attr='_pm', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='addfinalizer', ctx=Load()), args=[Attribute(value=Name(id='hookrecorder', ctx=Load()), attr='finish_recording', ctx=Load())], keywords=[])), Return(value=Name(id='hookrecorder', ctx=Load()))], decorator_list=[], returns=Constant(value='HookRecorder'))], decorator_list=[]), FunctionDef(name='get_public_names', args=arguments(posonlyargs=[], args=[arg(arg='values', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Only return names from iterator values without a leading underscore.')), Return(value=ListComp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='values', ctx=Load()), ifs=[Compare(left=Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[NotEq()], comparators=[Constant(value='_')])], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), ClassDef(name='RecordedHookCall', bases=[], keywords=[], body=[Expr(value=Constant(value='A recorded call to a hook.\n\n    The arguments to the hook call are set as attributes.\n    For example:\n\n    .. code-block:: python\n\n        calls = hook_recorder.getcalls("pytest_runtest_setup")\n        # Suppose pytest_runtest_setup was called once with `item=an_item`.\n        assert calls[0].item is an_item\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='kwargs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Store())], value=Name(id='name', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='d', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Delete(targets=[Subscript(value=Name(id='d', ctx=Load()), slice=Constant(value='_name'), ctx=Del())]), Return(value=JoinedStr(values=[Constant(value='<RecordedHookCall '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), conversion=114), Constant(value='(**'), FormattedValue(value=Name(id='d', ctx=Load()), conversion=114), Constant(value=')>')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[])], orelse=[])], decorator_list=[Name(id='final', ctx=Load())]), ClassDef(name='HookRecorder', bases=[], keywords=[], body=[Expr(value=Constant(value='Record all hooks called in a plugin manager.\n\n    Hook recorders are created by :class:`Pytester`.\n\n    This wraps all the hook calls in the plugin manager, recording each call\n    before propagating the normal calls.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pluginmanager', annotation=Name(id='PytestPluginManager', ctx=Load()))], kwonlyargs=[arg(arg='_ispytest', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[]), body=[Expr(value=Call(func=Name(id='check_ispytest', ctx=Load()), args=[Name(id='_ispytest', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_pluginmanager', ctx=Store())], value=Name(id='pluginmanager', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='calls', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='RecordedHookCall', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='ret', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='ExitCode', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), FunctionDef(name='before', args=arguments(posonlyargs=[], args=[arg(arg='hook_name', annotation=Name(id='str', ctx=Load())), arg(arg='hook_impls'), arg(arg='kwargs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='calls', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='RecordedHookCall', ctx=Load()), args=[Name(id='hook_name', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='after', args=arguments(posonlyargs=[], args=[arg(arg='outcome'), arg(arg='hook_name', annotation=Name(id='str', ctx=Load())), arg(arg='hook_impls'), arg(arg='kwargs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[], returns=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_undo_wrapping', ctx=Store())], value=Call(func=Attribute(value=Name(id='pluginmanager', ctx=Load()), attr='add_hookcall_monitoring', ctx=Load()), args=[Name(id='before', ctx=Load()), Name(id='after', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='finish_recording', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_undo_wrapping', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='getcalls', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='names', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get all recorded calls to hooks with the given names (or name).')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='names', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='names', ctx=Store())], value=Call(func=Attribute(value=Name(id='names', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=ListComp(elt=Name(id='call', ctx=Load()), generators=[comprehension(target=Name(id='call', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='calls', ctx=Load()), ifs=[Compare(left=Attribute(value=Name(id='call', ctx=Load()), attr='_name', ctx=Load()), ops=[In()], comparators=[Name(id='names', ctx=Load())])], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='RecordedHookCall', ctx=Load()), ctx=Load())), FunctionDef(name='assert_contains', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='entries', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='i', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='entries', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='entries', ctx=Load())], keywords=[])), Assign(targets=[Name(id='backlocals', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='f_locals', ctx=Load())), While(test=Name(id='entries', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='check', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='entries', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value=0)], keywords=[])), For(target=Tuple(elts=[Name(id='ind', ctx=Store()), Name(id='call', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='calls', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]), body=[If(test=Compare(left=Attribute(value=Name(id='call', ctx=Load()), attr='_name', ctx=Load()), ops=[Eq()], comparators=[Name(id='name', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='NAMEMATCH'), Name(id='name', ctx=Load()), Name(id='call', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='eval', ctx=Load()), args=[Name(id='check', ctx=Load()), Name(id='backlocals', ctx=Load()), Attribute(value=Name(id='call', ctx=Load()), attr='__dict__', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='CHECKERMATCH'), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='check', ctx=Load())], keywords=[]), Constant(value='->'), Name(id='call', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='NOCHECKERMATCH'), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='check', ctx=Load())], keywords=[]), Constant(value='-'), Name(id='call', ctx=Load())], keywords=[])), Continue()]), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=BinOp(left=Name(id='ind', ctx=Load()), op=Add(), right=Constant(value=1))), Break()], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='NONAMEMATCH'), Name(id='name', ctx=Load()), Constant(value='with'), Name(id='call', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[JoinedStr(values=[Constant(value='could not find '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=114), Constant(value=' check '), FormattedValue(value=Name(id='check', ctx=Load()), conversion=114)])], keywords=[]))])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='popcall', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='call', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='calls', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Attribute(value=Name(id='call', ctx=Load()), attr='_name', ctx=Load()), ops=[Eq()], comparators=[Name(id='name', ctx=Load())]), body=[Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='calls', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Del())]), Return(value=Name(id='call', ctx=Load()))], orelse=[])], orelse=[]), Assign(targets=[Name(id='lines', ctx=Store())], value=List(elts=[JoinedStr(values=[Constant(value='could not find call '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=114), Constant(value=', in:')])], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='extend', ctx=Load()), args=[ListComp(elt=BinOp(left=Constant(value='  %s'), op=Mod(), right=Name(id='x', ctx=Load())), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='calls', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='RecordedHookCall', ctx=Load())), FunctionDef(name='getcall', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getcalls', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), msg=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='values', ctx=Load())], ctx=Load())), Return(value=Subscript(value=Name(id='values', ctx=Load()), slice=Constant(value=0), ctx=Load()))], decorator_list=[], returns=Name(id='RecordedHookCall', ctx=Load())), FunctionDef(name='getreports', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='names', annotation=Constant(value="Literal['pytest_collectreport']"))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='CollectReport', ctx=Load()), ctx=Load())), FunctionDef(name='getreports', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='names', annotation=Constant(value="Literal['pytest_runtest_logreport']"))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='TestReport', ctx=Load()), ctx=Load())), FunctionDef(name='getreports', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='names', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[Constant(value='pytest_collectreport'), Constant(value='pytest_runtest_logreport')], ctx=Load())]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='CollectReport', ctx=Load()), Name(id='TestReport', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='getreports', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='names', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[Constant(value='pytest_collectreport'), Constant(value='pytest_runtest_logreport')], ctx=Load())]), body=[Return(value=ListComp(elt=Attribute(value=Name(id='x', ctx=Load()), attr='report', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getcalls', ctx=Load()), args=[Name(id='names', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='CollectReport', ctx=Load()), Name(id='TestReport', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='matchreport', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inamepart', annotation=Name(id='str', ctx=Load())), arg(arg='names', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='when', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Tuple(elts=[Constant(value='pytest_runtest_logreport'), Constant(value='pytest_collectreport')], ctx=Load()), Constant(value=None)]), body=[Expr(value=Constant(value='Return a testreport whose dotted import path matches.')), Assign(targets=[Name(id='values', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='rep', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getreports', ctx=Load()), args=[], keywords=[keyword(arg='names', value=Name(id='names', ctx=Load()))]), body=[If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='when', ctx=Load())), Compare(left=Attribute(value=Name(id='rep', ctx=Load()), attr='when', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='call')]), Attribute(value=Name(id='rep', ctx=Load()), attr='passed', ctx=Load())]), body=[Continue()], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='when', ctx=Load()), Compare(left=Attribute(value=Name(id='rep', ctx=Load()), attr='when', ctx=Load()), ops=[NotEq()], comparators=[Name(id='when', ctx=Load())])]), body=[Continue()], orelse=[]), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='inamepart', ctx=Load())), Compare(left=Name(id='inamepart', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Attribute(value=Name(id='rep', ctx=Load()), attr='nodeid', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='::')], keywords=[])])]), body=[Expr(value=Call(func=Attribute(value=Name(id='values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='rep', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='values', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='could not find test report matching %r: no test reports at all!'), op=Mod(), right=Tuple(elts=[Name(id='inamepart', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='found 2 or more testreports matching {!r}: {}'), attr='format', ctx=Load()), args=[Name(id='inamepart', ctx=Load()), Name(id='values', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Subscript(value=Name(id='values', ctx=Load()), slice=Constant(value=0), ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='CollectReport', ctx=Load()), Name(id='TestReport', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='getfailures', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='names', annotation=Constant(value="Literal['pytest_collectreport']"))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='CollectReport', ctx=Load()), ctx=Load())), FunctionDef(name='getfailures', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='names', annotation=Constant(value="Literal['pytest_runtest_logreport']"))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='TestReport', ctx=Load()), ctx=Load())), FunctionDef(name='getfailures', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='names', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[Constant(value='pytest_collectreport'), Constant(value='pytest_runtest_logreport')], ctx=Load())]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='CollectReport', ctx=Load()), Name(id='TestReport', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='getfailures', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='names', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Tuple(elts=[Constant(value='pytest_collectreport'), Constant(value='pytest_runtest_logreport')], ctx=Load())]), body=[Return(value=ListComp(elt=Name(id='rep', ctx=Load()), generators=[comprehension(target=Name(id='rep', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getreports', ctx=Load()), args=[Name(id='names', ctx=Load())], keywords=[]), ifs=[Attribute(value=Name(id='rep', ctx=Load()), attr='failed', ctx=Load())], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='CollectReport', ctx=Load()), Name(id='TestReport', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='getfailedcollections', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getfailures', ctx=Load()), args=[Constant(value='pytest_collectreport')], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='CollectReport', ctx=Load()), ctx=Load())), FunctionDef(name='listoutcomes', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='passed', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='skipped', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='failed', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='rep', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getreports', ctx=Load()), args=[Tuple(elts=[Constant(value='pytest_collectreport'), Constant(value='pytest_runtest_logreport')], ctx=Load())], keywords=[]), body=[If(test=Attribute(value=Name(id='rep', ctx=Load()), attr='passed', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='rep', ctx=Load()), attr='when', ctx=Load()), ops=[Eq()], comparators=[Constant(value='call')]), body=[Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='rep', ctx=Load()), Name(id='TestReport', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='passed', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='rep', ctx=Load())], keywords=[]))], orelse=[])], orelse=[If(test=Attribute(value=Name(id='rep', ctx=Load()), attr='skipped', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='skipped', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='rep', ctx=Load())], keywords=[]))], orelse=[Assert(test=Attribute(value=Name(id='rep', ctx=Load()), attr='failed', ctx=Load()), msg=JoinedStr(values=[Constant(value='Unexpected outcome: '), FormattedValue(value=Name(id='rep', ctx=Load()), conversion=114)])), Expr(value=Call(func=Attribute(value=Name(id='failed', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='rep', ctx=Load())], keywords=[]))])])], orelse=[]), Return(value=Tuple(elts=[Name(id='passed', ctx=Load()), Name(id='skipped', ctx=Load()), Name(id='failed', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='TestReport', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='CollectReport', ctx=Load()), Name(id='TestReport', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='CollectReport', ctx=Load()), Name(id='TestReport', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='countoutcomes', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=ListComp(elt=Call(func=Name(id='len', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='listoutcomes', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='assertoutcome', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='passed', annotation=Name(id='int', ctx=Load())), arg(arg='skipped', annotation=Name(id='int', ctx=Load())), arg(arg='failed', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=0), Constant(value=0)]), body=[Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), ImportFrom(module='_pytest.pytester_assertions', names=[alias(name='assertoutcome')], level=0), Assign(targets=[Name(id='outcomes', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='listoutcomes', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='assertoutcome', ctx=Load()), args=[Name(id='outcomes', ctx=Load())], keywords=[keyword(arg='passed', value=Name(id='passed', ctx=Load())), keyword(arg='skipped', value=Name(id='skipped', ctx=Load())), keyword(arg='failed', value=Name(id='failed', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='clear', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='calls', ctx=Load()), slice=Slice(), ctx=Store())], value=List(elts=[], ctx=Load()))], decorator_list=[], returns=Constant(value=None))], decorator_list=[Name(id='final', ctx=Load())]), FunctionDef(name='linecomp', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='A :class: `LineComp` instance for checking that an input linearly\n    contains a sequence of strings.')), Return(value=Call(func=Name(id='LineComp', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='fixture', ctx=Load())], returns=Constant(value='LineComp')), FunctionDef(name='LineMatcher_fixture', args=arguments(posonlyargs=[], args=[arg(arg='request', annotation=Name(id='FixtureRequest', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='A reference to the :class: `LineMatcher`.\n\n    This is instantiable with a list of lines (without their trailing newlines).\n    This is useful for testing large texts, such as the output of commands.\n    ')), Return(value=Name(id='LineMatcher', ctx=Load()))], decorator_list=[Call(func=Name(id='fixture', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Constant(value='LineMatcher'))])], returns=Subscript(value=Name(id='Type', ctx=Load()), slice=Constant(value='LineMatcher'), ctx=Load())), FunctionDef(name='pytester', args=arguments(posonlyargs=[], args=[arg(arg='request', annotation=Name(id='FixtureRequest', ctx=Load())), arg(arg='tmp_path_factory', annotation=Name(id='TempPathFactory', ctx=Load())), arg(arg='monkeypatch', annotation=Name(id='MonkeyPatch', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Facilities to write tests/configuration files, execute pytest in isolation, and match\n    against expected output, perfect for black-box testing of pytest plugins.\n\n    It attempts to isolate the test run from external factors as much as possible, modifying\n    the current working directory to ``path`` and environment variables during initialization.\n\n    It is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`\n    fixture but provides methods which aid in testing pytest itself.\n    ')), Return(value=Call(func=Name(id='Pytester', ctx=Load()), args=[Name(id='request', ctx=Load()), Name(id='tmp_path_factory', ctx=Load()), Name(id='monkeypatch', ctx=Load())], keywords=[keyword(arg='_ispytest', value=Constant(value=True))]))], decorator_list=[Name(id='fixture', ctx=Load())], returns=Constant(value='Pytester')), FunctionDef(name='_sys_snapshot', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='snappaths', ctx=Store())], value=Call(func=Name(id='SysPathsSnapshot', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='snapmods', ctx=Store())], value=Call(func=Name(id='SysModulesSnapshot', ctx=Load()), args=[], keywords=[])), Expr(value=Yield()), Expr(value=Call(func=Attribute(value=Name(id='snapmods', ctx=Load()), attr='restore', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='snappaths', ctx=Load()), attr='restore', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='fixture', ctx=Load())], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Constant(value=None), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), FunctionDef(name='_config_for_test', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='_pytest.config', names=[alias(name='get_config')], level=0), Assign(targets=[Name(id='config', ctx=Store())], value=Call(func=Name(id='get_config', ctx=Load()), args=[], keywords=[])), Expr(value=Yield(value=Name(id='config', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='_ensure_unconfigure', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='fixture', ctx=Load())], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Name(id='Config', ctx=Load()), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='rex_session_duration', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\\d+\\.\\d\\ds')], keywords=[])), Assign(targets=[Name(id='rex_outcome', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='(\\d+) (\\w+)')], keywords=[])), ClassDef(name='RunResult', bases=[], keywords=[], body=[Expr(value=Constant(value='The result of running a command from :class:`~pytest.Pytester`.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ret', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='ExitCode', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='outlines', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='errlines', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='duration', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='ret', ctx=Store()), annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='ExitCode', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='ExitCode', ctx=Load()), args=[Name(id='ret', ctx=Load())], keywords=[]), simple=0), Expr(value=Constant(value='The return value.'))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ret', ctx=Store())], value=Name(id='ret', ctx=Load()))])], orelse=[], finalbody=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='outlines', ctx=Store())], value=Name(id='outlines', ctx=Load())), Expr(value=Constant(value='List of lines captured from stdout.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errlines', ctx=Store())], value=Name(id='errlines', ctx=Load())), Expr(value=Constant(value='List of lines captured from stderr.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stdout', ctx=Store())], value=Call(func=Name(id='LineMatcher', ctx=Load()), args=[Name(id='outlines', ctx=Load())], keywords=[])), Expr(value=Constant(value=':class:`~pytest.LineMatcher` of stdout.\n\n        Use e.g. :func:`str(stdout) <pytest.LineMatcher.__str__()>` to reconstruct stdout, or the commonly used\n        :func:`stdout.fnmatch_lines() <pytest.LineMatcher.fnmatch_lines()>` method.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stderr', ctx=Store())], value=Call(func=Name(id='LineMatcher', ctx=Load()), args=[Name(id='errlines', ctx=Load())], keywords=[])), Expr(value=Constant(value=':class:`~pytest.LineMatcher` of stderr.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='duration', ctx=Store())], value=Name(id='duration', ctx=Load())), Expr(value=Constant(value='Duration in seconds.'))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='<RunResult ret=%s len(stdout.lines)=%d len(stderr.lines)=%d duration=%.2fs>'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='ret', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stdout', ctx=Load()), attr='lines', ctx=Load())], keywords=[]), Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stderr', ctx=Load()), attr='lines', ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='duration', ctx=Load())], ctx=Load())))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='parseoutcomes', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a dictionary of outcome noun -> count from parsing the terminal\n        output that the test process produced.\n\n        The returned nouns will always be in plural form::\n\n            ======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====\n\n        Will return ``{"failed": 1, "passed": 1, "warnings": 1, "errors": 1}``.\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parse_summary_nouns', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='outlines', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='parse_summary_nouns', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='lines')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Extract the nouns from a pytest terminal summary line.\n\n        It always returns the plural noun for consistency::\n\n            ======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====\n\n        Will return ``{"failed": 1, "passed": 1, "warnings": 1, "errors": 1}``.\n        ')), For(target=Name(id='line', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='rex_session_duration', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='outcomes', ctx=Store())], value=Call(func=Attribute(value=Name(id='rex_outcome', ctx=Load()), attr='findall', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ret', ctx=Store())], value=DictComp(key=Name(id='noun', ctx=Load()), value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='count', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='count', ctx=Store()), Name(id='noun', ctx=Store())], ctx=Store()), iter=Name(id='outcomes', ctx=Load()), ifs=[], is_async=0)])), Break()], orelse=[])], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Pytest terminal summary report not found')], keywords=[]))]), Assign(targets=[Name(id='to_plural', ctx=Store())], value=Dict(keys=[Constant(value='warning'), Constant(value='error')], values=[Constant(value='warnings'), Constant(value='errors')])), Return(value=DictComp(key=Call(func=Attribute(value=Name(id='to_plural', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='k', ctx=Load()), Name(id='k', ctx=Load())], keywords=[]), value=Name(id='v', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='assert_outcomes', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='passed', annotation=Name(id='int', ctx=Load())), arg(arg='skipped', annotation=Name(id='int', ctx=Load())), arg(arg='failed', annotation=Name(id='int', ctx=Load())), arg(arg='errors', annotation=Name(id='int', ctx=Load())), arg(arg='xpassed', annotation=Name(id='int', ctx=Load())), arg(arg='xfailed', annotation=Name(id='int', ctx=Load())), arg(arg='warnings', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='deselected', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=0), Constant(value=0), Constant(value=0), Constant(value=0), Constant(value=0), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="\n        Assert that the specified outcomes appear with the respective\n        numbers (0 means it didn't occur) in the text output from a test run.\n\n        ``warnings`` and ``deselected`` are only checked if not None.\n        ")), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), ImportFrom(module='_pytest.pytester_assertions', names=[alias(name='assert_outcomes')], level=0), Assign(targets=[Name(id='outcomes', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parseoutcomes', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='assert_outcomes', ctx=Load()), args=[Name(id='outcomes', ctx=Load())], keywords=[keyword(arg='passed', value=Name(id='passed', ctx=Load())), keyword(arg='skipped', value=Name(id='skipped', ctx=Load())), keyword(arg='failed', value=Name(id='failed', ctx=Load())), keyword(arg='errors', value=Name(id='errors', ctx=Load())), keyword(arg='xpassed', value=Name(id='xpassed', ctx=Load())), keyword(arg='xfailed', value=Name(id='xfailed', ctx=Load())), keyword(arg='warnings', value=Name(id='warnings', ctx=Load())), keyword(arg='deselected', value=Name(id='deselected', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[Name(id='final', ctx=Load())]), ClassDef(name='CwdSnapshot', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__saved', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='restore', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='chdir', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__saved', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='SysModulesSnapshot', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='preserve', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__preserve', ctx=Store())], value=Name(id='preserve', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__saved', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='restore', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='__preserve', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__saved', ctx=Load()), attr='update', ctx=Load()), args=[GeneratorExp(elt=Tuple(elts=[Name(id='k', ctx=Load()), Name(id='m', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='m', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__preserve', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], is_async=0)])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), attr='update', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__saved', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='SysPathsSnapshot', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__saved', ctx=Store())], value=Tuple(elts=[Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load())], keywords=[]), Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='sys', ctx=Load()), attr='meta_path', ctx=Load())], keywords=[])], ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='restore', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), slice=Slice(), ctx=Store()), Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='meta_path', ctx=Load()), slice=Slice(), ctx=Store())], ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='__saved', ctx=Load()))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='Pytester', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Facilities to write tests/configuration files, execute pytest in isolation, and match\n    against expected output, perfect for black-box testing of pytest plugins.\n\n    It attempts to isolate the test run from external factors as much as possible, modifying\n    the current working directory to :attr:`path` and environment variables during initialization.\n    ')), Assign(targets=[Name(id='__test__', ctx=Store())], value=Constant(value=False)), AnnAssign(target=Name(id='CLOSE_STDIN', ctx=Store()), annotation=Constant(value='Final'), value=Name(id='NOTSET', ctx=Load()), simple=1), ClassDef(name='TimeoutExpired', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Pass()], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='request', annotation=Name(id='FixtureRequest', ctx=Load())), arg(arg='tmp_path_factory', annotation=Name(id='TempPathFactory', ctx=Load())), arg(arg='monkeypatch', annotation=Name(id='MonkeyPatch', ctx=Load()))], kwonlyargs=[arg(arg='_ispytest', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[]), body=[Expr(value=Call(func=Name(id='check_ispytest', ctx=Load()), args=[Name(id='_ispytest', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Store())], value=Name(id='request', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_mod_collections', ctx=Store()), annotation=Subscript(value=Name(id='WeakKeyDictionary', ctx=Load()), slice=Tuple(elts=[Name(id='Collector', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Item', ctx=Load()), Name(id='Collector', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='WeakKeyDictionary', ctx=Load()), args=[], keywords=[]), simple=0), If(test=Attribute(value=Name(id='request', ctx=Load()), attr='function', ctx=Load()), body=[AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Attribute(value=Attribute(value=Name(id='request', ctx=Load()), attr='function', ctx=Load()), attr='__name__', ctx=Load()), simple=1)], orelse=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='request', ctx=Load()), attr='node', ctx=Load()), attr='name', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Store())], value=Name(id='name', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_path', ctx=Store()), annotation=Name(id='Path', ctx=Load()), value=Call(func=Attribute(value=Name(id='tmp_path_factory', ctx=Load()), attr='mktemp', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[keyword(arg='numbered', value=Constant(value=True))]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='plugins', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='_PluggyPlugin', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cwd_snapshot', ctx=Store())], value=Call(func=Name(id='CwdSnapshot', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sys_path_snapshot', ctx=Store())], value=Call(func=Name(id='SysPathsSnapshot', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sys_modules_snapshot', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__take_sys_modules_snapshot', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='chdir', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='addfinalizer', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_finalize', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_method', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='config', ctx=Load()), attr='getoption', ctx=Load()), args=[Constant(value='--runpytest')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_test_tmproot', ctx=Store())], value=Call(func=Attribute(value=Name(id='tmp_path_factory', ctx=Load()), attr='mktemp', ctx=Load()), args=[JoinedStr(values=[Constant(value='tmp-'), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1)])], keywords=[keyword(arg='numbered', value=Constant(value=True))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_monkeypatch', ctx=Store()), Name(id='mp', ctx=Store())], value=Name(id='monkeypatch', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='mp', ctx=Load()), attr='setenv', ctx=Load()), args=[Constant(value='PYTEST_DEBUG_TEMPROOT'), Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_test_tmproot', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='mp', ctx=Load()), attr='delenv', ctx=Load()), args=[Constant(value='TOX_ENV_DIR')], keywords=[keyword(arg='raising', value=Constant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='mp', ctx=Load()), attr='delenv', ctx=Load()), args=[Constant(value='PYTEST_ADDOPTS')], keywords=[keyword(arg='raising', value=Constant(value=False))])), Assign(targets=[Name(id='tmphome', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='mp', ctx=Load()), attr='setenv', ctx=Load()), args=[Constant(value='HOME'), Name(id='tmphome', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='mp', ctx=Load()), attr='setenv', ctx=Load()), args=[Constant(value='USERPROFILE'), Name(id='tmphome', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='mp', ctx=Load()), attr='setenv', ctx=Load()), args=[Constant(value='PY_COLORS'), Constant(value='0')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='path', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Temporary directory path used to create files/run tests from, etc.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_path', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Path', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<Pytester '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), conversion=114), Constant(value='>')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_finalize', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Clean up global state artifacts.\n\n        Some methods modify the global interpreter state and this tries to\n        clean this up. It does not remove the temporary directory however so\n        it can be looked at after the test run has finished.\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sys_modules_snapshot', ctx=Load()), attr='restore', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sys_path_snapshot', ctx=Load()), attr='restore', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cwd_snapshot', ctx=Load()), attr='restore', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__take_sys_modules_snapshot', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='preserve_module', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='startswith', ctx=Load()), args=[Tuple(elts=[Constant(value='zope'), Constant(value='readline')], ctx=Load())], keywords=[]))], decorator_list=[]), Return(value=Call(func=Name(id='SysModulesSnapshot', ctx=Load()), args=[], keywords=[keyword(arg='preserve', value=Name(id='preserve_module', ctx=Load()))]))], decorator_list=[], returns=Name(id='SysModulesSnapshot', ctx=Load())), FunctionDef(name='make_hook_recorder', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pluginmanager', annotation=Name(id='PytestPluginManager', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a new :class:`HookRecorder` for a :class:`PytestPluginManager`.')), Assign(targets=[Attribute(value=Name(id='pluginmanager', ctx=Load()), attr='reprec', ctx=Store()), Name(id='reprec', ctx=Store())], value=Call(func=Name(id='HookRecorder', ctx=Load()), args=[Name(id='pluginmanager', ctx=Load())], keywords=[keyword(arg='_ispytest', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='addfinalizer', ctx=Load()), args=[Attribute(value=Name(id='reprec', ctx=Load()), attr='finish_recording', ctx=Load())], keywords=[])), Return(value=Name(id='reprec', ctx=Load()))], decorator_list=[], returns=Name(id='HookRecorder', ctx=Load())), FunctionDef(name='chdir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Cd into the temporary directory.\n\n        This is done automatically upon instantiation.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='chdir', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_makefile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ext', annotation=Name(id='str', ctx=Load())), arg(arg='lines', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Any', ctx=Load()), Name(id='bytes', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='files', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='encoding', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='utf-8')]), body=[Assign(targets=[Name(id='items', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='files', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='ext', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='ext', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='.')], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='pytester.makefile expects a file extension, try .'), FormattedValue(value=Name(id='ext', ctx=Load()), conversion=-1), Constant(value=' instead of '), FormattedValue(value=Name(id='ext', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), FunctionDef(name='to_text', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Any', ctx=Load()), Name(id='bytes', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='bytes', ctx=Load())], keywords=[]), body=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='decode', ctx=Load()), args=[Name(id='encoding', ctx=Load())], keywords=[]), orelse=Call(func=Name(id='str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[])))], decorator_list=[], returns=Name(id='str', ctx=Load())), If(test=Name(id='lines', ctx=Load()), body=[Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='to_text', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='lines', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='basename', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='items', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Tuple(elts=[Name(id='basename', ctx=Load()), Name(id='source', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='ret', ctx=Store())], value=Constant(value=None)), For(target=Tuple(elts=[Name(id='basename', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='items', ctx=Load()), body=[Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Name(id='basename', ctx=Load())], keywords=[]), attr='with_suffix', ctx=Load()), args=[Name(id='ext', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='p', ctx=Load()), attr='parent', ctx=Load()), attr='mkdir', ctx=Load()), args=[], keywords=[keyword(arg='parents', value=Constant(value=True)), keyword(arg='exist_ok', value=Constant(value=True))])), Assign(targets=[Name(id='source_', ctx=Store())], value=Call(func=Name(id='Source', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='to_text', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Attribute(value=Name(id='source_', ctx=Load()), attr='lines', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='write_text', ctx=Load()), args=[Call(func=Attribute(value=Name(id='source', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='encoding', value=Name(id='encoding', ctx=Load()))])), If(test=Compare(left=Name(id='ret', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Name(id='p', ctx=Load()))], orelse=[])], orelse=[]), Assert(test=Compare(left=Name(id='ret', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='makefile', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ext', annotation=Name(id='str', ctx=Load()))], vararg=arg(arg='args', annotation=Name(id='str', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='str', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Create new text file(s) in the test directory.\n\n        :param ext:\n            The extension the file(s) should use, including the dot, e.g. `.py`.\n        :param args:\n            All args are treated as strings and joined using newlines.\n            The result is written as contents to the file.  The name of the\n            file is based on the test function requesting this fixture.\n        :param kwargs:\n            Each keyword is the name of a file, while the value of it will\n            be written as contents of the file.\n        :returns:\n            The first created file.\n\n        Examples:\n\n        .. code-block:: python\n\n            pytester.makefile(".txt", "line1", "line2")\n\n            pytester.makefile(".ini", pytest="[pytest]\\naddopts=-rs\\n")\n\n        To create binary files, use :meth:`pathlib.Path.write_bytes` directly:\n\n        .. code-block:: python\n\n            filename = pytester.path.joinpath("foo.bin")\n            filename.write_bytes(b"...")\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_makefile', ctx=Load()), args=[Name(id='ext', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='makeconftest', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Write a contest.py file.\n\n        :param source: The contents.\n        :returns: The conftest.py file.\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='makepyfile', ctx=Load()), args=[], keywords=[keyword(arg='conftest', value=Name(id='source', ctx=Load()))]))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='makeini', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Write a tox.ini file.\n\n        :param source: The contents.\n        :returns: The tox.ini file.\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='makefile', ctx=Load()), args=[Constant(value='.ini')], keywords=[keyword(arg='tox', value=Name(id='source', ctx=Load()))]))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='getinicfg', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the pytest section from the tox.ini config file.')), Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='makeini', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])), Return(value=Subscript(value=Call(func=Name(id='IniConfig', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])], keywords=[]), slice=Constant(value='pytest'), ctx=Load()))], decorator_list=[], returns=Name(id='SectionWrapper', ctx=Load())), FunctionDef(name='makepyprojecttoml', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Write a pyproject.toml file.\n\n        :param source: The contents.\n        :returns: The pyproject.ini file.\n\n        .. versionadded:: 6.0\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='makefile', ctx=Load()), args=[Constant(value='.toml')], keywords=[keyword(arg='pyproject', value=Name(id='source', ctx=Load()))]))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='makepyfile', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Shortcut for .makefile() with a .py extension.\n\n        Defaults to the test name with a \'.py\' extension, e.g test_foobar.py, overwriting\n        existing files.\n\n        Examples:\n\n        .. code-block:: python\n\n            def test_something(pytester):\n                # Initial file is created test_something.py.\n                pytester.makepyfile("foobar")\n                # To create multiple files, pass kwargs accordingly.\n                pytester.makepyfile(custom="foobar")\n                # At this point, both \'test_something.py\' & \'custom.py\' exist in the test directory.\n\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_makefile', ctx=Load()), args=[Constant(value='.py'), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='maketxtfile', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Shortcut for .makefile() with a .txt extension.\n\n        Defaults to the test name with a \'.txt\' extension, e.g test_foobar.txt, overwriting\n        existing files.\n\n        Examples:\n\n        .. code-block:: python\n\n            def test_something(pytester):\n                # Initial file is created test_something.txt.\n                pytester.maketxtfile("foobar")\n                # To create multiple files, pass kwargs accordingly.\n                pytester.maketxtfile(custom="foobar")\n                # At this point, both \'test_something.txt\' & \'custom.txt\' exist in the test directory.\n\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_makefile', ctx=Load()), args=[Constant(value='.txt'), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='syspathinsert', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Prepend a directory to sys.path, defaults to :attr:`path`.\n\n        This is undone automatically when this object dies at the end of each\n        test.\n\n        :param path:\n            The path.\n        ')), If(test=Compare(left=Name(id='path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_monkeypatch', ctx=Load()), attr='syspath_prepend', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='mkdir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a new (sub)directory.\n\n        :param name:\n            The name of the directory, relative to the pytester path.\n        :returns:\n            The created directory.\n        ')), Assign(targets=[Name(id='p', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), op=Div(), right=Name(id='name', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='mkdir', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='p', ctx=Load()))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='mkpydir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a new python package.\n\n        This creates a (sub)directory with an empty ``__init__.py`` file so it\n        gets recognised as a Python package.\n        ')), Assign(targets=[Name(id='p', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), op=Div(), right=Name(id='name', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='mkdir', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='joinpath', ctx=Load()), args=[Constant(value='__init__.py')], keywords=[]), attr='touch', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='p', ctx=Load()))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='copy_example', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Copy file from project's directory into the testdir.\n\n        :param name:\n            The name of the file to copy.\n        :return:\n            Path to the copied directory (inside ``self.path``).\n        ")), Assign(targets=[Name(id='example_dir_', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='config', ctx=Load()), attr='getini', ctx=Load()), args=[Constant(value='pytester_example_dir')], keywords=[])), If(test=Compare(left=Name(id='example_dir_', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="pytester_example_dir is unset, can't copy examples")], keywords=[]))], orelse=[]), AnnAssign(target=Name(id='example_dir', ctx=Store()), annotation=Name(id='Path', ctx=Load()), value=BinOp(left=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='config', ctx=Load()), attr='rootpath', ctx=Load()), op=Div(), right=Name(id='example_dir_', ctx=Load())), simple=1), For(target=Name(id='extra_element', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='node', ctx=Load()), attr='iter_markers', ctx=Load()), args=[Constant(value='pytester_example_path')], keywords=[]), body=[Assert(test=Attribute(value=Name(id='extra_element', ctx=Load()), attr='args', ctx=Load())), Assign(targets=[Name(id='example_dir', ctx=Store())], value=Call(func=Attribute(value=Name(id='example_dir', ctx=Load()), attr='joinpath', ctx=Load()), args=[Starred(value=Attribute(value=Name(id='extra_element', ctx=Load()), attr='args', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='func_name', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())), Assign(targets=[Name(id='maybe_dir', ctx=Store())], value=BinOp(left=Name(id='example_dir', ctx=Load()), op=Div(), right=Name(id='func_name', ctx=Load()))), Assign(targets=[Name(id='maybe_file', ctx=Store())], value=BinOp(left=Name(id='example_dir', ctx=Load()), op=Div(), right=BinOp(left=Name(id='func_name', ctx=Load()), op=Add(), right=Constant(value='.py')))), If(test=Call(func=Attribute(value=Name(id='maybe_dir', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='example_path', ctx=Store())], value=Name(id='maybe_dir', ctx=Load()))], orelse=[If(test=Call(func=Attribute(value=Name(id='maybe_file', ctx=Load()), attr='is_file', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='example_path', ctx=Store())], value=Name(id='maybe_file', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='LookupError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='func_name', ctx=Load()), conversion=-1), Constant(value=" can't be found as module or package in "), FormattedValue(value=Name(id='example_dir', ctx=Load()), conversion=-1)])], keywords=[]))])])], orelse=[Assign(targets=[Name(id='example_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='example_dir', ctx=Load()), attr='joinpath', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))]), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='example_path', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='example_path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Constant(value='__init__.py')], keywords=[]), attr='is_file', ctx=Load()), args=[], keywords=[]))]), body=[Expr(value=Call(func=Name(id='copytree', ctx=Load()), args=[Name(id='example_path', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()))], orelse=[If(test=Call(func=Attribute(value=Name(id='example_path', ctx=Load()), attr='is_file', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Attribute(value=Name(id='example_path', ctx=Load()), attr='name', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='copy', ctx=Load()), args=[Name(id='example_path', ctx=Load()), Name(id='result', ctx=Load())], keywords=[])), Return(value=Name(id='result', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='LookupError', ctx=Load()), args=[JoinedStr(values=[Constant(value='example "'), FormattedValue(value=Name(id='example_path', ctx=Load()), conversion=-1), Constant(value='" is not found as a file or directory')])], keywords=[]))])])], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='getnode', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='config', annotation=Name(id='Config', ctx=Load())), arg(arg='arg', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the collection node of a file.\n\n        :param config:\n           A pytest config.\n           See :py:meth:`parseconfig` and :py:meth:`parseconfigure` for creating it.\n        :param arg:\n            Path to the file.\n        :returns:\n            The node.\n        ')), Assign(targets=[Name(id='session', ctx=Store())], value=Call(func=Attribute(value=Name(id='Session', ctx=Load()), attr='from_config', ctx=Load()), args=[Name(id='config', ctx=Load())], keywords=[])), Assert(test=Compare(left=Constant(value='::'), ops=[NotIn()], comparators=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='arg', ctx=Load())], keywords=[])])), Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Name(id='arg', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='hook', ctx=Load()), attr='pytest_sessionstart', ctx=Load()), args=[], keywords=[keyword(arg='session', value=Name(id='session', ctx=Load()))])), Assign(targets=[Name(id='res', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='session', ctx=Load()), attr='perform_collect', ctx=Load()), args=[List(elts=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])], ctx=Load())], keywords=[keyword(arg='genitems', value=Constant(value=False))]), slice=Constant(value=0), ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='hook', ctx=Load()), attr='pytest_sessionfinish', ctx=Load()), args=[], keywords=[keyword(arg='session', value=Name(id='session', ctx=Load())), keyword(arg='exitstatus', value=Attribute(value=Name(id='ExitCode', ctx=Load()), attr='OK', ctx=Load()))])), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Collector', ctx=Load()), Name(id='Item', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='getpathnode', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the collection node of a file.\n\n        This is like :py:meth:`getnode` but uses :py:meth:`parseconfigure` to\n        create the (configured) pytest Config instance.\n\n        :param path:\n            Path to the file.\n        :returns:\n            The node.\n        ')), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='config', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parseconfigure', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='session', ctx=Store())], value=Call(func=Attribute(value=Name(id='Session', ctx=Load()), attr='from_config', ctx=Load()), args=[Name(id='config', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Name(id='bestrelpath', ctx=Load()), args=[Attribute(value=Name(id='session', ctx=Load()), attr='path', ctx=Load()), Name(id='path', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='hook', ctx=Load()), attr='pytest_sessionstart', ctx=Load()), args=[], keywords=[keyword(arg='session', value=Name(id='session', ctx=Load()))])), Assign(targets=[Name(id='res', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='session', ctx=Load()), attr='perform_collect', ctx=Load()), args=[List(elts=[Name(id='x', ctx=Load())], ctx=Load())], keywords=[keyword(arg='genitems', value=Constant(value=False))]), slice=Constant(value=0), ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='hook', ctx=Load()), attr='pytest_sessionfinish', ctx=Load()), args=[], keywords=[keyword(arg='session', value=Name(id='session', ctx=Load())), keyword(arg='exitstatus', value=Attribute(value=Name(id='ExitCode', ctx=Load()), attr='OK', ctx=Load()))])), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Collector', ctx=Load()), Name(id='Item', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='genitems', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='colitems', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Item', ctx=Load()), Name(id='Collector', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Generate all test items from a collection node.\n\n        This recurses into the collection node and returns a list of all the\n        test items contained within.\n\n        :param colitems:\n            The collection nodes.\n        :returns:\n            The collected items.\n        ')), Assign(targets=[Name(id='session', ctx=Store())], value=Attribute(value=Subscript(value=Name(id='colitems', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='session', ctx=Load())), AnnAssign(target=Name(id='result', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Item', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Name(id='colitem', ctx=Store()), iter=Name(id='colitems', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='session', ctx=Load()), attr='genitems', ctx=Load()), args=[Name(id='colitem', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Item', ctx=Load()), ctx=Load())), FunctionDef(name='runitem', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Run the "test_func" Item.\n\n        The calling test instance (class containing the test method) must\n        provide a ``.getrunner()`` method which should return a runner which\n        can run the test protocol for a single item, e.g.\n        :py:func:`_pytest.runner.runtestprotocol`.\n        ')), Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getitem', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])), Assign(targets=[Name(id='testclassinstance', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='instance', ctx=Load())), Assign(targets=[Name(id='runner', ctx=Store())], value=Call(func=Attribute(value=Name(id='testclassinstance', ctx=Load()), attr='getrunner', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='runner', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='inline_runsource', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Name(id='str', ctx=Load()))], vararg=arg(arg='cmdlineargs'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Run a test module in process using ``pytest.main()``.\n\n        This run writes "source" into a temporary file and runs\n        ``pytest.main()`` on it, returning a :py:class:`HookRecorder` instance\n        for the result.\n\n        :param source: The source code of the test module.\n        :param cmdlineargs: Any extra command line arguments to use.\n        ')), Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='makepyfile', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Name(id='cmdlineargs', ctx=Load())], keywords=[]), op=Add(), right=List(elts=[Name(id='p', ctx=Load())], ctx=Load()))), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='inline_run', ctx=Load()), args=[Starred(value=Name(id='values', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='HookRecorder', ctx=Load())), FunctionDef(name='inline_genitems', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Run ``pytest.main(['--collectonly'])`` in-process.\n\n        Runs the :py:func:`pytest.main` function to run all of pytest inside\n        the test process itself like :py:meth:`inline_run`, but returns a\n        tuple of the collected items and a :py:class:`HookRecorder` instance.\n        ")), Assign(targets=[Name(id='rec', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='inline_run', ctx=Load()), args=[Constant(value='--collect-only'), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[])), Assign(targets=[Name(id='items', ctx=Store())], value=ListComp(elt=Attribute(value=Name(id='x', ctx=Load()), attr='item', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='rec', ctx=Load()), attr='getcalls', ctx=Load()), args=[Constant(value='pytest_itemcollected')], keywords=[]), ifs=[], is_async=0)])), Return(value=Tuple(elts=[Name(id='items', ctx=Load()), Name(id='rec', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Item', ctx=Load()), ctx=Load()), Name(id='HookRecorder', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='inline_run', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load())), kwonlyargs=[arg(arg='plugins'), arg(arg='no_reraise_ctrlc', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Tuple(elts=[], ctx=Load()), Constant(value=False)], defaults=[]), body=[Expr(value=Constant(value='Run ``pytest.main()`` in-process, returning a HookRecorder.\n\n        Runs the :py:func:`pytest.main` function to run all of pytest inside\n        the test process itself.  This means it can return a\n        :py:class:`HookRecorder` instance which gives more detailed results\n        from that run than can be done by matching stdout/stderr from\n        :py:meth:`runpytest`.\n\n        :param args:\n            Command line arguments to pass to :py:func:`pytest.main`.\n        :param plugins:\n            Extra plugin instances the ``pytest.main()`` instance should use.\n        :param no_reraise_ctrlc:\n            Typically we reraise keyboard interrupts from the child run. If\n            True, the KeyboardInterrupt exception is captured.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='importlib', ctx=Load()), attr='invalidate_caches', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='plugins', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='plugins', ctx=Load())], keywords=[])), Assign(targets=[Name(id='finalizers', ctx=Store())], value=List(elts=[], ctx=Load())), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='finalizers', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__take_sys_modules_snapshot', ctx=Load()), args=[], keywords=[]), attr='restore', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='finalizers', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Call(func=Name(id='SysPathsSnapshot', ctx=Load()), args=[], keywords=[]), attr='restore', ctx=Load())], keywords=[])), Assign(targets=[Name(id='rec', ctx=Store())], value=List(elts=[], ctx=Load())), ClassDef(name='Collect', bases=[], keywords=[], body=[FunctionDef(name='pytest_configure', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='rec', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_hook_recorder', ctx=Load()), args=[Attribute(value=Name(id='config', ctx=Load()), attr='pluginmanager', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='plugins', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='Collect', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='main', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='args', ctx=Load()), ifs=[], is_async=0)])], keywords=[keyword(arg='plugins', value=Name(id='plugins', ctx=Load()))])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='rec', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='reprec', ctx=Store())], value=Call(func=Attribute(value=Name(id='rec', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[]))], orelse=[ClassDef(name='reprec', bases=[], keywords=[], body=[Pass()], decorator_list=[])]), Assign(targets=[Attribute(value=Name(id='reprec', ctx=Load()), attr='ret', ctx=Store())], value=Name(id='ret', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='ret', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='ExitCode', ctx=Load()), attr='INTERRUPTED', ctx=Load())]), UnaryOp(op=Not(), operand=Name(id='no_reraise_ctrlc', ctx=Load()))]), body=[Assign(targets=[Name(id='calls', ctx=Store())], value=Call(func=Attribute(value=Name(id='reprec', ctx=Load()), attr='getcalls', ctx=Load()), args=[Constant(value='pytest_keyboard_interrupt')], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='calls', ctx=Load()), Compare(left=Attribute(value=Attribute(value=Subscript(value=Name(id='calls', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), attr='excinfo', ctx=Load()), attr='type', ctx=Load()), ops=[Eq()], comparators=[Name(id='KeyboardInterrupt', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='KeyboardInterrupt', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='reprec', ctx=Load()))], handlers=[], orelse=[], finalbody=[For(target=Name(id='finalizer', ctx=Store()), iter=Name(id='finalizers', ctx=Load()), body=[Expr(value=Call(func=Name(id='finalizer', ctx=Load()), args=[], keywords=[]))], orelse=[])])], decorator_list=[], returns=Name(id='HookRecorder', ctx=Load())), FunctionDef(name='runpytest_inprocess', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Return result of running pytest in-process, providing a similar\n        interface to what self.runpytest() provides.')), Assign(targets=[Name(id='syspathinsert', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='syspathinsert'), Constant(value=False)], keywords=[])), If(test=Name(id='syspathinsert', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='syspathinsert', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='now', ctx=Store())], value=Call(func=Attribute(value=Name(id='timing', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='capture', ctx=Store())], value=Call(func=Name(id='_get_multicapture', ctx=Load()), args=[Constant(value='sys')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='capture', ctx=Load()), attr='start_capturing', ctx=Load()), args=[], keywords=[])), Try(body=[Try(body=[Assign(targets=[Name(id='reprec', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='inline_run', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='SystemExit', ctx=Load()), name='e', body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='e', ctx=Load()), attr='args', ctx=Load()), slice=Constant(value=0), ctx=Load())), Try(body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='ExitCode', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='e', ctx=Load()), attr='args', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), ClassDef(name='reprec', bases=[], keywords=[], body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Name(id='ret', ctx=Load()))], decorator_list=[])]), ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='print_exc', ctx=Load()), args=[], keywords=[])), ClassDef(name='reprec', bases=[], keywords=[], body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='ExitCode', ctx=Load()), args=[Constant(value=3)], keywords=[]))], decorator_list=[])])], orelse=[], finalbody=[])], handlers=[], orelse=[], finalbody=[Assign(targets=[Tuple(elts=[Name(id='out', ctx=Store()), Name(id='err', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='capture', ctx=Load()), attr='readouterr', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='capture', ctx=Load()), attr='stop_capturing', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stdout', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='out', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='err', ctx=Load())], keywords=[]))]), Assert(test=Compare(left=Attribute(value=Name(id='reprec', ctx=Load()), attr='ret', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Name(id='RunResult', ctx=Load()), args=[Attribute(value=Name(id='reprec', ctx=Load()), attr='ret', ctx=Load()), Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='err', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Attribute(value=Name(id='timing', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='now', ctx=Load()))], keywords=[])), Assign(targets=[Attribute(value=Name(id='res', ctx=Load()), attr='reprec', ctx=Store())], value=Name(id='reprec', ctx=Load())), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=Name(id='RunResult', ctx=Load())), FunctionDef(name='runpytest', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Run pytest inline or in a subprocess, depending on the command line\n        option "--runpytest" and return a :py:class:`~pytest.RunResult`.')), Assign(targets=[Name(id='new_args', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_ensure_basetemp', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_method', ctx=Load()), ops=[Eq()], comparators=[Constant(value='inprocess')]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='runpytest_inprocess', ctx=Load()), args=[Starred(value=Name(id='new_args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_method', ctx=Load()), ops=[Eq()], comparators=[Constant(value='subprocess')]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='runpytest_subprocess', ctx=Load()), args=[Starred(value=Name(id='new_args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[])]), Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Unrecognized runpytest option: '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_method', ctx=Load()), conversion=-1)])], keywords=[]))], decorator_list=[], returns=Name(id='RunResult', ctx=Load())), FunctionDef(name='_ensure_basetemp', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='args', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='new_args', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])), For(target=Name(id='x', ctx=Store()), iter=Name(id='new_args', ctx=Load()), body=[If(test=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), attr='startswith', ctx=Load()), args=[Constant(value='--basetemp')], keywords=[]), body=[Break()], orelse=[])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='new_args', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='--basetemp=%s'), op=Mod(), right=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='parent', ctx=Load()), attr='joinpath', ctx=Load()), args=[Constant(value='basetemp')], keywords=[]))], keywords=[]))]), Return(value=Name(id='new_args', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='parseconfig', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load())), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a new pytest :class:`pytest.Config` instance from given\n        commandline args.\n\n        This invokes the pytest bootstrapping code in _pytest.config to create a\n        new :py:class:`pytest.PytestPluginManager` and call the\n        :hook:`pytest_cmdline_parse` hook to create a new :class:`pytest.Config`\n        instance.\n\n        If :attr:`plugins` has been populated they should be plugin modules\n        to be registered with the plugin manager.\n        ')), Import(names=[alias(name='_pytest.config')]), Assign(targets=[Name(id='new_args', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_ensure_basetemp', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_args', ctx=Store())], value=ListComp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='new_args', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='config', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='_pytest', ctx=Load()), attr='config', ctx=Load()), attr='_prepareconfig', ctx=Load()), args=[Name(id='new_args', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='plugins', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='addfinalizer', ctx=Load()), args=[Attribute(value=Name(id='config', ctx=Load()), attr='_ensure_unconfigure', ctx=Load())], keywords=[])), Return(value=Name(id='config', ctx=Load()))], decorator_list=[], returns=Name(id='Config', ctx=Load())), FunctionDef(name='parseconfigure', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load())), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a new pytest configured Config instance.\n\n        Returns a new :py:class:`pytest.Config` instance like\n        :py:meth:`parseconfig`, but also calls the :hook:`pytest_configure`\n        hook.\n        ')), Assign(targets=[Name(id='config', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parseconfig', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='_do_configure', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='config', ctx=Load()))], decorator_list=[], returns=Name(id='Config', ctx=Load())), FunctionDef(name='getitem', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load())), arg(arg='funcname', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='test_func')]), body=[Expr(value=Constant(value="Return the test item for a test function.\n\n        Writes the source to a python file and runs pytest's collection on\n        the resulting module, returning the test item for the requested\n        function name.\n\n        :param source:\n            The module source.\n        :param funcname:\n            The name of the test function for which to return a test item.\n        :returns:\n            The test item.\n        ")), Assign(targets=[Name(id='items', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getitems', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])), For(target=Name(id='item', ctx=Store()), iter=Name(id='items', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='item', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Name(id='funcname', ctx=Load())]), body=[Return(value=Name(id='item', ctx=Load()))], orelse=[])], orelse=[]), Assert(test=Constant(value=0), msg=Call(func=Attribute(value=Constant(value='{!r} item not found in module:\n{}\nitems: {}'), attr='format', ctx=Load()), args=[Name(id='funcname', ctx=Load()), Name(id='source', ctx=Load()), Name(id='items', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Item', ctx=Load())), FunctionDef(name='getitems', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return all test items collected from the module.\n\n        Writes the source to a Python file and runs pytest's collection on\n        the resulting module, returning all test items contained within.\n        ")), Assign(targets=[Name(id='modcol', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getmodulecol', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='genitems', ctx=Load()), args=[List(elts=[Name(id='modcol', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Item', ctx=Load()), ctx=Load())), FunctionDef(name='getmodulecol', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='source', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load())), arg(arg='configargs')], kwonlyargs=[arg(arg='withinit', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Tuple(elts=[], ctx=Load())]), body=[Expr(value=Constant(value='Return the module collection node for ``source``.\n\n        Writes ``source`` to a file using :py:meth:`makepyfile` and then\n        runs the pytest collection on it, returning the collection node for the\n        test module.\n\n        :param source:\n            The source code of the module to collect.\n\n        :param configargs:\n            Any extra arguments to pass to :py:meth:`parseconfigure`.\n\n        :param withinit:\n            Whether to also write an ``__init__.py`` file to the same\n            directory to ensure it is a package.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='source', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='PathLike', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])), Assert(test=UnaryOp(op=Not(), operand=Name(id='withinit', ctx=Load())), msg=Constant(value='not supported for paths'))], orelse=[Assign(targets=[Name(id='kw', ctx=Store())], value=Dict(keys=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())], values=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])])), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='makepyfile', ctx=Load()), args=[], keywords=[keyword(value=Name(id='kw', ctx=Load()))]))]), If(test=Name(id='withinit', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='makepyfile', ctx=Load()), args=[], keywords=[keyword(arg='__init__', value=Constant(value='#'))]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='config', ctx=Store()), Name(id='config', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parseconfigure', ctx=Load()), args=[Name(id='path', ctx=Load()), Starred(value=Name(id='configargs', ctx=Load()), ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='getnode', ctx=Load()), args=[Name(id='config', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='collect_by_name', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='modcol', annotation=Name(id='Collector', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the collection node for name from the module collection.\n\n        Searches a module collection node for a collection node matching the\n        given name.\n\n        :param modcol: A module collection node; see :py:meth:`getmodulecol`.\n        :param name: The name of the node to return.\n        ')), If(test=Compare(left=Name(id='modcol', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_mod_collections', ctx=Load())]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_mod_collections', ctx=Load()), slice=Name(id='modcol', ctx=Load()), ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='modcol', ctx=Load()), attr='collect', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), For(target=Name(id='colitem', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_mod_collections', ctx=Load()), slice=Name(id='modcol', ctx=Load()), ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='colitem', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Name(id='name', ctx=Load())]), body=[Return(value=Name(id='colitem', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Item', ctx=Load()), Name(id='Collector', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='popen', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cmdargs', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='stdout', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='TextIO', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='stderr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='TextIO', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='stdin', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='NotSetType', ctx=Load()), Name(id='bytes', ctx=Load()), Subscript(value=Name(id='IO', ctx=Load()), slice=Name(id='Any', ctx=Load()), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[Attribute(value=Name(id='subprocess', ctx=Load()), attr='PIPE', ctx=Load()), Attribute(value=Name(id='subprocess', ctx=Load()), attr='PIPE', ctx=Load()), Name(id='CLOSE_STDIN', ctx=Load())]), body=[Expr(value=Constant(value='Invoke :py:class:`subprocess.Popen`.\n\n        Calls :py:class:`subprocess.Popen` making sure the current working\n        directory is in ``PYTHONPATH``.\n\n        You probably want to use :py:meth:`run` instead.\n        ')), Assign(targets=[Name(id='env', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='env', ctx=Load()), slice=Constant(value='PYTHONPATH'), ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='pathsep', ctx=Load()), attr='join', ctx=Load()), args=[Call(func=Name(id='filter', ctx=Load()), args=[Constant(value=None), List(elts=[Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getcwd', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='env', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='PYTHONPATH'), Constant(value='')], keywords=[])], ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='env'), ctx=Store())], value=Name(id='env', ctx=Load())), If(test=Compare(left=Name(id='stdin', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='CLOSE_STDIN', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='stdin'), ctx=Store())], value=Attribute(value=Name(id='subprocess', ctx=Load()), attr='PIPE', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='stdin', ctx=Load()), Name(id='bytes', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='stdin'), ctx=Store())], value=Attribute(value=Name(id='subprocess', ctx=Load()), attr='PIPE', ctx=Load()))], orelse=[Assign(targets=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='stdin'), ctx=Store())], value=Name(id='stdin', ctx=Load()))])]), Assign(targets=[Name(id='popen', ctx=Store())], value=Call(func=Attribute(value=Name(id='subprocess', ctx=Load()), attr='Popen', ctx=Load()), args=[Name(id='cmdargs', ctx=Load())], keywords=[keyword(arg='stdout', value=Name(id='stdout', ctx=Load())), keyword(arg='stderr', value=Name(id='stderr', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))])), If(test=Compare(left=Name(id='stdin', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='CLOSE_STDIN', ctx=Load())]), body=[Assert(test=Compare(left=Attribute(value=Name(id='popen', ctx=Load()), attr='stdin', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='popen', ctx=Load()), attr='stdin', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='stdin', ctx=Load()), Name(id='bytes', ctx=Load())], keywords=[]), body=[Assert(test=Compare(left=Attribute(value=Name(id='popen', ctx=Load()), attr='stdin', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='popen', ctx=Load()), attr='stdin', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='stdin', ctx=Load())], keywords=[]))], orelse=[])]), Return(value=Name(id='popen', ctx=Load()))], decorator_list=[]), FunctionDef(name='run', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='cmdargs', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load())), kwonlyargs=[arg(arg='timeout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='stdin', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='NotSetType', ctx=Load()), Name(id='bytes', ctx=Load()), Subscript(value=Name(id='IO', ctx=Load()), slice=Name(id='Any', ctx=Load()), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Name(id='CLOSE_STDIN', ctx=Load())], defaults=[]), body=[Expr(value=Constant(value='Run a command with arguments.\n\n        Run a process using :py:class:`subprocess.Popen` saving the stdout and\n        stderr.\n\n        :param cmdargs:\n            The sequence of arguments to pass to :py:class:`subprocess.Popen`,\n            with path-like objects being converted to :py:class:`str`\n            automatically.\n        :param timeout:\n            The period in seconds after which to timeout and raise\n            :py:class:`Pytester.TimeoutExpired`.\n        :param stdin:\n            Optional standard input.\n\n            - If it is :py:attr:`CLOSE_STDIN` (Default), then this method calls\n              :py:class:`subprocess.Popen` with ``stdin=subprocess.PIPE``, and\n              the standard input is closed immediately after the new command is\n              started.\n\n            - If it is of type :py:class:`bytes`, these bytes are sent to the\n              standard input of the command.\n\n            - Otherwise, it is passed through to :py:class:`subprocess.Popen`.\n              For further information in this case, consult the document of the\n              ``stdin`` parameter in :py:class:`subprocess.Popen`.\n        :returns:\n            The result.\n        ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='cmdargs', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='fspath', ctx=Load()), args=[Name(id='arg', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='arg', ctx=Store()), iter=Name(id='cmdargs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='p1', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Constant(value='stdout')], keywords=[])), Assign(targets=[Name(id='p2', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Constant(value='stderr')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='running:'), Starred(value=Name(id='cmdargs', ctx=Load()), ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='     in:'), Call(func=Attribute(value=Name(id='Path', ctx=Load()), attr='cwd', ctx=Load()), args=[], keywords=[])], keywords=[])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='p1', ctx=Load()), attr='open', ctx=Load()), args=[Constant(value='w')], keywords=[keyword(arg='encoding', value=Constant(value='utf8'))]), optional_vars=Name(id='f1', ctx=Store())), withitem(context_expr=Call(func=Attribute(value=Name(id='p2', ctx=Load()), attr='open', ctx=Load()), args=[Constant(value='w')], keywords=[keyword(arg='encoding', value=Constant(value='utf8'))]), optional_vars=Name(id='f2', ctx=Store()))], body=[Assign(targets=[Name(id='now', ctx=Store())], value=Call(func=Attribute(value=Name(id='timing', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='popen', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='popen', ctx=Load()), args=[Name(id='cmdargs', ctx=Load())], keywords=[keyword(arg='stdin', value=Name(id='stdin', ctx=Load())), keyword(arg='stdout', value=Name(id='f1', ctx=Load())), keyword(arg='stderr', value=Name(id='f2', ctx=Load())), keyword(arg='close_fds', value=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='win32')]))])), If(test=Compare(left=Attribute(value=Name(id='popen', ctx=Load()), attr='stdin', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='popen', ctx=Load()), attr='stdin', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[]), FunctionDef(name='handle_timeout', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='timeout_message', ctx=Store())], value=Call(func=Attribute(value=Constant(value='{seconds} second timeout expired running: {command}'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='seconds', value=Name(id='timeout', ctx=Load())), keyword(arg='command', value=Name(id='cmdargs', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='popen', ctx=Load()), attr='kill', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='popen', ctx=Load()), attr='wait', ctx=Load()), args=[], keywords=[])), Raise(exc=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='TimeoutExpired', ctx=Load()), args=[Name(id='timeout_message', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), If(test=Compare(left=Name(id='timeout', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='popen', ctx=Load()), attr='wait', ctx=Load()), args=[], keywords=[]))], orelse=[Try(body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='popen', ctx=Load()), attr='wait', ctx=Load()), args=[Name(id='timeout', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='subprocess', ctx=Load()), attr='TimeoutExpired', ctx=Load()), body=[Expr(value=Call(func=Name(id='handle_timeout', ctx=Load()), args=[], keywords=[]))])], orelse=[], finalbody=[])])]), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='p1', ctx=Load()), attr='open', ctx=Load()), args=[], keywords=[keyword(arg='encoding', value=Constant(value='utf8'))]), optional_vars=Name(id='f1', ctx=Store())), withitem(context_expr=Call(func=Attribute(value=Name(id='p2', ctx=Load()), attr='open', ctx=Load()), args=[], keywords=[keyword(arg='encoding', value=Constant(value='utf8'))]), optional_vars=Name(id='f2', ctx=Store()))], body=[Assign(targets=[Name(id='out', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='f1', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]), attr='splitlines', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='err', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='f2', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]), attr='splitlines', ctx=Load()), args=[], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_dump_lines', ctx=Load()), args=[Name(id='out', ctx=Load()), Attribute(value=Name(id='sys', ctx=Load()), attr='stdout', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_dump_lines', ctx=Load()), args=[Name(id='err', ctx=Load()), Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Load())], keywords=[])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='suppress', ctx=Load()), args=[Name(id='ValueError', ctx=Load())], keywords=[]))], body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='ExitCode', ctx=Load()), args=[Name(id='ret', ctx=Load())], keywords=[]))]), Return(value=Call(func=Name(id='RunResult', ctx=Load()), args=[Name(id='ret', ctx=Load()), Name(id='out', ctx=Load()), Name(id='err', ctx=Load()), BinOp(left=Call(func=Attribute(value=Name(id='timing', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='now', ctx=Load()))], keywords=[]))], decorator_list=[], returns=Name(id='RunResult', ctx=Load())), FunctionDef(name='_dump_lines', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines'), arg(arg='fp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[For(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[keyword(arg='file', value=Name(id='fp', ctx=Load()))]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='UnicodeEncodeError', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="couldn't print to "), FormattedValue(value=Name(id='fp', ctx=Load()), conversion=-1), Constant(value=' because of encoding')])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='_getpytestargs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='sys', ctx=Load()), attr='executable', ctx=Load()), Constant(value='-mpytest')], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='runpython', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='script', annotation=Constant(value='os.PathLike[str]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Run a python script using sys.executable as interpreter.')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='run', ctx=Load()), args=[Attribute(value=Name(id='sys', ctx=Load()), attr='executable', ctx=Load()), Name(id='script', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='RunResult', ctx=Load())), FunctionDef(name='runpython_c', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='command', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Run ``python -c "command"``.')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='run', ctx=Load()), args=[Attribute(value=Name(id='sys', ctx=Load()), attr='executable', ctx=Load()), Constant(value='-c'), Name(id='command', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='RunResult', ctx=Load())), FunctionDef(name='runpytest_subprocess', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load())), kwonlyargs=[arg(arg='timeout', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value='Run pytest as a subprocess with given arguments.\n\n        Any plugins added to the :py:attr:`plugins` list will be added using the\n        ``-p`` command line option.  Additionally ``--basetemp`` is used to put\n        any temporary files and directories in a numbered directory prefixed\n        with "runpytest-" to not conflict with the normal numbered pytest\n        location for temporary files and directories.\n\n        :param args:\n            The sequence of arguments to pass to the pytest subprocess.\n        :param timeout:\n            The period in seconds after which to timeout and raise\n            :py:class:`Pytester.TimeoutExpired`.\n        :returns:\n            The result.\n        ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Name(id='make_numbered_dir', ctx=Load()), args=[], keywords=[keyword(arg='root', value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load())), keyword(arg='prefix', value=Constant(value='runpytest-')), keyword(arg='mode', value=Constant(value=448))])), Assign(targets=[Name(id='args', ctx=Store())], value=BinOp(left=Tuple(elts=[BinOp(left=Constant(value='--basetemp=%s'), op=Mod(), right=Name(id='p', ctx=Load()))], ctx=Load()), op=Add(), right=Name(id='args', ctx=Load()))), Assign(targets=[Name(id='plugins', ctx=Store())], value=ListComp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='plugins', ctx=Load()), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])], is_async=0)])), If(test=Name(id='plugins', ctx=Load()), body=[Assign(targets=[Name(id='args', ctx=Store())], value=BinOp(left=Tuple(elts=[Constant(value='-p'), Subscript(value=Name(id='plugins', ctx=Load()), slice=Constant(value=0), ctx=Load())], ctx=Load()), op=Add(), right=Name(id='args', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='args', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_getpytestargs', ctx=Load()), args=[], keywords=[]), op=Add(), right=Name(id='args', ctx=Load()))), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='run', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(arg='timeout', value=Name(id='timeout', ctx=Load()))]))], decorator_list=[], returns=Name(id='RunResult', ctx=Load())), FunctionDef(name='spawn_pytest', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='string', annotation=Name(id='str', ctx=Load())), arg(arg='expect_timeout', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=10.0)]), body=[Expr(value=Constant(value='Run pytest using pexpect.\n\n        This makes sure to use the right pytest and sets up the temporary\n        directory locations.\n\n        The pexpect child is returned.\n        ')), Assign(targets=[Name(id='basetemp', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), op=Div(), right=Constant(value='temp-pexpect'))), Expr(value=Call(func=Attribute(value=Name(id='basetemp', ctx=Load()), attr='mkdir', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Constant(value=448))])), Assign(targets=[Name(id='invoke', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_getpytestargs', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='cmd', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='invoke', ctx=Load()), conversion=-1), Constant(value=' --basetemp='), FormattedValue(value=Name(id='basetemp', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Name(id='string', ctx=Load()), conversion=-1)])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='spawn', ctx=Load()), args=[Name(id='cmd', ctx=Load())], keywords=[keyword(arg='expect_timeout', value=Name(id='expect_timeout', ctx=Load()))]))], decorator_list=[], returns=Constant(value='pexpect.spawn')), FunctionDef(name='spawn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cmd', annotation=Name(id='str', ctx=Load())), arg(arg='expect_timeout', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=10.0)]), body=[Expr(value=Constant(value='Run a command using pexpect.\n\n        The pexpect child is returned.\n        ')), Assign(targets=[Name(id='pexpect', ctx=Store())], value=Call(func=Name(id='importorskip', ctx=Load()), args=[Constant(value='pexpect'), Constant(value='3.0')], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='sys', ctx=Load()), Constant(value='pypy_version_info')], keywords=[]), Compare(left=Constant(value='64'), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='platform', ctx=Load()), attr='machine', ctx=Load()), args=[], keywords=[])])]), body=[Expr(value=Call(func=Name(id='skip', ctx=Load()), args=[Constant(value='pypy-64 bit not supported')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='pexpect', ctx=Load()), Constant(value='spawn')], keywords=[])), body=[Expr(value=Call(func=Name(id='skip', ctx=Load()), args=[Constant(value='pexpect.spawn not available')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='logfile', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Constant(value='spawn.out')], keywords=[]), attr='open', ctx=Load()), args=[Constant(value='wb')], keywords=[])), Assign(targets=[Name(id='child', ctx=Store())], value=Call(func=Attribute(value=Name(id='pexpect', ctx=Load()), attr='spawn', ctx=Load()), args=[Name(id='cmd', ctx=Load())], keywords=[keyword(arg='logfile', value=Name(id='logfile', ctx=Load())), keyword(arg='timeout', value=Name(id='expect_timeout', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_request', ctx=Load()), attr='addfinalizer', ctx=Load()), args=[Attribute(value=Name(id='logfile', ctx=Load()), attr='close', ctx=Load())], keywords=[])), Return(value=Name(id='child', ctx=Load()))], decorator_list=[], returns=Constant(value='pexpect.spawn'))], decorator_list=[Name(id='final', ctx=Load())]), ClassDef(name='LineComp', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stringio', ctx=Store())], value=Call(func=Name(id='StringIO', ctx=Load()), args=[], keywords=[])), Expr(value=Constant(value=':class:`python:io.StringIO()` instance used for input.'))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='assert_contains_lines', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines2', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Assert that ``lines2`` are contained (linearly) in :attr:`stringio`'s value.\n\n        Lines are matched using :func:`LineMatcher.fnmatch_lines <pytest.LineMatcher.fnmatch_lines>`.\n        ")), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='val', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stringio', ctx=Load()), attr='getvalue', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stringio', ctx=Load()), attr='truncate', ctx=Load()), args=[Constant(value=0)], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stringio', ctx=Load()), attr='seek', ctx=Load()), args=[Constant(value=0)], keywords=[])), Assign(targets=[Name(id='lines1', ctx=Store())], value=Call(func=Attribute(value=Name(id='val', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='LineMatcher', ctx=Load()), args=[Name(id='lines1', ctx=Load())], keywords=[]), attr='fnmatch_lines', ctx=Load()), args=[Name(id='lines2', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='LineMatcher', bases=[], keywords=[], body=[Expr(value=Constant(value='Flexible matching of text.\n\n    This is a convenience class to test large texts like the output of\n    commands.\n\n    The constructor takes a list of lines without their trailing newlines, i.e.\n    ``text.splitlines()``.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Store())], value=Name(id='lines', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_log_output', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the entire original text.\n\n        .. versionadded:: 6.2\n            You can use :meth:`str` in older versions.\n        ')), Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_getlines', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines2', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='Source', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='lines2', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='lines2', ctx=Store())], value=Call(func=Name(id='Source', ctx=Load()), args=[Name(id='lines2', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='lines2', ctx=Load()), Name(id='Source', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='lines2', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='lines2', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='lines', ctx=Load()))], orelse=[]), Return(value=Name(id='lines2', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='fnmatch_lines_random', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines2', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check lines exist in the output in any order (using :func:`python:fnmatch.fnmatch`).')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_match_lines_random', ctx=Load()), args=[Name(id='lines2', ctx=Load()), Name(id='fnmatch', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='re_match_lines_random', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines2', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check lines exist in the output in any order (using :func:`python:re.match`).')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_match_lines_random', ctx=Load()), args=[Name(id='lines2', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='name'), arg(arg='pat')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='bool', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='pat', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])], keywords=[]))], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_match_lines_random', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines2', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='match_func', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='lines2', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_getlines', ctx=Load()), args=[Name(id='lines2', ctx=Load())], keywords=[])), For(target=Name(id='line', ctx=Store()), iter=Name(id='lines2', ctx=Load()), body=[For(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='line', ctx=Load()), ops=[Eq()], comparators=[Name(id='x', ctx=Load())]), Call(func=Name(id='match_func', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='line', ctx=Load())], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Constant(value='matched: '), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])], keywords=[])), Break()], orelse=[])], orelse=[Assign(targets=[Name(id='msg', ctx=Store())], value=BinOp(left=Constant(value='line %r not found in output'), op=Mod(), right=Name(id='line', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fail', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_lines_after', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fnline', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return all lines following the given line in the text.\n\n        The given line can contain glob wildcards.\n        ')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='line', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='fnline', ctx=Load()), ops=[Eq()], comparators=[Name(id='line', ctx=Load())]), Call(func=Name(id='fnmatch', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='fnline', ctx=Load())], keywords=[])]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load()))], orelse=[])], orelse=[]), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='line %r not found in output'), op=Mod(), right=Name(id='fnline', ctx=Load()))], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_log', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_log_output', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='args', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_log_text', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_log_output', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='fnmatch_lines', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines2', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='consecutive', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[]), body=[Expr(value=Constant(value='Check lines exist in the output (using :func:`python:fnmatch.fnmatch`).\n\n        The argument is a list of lines which have to match and can use glob\n        wildcards.  If they do not match a pytest.fail() is called.  The\n        matches and non-matches are also shown as part of the error message.\n\n        :param lines2: String patterns to match.\n        :param consecutive: Match lines consecutively?\n        ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_match_lines', ctx=Load()), args=[Name(id='lines2', ctx=Load()), Name(id='fnmatch', ctx=Load()), Constant(value='fnmatch')], keywords=[keyword(arg='consecutive', value=Name(id='consecutive', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='re_match_lines', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines2', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='consecutive', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[]), body=[Expr(value=Constant(value='Check lines exist in the output (using :func:`python:re.match`).\n\n        The argument is a list of lines which have to match using ``re.match``.\n        If they do not match a pytest.fail() is called.\n\n        The matches and non-matches are also shown as part of the error message.\n\n        :param lines2: string patterns to match.\n        :param consecutive: match lines consecutively?\n        ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_match_lines', ctx=Load()), args=[Name(id='lines2', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='name'), arg(arg='pat')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='bool', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='pat', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])], keywords=[])), Constant(value='re.match')], keywords=[keyword(arg='consecutive', value=Name(id='consecutive', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_match_lines', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lines2', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='match_func', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='match_nickname', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='consecutive', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[]), body=[Expr(value=Constant(value='Underlying implementation of ``fnmatch_lines`` and ``re_match_lines``.\n\n        :param Sequence[str] lines2:\n            List of string patterns to match. The actual format depends on\n            ``match_func``.\n        :param match_func:\n            A callable ``match_func(line, pattern)`` where line is the\n            captured line from stdout/stderr and pattern is the matching\n            pattern.\n        :param str match_nickname:\n            The nickname for the match function that will be logged to stdout\n            when a match occurs.\n        :param consecutive:\n            Match lines consecutively?\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='lines2', ctx=Load()), Attribute(value=Attribute(value=Name(id='collections', ctx=Load()), attr='abc', ctx=Load()), attr='Sequence', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='invalid type for lines2: '), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='lines2', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='lines2', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_getlines', ctx=Load()), args=[Name(id='lines2', ctx=Load())], keywords=[])), Assign(targets=[Name(id='lines1', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Load()), slice=Slice(), ctx=Load())), Assign(targets=[Name(id='extralines', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='wnick', ctx=Store())], value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='match_nickname', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))), Assign(targets=[Name(id='started', ctx=Store())], value=Constant(value=False)), For(target=Name(id='line', ctx=Store()), iter=Name(id='lines2', ctx=Load()), body=[Assign(targets=[Name(id='nomatchprinted', ctx=Store())], value=Constant(value=False)), While(test=Name(id='lines1', ctx=Load()), body=[Assign(targets=[Name(id='nextline', ctx=Store())], value=Call(func=Attribute(value=Name(id='lines1', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value=0)], keywords=[])), If(test=Compare(left=Name(id='line', ctx=Load()), ops=[Eq()], comparators=[Name(id='nextline', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Constant(value='exact match:'), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='started', ctx=Store())], value=Constant(value=True)), Break()], orelse=[If(test=Call(func=Name(id='match_func', ctx=Load()), args=[Name(id='nextline', ctx=Load()), Name(id='line', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[BinOp(left=Constant(value='%s:'), op=Mod(), right=Name(id='match_nickname', ctx=Load())), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{:>{width}}'), attr='format', ctx=Load()), args=[Constant(value='with:')], keywords=[keyword(arg='width', value=Name(id='wnick', ctx=Load()))]), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='nextline', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='started', ctx=Store())], value=Constant(value=True)), Break()], orelse=[If(test=BoolOp(op=And(), values=[Name(id='consecutive', ctx=Load()), Name(id='started', ctx=Load())]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='no consecutive match: '), FormattedValue(value=Name(id='line', ctx=Load()), conversion=114)])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{:>{width}}'), attr='format', ctx=Load()), args=[Constant(value='with:')], keywords=[keyword(arg='width', value=Name(id='wnick', ctx=Load()))]), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='nextline', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fail', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='nomatchprinted', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{:>{width}}'), attr='format', ctx=Load()), args=[Constant(value='nomatch:')], keywords=[keyword(arg='width', value=Name(id='wnick', ctx=Load()))]), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='nomatchprinted', ctx=Store())], value=Constant(value=True))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{:>{width}}'), attr='format', ctx=Load()), args=[Constant(value='and:')], keywords=[keyword(arg='width', value=Name(id='wnick', ctx=Load()))]), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='nextline', ctx=Load())], keywords=[])], keywords=[]))])]), Expr(value=Call(func=Attribute(value=Name(id='extralines', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='nextline', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[Constant(value='remains unmatched: '), FormattedValue(value=Name(id='line', ctx=Load()), conversion=114)])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fail', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_log_output', ctx=Store())], value=List(elts=[], ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='no_fnmatch_line', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pat', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Ensure captured lines do not match the given pattern, using ``fnmatch.fnmatch``.\n\n        :param str pat: The pattern to match lines.\n        ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_no_match_line', ctx=Load()), args=[Name(id='pat', ctx=Load()), Name(id='fnmatch', ctx=Load()), Constant(value='fnmatch')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='no_re_match_line', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pat', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Ensure captured lines do not match the given pattern, using ``re.match``.\n\n        :param str pat: The regular expression to match lines.\n        ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_no_match_line', ctx=Load()), args=[Name(id='pat', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='name'), arg(arg='pat')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='bool', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='pat', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])], keywords=[])), Constant(value='re.match')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_no_match_line', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pat', annotation=Name(id='str', ctx=Load())), arg(arg='match_func', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='match_nickname', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Ensure captured lines does not have a the given pattern, using ``fnmatch.fnmatch``.\n\n        :param str pat: The pattern to match lines.\n        ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='nomatch_printed', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='wnick', ctx=Store())], value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='match_nickname', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))), For(target=Name(id='line', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='lines', ctx=Load()), body=[If(test=Call(func=Name(id='match_func', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='pat', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='match_nickname', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='pat', ctx=Load()), conversion=114)])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{:>{width}}'), attr='format', ctx=Load()), args=[Constant(value='with:')], keywords=[keyword(arg='width', value=Name(id='wnick', ctx=Load()))]), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_fail', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=Name(id='nomatch_printed', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{:>{width}}'), attr='format', ctx=Load()), args=[Constant(value='nomatch:')], keywords=[keyword(arg='width', value=Name(id='wnick', ctx=Load()))]), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='pat', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='nomatch_printed', ctx=Store())], value=Constant(value=True))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{:>{width}}'), attr='format', ctx=Load()), args=[Constant(value='and:')], keywords=[keyword(arg='width', value=Name(id='wnick', ctx=Load()))]), Call(func=Name(id='repr', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_log_output', ctx=Store())], value=List(elts=[], ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_fail', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='msg', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='log_text', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_log_text', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_log_output', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[Name(id='log_text', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='str', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the entire original text.')), Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[])], type_ignores=[])