Module(body=[Expr(value=Constant(value='Exception classes and constants handling test outcomes as well as\nfunctions creating them.')), Import(names=[alias(name='sys')]), Import(names=[alias(name='warnings')]), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='cast')], level=0), ImportFrom(module='typing', names=[alias(name='NoReturn')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Type')], level=0), ImportFrom(module='typing', names=[alias(name='TypeVar')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='KEYWORD_MSG_ARG')], level=0), Assign(targets=[Name(id='TYPE_CHECKING', ctx=Store())], value=Constant(value=False)), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='typing_extensions', names=[alias(name='Protocol')], level=0)], orelse=[ImportFrom(module='typing', names=[alias(name='Generic')], level=0), Assign(targets=[Name(id='Protocol', ctx=Store())], value=Name(id='Generic', ctx=Load()))]), ClassDef(name='OutcomeException', bases=[Name(id='BaseException', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='msg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='pytrace', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=True)]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='msg', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='msg', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]))]), body=[Assign(targets=[Name(id='error_msg', ctx=Store())], value=Constant(value="{} expected string as 'msg' parameter, got '{}' instead.\nPerhaps you meant to use a mark?")), Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Name(id='error_msg', ctx=Load()), attr='format', ctx=Load()), args=[Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]), attr='__name__', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Store())], value=Name(id='msg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pytrace', ctx=Store())], value=Name(id='pytrace', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Load()))], orelse=[]), Return(value=JoinedStr(values=[Constant(value='<'), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value=' instance>')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), Assign(targets=[Name(id='__str__', ctx=Store())], value=Name(id='__repr__', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='TEST_OUTCOME', ctx=Store())], value=Tuple(elts=[Name(id='OutcomeException', ctx=Load()), Name(id='Exception', ctx=Load())], ctx=Load())), ClassDef(name='Skipped', bases=[Name(id='OutcomeException', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='__module__', ctx=Store())], value=Constant(value='builtins')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='msg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='pytrace', annotation=Name(id='bool', ctx=Load())), arg(arg='allow_module_level', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='_use_item_location', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value=None), Constant(value=True), Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='msg', value=Name(id='msg', ctx=Load())), keyword(arg='pytrace', value=Name(id='pytrace', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='allow_module_level', ctx=Store())], value=Name(id='allow_module_level', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_use_item_location', ctx=Store())], value=Name(id='_use_item_location', ctx=Load()))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='Failed', bases=[Name(id='OutcomeException', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised from an explicit call to pytest.fail().')), Assign(targets=[Name(id='__module__', ctx=Store())], value=Constant(value='builtins'))], decorator_list=[]), ClassDef(name='Exit', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised for immediate program exits (no tracebacks/summaries).')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='msg', annotation=Name(id='str', ctx=Load())), arg(arg='returncode', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='unknown reason'), Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Store())], value=Name(id='msg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='returncode', ctx=Store())], value=Name(id='returncode', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), Assign(targets=[Name(id='_F', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_F')], keywords=[keyword(arg='bound', value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))])), Assign(targets=[Name(id='_ET', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_ET')], keywords=[keyword(arg='bound', value=Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()))])), ClassDef(name='_WithException', bases=[Subscript(value=Name(id='Protocol', ctx=Load()), slice=Tuple(elts=[Name(id='_F', ctx=Load()), Name(id='_ET', ctx=Load())], ctx=Load()), ctx=Load())], keywords=[], body=[AnnAssign(target=Name(id='Exception', ctx=Store()), annotation=Name(id='_ET', ctx=Load()), simple=1), AnnAssign(target=Name(id='__call__', ctx=Store()), annotation=Name(id='_F', ctx=Load()), simple=1)], decorator_list=[]), FunctionDef(name='_with_exception', args=arguments(posonlyargs=[], args=[arg(arg='exception_type', annotation=Name(id='_ET', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='decorate', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Name(id='_F', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='func_with_exception', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Subscript(value=Name(id='_WithException', ctx=Load()), slice=Tuple(elts=[Name(id='_F', ctx=Load()), Name(id='_ET', ctx=Load())], ctx=Load()), ctx=Load()), Name(id='func', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='func_with_exception', ctx=Load()), attr='Exception', ctx=Store())], value=Name(id='exception_type', ctx=Load())), Return(value=Name(id='func_with_exception', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='_WithException', ctx=Load()), slice=Tuple(elts=[Name(id='_F', ctx=Load()), Name(id='_ET', ctx=Load())], ctx=Load()), ctx=Load())), Return(value=Name(id='decorate', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='_F', ctx=Load())], ctx=Load()), Subscript(value=Name(id='_WithException', ctx=Load()), slice=Tuple(elts=[Name(id='_F', ctx=Load()), Name(id='_ET', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='exit', args=arguments(posonlyargs=[], args=[arg(arg='reason', annotation=Name(id='str', ctx=Load())), arg(arg='returncode', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='msg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], defaults=[Constant(value=''), Constant(value=None)]), body=[Expr(value=Constant(value='Exit testing process.\n\n    :param reason:\n        The message to show as the reason for exiting pytest.  reason has a default value\n        only because `msg` is deprecated.\n\n    :param returncode:\n        Return code to be used when exiting pytest.\n\n    :param msg:\n        Same as ``reason``, but deprecated. Will be removed in a future version, use ``reason`` instead.\n    ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), ImportFrom(module='_pytest.config', names=[alias(name='UsageError')], level=0), If(test=BoolOp(op=And(), values=[Name(id='reason', ctx=Load()), Name(id='msg', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='UsageError', ctx=Load()), args=[Constant(value='cannot pass reason and msg to exit(), `msg` is deprecated, use `reason`.')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='reason', ctx=Load())), body=[If(test=Compare(left=Name(id='msg', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='UsageError', ctx=Load()), args=[Constant(value='exit() requires a reason argument')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Name(id='KEYWORD_MSG_ARG', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='func', value=Constant(value='exit'))])], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Assign(targets=[Name(id='reason', ctx=Store())], value=Name(id='msg', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='Exit', ctx=Load()), args=[Name(id='reason', ctx=Load()), Name(id='returncode', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='_with_exception', ctx=Load()), args=[Name(id='Exit', ctx=Load())], keywords=[])], returns=Name(id='NoReturn', ctx=Load())), FunctionDef(name='skip', args=arguments(posonlyargs=[], args=[arg(arg='reason', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='allow_module_level', annotation=Name(id='bool', ctx=Load())), arg(arg='msg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=False), Constant(value=None)], defaults=[Constant(value='')]), body=[Expr(value=Constant(value='Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param reason:\n        The message to show the user as reason for the skip.\n\n    :param allow_module_level:\n        Allows this function to be called at module level.\n        Raising the skip exception at module level will stop\n        the execution of the module and prevent the collection of all tests in the module,\n        even those defined before the `skip` call.\n\n        Defaults to False.\n\n    :param msg:\n        Same as ``reason``, but deprecated. Will be removed in a future version, use ``reason`` instead.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see :py:data:`doctest.SKIP`)\n        to skip a doctest statically.\n    ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='reason', ctx=Store())], value=Call(func=Name(id='_resolve_msg_to_reason', ctx=Load()), args=[Constant(value='skip'), Name(id='reason', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[])), Raise(exc=Call(func=Name(id='Skipped', ctx=Load()), args=[], keywords=[keyword(arg='msg', value=Name(id='reason', ctx=Load())), keyword(arg='allow_module_level', value=Name(id='allow_module_level', ctx=Load()))]))], decorator_list=[Call(func=Name(id='_with_exception', ctx=Load()), args=[Name(id='Skipped', ctx=Load())], keywords=[])], returns=Name(id='NoReturn', ctx=Load())), FunctionDef(name='fail', args=arguments(posonlyargs=[], args=[arg(arg='reason', annotation=Name(id='str', ctx=Load())), arg(arg='pytrace', annotation=Name(id='bool', ctx=Load())), arg(arg='msg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=True), Constant(value=None)]), body=[Expr(value=Constant(value='Explicitly fail an executing test with the given message.\n\n    :param reason:\n        The message to show the user as reason for the failure.\n\n    :param pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n\n    :param msg:\n        Same as ``reason``, but deprecated. Will be removed in a future version, use ``reason`` instead.\n    ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='reason', ctx=Store())], value=Call(func=Name(id='_resolve_msg_to_reason', ctx=Load()), args=[Constant(value='fail'), Name(id='reason', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[])), Raise(exc=Call(func=Name(id='Failed', ctx=Load()), args=[], keywords=[keyword(arg='msg', value=Name(id='reason', ctx=Load())), keyword(arg='pytrace', value=Name(id='pytrace', ctx=Load()))]))], decorator_list=[Call(func=Name(id='_with_exception', ctx=Load()), args=[Name(id='Failed', ctx=Load())], keywords=[])], returns=Name(id='NoReturn', ctx=Load())), FunctionDef(name='_resolve_msg_to_reason', args=arguments(posonlyargs=[], args=[arg(arg='func_name', annotation=Name(id='str', ctx=Load())), arg(arg='reason', annotation=Name(id='str', ctx=Load())), arg(arg='msg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Handles converting the deprecated msg parameter if provided into\n    reason, raising a deprecation warning.  This function will be removed\n    when the optional msg argument is removed from here in future.\n\n    :param str func_name:\n        The name of the offending function, this is formatted into the deprecation message.\n\n    :param str reason:\n        The reason= passed into either pytest.fail() or pytest.skip()\n\n    :param str msg:\n        The msg= passed into either pytest.fail() or pytest.skip().  This will\n        be converted into reason if it is provided to allow pytest.skip(msg=) or\n        pytest.fail(msg=) to continue working in the interim period.\n\n    :returns:\n        The value to use as reason.\n\n    ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), If(test=Compare(left=Name(id='msg', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Name(id='reason', ctx=Load()), body=[ImportFrom(module='pytest', names=[alias(name='UsageError')], level=0), Raise(exc=Call(func=Name(id='UsageError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Passing both ``reason`` and ``msg`` to pytest.'), FormattedValue(value=Name(id='func_name', ctx=Load()), conversion=-1), Constant(value='(...) is not permitted.')])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Name(id='KEYWORD_MSG_ARG', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='func', value=Name(id='func_name', ctx=Load()))])], keywords=[keyword(arg='stacklevel', value=Constant(value=3))])), Assign(targets=[Name(id='reason', ctx=Store())], value=Name(id='msg', ctx=Load()))], orelse=[]), Return(value=Name(id='reason', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), ClassDef(name='XFailed', bases=[Name(id='Failed', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised from an explicit call to pytest.xfail().'))], decorator_list=[]), FunctionDef(name='xfail', args=arguments(posonlyargs=[], args=[arg(arg='reason', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='')]), body=[Expr(value=Constant(value='Imperatively xfail an executing test or setup function with the given reason.\n\n    This function should be called only during testing (setup, call or teardown).\n\n    :param reason:\n        The message to show the user as reason for the xfail.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.xfail ref` marker when\n        possible to declare a test to be xfailed under certain conditions\n        like known bugs or missing features.\n    ')), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Raise(exc=Call(func=Name(id='XFailed', ctx=Load()), args=[Name(id='reason', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='_with_exception', ctx=Load()), args=[Name(id='XFailed', ctx=Load())], keywords=[])], returns=Name(id='NoReturn', ctx=Load())), FunctionDef(name='importorskip', args=arguments(posonlyargs=[], args=[arg(arg='modname', annotation=Name(id='str', ctx=Load())), arg(arg='minversion', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='reason', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Import and return the requested module ``modname``, or skip the\n    current test if the module cannot be imported.\n\n    :param modname:\n        The name of the module to import.\n    :param minversion:\n        If given, the imported module\'s ``__version__`` attribute must be at\n        least this minimal version, otherwise the test is still skipped.\n    :param reason:\n        If given, this reason is shown as the message when the module cannot\n        be imported.\n\n    :returns:\n        The imported module. This should be assigned to its canonical name.\n\n    Example::\n\n        docutils = pytest.importorskip("docutils")\n    ')), Import(names=[alias(name='warnings')]), Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Name(id='compile', ctx=Load()), args=[Name(id='modname', ctx=Load()), Constant(value=''), Constant(value='eval')], keywords=[])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='catch_warnings', ctx=Load()), args=[], keywords=[]))], body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='simplefilter', ctx=Load()), args=[Constant(value='ignore')], keywords=[])), Try(body=[Expr(value=Call(func=Name(id='__import__', ctx=Load()), args=[Name(id='modname', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), name='exc', body=[If(test=Compare(left=Name(id='reason', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='reason', ctx=Store())], value=JoinedStr(values=[Constant(value='could not import '), FormattedValue(value=Name(id='modname', ctx=Load()), conversion=114), Constant(value=': '), FormattedValue(value=Name(id='exc', ctx=Load()), conversion=-1)]))], orelse=[]), Raise(exc=Call(func=Name(id='Skipped', ctx=Load()), args=[Name(id='reason', ctx=Load())], keywords=[keyword(arg='allow_module_level', value=Constant(value=True))]), cause=Constant(value=None))])], orelse=[], finalbody=[])]), Assign(targets=[Name(id='mod', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='modname', ctx=Load()), ctx=Load())), If(test=Compare(left=Name(id='minversion', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='mod', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='verattr', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='mod', ctx=Load()), Constant(value='__version__'), Constant(value=None)], keywords=[])), If(test=Compare(left=Name(id='minversion', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[ImportFrom(module='packaging.version', names=[alias(name='Version')], level=0), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='verattr', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Call(func=Name(id='Version', ctx=Load()), args=[Name(id='verattr', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Call(func=Name(id='Version', ctx=Load()), args=[Name(id='minversion', ctx=Load())], keywords=[])])]), body=[Raise(exc=Call(func=Name(id='Skipped', ctx=Load()), args=[BinOp(left=Constant(value='module %r has __version__ %r, required is: %r'), op=Mod(), right=Tuple(elts=[Name(id='modname', ctx=Load()), Name(id='verattr', ctx=Load()), Name(id='minversion', ctx=Load())], ctx=Load()))], keywords=[keyword(arg='allow_module_level', value=Constant(value=True))]))], orelse=[])], orelse=[]), Return(value=Name(id='mod', ctx=Load()))], decorator_list=[], returns=Name(id='Any', ctx=Load()))], type_ignores=[])