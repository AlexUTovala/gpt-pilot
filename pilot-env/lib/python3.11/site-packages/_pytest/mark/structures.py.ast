Module(body=[Import(names=[alias(name='collections.abc')]), Import(names=[alias(name='dataclasses')]), Import(names=[alias(name='inspect')]), Import(names=[alias(name='warnings')]), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='Collection')], level=0), ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='Iterator')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Mapping')], level=0), ImportFrom(module='typing', names=[alias(name='MutableMapping')], level=0), ImportFrom(module='typing', names=[alias(name='NamedTuple')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='overload')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='Set')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='Type')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING')], level=0), ImportFrom(module='typing', names=[alias(name='TypeVar')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), ImportFrom(module='_code', names=[alias(name='getfslineno')], level=2), ImportFrom(module='compat', names=[alias(name='ascii_escaped')], level=2), ImportFrom(module='compat', names=[alias(name='final')], level=2), ImportFrom(module='compat', names=[alias(name='NOTSET')], level=2), ImportFrom(module='compat', names=[alias(name='NotSetType')], level=2), ImportFrom(module='_pytest.config', names=[alias(name='Config')], level=0), ImportFrom(module='_pytest.deprecated', names=[alias(name='check_ispytest')], level=0), ImportFrom(module='_pytest.outcomes', names=[alias(name='fail')], level=0), ImportFrom(module='_pytest.warning_types', names=[alias(name='PytestUnknownMarkWarning')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='nodes', names=[alias(name='Node')], level=2)], orelse=[]), Assign(targets=[Name(id='EMPTY_PARAMETERSET_OPTION', ctx=Store())], value=Constant(value='empty_parameter_set_mark')), FunctionDef(name='istestfunc', args=arguments(posonlyargs=[], args=[arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Call(func=Name(id='callable', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__name__'), Constant(value='<lambda>')], keywords=[]), ops=[NotEq()], comparators=[Constant(value='<lambda>')])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='get_empty_parameterset_mark', args=arguments(posonlyargs=[], args=[arg(arg='config', annotation=Name(id='Config', ctx=Load())), arg(arg='argnames', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='nodes', names=[alias(name='Collector')], level=2), Assign(targets=[Tuple(elts=[Name(id='fs', ctx=Store()), Name(id='lineno', ctx=Store())], ctx=Store())], value=Call(func=Name(id='getfslineno', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])), Assign(targets=[Name(id='reason', ctx=Store())], value=BinOp(left=Constant(value='got empty parameter set %r, function %s at %s:%d'), op=Mod(), right=Tuple(elts=[Name(id='argnames', ctx=Load()), Attribute(value=Name(id='func', ctx=Load()), attr='__name__', ctx=Load()), Name(id='fs', ctx=Load()), Name(id='lineno', ctx=Load())], ctx=Load()))), Assign(targets=[Name(id='requested_mark', ctx=Store())], value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='getini', ctx=Load()), args=[Name(id='EMPTY_PARAMETERSET_OPTION', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='requested_mark', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value=''), Constant(value=None), Constant(value='skip')], ctx=Load())]), body=[Assign(targets=[Name(id='mark', ctx=Store())], value=Call(func=Attribute(value=Name(id='MARK_GEN', ctx=Load()), attr='skip', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=Name(id='reason', ctx=Load()))]))], orelse=[If(test=Compare(left=Name(id='requested_mark', ctx=Load()), ops=[Eq()], comparators=[Constant(value='xfail')]), body=[Assign(targets=[Name(id='mark', ctx=Store())], value=Call(func=Attribute(value=Name(id='MARK_GEN', ctx=Load()), attr='xfail', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=Name(id='reason', ctx=Load())), keyword(arg='run', value=Constant(value=False))]))], orelse=[If(test=Compare(left=Name(id='requested_mark', ctx=Load()), ops=[Eq()], comparators=[Constant(value='fail_at_collect')]), body=[Assign(targets=[Name(id='f_name', ctx=Store())], value=Attribute(value=Name(id='func', ctx=Load()), attr='__name__', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='lineno', ctx=Store())], ctx=Store())], value=Call(func=Name(id='getfslineno', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])), Raise(exc=Call(func=Attribute(value=Name(id='Collector', ctx=Load()), attr='CollectError', ctx=Load()), args=[BinOp(left=Constant(value="Empty parameter set in '%s' at line %d"), op=Mod(), right=Tuple(elts=[Name(id='f_name', ctx=Load()), BinOp(left=Name(id='lineno', ctx=Load()), op=Add(), right=Constant(value=1))], ctx=Load()))], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='LookupError', ctx=Load()), args=[Name(id='requested_mark', ctx=Load())], keywords=[]))])])]), Return(value=Name(id='mark', ctx=Load()))], decorator_list=[], returns=Constant(value='MarkDecorator')), ClassDef(name='ParameterSet', bases=[Name(id='NamedTuple', ctx=Load())], keywords=[], body=[AnnAssign(target=Name(id='values', ctx=Store()), annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='object', ctx=Load()), Name(id='NotSetType', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='marks', ctx=Store()), annotation=Subscript(value=Name(id='Collection', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='MarkDecorator'), Constant(value='Mark')], ctx=Load()), ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='id', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='param', args=arguments(posonlyargs=[], args=[arg(arg='cls')], vararg=arg(arg='values', annotation=Name(id='object', ctx=Load())), kwonlyargs=[arg(arg='marks', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='MarkDecorator'), Subscript(value=Name(id='Collection', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='MarkDecorator'), Constant(value='Mark')], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='id', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Tuple(elts=[], ctx=Load()), Constant(value=None)], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='marks', ctx=Load()), Name(id='MarkDecorator', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='marks', ctx=Store())], value=Tuple(elts=[Name(id='marks', ctx=Load())], ctx=Load()))], orelse=[Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='marks', ctx=Load()), Attribute(value=Attribute(value=Name(id='collections', ctx=Load()), attr='abc', ctx=Load()), attr='Collection', ctx=Load())], keywords=[]))]), If(test=Compare(left=Name(id='id', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='id', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Expected id to be a string, got '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='id', ctx=Load())], keywords=[]), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='id', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='id', ctx=Store())], value=Call(func=Name(id='ascii_escaped', ctx=Load()), args=[Name(id='id', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='values', ctx=Load()), Name(id='marks', ctx=Load()), Name(id='id', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='ParameterSet')), FunctionDef(name='extract_from', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='parameterset', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='ParameterSet'), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='force_tuple', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value="Extract from an object or objects.\n\n        :param parameterset:\n            A legacy style parameterset that may or may not be a tuple,\n            and may or may not be wrapped into a mess of mark objects.\n\n        :param force_tuple:\n            Enforce tuple wrapping so single argument tuple values\n            don't get decomposed and break tests.\n        ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='parameterset', ctx=Load()), Name(id='cls', ctx=Load())], keywords=[]), body=[Return(value=Name(id='parameterset', ctx=Load()))], orelse=[]), If(test=Name(id='force_tuple', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='param', ctx=Load()), args=[Name(id='parameterset', ctx=Load())], keywords=[]))], orelse=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='parameterset', ctx=Load())], keywords=[keyword(arg='marks', value=List(elts=[], ctx=Load())), keyword(arg='id', value=Constant(value=None))]))])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='ParameterSet')), FunctionDef(name='_parse_parametrize_args', args=arguments(posonlyargs=[], args=[arg(arg='argnames', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='argvalues', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='ParameterSet'), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='argnames', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='argnames', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='argnames', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',')], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], is_async=0)])), Assign(targets=[Name(id='force_tuple', ctx=Store())], value=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='argnames', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]))], orelse=[Assign(targets=[Name(id='force_tuple', ctx=Store())], value=Constant(value=False))]), Return(value=Tuple(elts=[Name(id='argnames', ctx=Load()), Name(id='force_tuple', ctx=Load())], ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_parse_parametrize_parameters', args=arguments(posonlyargs=[], args=[arg(arg='argvalues', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='ParameterSet'), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='force_tuple', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=ListComp(elt=Call(func=Attribute(value=Name(id='ParameterSet', ctx=Load()), attr='extract_from', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='force_tuple', value=Name(id='force_tuple', ctx=Load()))]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='argvalues', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='ParameterSet'), ctx=Load())), FunctionDef(name='_for_parametrize', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='argnames', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='argvalues', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='ParameterSet'), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='func'), arg(arg='config', annotation=Name(id='Config', ctx=Load())), arg(arg='nodeid', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='argnames', ctx=Store()), Name(id='force_tuple', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_parse_parametrize_args', ctx=Load()), args=[Name(id='argnames', ctx=Load()), Name(id='argvalues', ctx=Load())], keywords=[])), Assign(targets=[Name(id='parameters', ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_parse_parametrize_parameters', ctx=Load()), args=[Name(id='argvalues', ctx=Load()), Name(id='force_tuple', ctx=Load())], keywords=[])), Delete(targets=[Name(id='argvalues', ctx=Del())]), If(test=Name(id='parameters', ctx=Load()), body=[For(target=Name(id='param', ctx=Store()), iter=Name(id='parameters', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='param', ctx=Load()), attr='values', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='argnames', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='{nodeid}: in "parametrize" the number of names ({names_len}):\n  {names}\nmust be equal to the number of values ({values_len}):\n  {values}')), Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[Call(func=Attribute(value=Name(id='msg', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='nodeid', value=Name(id='nodeid', ctx=Load())), keyword(arg='values', value=Attribute(value=Name(id='param', ctx=Load()), attr='values', ctx=Load())), keyword(arg='names', value=Name(id='argnames', ctx=Load())), keyword(arg='names_len', value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='argnames', ctx=Load())], keywords=[])), keyword(arg='values_len', value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='param', ctx=Load()), attr='values', ctx=Load())], keywords=[]))])], keywords=[keyword(arg='pytrace', value=Constant(value=False))]))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='mark', ctx=Store())], value=Call(func=Name(id='get_empty_parameterset_mark', ctx=Load()), args=[Name(id='config', ctx=Load()), Name(id='argnames', ctx=Load()), Name(id='func', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='ParameterSet', ctx=Load()), args=[], keywords=[keyword(arg='values', value=BinOp(left=Tuple(elts=[Name(id='NOTSET', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='argnames', ctx=Load())], keywords=[]))), keyword(arg='marks', value=List(elts=[Name(id='mark', ctx=Load())], ctx=Load())), keyword(arg='id', value=Constant(value=None))])], keywords=[]))]), Return(value=Tuple(elts=[Name(id='argnames', ctx=Load()), Name(id='parameters', ctx=Load())], ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='ParameterSet'), ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='Mark', bases=[], keywords=[], body=[Expr(value=Constant(value='A pytest mark.')), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='args', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Any', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='kwargs', ctx=Store()), annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='_param_ids_from', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='Mark'), ctx=Load()), value=Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='field', ctx=Load()), args=[], keywords=[keyword(arg='default', value=Constant(value=None)), keyword(arg='repr', value=Constant(value=False))]), simple=1), AnnAssign(target=Name(id='_param_ids_generated', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='field', ctx=Load()), args=[], keywords=[keyword(arg='default', value=Constant(value=None)), keyword(arg='repr', value=Constant(value=False))]), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='args', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Any', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='param_ids_from', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='Mark'), ctx=Load())), arg(arg='param_ids_generated', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='_ispytest', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=':meta private:')), Expr(value=Call(func=Name(id='check_ispytest', ctx=Load()), args=[Name(id='_ispytest', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__setattr__', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='name'), Name(id='name', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__setattr__', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='args'), Name(id='args', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__setattr__', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='kwargs'), Name(id='kwargs', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__setattr__', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='_param_ids_from'), Name(id='param_ids_from', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__setattr__', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='_param_ids_generated'), Name(id='param_ids_generated', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_has_param_ids', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Compare(left=Constant(value='ids'), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Load())]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load())], keywords=[]), ops=[GtE()], comparators=[Constant(value=4)])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='combined_with', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Constant(value='Mark'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param Mark other: The mark to combine with.\n        :rtype: Mark\n        ')), Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='name', ctx=Load())])), AnnAssign(target=Name(id='param_ids_from', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Mark', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='parametrize')]), body=[If(test=Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='_has_param_ids', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='param_ids_from', ctx=Store())], value=Name(id='other', ctx=Load()))], orelse=[If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_has_param_ids', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='param_ids_from', ctx=Store())], value=Name(id='self', ctx=Load()))], orelse=[])])], orelse=[]), Return(value=Call(func=Name(id='Mark', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load()), op=Add(), right=Attribute(value=Name(id='other', ctx=Load()), attr='args', ctx=Load())), Call(func=Name(id='dict', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Load())], keywords=[keyword(value=Attribute(value=Name(id='other', ctx=Load()), attr='kwargs', ctx=Load()))])], keywords=[keyword(arg='param_ids_from', value=Name(id='param_ids_from', ctx=Load())), keyword(arg='_ispytest', value=Constant(value=True))]))], decorator_list=[], returns=Constant(value='Mark'))], decorator_list=[Name(id='final', ctx=Load()), Call(func=Attribute(value=Name(id='dataclasses', ctx=Load()), attr='dataclass', ctx=Load()), args=[], keywords=[keyword(arg='frozen', value=Constant(value=True))])]), Assign(targets=[Name(id='Markable', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='Markable')], keywords=[keyword(arg='bound', value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), Name(id='type', ctx=Load())], ctx=Load()), ctx=Load()))])), ClassDef(name='MarkDecorator', bases=[], keywords=[], body=[Expr(value=Constant(value="A decorator for applying a mark on test functions and classes.\n\n    ``MarkDecorators`` are created with ``pytest.mark``::\n\n        mark1 = pytest.mark.NAME              # Simple MarkDecorator\n        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n\n    and can then be applied as decorators to test functions::\n\n        @mark2\n        def test_function():\n            pass\n\n    When a ``MarkDecorator`` is called, it does the following:\n\n    1. If called with a single class as its only positional argument and no\n       additional keyword arguments, it attaches the mark to the class so it\n       gets applied automatically to all test cases found in that class.\n\n    2. If called with a single function as its only positional argument and\n       no additional keyword arguments, it attaches the mark to the function,\n       containing all the arguments already stored internally in the\n       ``MarkDecorator``.\n\n    3. When called in any other case, it returns a new ``MarkDecorator``\n       instance with the original ``MarkDecorator``'s content updated with\n       the arguments passed to this call.\n\n    Note: The rules above prevent a ``MarkDecorator`` from storing only a\n    single function or class reference as its positional argument with no\n    additional keyword or positional arguments. You can work around this by\n    using `with_args()`.\n    ")), AnnAssign(target=Name(id='mark', ctx=Store()), annotation=Name(id='Mark', ctx=Load()), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mark', annotation=Name(id='Mark', ctx=Load()))], kwonlyargs=[arg(arg='_ispytest', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[]), body=[Expr(value=Constant(value=':meta private:')), Expr(value=Call(func=Name(id='check_ispytest', ctx=Load()), args=[Name(id='_ispytest', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mark', ctx=Store())], value=Name(id='mark', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Alias for mark.name.')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='mark', ctx=Load()), attr='name', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='args', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Alias for mark.args.')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='mark', ctx=Load()), attr='args', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Any', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())), FunctionDef(name='kwargs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Alias for mark.kwargs.')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='mark', ctx=Load()), attr='kwargs', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='markname', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=':meta private:')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='with_args', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Name(id='object', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='object', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n        ')), Assign(targets=[Name(id='mark', ctx=Store())], value=Call(func=Name(id='Mark', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[keyword(arg='_ispytest', value=Constant(value=True))])), Return(value=Call(func=Name(id='MarkDecorator', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='mark', ctx=Load()), attr='combined_with', ctx=Load()), args=[Name(id='mark', ctx=Load())], keywords=[])], keywords=[keyword(arg='_ispytest', value=Constant(value=True))]))], decorator_list=[], returns=Constant(value='MarkDecorator')), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='arg', annotation=Name(id='Markable', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Name(id='overload', ctx=Load())], returns=Name(id='Markable', ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Name(id='object', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='object', ctx=Load())), defaults=[]), body=[Pass()], decorator_list=[Name(id='overload', ctx=Load())], returns=Constant(value='MarkDecorator')), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args', annotation=Name(id='object', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='object', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Call the MarkDecorator.')), If(test=BoolOp(op=And(), values=[Name(id='args', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='kwargs', ctx=Load()))]), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='is_class', ctx=Store())], value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='isclass', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), BoolOp(op=Or(), values=[Call(func=Name(id='istestfunc', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), Name(id='is_class', ctx=Load())])]), body=[Expr(value=Call(func=Name(id='store_mark', ctx=Load()), args=[Name(id='func', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='mark', ctx=Load())], keywords=[])), Return(value=Name(id='func', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='with_args', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[Attribute(value=Name(id='dataclasses', ctx=Load()), attr='dataclass', ctx=Load())]), FunctionDef(name='get_unpacked_marks', args=arguments(posonlyargs=[], args=[arg(arg='obj', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='object', ctx=Load()), Name(id='type', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='consider_mro', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=True)], defaults=[]), body=[Expr(value=Constant(value='Obtain the unpacked marks that are stored on an object.\n\n    If obj is a class and consider_mro is true, return marks applied to\n    this class and all of its super-classes in MRO order. If consider_mro\n    is false, only return marks applied directly to this class.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='obj', ctx=Load()), Name(id='type', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='consider_mro', ctx=Load())), body=[Assign(targets=[Name(id='mark_lists', ctx=Store())], value=List(elts=[Call(func=Attribute(value=Attribute(value=Name(id='obj', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='pytestmark'), List(elts=[], ctx=Load())], keywords=[])], ctx=Load()))], orelse=[Assign(targets=[Name(id='mark_lists', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Attribute(value=Name(id='x', ctx=Load()), attr='__dict__', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='pytestmark'), List(elts=[], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='obj', ctx=Load()), attr='__mro__', ctx=Load()), ifs=[], is_async=0)]))]), Assign(targets=[Name(id='mark_list', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='item', ctx=Store()), iter=Name(id='mark_lists', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='item', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='mark_list', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='mark_list', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))])], orelse=[])], orelse=[Assign(targets=[Name(id='mark_attribute', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Constant(value='pytestmark'), List(elts=[], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='mark_attribute', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='mark_list', ctx=Store())], value=Name(id='mark_attribute', ctx=Load()))], orelse=[Assign(targets=[Name(id='mark_list', ctx=Store())], value=List(elts=[Name(id='mark_attribute', ctx=Load())], ctx=Load()))])]), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='normalize_mark_list', ctx=Load()), args=[Name(id='mark_list', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Mark', ctx=Load()), ctx=Load())), FunctionDef(name='normalize_mark_list', args=arguments(posonlyargs=[], args=[arg(arg='mark_list', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Mark', ctx=Load()), Name(id='MarkDecorator', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Normalize an iterable of Mark or MarkDecorator objects into a list of marks\n    by retrieving the `mark` attribute on MarkDecorator instances.\n\n    :param mark_list: marks to normalize\n    :returns: A new list of the extracted Mark objects\n    ')), For(target=Name(id='mark', ctx=Store()), iter=Name(id='mark_list', ctx=Load()), body=[Assign(targets=[Name(id='mark_obj', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='mark', ctx=Load()), Constant(value='mark'), Name(id='mark', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='mark_obj', ctx=Load()), Name(id='Mark', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='got '), FormattedValue(value=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='mark_obj', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' instead of Mark')])], keywords=[]))], orelse=[]), Expr(value=Yield(value=Name(id='mark_obj', ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Mark', ctx=Load()), ctx=Load())), FunctionDef(name='store_mark', args=arguments(posonlyargs=[], args=[arg(arg='obj'), arg(arg='mark', annotation=Name(id='Mark', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    ')), Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='mark', ctx=Load()), Name(id='Mark', ctx=Load())], keywords=[]), msg=Name(id='mark', ctx=Load())), Assign(targets=[Attribute(value=Name(id='obj', ctx=Load()), attr='pytestmark', ctx=Store())], value=List(elts=[Starred(value=Call(func=Name(id='get_unpacked_marks', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[keyword(arg='consider_mro', value=Constant(value=False))]), ctx=Load()), Name(id='mark', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Constant(value=None)), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='_pytest.scope', names=[alias(name='_ScopeName')], level=0), ClassDef(name='_SkipMarkDecorator', bases=[Name(id='MarkDecorator', ctx=Load())], keywords=[], body=[FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='arg', annotation=Name(id='Markable', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Name(id='Markable', ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='reason', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=Ellipsis)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Constant(value='MarkDecorator'))], decorator_list=[]), ClassDef(name='_SkipifMarkDecorator', bases=[Name(id='MarkDecorator', ctx=Load())], keywords=[], body=[FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='condition', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()))], vararg=arg(arg='conditions', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), kwonlyargs=[arg(arg='reason', annotation=Name(id='str', ctx=Load()))], kw_defaults=[Constant(value=Ellipsis)], defaults=[Constant(value=Ellipsis)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='MarkDecorator', ctx=Load()))], decorator_list=[]), ClassDef(name='_XfailMarkDecorator', bases=[Name(id='MarkDecorator', ctx=Load())], keywords=[], body=[FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='arg', annotation=Name(id='Markable', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Name(id='Markable', ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='condition', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()))], vararg=arg(arg='conditions', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), kwonlyargs=[arg(arg='reason', annotation=Name(id='str', ctx=Load())), arg(arg='run', annotation=Name(id='bool', ctx=Load())), arg(arg='raises', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='strict', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis)], defaults=[Constant(value=Ellipsis)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Name(id='MarkDecorator', ctx=Load()))], decorator_list=[]), ClassDef(name='_ParametrizeMarkDecorator', bases=[Name(id='MarkDecorator', ctx=Load())], keywords=[], body=[FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='argnames', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='argvalues', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParameterSet', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='indirect', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='ids', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value=None), Name(id='str', ctx=Load()), Name(id='float', ctx=Load()), Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Any', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='scope', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_ScopeName', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis)], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='MarkDecorator', ctx=Load()))], decorator_list=[]), ClassDef(name='_UsefixturesMarkDecorator', bases=[Name(id='MarkDecorator', ctx=Load())], keywords=[], body=[FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='fixtures', annotation=Name(id='str', ctx=Load())), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='MarkDecorator', ctx=Load()))], decorator_list=[]), ClassDef(name='_FilterwarningsMarkDecorator', bases=[Name(id='MarkDecorator', ctx=Load())], keywords=[], body=[FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='filters', annotation=Name(id='str', ctx=Load())), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='MarkDecorator', ctx=Load()))], decorator_list=[])], orelse=[]), ClassDef(name='MarkGenerator', bases=[], keywords=[], body=[Expr(value=Constant(value="Factory for :class:`MarkDecorator` objects - exposed as\n    a ``pytest.mark`` singleton instance.\n\n    Example::\n\n         import pytest\n\n         @pytest.mark.slowtest\n         def test_function():\n            pass\n\n    applies a 'slowtest' :class:`Mark` on ``test_function``.\n    ")), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[AnnAssign(target=Name(id='skip', ctx=Store()), annotation=Name(id='_SkipMarkDecorator', ctx=Load()), simple=1), AnnAssign(target=Name(id='skipif', ctx=Store()), annotation=Name(id='_SkipifMarkDecorator', ctx=Load()), simple=1), AnnAssign(target=Name(id='xfail', ctx=Store()), annotation=Name(id='_XfailMarkDecorator', ctx=Load()), simple=1), AnnAssign(target=Name(id='parametrize', ctx=Store()), annotation=Name(id='_ParametrizeMarkDecorator', ctx=Load()), simple=1), AnnAssign(target=Name(id='usefixtures', ctx=Store()), annotation=Name(id='_UsefixturesMarkDecorator', ctx=Load()), simple=1), AnnAssign(target=Name(id='filterwarnings', ctx=Store()), annotation=Name(id='_FilterwarningsMarkDecorator', ctx=Load()), simple=1)], orelse=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[arg(arg='_ispytest', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[]), body=[Expr(value=Call(func=Name(id='check_ispytest', ctx=Load()), args=[Name(id='_ispytest', ctx=Load())], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_config', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Config', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Generate a new :class:`MarkDecorator` with the given name.')), If(test=Compare(left=Subscript(value=Name(id='name', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Constant(value='_')]), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[Constant(value='Marker name must NOT start with underscore')], keywords=[]))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_config', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Load())]), body=[For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_config', ctx=Load()), attr='getini', ctx=Load()), args=[Constant(value='markers')], keywords=[]), body=[Assign(targets=[Name(id='marker', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':')], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='(')], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='marker', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Load())]), body=[If(test=BoolOp(op=Or(), values=[Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_config', ctx=Load()), attr='option', ctx=Load()), attr='strict_markers', ctx=Load()), Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_config', ctx=Load()), attr='option', ctx=Load()), attr='strict', ctx=Load())]), body=[Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=114), Constant(value=' not found in `markers` configuration option')])], keywords=[keyword(arg='pytrace', value=Constant(value=False))]))], orelse=[]), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='parameterize'), Constant(value='parametrise'), Constant(value='parameterise')], ctx=Load())]), body=[Assign(targets=[Name(id='__tracebackhide__', ctx=Store())], value=Constant(value=True)), Expr(value=Call(func=Name(id='fail', ctx=Load()), args=[JoinedStr(values=[Constant(value="Unknown '"), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value="' mark, did you mean 'parametrize'?")])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[BinOp(left=Constant(value='Unknown pytest.mark.%s - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html'), op=Mod(), right=Name(id='name', ctx=Load())), Name(id='PytestUnknownMarkWarning', ctx=Load()), Constant(value=2)], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='MarkDecorator', ctx=Load()), args=[Call(func=Name(id='Mark', ctx=Load()), args=[Name(id='name', ctx=Load()), Tuple(elts=[], ctx=Load()), Dict(keys=[], values=[])], keywords=[keyword(arg='_ispytest', value=Constant(value=True))])], keywords=[keyword(arg='_ispytest', value=Constant(value=True))]))], decorator_list=[], returns=Name(id='MarkDecorator', ctx=Load()))], decorator_list=[Name(id='final', ctx=Load())]), Assign(targets=[Name(id='MARK_GEN', ctx=Store())], value=Call(func=Name(id='MarkGenerator', ctx=Load()), args=[], keywords=[keyword(arg='_ispytest', value=Constant(value=True))])), ClassDef(name='NodeKeywords', bases=[Subscript(value=Name(id='MutableMapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='node'), Constant(value='parent'), Constant(value='_markers')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='node', annotation=Constant(value='Node'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='node', ctx=Store())], value=Name(id='node', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Store())], value=Attribute(value=Name(id='node', ctx=Load()), attr='parent', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Store())], value=Dict(keys=[Attribute(value=Name(id='node', ctx=Load()), attr='name', ctx=Load())], values=[Constant(value=True)]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise()], orelse=[]), Return(value=Subscript(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), attr='keywords', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='__setitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key', annotation=Name(id='str', ctx=Load())), arg(arg='value', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='key', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Load())]), BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='key', ctx=Load()), ops=[In()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), attr='keywords', ctx=Load())])])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwds', annotation=Name(id='Any', ctx=Load())), defaults=[Tuple(elts=[], ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='kwds', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__delitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot delete key in keywords dict')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=YieldFrom(value=Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Load()))), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[For(target=Name(id='keyword', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), attr='keywords', ctx=Load()), body=[If(test=Compare(left=Name(id='keyword', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_markers', ctx=Load())]), body=[Expr(value=Yield(value=Name(id='keyword', ctx=Load())))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='__len__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Constant(value=1), generators=[comprehension(target=Name(id='keyword', ctx=Store()), iter=Name(id='self', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<NodeKeywords for node '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='node', ctx=Load()), conversion=-1), Constant(value='>')]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[Name(id='final', ctx=Load())])], type_ignores=[])