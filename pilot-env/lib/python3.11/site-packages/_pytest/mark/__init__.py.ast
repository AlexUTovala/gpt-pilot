Module(body=[Expr(value=Constant(value='Generic mechanism for marking and selecting python functions.')), Import(names=[alias(name='dataclasses')]), ImportFrom(module='typing', names=[alias(name='AbstractSet')], level=0), ImportFrom(module='typing', names=[alias(name='Collection')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), ImportFrom(module='expression', names=[alias(name='Expression')], level=1), ImportFrom(module='expression', names=[alias(name='ParseError')], level=1), ImportFrom(module='structures', names=[alias(name='EMPTY_PARAMETERSET_OPTION')], level=1), ImportFrom(module='structures', names=[alias(name='get_empty_parameterset_mark')], level=1), ImportFrom(module='structures', names=[alias(name='Mark')], level=1), ImportFrom(module='structures', names=[alias(name='MARK_GEN')], level=1), ImportFrom(module='structures', names=[alias(name='MarkDecorator')], level=1), ImportFrom(module='structures', names=[alias(name='MarkGenerator')], level=1), ImportFrom(module='structures', names=[alias(name='ParameterSet')], level=1), ImportFrom(module='_pytest.config', names=[alias(name='Config')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='ExitCode')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='hookimpl')], level=0), ImportFrom(module='_pytest.config', names=[alias(name='UsageError')], level=0), ImportFrom(module='_pytest.config.argparsing', names=[alias(name='Parser')], level=0), ImportFrom(module='_pytest.stash', names=[alias(name='StashKey')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='_pytest.nodes', names=[alias(name='Item')], level=0)], orelse=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='MARK_GEN'), Constant(value='Mark'), Constant(value='MarkDecorator'), Constant(value='MarkGenerator'), Constant(value='ParameterSet'), Constant(value='get_empty_parameterset_mark')], ctx=Load())), Assign(targets=[Name(id='old_mark_config_key', ctx=Store())], value=Call(func=Subscript(value=Name(id='StashKey', ctx=Load()), slice=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Config', ctx=Load()), ctx=Load()), ctx=Load()), args=[], keywords=[])), FunctionDef(name='param', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='values', annotation=Name(id='object', ctx=Load())), kwonlyargs=[arg(arg='marks', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='MarkDecorator', ctx=Load()), Subscript(value=Name(id='Collection', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='MarkDecorator', ctx=Load()), Name(id='Mark', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='id', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Tuple(elts=[], ctx=Load()), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value='Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n            "test_input,expected",\n            [\n                ("3+5", 8),\n                pytest.param("6*9", 42, marks=pytest.mark.xfail),\n            ],\n        )\n        def test_eval(test_input, expected):\n            assert eval(test_input) == expected\n\n    :param values: Variable args of the values of the parameter set, in order.\n    :param marks: A single mark or a list of marks to be applied to this parameter set.\n    :param id: The id to attribute to this parameter set.\n    ')), Return(value=Call(func=Attribute(value=Name(id='ParameterSet', ctx=Load()), attr='param', ctx=Load()), args=[Starred(value=Name(id='values', ctx=Load()), ctx=Load())], keywords=[keyword(arg='marks', value=Name(id='marks', ctx=Load())), keyword(arg='id', value=Name(id='id', ctx=Load()))]))], decorator_list=[], returns=Name(id='ParameterSet', ctx=Load())), FunctionDef(name='pytest_addoption', args=arguments(posonlyargs=[], args=[arg(arg='parser', annotation=Name(id='Parser', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='group', ctx=Store())], value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='getgroup', ctx=Load()), args=[Constant(value='general')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='_addoption', ctx=Load()), args=[Constant(value='-k')], keywords=[keyword(arg='action', value=Constant(value='store')), keyword(arg='dest', value=Constant(value='keyword')), keyword(arg='default', value=Constant(value='')), keyword(arg='metavar', value=Constant(value='EXPRESSION')), keyword(arg='help', value=Constant(value="Only run tests which match the given substring expression. An expression is a Python evaluatable expression where all names are substring-matched against test names and their parent classes. Example: -k 'test_method or test_other' matches all test functions and classes whose name contains 'test_method' or 'test_other', while -k 'not test_method' matches those that don't contain 'test_method' in their names. -k 'not test_method and not test_other' will eliminate the matches. Additionally keywords are matched to classes and functions containing extra names in their 'extra_keyword_matches' set, as well as functions which have names assigned directly to them. The matching is case-insensitive."))])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='_addoption', ctx=Load()), args=[Constant(value='-m')], keywords=[keyword(arg='action', value=Constant(value='store')), keyword(arg='dest', value=Constant(value='markexpr')), keyword(arg='default', value=Constant(value='')), keyword(arg='metavar', value=Constant(value='MARKEXPR')), keyword(arg='help', value=Constant(value="Only run tests matching given mark expression. For example: -m 'mark1 and not mark2'."))])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='addoption', ctx=Load()), args=[Constant(value='--markers')], keywords=[keyword(arg='action', value=Constant(value='store_true')), keyword(arg='help', value=Constant(value='show markers (builtin, plugin and per-project ones).'))])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='addini', ctx=Load()), args=[Constant(value='markers'), Constant(value='Markers for test functions'), Constant(value='linelist')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='addini', ctx=Load()), args=[Name(id='EMPTY_PARAMETERSET_OPTION', ctx=Load()), Constant(value='Default marker for empty parametersets')], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='pytest_cmdline_main', args=arguments(posonlyargs=[], args=[arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Import(names=[alias(name='_pytest.config')]), If(test=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='option', ctx=Load()), attr='markers', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='_do_configure', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='tw', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='_pytest', ctx=Load()), attr='config', ctx=Load()), attr='create_terminal_writer', ctx=Load()), args=[Name(id='config', ctx=Load())], keywords=[])), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='getini', ctx=Load()), args=[Constant(value='markers')], keywords=[]), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':'), Constant(value=1)], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Name(id='parts', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='rest', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), body=Subscript(value=Name(id='parts', ctx=Load()), slice=Constant(value=1), ctx=Load()), orelse=Constant(value=''))), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='write', ctx=Load()), args=[BinOp(left=Constant(value='@pytest.mark.%s:'), op=Mod(), right=Name(id='name', ctx=Load()))], keywords=[keyword(arg='bold', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='line', ctx=Load()), args=[Name(id='rest', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='tw', ctx=Load()), attr='line', ctx=Load()), args=[], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='_ensure_unconfigure', ctx=Load()), args=[], keywords=[])), Return(value=Constant(value=0))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[Call(func=Name(id='hookimpl', ctx=Load()), args=[], keywords=[keyword(arg='tryfirst', value=Constant(value=True))])], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='ExitCode', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), ClassDef(name='KeywordMatcher', bases=[], keywords=[], body=[Expr(value=Constant(value="A matcher for keywords.\n\n    Given a list of names, matches any substring of one of these names. The\n    string inclusion check is case-insensitive.\n\n    Will match on the name of colitem, including the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_keyword_matches' set of\n    any item, as well as names directly assigned to test functions.\n    ")), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='_names')], ctx=Load())), AnnAssign(target=Name(id='_names', ctx=Store()), annotation=Subscript(value=Name(id='AbstractSet', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='from_item', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='item', annotation=Constant(value='Item'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mapped_names', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Import(names=[alias(name='pytest')]), For(target=Name(id='node', ctx=Store()), iter=Call(func=Attribute(value=Name(id='item', ctx=Load()), attr='listchain', ctx=Load()), args=[], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Attribute(value=Name(id='pytest', ctx=Load()), attr='Session', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='mapped_names', ctx=Load()), attr='add', ctx=Load()), args=[Attribute(value=Name(id='node', ctx=Load()), attr='name', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='mapped_names', ctx=Load()), attr='update', ctx=Load()), args=[Call(func=Attribute(value=Name(id='item', ctx=Load()), attr='listextrakeywords', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='function_obj', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='item', ctx=Load()), Constant(value='function'), Constant(value=None)], keywords=[])), If(test=Name(id='function_obj', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='mapped_names', ctx=Load()), attr='update', ctx=Load()), args=[Attribute(value=Name(id='function_obj', ctx=Load()), attr='__dict__', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='mapped_names', ctx=Load()), attr='update', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='mark', ctx=Load()), attr='name', ctx=Load()), generators=[comprehension(target=Name(id='mark', ctx=Store()), iter=Call(func=Attribute(value=Name(id='item', ctx=Load()), attr='iter_markers', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='mapped_names', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='KeywordMatcher')), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='subname', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='subname', ctx=Store())], value=Call(func=Attribute(value=Name(id='subname', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='names', ctx=Store())], value=GeneratorExp(elt=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='name', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_names', ctx=Load()), ifs=[], is_async=0)])), For(target=Name(id='name', ctx=Store()), iter=Name(id='names', ctx=Load()), body=[If(test=Compare(left=Name(id='subname', ctx=Load()), ops=[In()], comparators=[Name(id='name', ctx=Load())]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Constant(value=False))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[Attribute(value=Name(id='dataclasses', ctx=Load()), attr='dataclass', ctx=Load())]), FunctionDef(name='deselect_by_keyword', args=arguments(posonlyargs=[], args=[arg(arg='items', annotation=Constant(value='List[Item]')), arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='keywordexpr', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='option', ctx=Load()), attr='keyword', ctx=Load()), attr='lstrip', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='keywordexpr', ctx=Load())), body=[Return()], orelse=[]), Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Name(id='_parse_expression', ctx=Load()), args=[Name(id='keywordexpr', ctx=Load()), Constant(value="Wrong expression passed to '-k'")], keywords=[])), Assign(targets=[Name(id='remaining', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='deselected', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='colitem', ctx=Store()), iter=Name(id='items', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='expr', ctx=Load()), attr='evaluate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='KeywordMatcher', ctx=Load()), attr='from_item', ctx=Load()), args=[Name(id='colitem', ctx=Load())], keywords=[])], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='deselected', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='colitem', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='remaining', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='colitem', ctx=Load())], keywords=[]))])], orelse=[]), If(test=Name(id='deselected', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='hook', ctx=Load()), attr='pytest_deselected', ctx=Load()), args=[], keywords=[keyword(arg='items', value=Name(id='deselected', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='items', ctx=Load()), slice=Slice(), ctx=Store())], value=Name(id='remaining', ctx=Load()))], orelse=[])], decorator_list=[], returns=Constant(value=None)), ClassDef(name='MarkMatcher', bases=[], keywords=[], body=[Expr(value=Constant(value='A matcher for markers which are present.\n\n    Tries to match on any marker names, attached to the given colitem.\n    ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='own_mark_names')], ctx=Load())), AnnAssign(target=Name(id='own_mark_names', ctx=Store()), annotation=Subscript(value=Name(id='AbstractSet', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='from_item', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='item', annotation=Constant(value='Item'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mark_names', ctx=Store())], value=SetComp(elt=Attribute(value=Name(id='mark', ctx=Load()), attr='name', ctx=Load()), generators=[comprehension(target=Name(id='mark', ctx=Store()), iter=Call(func=Attribute(value=Name(id='item', ctx=Load()), attr='iter_markers', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='mark_names', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='MarkMatcher')), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='own_mark_names', ctx=Load())]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[Attribute(value=Name(id='dataclasses', ctx=Load()), attr='dataclass', ctx=Load())]), FunctionDef(name='deselect_by_mark', args=arguments(posonlyargs=[], args=[arg(arg='items', annotation=Constant(value='List[Item]')), arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='matchexpr', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='option', ctx=Load()), attr='markexpr', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='matchexpr', ctx=Load())), body=[Return()], orelse=[]), Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Name(id='_parse_expression', ctx=Load()), args=[Name(id='matchexpr', ctx=Load()), Constant(value="Wrong expression passed to '-m'")], keywords=[])), AnnAssign(target=Name(id='remaining', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Item', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='deselected', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Item', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Name(id='item', ctx=Store()), iter=Name(id='items', ctx=Load()), body=[If(test=Call(func=Attribute(value=Name(id='expr', ctx=Load()), attr='evaluate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='MarkMatcher', ctx=Load()), attr='from_item', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='remaining', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='deselected', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))])], orelse=[]), If(test=Name(id='deselected', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='hook', ctx=Load()), attr='pytest_deselected', ctx=Load()), args=[], keywords=[keyword(arg='items', value=Name(id='deselected', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='items', ctx=Load()), slice=Slice(), ctx=Store())], value=Name(id='remaining', ctx=Load()))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_parse_expression', args=arguments(posonlyargs=[], args=[arg(arg='expr', annotation=Name(id='str', ctx=Load())), arg(arg='exc_message', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Call(func=Attribute(value=Name(id='Expression', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='UsageError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='exc_message', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='expr', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]), cause=Constant(value=None))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='Expression', ctx=Load())), FunctionDef(name='pytest_collection_modifyitems', args=arguments(posonlyargs=[], args=[arg(arg='items', annotation=Constant(value='List[Item]')), arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Name(id='deselect_by_keyword', ctx=Load()), args=[Name(id='items', ctx=Load()), Name(id='config', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='deselect_by_mark', ctx=Load()), args=[Name(id='items', ctx=Load()), Name(id='config', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='pytest_configure', args=arguments(posonlyargs=[], args=[arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='config', ctx=Load()), attr='stash', ctx=Load()), slice=Name(id='old_mark_config_key', ctx=Load()), ctx=Store())], value=Attribute(value=Name(id='MARK_GEN', ctx=Load()), attr='_config', ctx=Load())), Assign(targets=[Attribute(value=Name(id='MARK_GEN', ctx=Load()), attr='_config', ctx=Store())], value=Name(id='config', ctx=Load())), Assign(targets=[Name(id='empty_parameterset', ctx=Store())], value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='getini', ctx=Load()), args=[Name(id='EMPTY_PARAMETERSET_OPTION', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='empty_parameterset', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value='skip'), Constant(value='xfail'), Constant(value='fail_at_collect'), Constant(value=None), Constant(value='')], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='UsageError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{!s} must be one of skip, xfail or fail_at_collect but it is {!r}'), attr='format', ctx=Load()), args=[Name(id='EMPTY_PARAMETERSET_OPTION', ctx=Load()), Name(id='empty_parameterset', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='pytest_unconfigure', args=arguments(posonlyargs=[], args=[arg(arg='config', annotation=Name(id='Config', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='MARK_GEN', ctx=Load()), attr='_config', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='config', ctx=Load()), attr='stash', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='old_mark_config_key', ctx=Load()), Constant(value=None)], keywords=[]))], decorator_list=[], returns=Constant(value=None))], type_ignores=[])