Module(body=[Import(names=[alias(name='atexit')]), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='fnmatch')]), Import(names=[alias(name='importlib.util')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='os')]), Import(names=[alias(name='shutil')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='types')]), Import(names=[alias(name='uuid')]), Import(names=[alias(name='warnings')]), ImportFrom(module='enum', names=[alias(name='Enum')], level=0), ImportFrom(module='errno', names=[alias(name='EBADF')], level=0), ImportFrom(module='errno', names=[alias(name='ELOOP')], level=0), ImportFrom(module='errno', names=[alias(name='ENOENT')], level=0), ImportFrom(module='errno', names=[alias(name='ENOTDIR')], level=0), ImportFrom(module='functools', names=[alias(name='partial')], level=0), ImportFrom(module='os.path', names=[alias(name='expanduser')], level=0), ImportFrom(module='os.path', names=[alias(name='expandvars')], level=0), ImportFrom(module='os.path', names=[alias(name='isabs')], level=0), ImportFrom(module='os.path', names=[alias(name='sep')], level=0), ImportFrom(module='pathlib', names=[alias(name='Path')], level=0), ImportFrom(module='pathlib', names=[alias(name='PurePath')], level=0), ImportFrom(module='posixpath', names=[alias(name='sep', asname='posix_sep')], level=0), ImportFrom(module='types', names=[alias(name='ModuleType')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='Iterator')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Set')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='Type')], level=0), ImportFrom(module='typing', names=[alias(name='TypeVar')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), ImportFrom(module='_pytest.compat', names=[alias(name='assert_never')], level=0), ImportFrom(module='_pytest.outcomes', names=[alias(name='skip')], level=0), ImportFrom(module='_pytest.warning_types', names=[alias(name='PytestWarning')], level=0), Assign(targets=[Name(id='LOCK_TIMEOUT', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Constant(value=60), op=Mult(), right=Constant(value=60)), op=Mult(), right=Constant(value=24)), op=Mult(), right=Constant(value=3))), Assign(targets=[Name(id='_AnyPurePath', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_AnyPurePath')], keywords=[keyword(arg='bound', value=Name(id='PurePath', ctx=Load()))])), Assign(targets=[Name(id='_IGNORED_ERRORS', ctx=Store())], value=Tuple(elts=[Name(id='ENOENT', ctx=Load()), Name(id='ENOTDIR', ctx=Load()), Name(id='EBADF', ctx=Load()), Name(id='ELOOP', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='_IGNORED_WINERRORS', ctx=Store())], value=Tuple(elts=[Constant(value=21), Constant(value=1921)], ctx=Load())), FunctionDef(name='_ignore_error', args=arguments(posonlyargs=[], args=[arg(arg='exception')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='exception', ctx=Load()), Constant(value='errno'), Constant(value=None)], keywords=[]), ops=[In()], comparators=[Name(id='_IGNORED_ERRORS', ctx=Load())]), Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='exception', ctx=Load()), Constant(value='winerror'), Constant(value=None)], keywords=[]), ops=[In()], comparators=[Name(id='_IGNORED_WINERRORS', ctx=Load())])]))], decorator_list=[]), FunctionDef(name='get_lock_path', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='_AnyPurePath', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='joinpath', ctx=Load()), args=[Constant(value='.lock')], keywords=[]))], decorator_list=[], returns=Name(id='_AnyPurePath', ctx=Load())), FunctionDef(name='on_rm_rf_error', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='path', annotation=Name(id='str', ctx=Load())), arg(arg='excinfo', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='BaseException', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Type', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()), Name(id='BaseException', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='types', ctx=Load()), attr='TracebackType', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='start_path', annotation=Name(id='Path', ctx=Load()))], kw_defaults=[None], defaults=[]), body=[Expr(value=Constant(value='Handle known read-only errors during rmtree.\n\n    The returned value is used only by our own tests.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='excinfo', ctx=Load()), Name(id='BaseException', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='exc', ctx=Store())], value=Name(id='excinfo', ctx=Load()))], orelse=[Assign(targets=[Name(id='exc', ctx=Store())], value=Subscript(value=Name(id='excinfo', ctx=Load()), slice=Constant(value=1), ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='exc', ctx=Load()), Name(id='FileNotFoundError', ctx=Load())], keywords=[]), body=[Return(value=Constant(value=False))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='exc', ctx=Load()), Name(id='PermissionError', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Name(id='PytestWarning', ctx=Load()), args=[JoinedStr(values=[Constant(value='(rm_rf) error removing '), FormattedValue(value=Name(id='path', ctx=Load()), conversion=-1), Constant(value='\n'), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='exc', ctx=Load())], keywords=[]), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='exc', ctx=Load()), conversion=-1)])], keywords=[])], keywords=[])), Return(value=Constant(value=False))], orelse=[]), If(test=Compare(left=Name(id='func', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Attribute(value=Name(id='os', ctx=Load()), attr='rmdir', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='unlink', ctx=Load())], ctx=Load())]), body=[If(test=Compare(left=Name(id='func', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Attribute(value=Name(id='os', ctx=Load()), attr='open', ctx=Load())], ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Name(id='PytestWarning', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='(rm_rf) unknown function {} when removing {}:\n{}: {}'), attr='format', ctx=Load()), args=[Name(id='func', ctx=Load()), Name(id='path', ctx=Load()), Call(func=Name(id='type', ctx=Load()), args=[Name(id='exc', ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), Return(value=Constant(value=False))], orelse=[]), Import(names=[alias(name='stat')]), FunctionDef(name='chmod_rw', args=arguments(posonlyargs=[], args=[arg(arg='p', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mode', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='stat', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[]), attr='st_mode', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='chmod', ctx=Load()), args=[Name(id='p', ctx=Load()), BinOp(left=BinOp(left=Name(id='mode', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='stat', ctx=Load()), attr='S_IRUSR', ctx=Load())), op=BitOr(), right=Attribute(value=Name(id='stat', ctx=Load()), attr='S_IWUSR', ctx=Load()))], keywords=[]))], decorator_list=[], returns=Constant(value=None)), Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='is_file', ctx=Load()), args=[], keywords=[]), body=[For(target=Name(id='parent', ctx=Store()), iter=Attribute(value=Name(id='p', ctx=Load()), attr='parents', ctx=Load()), body=[Expr(value=Call(func=Name(id='chmod_rw', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='parent', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='parent', ctx=Load()), ops=[Eq()], comparators=[Name(id='start_path', ctx=Load())]), body=[Break()], orelse=[])], orelse=[])], orelse=[]), Expr(value=Call(func=Name(id='chmod_rw', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='func', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Return(value=Constant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='ensure_extended_length_path', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the extended-length version of a path (Windows).\n\n    On Windows, by default, the maximum length of a path (MAX_PATH) is 260\n    characters, and operations on paths longer than that fail. But it is possible\n    to overcome this by converting the path to "extended-length" form before\n    performing the operation:\n    https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation\n\n    On Windows, this function returns the extended-length absolute version of path.\n    On other platforms it returns path unchanged.\n    ')), If(test=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='win32')], keywords=[]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='resolve', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Call(func=Name(id='get_extended_length_path_str', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='path', ctx=Load()))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='get_extended_length_path_str', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Convert a path to a Windows extended length path.')), Assign(targets=[Name(id='long_path_prefix', ctx=Store())], value=Constant(value='\\\\?\\')), Assign(targets=[Name(id='unc_long_path_prefix', ctx=Store())], value=Constant(value='\\\\?\\UNC\\')), If(test=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='startswith', ctx=Load()), args=[Tuple(elts=[Name(id='long_path_prefix', ctx=Load()), Name(id='unc_long_path_prefix', ctx=Load())], ctx=Load())], keywords=[]), body=[Return(value=Name(id='path', ctx=Load()))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='\\\\')], keywords=[]), body=[Return(value=BinOp(left=Name(id='unc_long_path_prefix', ctx=Load()), op=Add(), right=Subscript(value=Name(id='path', ctx=Load()), slice=Slice(lower=Constant(value=2)), ctx=Load())))], orelse=[]), Return(value=BinOp(left=Name(id='long_path_prefix', ctx=Load()), op=Add(), right=Name(id='path', ctx=Load())))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='rm_rf', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove the path contents recursively, even if some elements\n    are read-only.')), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='ensure_extended_length_path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='onerror', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='on_rm_rf_error', ctx=Load())], keywords=[keyword(arg='start_path', value=Name(id='path', ctx=Load()))])), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=12)], ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='rmtree', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[keyword(arg='onexc', value=Name(id='onerror', ctx=Load()))]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='rmtree', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[keyword(arg='onerror', value=Name(id='onerror', ctx=Load()))]))])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='find_prefixed', args=arguments(posonlyargs=[], args=[arg(arg='root', annotation=Name(id='Path', ctx=Load())), arg(arg='prefix', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find all elements in root that begin with the prefix, case insensitive.')), Assign(targets=[Name(id='l_prefix', ctx=Store())], value=Call(func=Attribute(value=Name(id='prefix', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), For(target=Name(id='x', ctx=Store()), iter=Call(func=Attribute(value=Name(id='root', ctx=Load()), attr='iterdir', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='x', ctx=Load()), attr='name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Name(id='l_prefix', ctx=Load())], keywords=[]), body=[Expr(value=Yield(value=Name(id='x', ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load())), FunctionDef(name='extract_suffixes', args=arguments(posonlyargs=[], args=[arg(arg='iter', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='PurePath', ctx=Load()), ctx=Load())), arg(arg='prefix', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the parts of the paths following the prefix.\n\n    :param iter: Iterator over path names.\n    :param prefix: Expected prefix of the path names.\n    ')), Assign(targets=[Name(id='p_len', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prefix', ctx=Load())], keywords=[])), For(target=Name(id='p', ctx=Store()), iter=Name(id='iter', ctx=Load()), body=[Expr(value=Yield(value=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='name', ctx=Load()), slice=Slice(lower=Name(id='p_len', ctx=Load())), ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='find_suffixes', args=arguments(posonlyargs=[], args=[arg(arg='root', annotation=Name(id='Path', ctx=Load())), arg(arg='prefix', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Combine find_prefixes and extract_suffixes.')), Return(value=Call(func=Name(id='extract_suffixes', ctx=Load()), args=[Call(func=Name(id='find_prefixed', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='prefix', ctx=Load())], keywords=[]), Name(id='prefix', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='parse_num', args=arguments(posonlyargs=[], args=[arg(arg='maybe_num')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parse number path suffixes, returns -1 on error.')), Try(body=[Return(value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='maybe_num', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=UnaryOp(op=USub(), operand=Constant(value=1)))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='_force_symlink', args=arguments(posonlyargs=[], args=[arg(arg='root', annotation=Name(id='Path', ctx=Load())), arg(arg='target', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='PurePath', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='link_to', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Path', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Helper to create the current symlink.\n\n    It's full of race conditions that are reasonably OK to ignore\n    for the context of best effort linking to the latest test run.\n\n    The presumption being that in case of much parallelism\n    the inaccuracy is going to be acceptable.\n    ")), Assign(targets=[Name(id='current_symlink', ctx=Store())], value=Call(func=Attribute(value=Name(id='root', ctx=Load()), attr='joinpath', ctx=Load()), args=[Name(id='target', ctx=Load())], keywords=[])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='current_symlink', ctx=Load()), attr='unlink', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='current_symlink', ctx=Load()), attr='symlink_to', ctx=Load()), args=[Name(id='link_to', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='make_numbered_dir', args=arguments(posonlyargs=[], args=[arg(arg='root', annotation=Name(id='Path', ctx=Load())), arg(arg='prefix', annotation=Name(id='str', ctx=Load())), arg(arg='mode', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=448)]), body=[Expr(value=Constant(value='Create a directory with an increased number as suffix for the given prefix.')), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=10)], keywords=[]), body=[Assign(targets=[Name(id='max_existing', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='parse_num', ctx=Load()), Call(func=Name(id='find_suffixes', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='prefix', ctx=Load())], keywords=[])], keywords=[])], keywords=[keyword(arg='default', value=UnaryOp(op=USub(), operand=Constant(value=1)))])), Assign(targets=[Name(id='new_number', ctx=Store())], value=BinOp(left=Name(id='max_existing', ctx=Load()), op=Add(), right=Constant(value=1))), Assign(targets=[Name(id='new_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='root', ctx=Load()), attr='joinpath', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='new_number', ctx=Load()), conversion=-1)])], keywords=[])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='new_path', ctx=Load()), attr='mkdir', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Pass()])], orelse=[Expr(value=Call(func=Name(id='_force_symlink', ctx=Load()), args=[Name(id='root', ctx=Load()), BinOp(left=Name(id='prefix', ctx=Load()), op=Add(), right=Constant(value='current')), Name(id='new_path', ctx=Load())], keywords=[])), Return(value=Name(id='new_path', ctx=Load()))], finalbody=[])], orelse=[Raise(exc=Call(func=Name(id='OSError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='could not create numbered dir with prefix {prefix} in {root} after 10 tries'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='prefix', value=Name(id='prefix', ctx=Load())), keyword(arg='root', value=Name(id='root', ctx=Load()))])], keywords=[]))])], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='create_cleanup_lock', args=arguments(posonlyargs=[], args=[arg(arg='p', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a lock to prevent premature folder cleanup.')), Assign(targets=[Name(id='lock_path', ctx=Store())], value=Call(func=Name(id='get_lock_path', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='fd', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='open', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='lock_path', ctx=Load())], keywords=[]), BinOp(left=BinOp(left=Attribute(value=Name(id='os', ctx=Load()), attr='O_WRONLY', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='os', ctx=Load()), attr='O_CREAT', ctx=Load())), op=BitOr(), right=Attribute(value=Name(id='os', ctx=Load()), attr='O_EXCL', ctx=Load())), Constant(value=420)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='FileExistsError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='OSError', ctx=Load()), args=[JoinedStr(values=[Constant(value='cannot create lockfile in '), FormattedValue(value=Name(id='p', ctx=Load()), conversion=-1)])], keywords=[]), cause=Name(id='e', ctx=Load()))])], orelse=[Assign(targets=[Name(id='pid', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getpid', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='spid', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[]), attr='encode', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='fd', ctx=Load()), Name(id='spid', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='close', ctx=Load()), args=[Name(id='fd', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='lock_path', ctx=Load()), attr='is_file', ctx=Load()), args=[], keywords=[])), body=[Raise(exc=Call(func=Name(id='OSError', ctx=Load()), args=[Constant(value='lock path got renamed after successful creation')], keywords=[]))], orelse=[]), Return(value=Name(id='lock_path', ctx=Load()))], finalbody=[])], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='register_cleanup_lock_removal', args=arguments(posonlyargs=[], args=[arg(arg='lock_path', annotation=Name(id='Path', ctx=Load())), arg(arg='register')], kwonlyargs=[], kw_defaults=[], defaults=[Attribute(value=Name(id='atexit', ctx=Load()), attr='register', ctx=Load())]), body=[Expr(value=Constant(value='Register a cleanup function for removing a lock, by default on atexit.')), Assign(targets=[Name(id='pid', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getpid', ctx=Load()), args=[], keywords=[])), FunctionDef(name='cleanup_on_exit', args=arguments(posonlyargs=[], args=[arg(arg='lock_path', annotation=Name(id='Path', ctx=Load())), arg(arg='original_pid', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='lock_path', ctx=Load()), Name(id='pid', ctx=Load())]), body=[Assign(targets=[Name(id='current_pid', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getpid', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='current_pid', ctx=Load()), ops=[NotEq()], comparators=[Name(id='original_pid', ctx=Load())]), body=[Return()], orelse=[]), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='lock_path', ctx=Load()), attr='unlink', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], decorator_list=[], returns=Constant(value=None)), Return(value=Call(func=Name(id='register', ctx=Load()), args=[Name(id='cleanup_on_exit', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='maybe_delete_a_numbered_dir', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Remove a numbered directory if its lock can be obtained and it does\n    not seem to be in use.')), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='ensure_extended_length_path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='lock_path', ctx=Store())], value=Constant(value=None)), Try(body=[Assign(targets=[Name(id='lock_path', ctx=Store())], value=Call(func=Name(id='create_cleanup_lock', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='parent', ctx=Store())], value=Attribute(value=Name(id='path', ctx=Load()), attr='parent', ctx=Load())), Assign(targets=[Name(id='garbage', ctx=Store())], value=Call(func=Attribute(value=Name(id='parent', ctx=Load()), attr='joinpath', ctx=Load()), args=[JoinedStr(values=[Constant(value='garbage-'), FormattedValue(value=Call(func=Attribute(value=Name(id='uuid', ctx=Load()), attr='uuid4', ctx=Load()), args=[], keywords=[]), conversion=-1)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='garbage', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='rm_rf', ctx=Load()), args=[Name(id='garbage', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Return()])], orelse=[], finalbody=[If(test=Compare(left=Name(id='lock_path', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='lock_path', ctx=Load()), attr='unlink', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[])])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='ensure_deletable', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='Path', ctx=Load())), arg(arg='consider_lock_dead_if_created_before', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if `path` is deletable based on whether the lock file is expired.')), If(test=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='is_symlink', ctx=Load()), args=[], keywords=[]), body=[Return(value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='lock', ctx=Store())], value=Call(func=Name(id='get_lock_path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Try(body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='lock', ctx=Load()), attr='is_file', ctx=Load()), args=[], keywords=[])), body=[Return(value=Constant(value=True))], orelse=[])], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[]), Try(body=[Assign(targets=[Name(id='lock_time', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='lock', ctx=Load()), attr='stat', ctx=Load()), args=[], keywords=[]), attr='st_mtime', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[If(test=Compare(left=Name(id='lock_time', ctx=Load()), ops=[Lt()], comparators=[Name(id='consider_lock_dead_if_created_before', ctx=Load())]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='suppress', ctx=Load()), args=[Name(id='OSError', ctx=Load())], keywords=[]))], body=[Expr(value=Call(func=Attribute(value=Name(id='lock', ctx=Load()), attr='unlink', ctx=Load()), args=[], keywords=[])), Return(value=Constant(value=True))])], orelse=[]), Return(value=Constant(value=False))], finalbody=[])], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='try_cleanup', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='Path', ctx=Load())), arg(arg='consider_lock_dead_if_created_before', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Try to cleanup a folder if we can ensure it's deletable.")), If(test=Call(func=Name(id='ensure_deletable', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='consider_lock_dead_if_created_before', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='maybe_delete_a_numbered_dir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='cleanup_candidates', args=arguments(posonlyargs=[], args=[arg(arg='root', annotation=Name(id='Path', ctx=Load())), arg(arg='prefix', annotation=Name(id='str', ctx=Load())), arg(arg='keep', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='List candidates for numbered directories to be removed - follows py.path.')), Assign(targets=[Name(id='max_existing', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='parse_num', ctx=Load()), Call(func=Name(id='find_suffixes', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='prefix', ctx=Load())], keywords=[])], keywords=[])], keywords=[keyword(arg='default', value=UnaryOp(op=USub(), operand=Constant(value=1)))])), Assign(targets=[Name(id='max_delete', ctx=Store())], value=BinOp(left=Name(id='max_existing', ctx=Load()), op=Sub(), right=Name(id='keep', ctx=Load()))), Assign(targets=[Name(id='paths', ctx=Store())], value=Call(func=Name(id='find_prefixed', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='prefix', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='paths', ctx=Store()), Name(id='paths2', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='tee', ctx=Load()), args=[Name(id='paths', ctx=Load())], keywords=[])), Assign(targets=[Name(id='numbers', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='parse_num', ctx=Load()), Call(func=Name(id='extract_suffixes', ctx=Load()), args=[Name(id='paths2', ctx=Load()), Name(id='prefix', ctx=Load())], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='path', ctx=Store()), Name(id='number', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='paths', ctx=Load()), Name(id='numbers', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='number', ctx=Load()), ops=[LtE()], comparators=[Name(id='max_delete', ctx=Load())]), body=[Expr(value=Yield(value=Name(id='path', ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load())), FunctionDef(name='cleanup_dead_symlinks', args=arguments(posonlyargs=[], args=[arg(arg='root', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='left_dir', ctx=Store()), iter=Call(func=Attribute(value=Name(id='root', ctx=Load()), attr='iterdir', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='left_dir', ctx=Load()), attr='is_symlink', ctx=Load()), args=[], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='left_dir', ctx=Load()), attr='resolve', ctx=Load()), args=[], keywords=[]), attr='exists', ctx=Load()), args=[], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='left_dir', ctx=Load()), attr='unlink', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='cleanup_numbered_dir', args=arguments(posonlyargs=[], args=[arg(arg='root', annotation=Name(id='Path', ctx=Load())), arg(arg='prefix', annotation=Name(id='str', ctx=Load())), arg(arg='keep', annotation=Name(id='int', ctx=Load())), arg(arg='consider_lock_dead_if_created_before', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Cleanup for lock driven numbered directories.')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='root', ctx=Load()), attr='exists', ctx=Load()), args=[], keywords=[])), body=[Return()], orelse=[]), For(target=Name(id='path', ctx=Store()), iter=Call(func=Name(id='cleanup_candidates', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='prefix', ctx=Load()), Name(id='keep', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='try_cleanup', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='consider_lock_dead_if_created_before', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='path', ctx=Store()), iter=Call(func=Attribute(value=Name(id='root', ctx=Load()), attr='glob', ctx=Load()), args=[Constant(value='garbage-*')], keywords=[]), body=[Expr(value=Call(func=Name(id='try_cleanup', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='consider_lock_dead_if_created_before', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='cleanup_dead_symlinks', ctx=Load()), args=[Name(id='root', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='make_numbered_dir_with_cleanup', args=arguments(posonlyargs=[], args=[arg(arg='root', annotation=Name(id='Path', ctx=Load())), arg(arg='prefix', annotation=Name(id='str', ctx=Load())), arg(arg='keep', annotation=Name(id='int', ctx=Load())), arg(arg='lock_timeout', annotation=Name(id='float', ctx=Load())), arg(arg='mode', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create a numbered dir with a cleanup lock and remove old ones.')), Assign(targets=[Name(id='e', ctx=Store())], value=Constant(value=None)), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=10)], keywords=[]), body=[Try(body=[Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Name(id='make_numbered_dir', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='prefix', ctx=Load()), Name(id='mode', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='keep', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='lock_path', ctx=Store())], value=Call(func=Name(id='create_cleanup_lock', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='register_cleanup_lock_removal', ctx=Load()), args=[Name(id='lock_path', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='exc', body=[Assign(targets=[Name(id='e', ctx=Store())], value=Name(id='exc', ctx=Load()))])], orelse=[Assign(targets=[Name(id='consider_lock_dead_if_created_before', ctx=Store())], value=BinOp(left=Attribute(value=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='stat', ctx=Load()), args=[], keywords=[]), attr='st_mtime', ctx=Load()), op=Sub(), right=Name(id='lock_timeout', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='atexit', ctx=Load()), attr='register', ctx=Load()), args=[Name(id='cleanup_numbered_dir', ctx=Load()), Name(id='root', ctx=Load()), Name(id='prefix', ctx=Load()), Name(id='keep', ctx=Load()), Name(id='consider_lock_dead_if_created_before', ctx=Load())], keywords=[])), Return(value=Name(id='p', ctx=Load()))], finalbody=[])], orelse=[]), Assert(test=Compare(left=Name(id='e', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Raise(exc=Name(id='e', ctx=Load()))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='resolve_from_str', args=arguments(posonlyargs=[], args=[arg(arg='input', annotation=Name(id='str', ctx=Load())), arg(arg='rootpath', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='input', ctx=Store())], value=Call(func=Name(id='expanduser', ctx=Load()), args=[Name(id='input', ctx=Load())], keywords=[])), Assign(targets=[Name(id='input', ctx=Store())], value=Call(func=Name(id='expandvars', ctx=Load()), args=[Name(id='input', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isabs', ctx=Load()), args=[Name(id='input', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='input', ctx=Load())], keywords=[]))], orelse=[Return(value=Call(func=Attribute(value=Name(id='rootpath', ctx=Load()), attr='joinpath', ctx=Load()), args=[Name(id='input', ctx=Load())], keywords=[]))])], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='fnmatch_ex', args=arguments(posonlyargs=[], args=[arg(arg='pattern', annotation=Name(id='str', ctx=Load())), arg(arg='path', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='A port of FNMatcher from py.path.common which works with PurePath() instances.\n\n    The difference between this algorithm and PurePath.match() is that the\n    latter matches "**" glob expressions for each part of the path, while\n    this algorithm uses the whole path instead.\n\n    For example:\n        "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"\n        with this algorithm, but not with PurePath.match().\n\n    This algorithm was ported to keep backward-compatibility with existing\n    settings which assume paths match according this logic.\n\n    References:\n    * https://bugs.python.org/issue29249\n    * https://bugs.python.org/issue34731\n    ')), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='PurePath', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='iswin32', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='win')], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='iswin32', ctx=Load()), Compare(left=Name(id='sep', ctx=Load()), ops=[NotIn()], comparators=[Name(id='pattern', ctx=Load())]), Compare(left=Name(id='posix_sep', ctx=Load()), ops=[In()], comparators=[Name(id='pattern', ctx=Load())])]), body=[Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='pattern', ctx=Load()), attr='replace', ctx=Load()), args=[Name(id='posix_sep', ctx=Load()), Name(id='sep', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='sep', ctx=Load()), ops=[NotIn()], comparators=[Name(id='pattern', ctx=Load())]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='path', ctx=Load()), attr='name', ctx=Load()))], orelse=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='is_absolute', ctx=Load()), args=[], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isabs', ctx=Load()), args=[Name(id='pattern', ctx=Load())], keywords=[]))]), body=[Assign(targets=[Name(id='pattern', ctx=Store())], value=JoinedStr(values=[Constant(value='*'), FormattedValue(value=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='pattern', ctx=Load()), conversion=-1)]))], orelse=[])]), Return(value=Call(func=Attribute(value=Name(id='fnmatch', ctx=Load()), attr='fnmatch', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='pattern', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='parts', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='sep', ctx=Load())], keywords=[])), Return(value=SetComp(elt=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='sep', ctx=Load()), attr='join', ctx=Load()), args=[Subscript(value=Name(id='parts', ctx=Load()), slice=Slice(upper=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load())], keywords=[]), Name(id='sep', ctx=Load())]), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[])], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='symlink_or_skip', args=arguments(posonlyargs=[], args=[arg(arg='src'), arg(arg='dst')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Make a symlink, or skip the test in case symlinks are not supported.')), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='symlink', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='src', ctx=Load())], keywords=[]), Call(func=Name(id='str', ctx=Load()), args=[Name(id='dst', ctx=Load())], keywords=[])], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='skip', ctx=Load()), args=[JoinedStr(values=[Constant(value='symlinks not supported: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), ClassDef(name='ImportMode', bases=[Name(id='Enum', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Possible values for `mode` parameter of `import_path`.')), Assign(targets=[Name(id='prepend', ctx=Store())], value=Constant(value='prepend')), Assign(targets=[Name(id='append', ctx=Store())], value=Constant(value='append')), Assign(targets=[Name(id='importlib', ctx=Store())], value=Constant(value='importlib'))], decorator_list=[]), ClassDef(name='ImportPathMismatchError', bases=[Name(id='ImportError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised on import_path() if there is a mismatch of __file__\'s.\n\n    This can happen when `import_path` is called multiple times with different filenames that has\n    the same basename but reside in packages\n    (for example "/tests1/test_foo.py" and "/tests2/test_foo.py").\n    '))], decorator_list=[]), FunctionDef(name='import_path', args=arguments(posonlyargs=[], args=[arg(arg='p', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='mode', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ImportMode', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='root', annotation=Name(id='Path', ctx=Load()))], kw_defaults=[Attribute(value=Name(id='ImportMode', ctx=Load()), attr='prepend', ctx=Load()), None], defaults=[]), body=[Expr(value=Constant(value='Import and return a module from the given path, which can be a file (a module) or\n    a directory (a package).\n\n    The import mechanism used is controlled by the `mode` parameter:\n\n    * `mode == ImportMode.prepend`: the directory containing the module (or package, taking\n      `__init__.py` files into account) will be put at the *start* of `sys.path` before\n      being imported with `importlib.import_module`.\n\n    * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended\n      to the end of `sys.path`, if not already in `sys.path`.\n\n    * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`\n      to import the module, which avoids having to muck with `sys.path` at all. It effectively\n      allows having same-named test modules in different places.\n\n    :param root:\n        Used as an anchor when mode == ImportMode.importlib to obtain\n        a unique name for the module being imported so it can safely be stored\n        into ``sys.modules``.\n\n    :raises ImportPathMismatchError:\n        If after importing the given `path` and the module `__file__`\n        are different. Only raised in `prepend` and `append` modes.\n    ')), Assign(targets=[Name(id='mode', ctx=Store())], value=Call(func=Name(id='ImportMode', ctx=Load()), args=[Name(id='mode', ctx=Load())], keywords=[])), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='p', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='exists', ctx=Load()), args=[], keywords=[])), body=[Raise(exc=Call(func=Name(id='ImportError', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='mode', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='ImportMode', ctx=Load()), attr='importlib', ctx=Load())]), body=[Assign(targets=[Name(id='module_name', ctx=Store())], value=Call(func=Name(id='module_name_from_path', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='root', ctx=Load())], keywords=[])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='suppress', ctx=Load()), args=[Name(id='KeyError', ctx=Load())], keywords=[]))], body=[Return(value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='module_name', ctx=Load()), ctx=Load()))]), For(target=Name(id='meta_importer', ctx=Store()), iter=Attribute(value=Name(id='sys', ctx=Load()), attr='meta_path', ctx=Load()), body=[Assign(targets=[Name(id='spec', ctx=Store())], value=Call(func=Attribute(value=Name(id='meta_importer', ctx=Load()), attr='find_spec', ctx=Load()), args=[Name(id='module_name', ctx=Load()), List(elts=[Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='path', ctx=Load()), attr='parent', ctx=Load())], keywords=[])], ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='spec', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Break()], orelse=[])], orelse=[Assign(targets=[Name(id='spec', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='util', ctx=Load()), attr='spec_from_file_location', ctx=Load()), args=[Name(id='module_name', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[]))]), If(test=Compare(left=Name(id='spec', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ImportError', ctx=Load()), args=[JoinedStr(values=[Constant(value="Can't find module "), FormattedValue(value=Name(id='module_name', ctx=Load()), conversion=-1), Constant(value=' at location '), FormattedValue(value=Name(id='path', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='mod', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='util', ctx=Load()), attr='module_from_spec', ctx=Load()), args=[Name(id='spec', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='module_name', ctx=Load()), ctx=Store())], value=Name(id='mod', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='spec', ctx=Load()), attr='loader', ctx=Load()), attr='exec_module', ctx=Load()), args=[Name(id='mod', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='insert_missing_modules', ctx=Load()), args=[Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), Name(id='module_name', ctx=Load())], keywords=[])), Return(value=Name(id='mod', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='pkg_path', ctx=Store())], value=Call(func=Name(id='resolve_package_path', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='pkg_path', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='pkg_root', ctx=Store())], value=Attribute(value=Name(id='pkg_path', ctx=Load()), attr='parent', ctx=Load())), Assign(targets=[Name(id='names', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='with_suffix', ctx=Load()), args=[Constant(value='')], keywords=[]), attr='relative_to', ctx=Load()), args=[Name(id='pkg_root', ctx=Load())], keywords=[]), attr='parts', ctx=Load())], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='names', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), ops=[Eq()], comparators=[Constant(value='__init__')]), body=[Expr(value=Call(func=Attribute(value=Name(id='names', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='module_name', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Name(id='names', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='pkg_root', ctx=Store())], value=Attribute(value=Name(id='path', ctx=Load()), attr='parent', ctx=Load())), Assign(targets=[Name(id='module_name', ctx=Store())], value=Attribute(value=Name(id='path', ctx=Load()), attr='stem', ctx=Load()))]), If(test=Compare(left=Name(id='mode', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='ImportMode', ctx=Load()), attr='append', ctx=Load())]), body=[If(test=Compare(left=Call(func=Name(id='str', ctx=Load()), args=[Name(id='pkg_root', ctx=Load())], keywords=[]), ops=[NotIn()], comparators=[Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='pkg_root', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[If(test=Compare(left=Name(id='mode', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='ImportMode', ctx=Load()), attr='prepend', ctx=Load())]), body=[If(test=Compare(left=Call(func=Name(id='str', ctx=Load()), args=[Name(id='pkg_root', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), slice=Constant(value=0), ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Call(func=Name(id='str', ctx=Load()), args=[Name(id='pkg_root', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[Expr(value=Call(func=Name(id='assert_never', ctx=Load()), args=[Name(id='mode', ctx=Load())], keywords=[]))])]), Expr(value=Call(func=Attribute(value=Name(id='importlib', ctx=Load()), attr='import_module', ctx=Load()), args=[Name(id='module_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='mod', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='modules', ctx=Load()), slice=Name(id='module_name', ctx=Load()), ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='path', ctx=Load()), attr='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__init__.py')]), body=[Return(value=Name(id='mod', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='ignore', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='PY_IGNORE_IMPORTMISMATCH'), Constant(value='')], keywords=[])), If(test=Compare(left=Name(id='ignore', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='1')]), body=[Assign(targets=[Name(id='module_file', ctx=Store())], value=Attribute(value=Name(id='mod', ctx=Load()), attr='__file__', ctx=Load())), If(test=Compare(left=Name(id='module_file', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ImportPathMismatchError', ctx=Load()), args=[Name(id='module_name', ctx=Load()), Name(id='module_file', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='module_file', ctx=Load()), attr='endswith', ctx=Load()), args=[Tuple(elts=[Constant(value='.pyc'), Constant(value='.pyo')], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='module_file', ctx=Store())], value=Subscript(value=Name(id='module_file', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='module_file', ctx=Load()), attr='endswith', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), op=Add(), right=Constant(value='__init__.py'))], keywords=[]), body=[Assign(targets=[Name(id='module_file', ctx=Store())], value=Subscript(value=Name(id='module_file', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Call(func=Name(id='len', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='os', ctx=Load()), attr='sep', ctx=Load()), op=Add(), right=Constant(value='__init__.py'))], keywords=[]))), ctx=Load()))], orelse=[]), Try(body=[Assign(targets=[Name(id='is_same', ctx=Store())], value=Call(func=Name(id='_is_same', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), Name(id='module_file', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Assign(targets=[Name(id='is_same', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[]), If(test=UnaryOp(op=Not(), operand=Name(id='is_same', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ImportPathMismatchError', ctx=Load()), args=[Name(id='module_name', ctx=Load()), Name(id='module_file', ctx=Load()), Name(id='path', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='mod', ctx=Load()))], decorator_list=[], returns=Name(id='ModuleType', ctx=Load())), If(test=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='win')], keywords=[]), body=[FunctionDef(name='_is_same', args=arguments(posonlyargs=[], args=[arg(arg='f1', annotation=Name(id='str', ctx=Load())), arg(arg='f2', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='f1', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='Path', ctx=Load()), args=[Name(id='f2', ctx=Load())], keywords=[])]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='samefile', ctx=Load()), args=[Name(id='f1', ctx=Load()), Name(id='f2', ctx=Load())], keywords=[])]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], orelse=[FunctionDef(name='_is_same', args=arguments(posonlyargs=[], args=[arg(arg='f1', annotation=Name(id='str', ctx=Load())), arg(arg='f2', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='samefile', ctx=Load()), args=[Name(id='f1', ctx=Load()), Name(id='f2', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))]), FunctionDef(name='module_name_from_path', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='Path', ctx=Load())), arg(arg='root', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return a dotted module name based on the given path, anchored on root.\n\n    For example: path="projects/src/tests/test_foo.py" and root="/projects", the\n    resulting module name will be "src.tests.test_foo".\n    ')), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='with_suffix', ctx=Load()), args=[Constant(value='')], keywords=[])), Try(body=[Assign(targets=[Name(id='relative_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='relative_to', ctx=Load()), args=[Name(id='root', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Assign(targets=[Name(id='path_parts', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='path', ctx=Load()), attr='parts', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()))])], orelse=[Assign(targets=[Name(id='path_parts', ctx=Store())], value=Attribute(value=Name(id='relative_path', ctx=Load()), attr='parts', ctx=Load()))], finalbody=[]), If(test=Compare(left=Subscript(value=Name(id='path_parts', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), ops=[Eq()], comparators=[Constant(value='__init__')]), body=[Assign(targets=[Name(id='path_parts', ctx=Store())], value=Subscript(value=Name(id='path_parts', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Name(id='path_parts', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='insert_missing_modules', args=arguments(posonlyargs=[], args=[arg(arg='modules', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ModuleType', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='module_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n\n    When we want to import a module as "src.tests.test_foo" for example, we need\n    to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",\n    otherwise "src.tests.test_foo" is not importable by ``__import__``.\n    ')), Assign(targets=[Name(id='module_parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='module_name', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), AnnAssign(target=Name(id='child_module', ctx=Store()), annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ModuleType', ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), AnnAssign(target=Name(id='module', ctx=Store()), annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ModuleType', ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), AnnAssign(target=Name(id='child_name', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Constant(value=''), simple=1), While(test=Name(id='module_name', ctx=Load()), body=[If(test=Compare(left=Name(id='module_name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='modules', ctx=Load())]), body=[Try(body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='sys', ctx=Load()), attr='meta_path', ctx=Load())), body=[Raise(exc=Name(id='ModuleNotFoundError', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Attribute(value=Name(id='importlib', ctx=Load()), attr='import_module', ctx=Load()), args=[Name(id='module_name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ModuleNotFoundError', ctx=Load()), body=[Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Name(id='ModuleType', ctx=Load()), args=[Name(id='module_name', ctx=Load())], keywords=[keyword(arg='doc', value=Constant(value="Empty module created by pytest's importmode=importlib."))]))])], orelse=[], finalbody=[])], orelse=[Assign(targets=[Name(id='module', ctx=Store())], value=Subscript(value=Name(id='modules', ctx=Load()), slice=Name(id='module_name', ctx=Load()), ctx=Load()))]), If(test=Name(id='child_module', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='module', ctx=Load()), Name(id='child_name', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='module', ctx=Load()), Name(id='child_name', ctx=Load()), Name(id='child_module', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='modules', ctx=Load()), slice=Name(id='module_name', ctx=Load()), ctx=Store())], value=Name(id='module', ctx=Load()))], orelse=[])], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='child_module', ctx=Store()), Name(id='child_name', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='module', ctx=Load()), Subscript(value=Call(func=Attribute(value=Name(id='module_name', ctx=Load()), attr='rpartition', ctx=Load()), args=[Constant(value='.')], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='module_parts', ctx=Load()), attr='pop', ctx=Load()), args=[UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[])), Assign(targets=[Name(id='module_name', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Name(id='module_parts', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='resolve_package_path', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n\n    Returns None if it can not be determined.\n    ')), Assign(targets=[Name(id='result', ctx=Store())], value=Constant(value=None)), For(target=Name(id='parent', ctx=Store()), iter=Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), args=[Tuple(elts=[Name(id='path', ctx=Load())], ctx=Load()), Attribute(value=Name(id='path', ctx=Load()), attr='parents', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='parent', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parent', ctx=Load()), attr='joinpath', ctx=Load()), args=[Constant(value='__init__.py')], keywords=[]), attr='is_file', ctx=Load()), args=[], keywords=[])), body=[Break()], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='parent', ctx=Load()), attr='name', ctx=Load()), attr='isidentifier', ctx=Load()), args=[], keywords=[])), body=[Break()], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Name(id='parent', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load())), FunctionDef(name='scandir', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Scan a directory recursively, in breadth-first order.\n\n    The returned entries are sorted.\n    ')), Assign(targets=[Name(id='entries', ctx=Store())], value=List(elts=[], ctx=Load())), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='scandir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), optional_vars=Name(id='s', ctx=Store()))], body=[For(target=Name(id='entry', ctx=Store()), iter=Name(id='s', ctx=Load()), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='entry', ctx=Load()), attr='is_file', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), name='err', body=[If(test=Call(func=Name(id='_ignore_error', ctx=Load()), args=[Name(id='err', ctx=Load())], keywords=[]), body=[Continue()], orelse=[]), Raise()])], orelse=[], finalbody=[]), Expr(value=Call(func=Attribute(value=Name(id='entries', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='entry', ctx=Load())], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='entries', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='entry')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Attribute(value=Name(id='entry', ctx=Load()), attr='name', ctx=Load())))])), Return(value=Name(id='entries', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='os.DirEntry[str]'), ctx=Load())), FunctionDef(name='visit', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='os.PathLike[str]')], ctx=Load()), ctx=Load())), arg(arg='recurse', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Constant(value='os.DirEntry[str]')], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Walk a directory recursively, in breadth-first order.\n\n    The `recurse` predicate determines whether a directory is recursed.\n\n    Entries at each directory level are sorted.\n    ')), Assign(targets=[Name(id='entries', ctx=Store())], value=Call(func=Name(id='scandir', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Expr(value=YieldFrom(value=Name(id='entries', ctx=Load()))), For(target=Name(id='entry', ctx=Store()), iter=Name(id='entries', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='entry', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='recurse', ctx=Load()), args=[Name(id='entry', ctx=Load())], keywords=[])]), body=[Expr(value=YieldFrom(value=Call(func=Name(id='visit', ctx=Load()), args=[Attribute(value=Name(id='entry', ctx=Load()), attr='path', ctx=Load()), Name(id='recurse', ctx=Load())], keywords=[])))], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Constant(value='os.DirEntry[str]'), ctx=Load())), FunctionDef(name='absolutepath', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Path', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Convert a path to an absolute path using os.path.abspath.\n\n    Prefer this over Path.resolve() (see #6523).\n    Prefer this over Path.absolute() (not public, doesn't normalize).\n    ")), Return(value=Call(func=Name(id='Path', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='Path', ctx=Load())), FunctionDef(name='commonpath', args=arguments(posonlyargs=[], args=[arg(arg='path1', annotation=Name(id='Path', ctx=Load())), arg(arg='path2', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the common part shared with the other path, or None if there is\n    no common part.\n\n    If one path is relative and one is absolute, returns None.\n    ')), Try(body=[Return(value=Call(func=Name(id='Path', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='commonpath', ctx=Load()), args=[Tuple(elts=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='path1', ctx=Load())], keywords=[]), Call(func=Name(id='str', ctx=Load()), args=[Name(id='path2', ctx=Load())], keywords=[])], ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=Constant(value=None))])], orelse=[], finalbody=[])], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Path', ctx=Load()), ctx=Load())), FunctionDef(name='bestrelpath', args=arguments(posonlyargs=[], args=[arg(arg='directory', annotation=Name(id='Path', ctx=Load())), arg(arg='dest', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a string which is a relative path from directory to dest such\n    that directory/bestrelpath == dest.\n\n    The paths must be either both absolute or both relative.\n\n    If no such path can be determined, returns dest.\n    ')), Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='directory', ctx=Load()), Name(id='Path', ctx=Load())], keywords=[])), Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='dest', ctx=Load()), Name(id='Path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='dest', ctx=Load()), ops=[Eq()], comparators=[Name(id='directory', ctx=Load())]), body=[Return(value=Attribute(value=Name(id='os', ctx=Load()), attr='curdir', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='base', ctx=Store())], value=Call(func=Name(id='commonpath', ctx=Load()), args=[Name(id='directory', ctx=Load()), Name(id='dest', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='base', ctx=Load())), body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='reldirectory', ctx=Store())], value=Call(func=Attribute(value=Name(id='directory', ctx=Load()), attr='relative_to', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[])), Assign(targets=[Name(id='reldest', ctx=Store())], value=Call(func=Attribute(value=Name(id='dest', ctx=Load()), attr='relative_to', ctx=Load()), args=[Name(id='base', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Starred(value=BinOp(left=List(elts=[Attribute(value=Name(id='os', ctx=Load()), attr='pardir', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='reldirectory', ctx=Load()), attr='parts', ctx=Load())], keywords=[])), ctx=Load()), Starred(value=Attribute(value=Name(id='reldest', ctx=Load()), attr='parts', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='copytree', args=arguments(posonlyargs=[], args=[arg(arg='source', annotation=Name(id='Path', ctx=Load())), arg(arg='target', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Recursively copy a source directory to target.')), Assert(test=Call(func=Attribute(value=Name(id='source', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[])), For(target=Name(id='entry', ctx=Store()), iter=Call(func=Name(id='visit', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[keyword(arg='recurse', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='entry')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='entry', ctx=Load()), attr='is_symlink', ctx=Load()), args=[], keywords=[]))))]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Name(id='Path', ctx=Load()), args=[Name(id='entry', ctx=Load())], keywords=[])), Assign(targets=[Name(id='relpath', ctx=Store())], value=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='relative_to', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])), Assign(targets=[Name(id='newx', ctx=Store())], value=BinOp(left=Name(id='target', ctx=Load()), op=Div(), right=Name(id='relpath', ctx=Load()))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='newx', ctx=Load()), attr='parent', ctx=Load()), attr='mkdir', ctx=Load()), args=[], keywords=[keyword(arg='exist_ok', value=Constant(value=True))])), If(test=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='is_symlink', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='newx', ctx=Load()), attr='symlink_to', ctx=Load()), args=[Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='readlink', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='is_file', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='copyfile', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='newx', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='is_dir', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='newx', ctx=Load()), attr='mkdir', ctx=Load()), args=[], keywords=[keyword(arg='exist_ok', value=Constant(value=True))]))], orelse=[])])])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='safe_exists', args=arguments(posonlyargs=[], args=[arg(arg='p', annotation=Name(id='Path', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Like Path.exists(), but account for input arguments that might be too long (#11394).')), Try(body=[Return(value=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='exists', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ValueError', ctx=Load()), Name(id='OSError', ctx=Load())], ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='bool', ctx=Load()))], type_ignores=[])