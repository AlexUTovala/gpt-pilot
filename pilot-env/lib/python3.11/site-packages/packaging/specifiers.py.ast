Module(body=[Expr(value=Constant(value='\n.. testsetup::\n\n    from packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier\n    from packaging.version import Version\n')), Import(names=[alias(name='abc')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='re')]), ImportFrom(module='typing', names=[alias(name='Callable'), alias(name='Iterable'), alias(name='Iterator'), alias(name='List'), alias(name='Optional'), alias(name='Set'), alias(name='Tuple'), alias(name='TypeVar'), alias(name='Union')], level=0), ImportFrom(module='utils', names=[alias(name='canonicalize_version')], level=1), ImportFrom(module='version', names=[alias(name='Version')], level=1), Assign(targets=[Name(id='UnparsedVersion', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Version', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='UnparsedVersionVar', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='UnparsedVersionVar')], keywords=[keyword(arg='bound', value=Name(id='UnparsedVersion', ctx=Load()))])), Assign(targets=[Name(id='CallableOperator', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Version', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_coerce_version', args=arguments(posonlyargs=[], args=[arg(arg='version', annotation=Name(id='UnparsedVersion', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='version', ctx=Load()), Name(id='Version', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Name(id='Version', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='version', ctx=Load()))], decorator_list=[], returns=Name(id='Version', ctx=Load())), ClassDef(name='InvalidSpecifier', bases=[Name(id='ValueError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n\n    >>> Specifier("lolwat")\n    Traceback (most recent call last):\n        ...\n    packaging.specifiers.InvalidSpecifier: Invalid specifier: \'lolwat\'\n    '))], decorator_list=[]), ClassDef(name='BaseSpecifier', bases=[], keywords=[keyword(arg='metaclass', value=Attribute(value=Name(id='abc', ctx=Load()), attr='ABCMeta', ctx=Load()))], body=[FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returns the str representation of this Specifier-like object. This\n        should be representative of the Specifier itself.\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returns a hash value for this Specifier-like object.\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returns a boolean representing whether or not the two Specifier-like\n        objects are equal.\n\n        :param other: The other object to check against.\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='prereleases', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether or not pre-releases as a whole are allowed.\n\n        This can be set to either ``True`` or ``False`` to explicitly enable or disable\n        prereleases or it can be set to ``None`` (the default) to use default semantics.\n        '))], decorator_list=[Name(id='property', ctx=Load()), Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), FunctionDef(name='prereleases', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Setter for :attr:`prereleases`.\n\n        :param value: The value to set.\n        '))], decorator_list=[Attribute(value=Name(id='prereleases', ctx=Load()), attr='setter', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='contains', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item', annotation=Name(id='str', ctx=Load())), arg(arg='prereleases', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Determines if the given item is contained within this specifier.\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterable', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='UnparsedVersionVar', ctx=Load()), ctx=Load())), arg(arg='prereleases', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Takes an iterable of items and filters them so that only items which\n        are contained within this specifier are allowed in it.\n        '))], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='UnparsedVersionVar', ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='Specifier', bases=[Name(id='BaseSpecifier', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='This class abstracts handling of version specifiers.\n\n    .. tip::\n\n        It is generally not required to instantiate this manually. You should instead\n        prefer to work with :class:`SpecifierSet` instead, which can parse\n        comma-separated version specifiers (which is what package metadata contains).\n    ')), Assign(targets=[Name(id='_operator_regex_str', ctx=Store())], value=Constant(value='\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        ')), Assign(targets=[Name(id='_version_regex_str', ctx=Store())], value=Constant(value="\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \\s*\n                [^\\s;)]*  # The arbitrary version can be just about anything,\n                          # we match everything except for whitespace, a\n                          # semi-colon for marker support, and a closing paren\n                          # since versions can be enclosed in them.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n\n                # You cannot use a wild card and a pre-release, post-release, a dev or\n                # local version together so group them with a | and make them optional.\n                (?:\n                    \\.\\*  # Wild card syntax of .*\n                    |\n                    (?:                                  # pre release\n                        [-_\\.]?\n                        (alpha|beta|preview|pre|a|b|c|rc)\n                        [-_\\.]?\n                        [0-9]*\n                    )?\n                    (?:                                  # post release\n                        (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                    )?\n                    (?:[-_\\.]?dev[-_\\.]?[0-9]*)?         # dev release\n                    (?:\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*)? # local\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n        )\n        ")), Assign(targets=[Name(id='_regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value='^\\s*'), op=Add(), right=Name(id='_operator_regex_str', ctx=Load())), op=Add(), right=Name(id='_version_regex_str', ctx=Load())), op=Add(), right=Constant(value='\\s*$')), BinOp(left=Attribute(value=Name(id='re', ctx=Load()), attr='VERBOSE', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='_operators', ctx=Store())], value=Dict(keys=[Constant(value='~='), Constant(value='=='), Constant(value='!='), Constant(value='<='), Constant(value='>='), Constant(value='<'), Constant(value='>'), Constant(value='===')], values=[Constant(value='compatible'), Constant(value='equal'), Constant(value='not_equal'), Constant(value='less_than_equal'), Constant(value='greater_than_equal'), Constant(value='less_than'), Constant(value='greater_than'), Constant(value='arbitrary')])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='spec', annotation=Name(id='str', ctx=Load())), arg(arg='prereleases', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=None)]), body=[Expr(value=Constant(value='Initialize a Specifier instance.\n\n        :param spec:\n            The string representation of a specifier which will be parsed and\n            normalized before use.\n        :param prereleases:\n            This tells the specifier if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n        :raises InvalidSpecifier:\n            If the given specifier is invalid (i.e. bad syntax).\n        ')), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_regex', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='spec', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='match', ctx=Load())), body=[Raise(exc=Call(func=Name(id='InvalidSpecifier', ctx=Load()), args=[JoinedStr(values=[Constant(value="Invalid specifier: '"), FormattedValue(value=Name(id='spec', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[]))], orelse=[]), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_spec', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), value=Tuple(elts=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='operator')], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='version')], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[])], ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Store())], value=Name(id='prereleases', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='prereleases', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='operator', ctx=Store()), Name(id='version', ctx=Store())], ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_spec', ctx=Load())), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='=='), Constant(value='>='), Constant(value='<='), Constant(value='~='), Constant(value='===')], ctx=Load())]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[Eq()], comparators=[Constant(value='==')]), Call(func=Attribute(value=Name(id='version', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.*')], keywords=[])]), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Subscript(value=Name(id='version', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=2))), ctx=Load()))], orelse=[]), If(test=Attribute(value=Call(func=Name(id='Version', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]), attr='is_prerelease', ctx=Load()), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Constant(value=False))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='prereleases', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='prereleases', ctx=Load()), attr='setter', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='operator', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The operator of this specifier.\n\n        >>> Specifier("==1.2.3").operator\n        \'==\'\n        ')), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spec', ctx=Load()), slice=Constant(value=0), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='version', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The version of this specifier.\n\n        >>> Specifier("==1.2.3").version\n        \'1.2.3\'\n        ')), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spec', ctx=Load()), slice=Constant(value=1), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A representation of the Specifier that shows all internal state.\n\n        >>> Specifier('>=1.0.0')\n        <Specifier('>=1.0.0')>\n        >>> Specifier('>=1.0.0', prereleases=False)\n        <Specifier('>=1.0.0', prereleases=False)>\n        >>> Specifier('>=1.0.0', prereleases=True)\n        <Specifier('>=1.0.0', prereleases=True)>\n        ")), Assign(targets=[Name(id='pre', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=JoinedStr(values=[Constant(value=', prereleases='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='prereleases', ctx=Load()), conversion=114)]), orelse=Constant(value=''))), Return(value=JoinedStr(values=[Constant(value='<'), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='('), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), conversion=114), FormattedValue(value=Name(id='pre', ctx=Load()), conversion=-1), Constant(value=')>')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A string representation of the Specifier that can be round-tripped.\n\n        >>> str(Specifier('>=1.0.0'))\n        '>=1.0.0'\n        >>> str(Specifier('>=1.0.0', prereleases=False))\n        '>=1.0.0'\n        ")), Return(value=Call(func=Attribute(value=Constant(value='{}{}'), attr='format', ctx=Load()), args=[Starred(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spec', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_canonical_spec', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='canonical_version', ctx=Store())], value=Call(func=Name(id='canonicalize_version', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spec', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[keyword(arg='strip_trailing_zero', value=Compare(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spec', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[NotEq()], comparators=[Constant(value='~=')]))])), Return(value=Tuple(elts=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_spec', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='canonical_version', ctx=Load())], ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_canonical_spec', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether or not the two Specifier-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> Specifier("==1.2.3") == Specifier("== 1.2.3.0")\n        True\n        >>> (Specifier("==1.2.3", prereleases=False) ==\n        ...  Specifier("==1.2.3", prereleases=True))\n        True\n        >>> Specifier("==1.2.3") == "==1.2.3"\n        True\n        >>> Specifier("==1.2.3") == Specifier("==1.2.4")\n        False\n        >>> Specifier("==1.2.3") == Specifier("~=1.2.3")\n        False\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Try(body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='InvalidSpecifier', ctx=Load()), body=[Return(value=Name(id='NotImplemented', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[])]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_canonical_spec', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='_canonical_spec', ctx=Load())]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_get_operator', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='op', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='operator_callable', ctx=Store()), annotation=Name(id='CallableOperator', ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), JoinedStr(values=[Constant(value='_compare_'), FormattedValue(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_operators', ctx=Load()), slice=Name(id='op', ctx=Load()), ctx=Load()), conversion=-1)])], keywords=[]), simple=1), Return(value=Name(id='operator_callable', ctx=Load()))], decorator_list=[], returns=Name(id='CallableOperator', ctx=Load())), FunctionDef(name='_compare_compatible', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prospective', annotation=Name(id='Version', ctx=Load())), arg(arg='spec', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Subscript(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='takewhile', ctx=Load()), args=[Name(id='_is_not_suffix', ctx=Load()), Call(func=Name(id='_version_split', ctx=Load()), args=[Name(id='spec', ctx=Load())], keywords=[])], keywords=[])], keywords=[]), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[])), AugAssign(target=Name(id='prefix', ctx=Store()), op=Add(), value=Constant(value='.*')), Return(value=BoolOp(op=And(), values=[Call(func=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_operator', ctx=Load()), args=[Constant(value='>=')], keywords=[]), args=[Name(id='prospective', ctx=Load()), Name(id='spec', ctx=Load())], keywords=[]), Call(func=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_operator', ctx=Load()), args=[Constant(value='==')], keywords=[]), args=[Name(id='prospective', ctx=Load()), Name(id='prefix', ctx=Load())], keywords=[])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compare_equal', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prospective', annotation=Name(id='Version', ctx=Load())), arg(arg='spec', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Attribute(value=Name(id='spec', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.*')], keywords=[]), body=[Assign(targets=[Name(id='normalized_prospective', ctx=Store())], value=Call(func=Name(id='canonicalize_version', ctx=Load()), args=[Attribute(value=Name(id='prospective', ctx=Load()), attr='public', ctx=Load())], keywords=[keyword(arg='strip_trailing_zero', value=Constant(value=False))])), Assign(targets=[Name(id='normalized_spec', ctx=Store())], value=Call(func=Name(id='canonicalize_version', ctx=Load()), args=[Subscript(value=Name(id='spec', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=2))), ctx=Load())], keywords=[keyword(arg='strip_trailing_zero', value=Constant(value=False))])), Assign(targets=[Name(id='split_spec', ctx=Store())], value=Call(func=Name(id='_version_split', ctx=Load()), args=[Name(id='normalized_spec', ctx=Load())], keywords=[])), Assign(targets=[Name(id='split_prospective', ctx=Store())], value=Call(func=Name(id='_version_split', ctx=Load()), args=[Name(id='normalized_prospective', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='padded_prospective', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_pad_version', ctx=Load()), args=[Name(id='split_prospective', ctx=Load()), Name(id='split_spec', ctx=Load())], keywords=[])), Assign(targets=[Name(id='shortened_prospective', ctx=Store())], value=Subscript(value=Name(id='padded_prospective', ctx=Load()), slice=Slice(upper=Call(func=Name(id='len', ctx=Load()), args=[Name(id='split_spec', ctx=Load())], keywords=[])), ctx=Load())), Return(value=Compare(left=Name(id='shortened_prospective', ctx=Load()), ops=[Eq()], comparators=[Name(id='split_spec', ctx=Load())]))], orelse=[Assign(targets=[Name(id='spec_version', ctx=Store())], value=Call(func=Name(id='Version', ctx=Load()), args=[Name(id='spec', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='spec_version', ctx=Load()), attr='local', ctx=Load())), body=[Assign(targets=[Name(id='prospective', ctx=Store())], value=Call(func=Name(id='Version', ctx=Load()), args=[Attribute(value=Name(id='prospective', ctx=Load()), attr='public', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Compare(left=Name(id='prospective', ctx=Load()), ops=[Eq()], comparators=[Name(id='spec_version', ctx=Load())]))])], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compare_not_equal', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prospective', annotation=Name(id='Version', ctx=Load())), arg(arg='spec', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compare_equal', ctx=Load()), args=[Name(id='prospective', ctx=Load()), Name(id='spec', ctx=Load())], keywords=[])))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compare_less_than_equal', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prospective', annotation=Name(id='Version', ctx=Load())), arg(arg='spec', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Name(id='Version', ctx=Load()), args=[Attribute(value=Name(id='prospective', ctx=Load()), attr='public', ctx=Load())], keywords=[]), ops=[LtE()], comparators=[Call(func=Name(id='Version', ctx=Load()), args=[Name(id='spec', ctx=Load())], keywords=[])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compare_greater_than_equal', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prospective', annotation=Name(id='Version', ctx=Load())), arg(arg='spec', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Name(id='Version', ctx=Load()), args=[Attribute(value=Name(id='prospective', ctx=Load()), attr='public', ctx=Load())], keywords=[]), ops=[GtE()], comparators=[Call(func=Name(id='Version', ctx=Load()), args=[Name(id='spec', ctx=Load())], keywords=[])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compare_less_than', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prospective', annotation=Name(id='Version', ctx=Load())), arg(arg='spec_str', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='spec', ctx=Store())], value=Call(func=Name(id='Version', ctx=Load()), args=[Name(id='spec_str', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='prospective', ctx=Load()), ops=[Lt()], comparators=[Name(id='spec', ctx=Load())])), body=[Return(value=Constant(value=False))], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='spec', ctx=Load()), attr='is_prerelease', ctx=Load())), Attribute(value=Name(id='prospective', ctx=Load()), attr='is_prerelease', ctx=Load())]), body=[If(test=Compare(left=Call(func=Name(id='Version', ctx=Load()), args=[Attribute(value=Name(id='prospective', ctx=Load()), attr='base_version', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='Version', ctx=Load()), args=[Attribute(value=Name(id='spec', ctx=Load()), attr='base_version', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=False))], orelse=[])], orelse=[]), Return(value=Constant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compare_greater_than', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prospective', annotation=Name(id='Version', ctx=Load())), arg(arg='spec_str', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='spec', ctx=Store())], value=Call(func=Name(id='Version', ctx=Load()), args=[Name(id='spec_str', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='prospective', ctx=Load()), ops=[Gt()], comparators=[Name(id='spec', ctx=Load())])), body=[Return(value=Constant(value=False))], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='spec', ctx=Load()), attr='is_postrelease', ctx=Load())), Attribute(value=Name(id='prospective', ctx=Load()), attr='is_postrelease', ctx=Load())]), body=[If(test=Compare(left=Call(func=Name(id='Version', ctx=Load()), args=[Attribute(value=Name(id='prospective', ctx=Load()), attr='base_version', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='Version', ctx=Load()), args=[Attribute(value=Name(id='spec', ctx=Load()), attr='base_version', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=False))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='prospective', ctx=Load()), attr='local', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Call(func=Name(id='Version', ctx=Load()), args=[Attribute(value=Name(id='prospective', ctx=Load()), attr='base_version', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='Version', ctx=Load()), args=[Attribute(value=Name(id='spec', ctx=Load()), attr='base_version', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=False))], orelse=[])], orelse=[]), Return(value=Constant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compare_arbitrary', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prospective', annotation=Name(id='Version', ctx=Load())), arg(arg='spec', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='prospective', ctx=Load())], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='spec', ctx=Load())], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Version', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> "1.2.3" in Specifier(">=1.2.3")\n        True\n        >>> Version("1.2.3") in Specifier(">=1.2.3")\n        True\n        >>> "1.0.0" in Specifier(">=1.2.3")\n        False\n        >>> "1.3.0a1" in Specifier(">=1.2.3")\n        False\n        >>> "1.3.0a1" in Specifier(">=1.2.3", prereleases=True)\n        True\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='contains', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='contains', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item', annotation=Name(id='UnparsedVersion', ctx=Load())), arg(arg='prereleases', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return whether or not the item is contained in this specifier.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this Specifier. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> Specifier(">=1.2.3").contains("1.2.3")\n        True\n        >>> Specifier(">=1.2.3").contains(Version("1.2.3"))\n        True\n        >>> Specifier(">=1.2.3").contains("1.0.0")\n        False\n        >>> Specifier(">=1.2.3").contains("1.3.0a1")\n        False\n        >>> Specifier(">=1.2.3", prereleases=True).contains("1.3.0a1")\n        True\n        >>> Specifier(">=1.2.3").contains("1.3.0a1", prereleases=True)\n        True\n        ')), If(test=Compare(left=Name(id='prereleases', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='prereleases', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='prereleases', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='normalized_item', ctx=Store())], value=Call(func=Name(id='_coerce_version', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='normalized_item', ctx=Load()), attr='is_prerelease', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='prereleases', ctx=Load()))]), body=[Return(value=Constant(value=False))], orelse=[]), AnnAssign(target=Name(id='operator_callable', ctx=Store()), annotation=Name(id='CallableOperator', ctx=Load()), value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_operator', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='operator', ctx=Load())], keywords=[]), simple=1), Return(value=Call(func=Name(id='operator_callable', ctx=Load()), args=[Name(id='normalized_item', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterable', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='UnparsedVersionVar', ctx=Load()), ctx=Load())), arg(arg='prereleases', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Filter items in the given iterable, that match the specifier.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(Specifier().contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(Specifier(">=1.2.3").filter(["1.2", "1.3", "1.5a1"]))\n        [\'1.3\']\n        >>> list(Specifier(">=1.2.3").filter(["1.2", "1.2.3", "1.3", Version("1.4")]))\n        [\'1.2.3\', \'1.3\', <Version(\'1.4\')>]\n        >>> list(Specifier(">=1.2.3").filter(["1.2", "1.5a1"]))\n        [\'1.5a1\']\n        >>> list(Specifier(">=1.2.3").filter(["1.3", "1.5a1"], prereleases=True))\n        [\'1.3\', \'1.5a1\']\n        >>> list(Specifier(">=1.2.3", prereleases=True).filter(["1.3", "1.5a1"]))\n        [\'1.3\', \'1.5a1\']\n        ')), Assign(targets=[Name(id='yielded', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='found_prereleases', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='kw', ctx=Store())], value=Dict(keys=[Constant(value='prereleases')], values=[IfExp(test=Compare(left=Name(id='prereleases', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='prereleases', ctx=Load()), orelse=Constant(value=True))])), For(target=Name(id='version', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[Assign(targets=[Name(id='parsed_version', ctx=Store())], value=Call(func=Name(id='_coerce_version', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='contains', ctx=Load()), args=[Name(id='parsed_version', ctx=Load())], keywords=[keyword(value=Name(id='kw', ctx=Load()))]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='parsed_version', ctx=Load()), attr='is_prerelease', ctx=Load()), UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Name(id='prereleases', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='prereleases', ctx=Load())]))]), body=[Expr(value=Call(func=Attribute(value=Name(id='found_prereleases', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='yielded', ctx=Store())], value=Constant(value=True)), Expr(value=Yield(value=Name(id='version', ctx=Load())))])], orelse=[])], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='yielded', ctx=Load())), Name(id='found_prereleases', ctx=Load())]), body=[For(target=Name(id='version', ctx=Store()), iter=Name(id='found_prereleases', ctx=Load()), body=[Expr(value=Yield(value=Name(id='version', ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='UnparsedVersionVar', ctx=Load()), ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_prefix_regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^([0-9]+)((?:a|b|c|rc)[0-9]+)$')], keywords=[])), FunctionDef(name='_version_split', args=arguments(posonlyargs=[], args=[arg(arg='version', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='result', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Name(id='item', ctx=Store()), iter=Call(func=Attribute(value=Name(id='version', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='_prefix_regex', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_is_not_suffix', args=arguments(posonlyargs=[], args=[arg(arg='segment', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=UnaryOp(op=Not(), operand=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='prefix', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='prefix', ctx=Store()), iter=Tuple(elts=[Constant(value='dev'), Constant(value='a'), Constant(value='b'), Constant(value='rc'), Constant(value='post')], ctx=Load()), ifs=[], is_async=0)])], keywords=[])))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_pad_version', args=arguments(posonlyargs=[], args=[arg(arg='left', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='right', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='left_split', ctx=Store()), Name(id='right_split', ctx=Store())], ctx=Store())], value=Tuple(elts=[List(elts=[], ctx=Load()), List(elts=[], ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='left_split', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='takewhile', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[])), Name(id='left', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='right_split', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='takewhile', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[])), Name(id='right', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='left_split', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='left', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='left_split', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='right_split', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='right', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='right_split', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='left_split', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=1), BinOp(left=List(elts=[Constant(value='0')], ctx=Load()), op=Mult(), right=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='right_split', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='left_split', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], keywords=[]))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='right_split', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=1), BinOp(left=List(elts=[Constant(value='0')], ctx=Load()), op=Mult(), right=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='left_split', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='right_split', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], keywords=[]))], keywords=[])), Return(value=Tuple(elts=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), args=[Starred(value=Name(id='left_split', ctx=Load()), ctx=Load())], keywords=[])], keywords=[]), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), args=[Starred(value=Name(id='right_split', ctx=Load()), ctx=Load())], keywords=[])], keywords=[])], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='SpecifierSet', bases=[Name(id='BaseSpecifier', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='This class abstracts handling of a set of version specifiers.\n\n    It can be passed a single specifier (``>=3.0``), a comma-separated list of\n    specifiers (``>=3.0,!=3.1``), or no specifier at all.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='specifiers', annotation=Name(id='str', ctx=Load())), arg(arg='prereleases', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=None)]), body=[Expr(value=Constant(value='Initialize a SpecifierSet instance.\n\n        :param specifiers:\n            The string representation of a specifier or a comma-separated list of\n            specifiers which will be parsed and normalized before use.\n        :param prereleases:\n            This tells the SpecifierSet if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n\n        :raises InvalidSpecifier:\n            If the given ``specifiers`` are not parseable than this exception will be\n            raised.\n        ')), Assign(targets=[Name(id='split_specifiers', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='s', ctx=Store()), iter=Call(func=Attribute(value=Name(id='specifiers', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',')], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], is_async=0)])), AnnAssign(target=Name(id='parsed', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='Specifier', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), For(target=Name(id='specifier', ctx=Store()), iter=Name(id='split_specifiers', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='parsed', ctx=Load()), attr='add', ctx=Load()), args=[Call(func=Name(id='Specifier', ctx=Load()), args=[Name(id='specifier', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Name(id='parsed', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Store())], value=Name(id='prereleases', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='prereleases', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Return(value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='s', ctx=Load()), attr='prereleases', ctx=Load()), generators=[comprehension(target=Name(id='s', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), FunctionDef(name='prereleases', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='prereleases', ctx=Load()), attr='setter', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="A representation of the specifier set that shows all internal state.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> SpecifierSet('>=1.0.0,!=2.0.0')\n        <SpecifierSet('!=2.0.0,>=1.0.0')>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=False)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=False)>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=True)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=True)>\n        ")), Assign(targets=[Name(id='pre', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=JoinedStr(values=[Constant(value=', prereleases='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='prereleases', ctx=Load()), conversion=114)]), orelse=Constant(value=''))), Return(value=JoinedStr(values=[Constant(value='<SpecifierSet('), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), conversion=114), FormattedValue(value=Name(id='pre', ctx=Load()), conversion=-1), Constant(value=')>')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='A string representation of the specifier set that can be round-tripped.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> str(SpecifierSet(">=1.0.0,!=1.0.1"))\n        \'!=1.0.1,>=1.0.0\'\n        >>> str(SpecifierSet(">=1.0.0,!=1.0.1", prereleases=False))\n        \'!=1.0.1,>=1.0.0\'\n        ')), Return(value=Call(func=Attribute(value=Constant(value=','), attr='join', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='s', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='hash', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='__and__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='SpecifierSet'), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a SpecifierSet which is a combination of the two sets.\n\n        :param other: The other object to combine with.\n\n        >>> SpecifierSet(">=1.0.0,!=1.0.1") & \'<=2.0.0,!=2.0.1\'\n        <SpecifierSet(\'!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0\')>\n        >>> SpecifierSet(">=1.0.0,!=1.0.1") & SpecifierSet(\'<=2.0.0,!=2.0.1\')\n        <SpecifierSet(\'!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0\')>\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Name(id='SpecifierSet', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='SpecifierSet', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[])]), Assign(targets=[Name(id='specifier', ctx=Store())], value=Call(func=Name(id='SpecifierSet', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='specifier', ctx=Load()), attr='_specs', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='other', ctx=Load()), attr='_specs', ctx=Load()))], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='other', ctx=Load()), attr='_prereleases', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Attribute(value=Name(id='specifier', ctx=Load()), attr='_prereleases', ctx=Store())], value=Attribute(value=Name(id='other', ctx=Load()), attr='_prereleases', ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='other', ctx=Load()), attr='_prereleases', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Attribute(value=Name(id='specifier', ctx=Load()), attr='_prereleases', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='_prereleases', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='specifier', ctx=Load()), attr='_prereleases', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_prereleases', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Cannot combine SpecifierSets with True and False prerelease overrides.')], keywords=[]))])])]), Return(value=Name(id='specifier', ctx=Load()))], decorator_list=[], returns=Constant(value='SpecifierSet')), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether or not the two SpecifierSet-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> SpecifierSet(">=1.0.0,!=1.0.1") == SpecifierSet(">=1.0.0,!=1.0.1")\n        True\n        >>> (SpecifierSet(">=1.0.0,!=1.0.1", prereleases=False) ==\n        ...  SpecifierSet(">=1.0.0,!=1.0.1", prereleases=True))\n        True\n        >>> SpecifierSet(">=1.0.0,!=1.0.1") == ">=1.0.0,!=1.0.1"\n        True\n        >>> SpecifierSet(">=1.0.0,!=1.0.1") == SpecifierSet(">=1.0.0")\n        False\n        >>> SpecifierSet(">=1.0.0,!=1.0.1") == SpecifierSet(">=1.0.0,!=1.0.2")\n        False\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Specifier', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Name(id='SpecifierSet', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='SpecifierSet', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[])]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='_specs', ctx=Load())]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='__len__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns the number of specifiers in this specifier set.')), Return(value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returns an iterator over all the underlying :class:`Specifier` instances\n        in this specifier set.\n\n        >>> sorted(SpecifierSet(">=1.0.0,!=1.0.1"), key=str)\n        [<Specifier(\'!=1.0.1\')>, <Specifier(\'>=1.0.0\')>]\n        ')), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Specifier', ctx=Load()), ctx=Load())), FunctionDef(name='__contains__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item', annotation=Name(id='UnparsedVersion', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> "1.2.3" in SpecifierSet(">=1.0.0,!=1.0.1")\n        True\n        >>> Version("1.2.3") in SpecifierSet(">=1.0.0,!=1.0.1")\n        True\n        >>> "1.0.1" in SpecifierSet(">=1.0.0,!=1.0.1")\n        False\n        >>> "1.3.0a1" in SpecifierSet(">=1.0.0,!=1.0.1")\n        False\n        >>> "1.3.0a1" in SpecifierSet(">=1.0.0,!=1.0.1", prereleases=True)\n        True\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='contains', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='contains', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='item', annotation=Name(id='UnparsedVersion', ctx=Load())), arg(arg='prereleases', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='installed', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Return whether or not the item is contained in this SpecifierSet.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this SpecifierSet. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> SpecifierSet(">=1.0.0,!=1.0.1").contains("1.2.3")\n        True\n        >>> SpecifierSet(">=1.0.0,!=1.0.1").contains(Version("1.2.3"))\n        True\n        >>> SpecifierSet(">=1.0.0,!=1.0.1").contains("1.0.1")\n        False\n        >>> SpecifierSet(">=1.0.0,!=1.0.1").contains("1.3.0a1")\n        False\n        >>> SpecifierSet(">=1.0.0,!=1.0.1", prereleases=True).contains("1.3.0a1")\n        True\n        >>> SpecifierSet(">=1.0.0,!=1.0.1").contains("1.3.0a1", prereleases=True)\n        True\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='item', ctx=Load()), Name(id='Version', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Name(id='Version', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='prereleases', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='prereleases', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='prereleases', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='prereleases', ctx=Load())), Attribute(value=Name(id='item', ctx=Load()), attr='is_prerelease', ctx=Load())]), body=[Return(value=Constant(value=False))], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='installed', ctx=Load()), Attribute(value=Name(id='item', ctx=Load()), attr='is_prerelease', ctx=Load())]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Name(id='Version', ctx=Load()), args=[Attribute(value=Name(id='item', ctx=Load()), attr='base_version', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='contains', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[keyword(arg='prereleases', value=Name(id='prereleases', ctx=Load()))]), generators=[comprehension(target=Name(id='s', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterable', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='UnparsedVersionVar', ctx=Load()), ctx=Load())), arg(arg='prereleases', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Filter items in the given iterable, that match the specifiers in this set.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(SpecifierSet(...).contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(SpecifierSet(">=1.2.3").filter(["1.2", "1.3", "1.5a1"]))\n        [\'1.3\']\n        >>> list(SpecifierSet(">=1.2.3").filter(["1.2", "1.3", Version("1.4")]))\n        [\'1.3\', <Version(\'1.4\')>]\n        >>> list(SpecifierSet(">=1.2.3").filter(["1.2", "1.5a1"]))\n        []\n        >>> list(SpecifierSet(">=1.2.3").filter(["1.3", "1.5a1"], prereleases=True))\n        [\'1.3\', \'1.5a1\']\n        >>> list(SpecifierSet(">=1.2.3", prereleases=True).filter(["1.3", "1.5a1"]))\n        [\'1.3\', \'1.5a1\']\n\n        An "empty" SpecifierSet will filter items based on the presence of prerelease\n        versions in the set.\n\n        >>> list(SpecifierSet("").filter(["1.3", "1.5a1"]))\n        [\'1.3\']\n        >>> list(SpecifierSet("").filter(["1.5a1"]))\n        [\'1.5a1\']\n        >>> list(SpecifierSet("", prereleases=True).filter(["1.3", "1.5a1"]))\n        [\'1.3\', \'1.5a1\']\n        >>> list(SpecifierSet("").filter(["1.3", "1.5a1"], prereleases=True))\n        [\'1.3\', \'1.5a1\']\n        ')), If(test=Compare(left=Name(id='prereleases', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='prereleases', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='prereleases', ctx=Load()))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load()), body=[For(target=Name(id='spec', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_specs', ctx=Load()), body=[Assign(targets=[Name(id='iterable', ctx=Store())], value=Call(func=Attribute(value=Name(id='spec', ctx=Load()), attr='filter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[keyword(arg='prereleases', value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='prereleases', ctx=Load())], keywords=[]))]))], orelse=[]), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='iterable', ctx=Load())], keywords=[]))], orelse=[AnnAssign(target=Name(id='filtered', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='UnparsedVersionVar', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='found_prereleases', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='UnparsedVersionVar', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Name(id='item', ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[Assign(targets=[Name(id='parsed_version', ctx=Store())], value=Call(func=Name(id='_coerce_version', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='parsed_version', ctx=Load()), attr='is_prerelease', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='prereleases', ctx=Load()))]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='filtered', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='found_prereleases', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='filtered', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))])], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='filtered', ctx=Load())), Name(id='found_prereleases', ctx=Load()), Compare(left=Name(id='prereleases', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='found_prereleases', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='filtered', ctx=Load())], keywords=[]))])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='UnparsedVersionVar', ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])