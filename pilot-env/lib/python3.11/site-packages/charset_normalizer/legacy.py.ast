Module(body=[ImportFrom(module='typing', names=[alias(name='Any'), alias(name='Dict'), alias(name='Optional'), alias(name='Union')], level=0), ImportFrom(module='warnings', names=[alias(name='warn')], level=0), ImportFrom(module='api', names=[alias(name='from_bytes')], level=1), ImportFrom(module='constant', names=[alias(name='CHARDET_CORRESPONDENCE')], level=1), FunctionDef(name='detect', args=arguments(posonlyargs=[], args=[arg(arg='byte_str', annotation=Name(id='bytes', ctx=Load())), arg(arg='should_rename_legacy', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    chardet legacy method\n    Detect the encoding of the given byte string. It should be mostly backward-compatible.\n    Encoding name will match Chardet own writing whenever possible. (Not on encoding name unsupported by it)\n    This function is deprecated and should be used to migrate your project easily, consult the documentation for\n    further information. Not planned for removal.\n\n    :param byte_str:     The byte sequence to examine.\n    :param should_rename_legacy:  Should we rename legacy encodings\n                                  to their more modern equivalents?\n    ')), If(test=Call(func=Name(id='len', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="charset-normalizer disregard arguments '"), FormattedValue(value=Call(func=Attribute(value=Constant(value=','), attr='join', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]), conversion=-1), Constant(value="' in legacy function detect()")])], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='byte_str', ctx=Load()), Tuple(elts=[Name(id='bytearray', ctx=Load()), Name(id='bytes', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Expected object of type bytes or bytearray, got: {0}'), attr='format', ctx=Load()), args=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='byte_str', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='byte_str', ctx=Load()), Name(id='bytearray', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='byte_str', ctx=Store())], value=Call(func=Name(id='bytes', ctx=Load()), args=[Name(id='byte_str', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='from_bytes', ctx=Load()), args=[Name(id='byte_str', ctx=Load())], keywords=[]), attr='best', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='encoding', ctx=Store())], value=IfExp(test=Compare(left=Name(id='r', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='r', ctx=Load()), attr='encoding', ctx=Load()), orelse=Constant(value=None))), Assign(targets=[Name(id='language', ctx=Store())], value=IfExp(test=BoolOp(op=And(), values=[Compare(left=Name(id='r', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='r', ctx=Load()), attr='language', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='Unknown')])]), body=Attribute(value=Name(id='r', ctx=Load()), attr='language', ctx=Load()), orelse=Constant(value=''))), Assign(targets=[Name(id='confidence', ctx=Store())], value=IfExp(test=Compare(left=Name(id='r', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=BinOp(left=Constant(value=1.0), op=Sub(), right=Attribute(value=Name(id='r', ctx=Load()), attr='chaos', ctx=Load())), orelse=Constant(value=None))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='r', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='encoding', ctx=Load()), ops=[Eq()], comparators=[Constant(value='utf_8')]), Attribute(value=Name(id='r', ctx=Load()), attr='bom', ctx=Load())]), body=[AugAssign(target=Name(id='encoding', ctx=Store()), op=Add(), value=Constant(value='_sig'))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='should_rename_legacy', ctx=Load()), ops=[Is()], comparators=[Constant(value=False)]), Compare(left=Name(id='encoding', ctx=Load()), ops=[In()], comparators=[Name(id='CHARDET_CORRESPONDENCE', ctx=Load())])]), body=[Assign(targets=[Name(id='encoding', ctx=Store())], value=Subscript(value=Name(id='CHARDET_CORRESPONDENCE', ctx=Load()), slice=Name(id='encoding', ctx=Load()), ctx=Load()))], orelse=[]), Return(value=Dict(keys=[Constant(value='encoding'), Constant(value='language'), Constant(value='confidence')], values=[Name(id='encoding', ctx=Load()), Name(id='language', ctx=Load()), Name(id='confidence', ctx=Load())]))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], type_ignores=[])