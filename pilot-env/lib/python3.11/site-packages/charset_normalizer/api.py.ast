Module(body=[Import(names=[alias(name='logging')]), ImportFrom(module='os', names=[alias(name='PathLike')], level=0), ImportFrom(module='typing', names=[alias(name='BinaryIO'), alias(name='List'), alias(name='Optional'), alias(name='Set'), alias(name='Union')], level=0), ImportFrom(module='cd', names=[alias(name='coherence_ratio'), alias(name='encoding_languages'), alias(name='mb_encoding_languages'), alias(name='merge_coherence_ratios')], level=1), ImportFrom(module='constant', names=[alias(name='IANA_SUPPORTED'), alias(name='TOO_BIG_SEQUENCE'), alias(name='TOO_SMALL_SEQUENCE'), alias(name='TRACE')], level=1), ImportFrom(module='md', names=[alias(name='mess_ratio')], level=1), ImportFrom(module='models', names=[alias(name='CharsetMatch'), alias(name='CharsetMatches')], level=1), ImportFrom(module='utils', names=[alias(name='any_specified_encoding'), alias(name='cut_sequence_chunks'), alias(name='iana_name'), alias(name='identify_sig_or_bom'), alias(name='is_cp_similar'), alias(name='is_multi_byte_encoding'), alias(name='should_strip_sig_or_bom')], level=1), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Constant(value='charset_normalizer')], keywords=[])), Assign(targets=[Name(id='explain_handler', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='StreamHandler', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='explain_handler', ctx=Load()), attr='setFormatter', ctx=Load()), args=[Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='Formatter', ctx=Load()), args=[Constant(value='%(asctime)s | %(levelname)s | %(message)s')], keywords=[])], keywords=[])), FunctionDef(name='from_bytes', args=arguments(posonlyargs=[], args=[arg(arg='sequences', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bytes', ctx=Load()), Name(id='bytearray', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='steps', annotation=Name(id='int', ctx=Load())), arg(arg='chunk_size', annotation=Name(id='int', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='cp_isolation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='cp_exclusion', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='preemptive_behaviour', annotation=Name(id='bool', ctx=Load())), arg(arg='explain', annotation=Name(id='bool', ctx=Load())), arg(arg='language_threshold', annotation=Name(id='float', ctx=Load())), arg(arg='enable_fallback', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=5), Constant(value=512), Constant(value=0.2), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=False), Constant(value=0.1), Constant(value=True)]), body=[Expr(value=Constant(value="\n    Given a raw bytes sequence, return the best possibles charset usable to render str objects.\n    If there is no results, it is a strong indicator that the source is binary/not text.\n    By default, the process will extract 5 blocks of 512o each to assess the mess and coherence of a given sequence.\n    And will give up a particular code page after 20% of measured mess. Those criteria are customizable at will.\n\n    The preemptive behavior DOES NOT replace the traditional detection workflow, it prioritize a particular code page\n    but never take it for granted. Can improve the performance.\n\n    You may want to focus your attention to some code page or/and not others, use cp_isolation and cp_exclusion for that\n    purpose.\n\n    This function will strip the SIG in the payload/sequence every time except on UTF-16, UTF-32.\n    By default the library does not setup any handler other than the NullHandler, if you choose to set the 'explain'\n    toggle to True it will alter the logger configuration to add a StreamHandler that is suitable for debugging.\n    Custom logging format and handler can be set manually.\n    ")), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='sequences', ctx=Load()), Tuple(elts=[Name(id='bytearray', ctx=Load()), Name(id='bytes', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Expected object of type bytes or bytearray, got: {0}'), attr='format', ctx=Load()), args=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='sequences', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), If(test=Name(id='explain', ctx=Load()), body=[AnnAssign(target=Name(id='previous_logger_level', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Attribute(value=Name(id='logger', ctx=Load()), attr='level', ctx=Load()), simple=1), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='addHandler', ctx=Load()), args=[Name(id='explain_handler', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='setLevel', ctx=Load()), args=[Name(id='TRACE', ctx=Load())], keywords=[]))], orelse=[]), AnnAssign(target=Name(id='length', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sequences', ctx=Load())], keywords=[]), simple=1), If(test=Compare(left=Name(id='length', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Encoding detection on empty bytes, assuming utf_8 intention.')], keywords=[])), If(test=Name(id='explain', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='removeHandler', ctx=Load()), args=[Name(id='explain_handler', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='setLevel', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='previous_logger_level', ctx=Load()), Attribute(value=Name(id='logging', ctx=Load()), attr='WARNING', ctx=Load())])], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='CharsetMatches', ctx=Load()), args=[List(elts=[Call(func=Name(id='CharsetMatch', ctx=Load()), args=[Name(id='sequences', ctx=Load()), Constant(value='utf_8'), Constant(value=0.0), Constant(value=False), List(elts=[], ctx=Load()), Constant(value='')], keywords=[])], ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='cp_isolation', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='cp_isolation is set. use this flag for debugging purpose. limited list of encoding allowed : %s.'), Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='cp_isolation', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='cp_isolation', ctx=Store())], value=ListComp(elt=Call(func=Name(id='iana_name', ctx=Load()), args=[Name(id='cp', ctx=Load()), Constant(value=False)], keywords=[]), generators=[comprehension(target=Name(id='cp', ctx=Store()), iter=Name(id='cp_isolation', ctx=Load()), ifs=[], is_async=0)]))], orelse=[Assign(targets=[Name(id='cp_isolation', ctx=Store())], value=List(elts=[], ctx=Load()))]), If(test=Compare(left=Name(id='cp_exclusion', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='cp_exclusion is set. use this flag for debugging purpose. limited list of encoding excluded : %s.'), Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='cp_exclusion', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='cp_exclusion', ctx=Store())], value=ListComp(elt=Call(func=Name(id='iana_name', ctx=Load()), args=[Name(id='cp', ctx=Load()), Constant(value=False)], keywords=[]), generators=[comprehension(target=Name(id='cp', ctx=Store()), iter=Name(id='cp_exclusion', ctx=Load()), ifs=[], is_async=0)]))], orelse=[Assign(targets=[Name(id='cp_exclusion', ctx=Store())], value=List(elts=[], ctx=Load()))]), If(test=Compare(left=Name(id='length', ctx=Load()), ops=[LtE()], comparators=[BinOp(left=Name(id='chunk_size', ctx=Load()), op=Mult(), right=Name(id='steps', ctx=Load()))]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='override steps (%i) and chunk_size (%i) as content does not fit (%i byte(s) given) parameters.'), Name(id='steps', ctx=Load()), Name(id='chunk_size', ctx=Load()), Name(id='length', ctx=Load())], keywords=[])), Assign(targets=[Name(id='steps', ctx=Store())], value=Constant(value=1)), Assign(targets=[Name(id='chunk_size', ctx=Store())], value=Name(id='length', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='steps', ctx=Load()), ops=[Gt()], comparators=[Constant(value=1)]), Compare(left=BinOp(left=Name(id='length', ctx=Load()), op=Div(), right=Name(id='steps', ctx=Load())), ops=[Lt()], comparators=[Name(id='chunk_size', ctx=Load())])]), body=[Assign(targets=[Name(id='chunk_size', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='length', ctx=Load()), op=Div(), right=Name(id='steps', ctx=Load()))], keywords=[]))], orelse=[]), AnnAssign(target=Name(id='is_too_small_sequence', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sequences', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Name(id='TOO_SMALL_SEQUENCE', ctx=Load())]), simple=1), AnnAssign(target=Name(id='is_too_large_sequence', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sequences', ctx=Load())], keywords=[]), ops=[GtE()], comparators=[Name(id='TOO_BIG_SEQUENCE', ctx=Load())]), simple=1), If(test=Name(id='is_too_small_sequence', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Call(func=Attribute(value=Constant(value='Trying to detect encoding from a tiny portion of ({}) byte(s).'), attr='format', ctx=Load()), args=[Name(id='length', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=Name(id='is_too_large_sequence', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Call(func=Attribute(value=Constant(value='Using lazy str decoding because the payload is quite large, ({}) byte(s).'), attr='format', ctx=Load()), args=[Name(id='length', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])]), AnnAssign(target=Name(id='prioritized_encodings', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='specified_encoding', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=IfExp(test=Name(id='preemptive_behaviour', ctx=Load()), body=Call(func=Name(id='any_specified_encoding', ctx=Load()), args=[Name(id='sequences', ctx=Load())], keywords=[]), orelse=Constant(value=None)), simple=1), If(test=Compare(left=Name(id='specified_encoding', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='prioritized_encodings', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='specified_encoding', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='Detected declarative mark in sequence. Priority +1 given for %s.'), Name(id='specified_encoding', ctx=Load())], keywords=[]))], orelse=[]), AnnAssign(target=Name(id='tested', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), AnnAssign(target=Name(id='tested_but_hard_failure', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='tested_but_soft_failure', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='fallback_ascii', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CharsetMatch', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), AnnAssign(target=Name(id='fallback_u8', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CharsetMatch', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), AnnAssign(target=Name(id='fallback_specified', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CharsetMatch', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), AnnAssign(target=Name(id='results', ctx=Store()), annotation=Name(id='CharsetMatches', ctx=Load()), value=Call(func=Name(id='CharsetMatches', ctx=Load()), args=[], keywords=[]), simple=1), Assign(targets=[Tuple(elts=[Name(id='sig_encoding', ctx=Store()), Name(id='sig_payload', ctx=Store())], ctx=Store())], value=Call(func=Name(id='identify_sig_or_bom', ctx=Load()), args=[Name(id='sequences', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='sig_encoding', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='prioritized_encodings', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='sig_encoding', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='Detected a SIG or BOM mark on first %i byte(s). Priority +1 given for %s.'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='sig_payload', ctx=Load())], keywords=[]), Name(id='sig_encoding', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='prioritized_encodings', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='ascii')], keywords=[])), If(test=Compare(left=Constant(value='utf_8'), ops=[NotIn()], comparators=[Name(id='prioritized_encodings', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='prioritized_encodings', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='utf_8')], keywords=[]))], orelse=[]), For(target=Name(id='encoding_iana', ctx=Store()), iter=BinOp(left=Name(id='prioritized_encodings', ctx=Load()), op=Add(), right=Name(id='IANA_SUPPORTED', ctx=Load())), body=[If(test=BoolOp(op=And(), values=[Name(id='cp_isolation', ctx=Load()), Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[NotIn()], comparators=[Name(id='cp_isolation', ctx=Load())])]), body=[Continue()], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='cp_exclusion', ctx=Load()), Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[In()], comparators=[Name(id='cp_exclusion', ctx=Load())])]), body=[Continue()], orelse=[]), If(test=Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[In()], comparators=[Name(id='tested', ctx=Load())]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='tested', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load())], keywords=[])), AnnAssign(target=Name(id='decoded_payload', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), AnnAssign(target=Name(id='bom_or_sig_available', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=Compare(left=Name(id='sig_encoding', ctx=Load()), ops=[Eq()], comparators=[Name(id='encoding_iana', ctx=Load())]), simple=1), AnnAssign(target=Name(id='strip_sig_or_bom', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=BoolOp(op=And(), values=[Name(id='bom_or_sig_available', ctx=Load()), Call(func=Name(id='should_strip_sig_or_bom', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load())], keywords=[])]), simple=1), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[In()], comparators=[Set(elts=[Constant(value='utf_16'), Constant(value='utf_32')])]), UnaryOp(op=Not(), operand=Name(id='bom_or_sig_available', ctx=Load()))]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value="Encoding %s won't be tested as-is because it require a BOM. Will try some sub-encoder LE/BE."), Name(id='encoding_iana', ctx=Load())], keywords=[])), Continue()], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[In()], comparators=[Set(elts=[Constant(value='utf_7')])]), UnaryOp(op=Not(), operand=Name(id='bom_or_sig_available', ctx=Load()))]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value="Encoding %s won't be tested as-is because detection is unreliable without BOM/SIG."), Name(id='encoding_iana', ctx=Load())], keywords=[])), Continue()], orelse=[]), Try(body=[AnnAssign(target=Name(id='is_multi_byte_decoder', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=Call(func=Name(id='is_multi_byte_encoding', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load())], keywords=[]), simple=1)], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ModuleNotFoundError', ctx=Load()), Name(id='ImportError', ctx=Load())], ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='Encoding %s does not provide an IncrementalDecoder'), Name(id='encoding_iana', ctx=Load())], keywords=[])), Continue()])], orelse=[], finalbody=[]), Try(body=[If(test=BoolOp(op=And(), values=[Name(id='is_too_large_sequence', ctx=Load()), Compare(left=Name(id='is_multi_byte_decoder', ctx=Load()), ops=[Is()], comparators=[Constant(value=False)])]), body=[Expr(value=Call(func=Name(id='str', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='strip_sig_or_bom', ctx=Load()), ops=[Is()], comparators=[Constant(value=False)]), body=Subscript(value=Name(id='sequences', ctx=Load()), slice=Slice(upper=Call(func=Name(id='int', ctx=Load()), args=[Constant(value=500000.0)], keywords=[])), ctx=Load()), orelse=Subscript(value=Name(id='sequences', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sig_payload', ctx=Load())], keywords=[]), upper=Call(func=Name(id='int', ctx=Load()), args=[Constant(value=500000.0)], keywords=[])), ctx=Load()))], keywords=[keyword(arg='encoding', value=Name(id='encoding_iana', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='decoded_payload', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='strip_sig_or_bom', ctx=Load()), ops=[Is()], comparators=[Constant(value=False)]), body=Name(id='sequences', ctx=Load()), orelse=Subscript(value=Name(id='sequences', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sig_payload', ctx=Load())], keywords=[])), ctx=Load()))], keywords=[keyword(arg='encoding', value=Name(id='encoding_iana', ctx=Load()))]))])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='UnicodeDecodeError', ctx=Load()), Name(id='LookupError', ctx=Load())], ctx=Load()), name='e', body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='LookupError', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='Code page %s does not fit given bytes sequence at ALL. %s'), Name(id='encoding_iana', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='tested_but_hard_failure', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load())], keywords=[])), Continue()])], orelse=[], finalbody=[]), AnnAssign(target=Name(id='similar_soft_failure_test', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=Constant(value=False), simple=1), For(target=Name(id='encoding_soft_failed', ctx=Store()), iter=Name(id='tested_but_soft_failure', ctx=Load()), body=[If(test=Call(func=Name(id='is_cp_similar', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load()), Name(id='encoding_soft_failed', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='similar_soft_failure_test', ctx=Store())], value=Constant(value=True)), Break()], orelse=[])], orelse=[]), If(test=Name(id='similar_soft_failure_test', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='%s is deemed too similar to code page %s and was consider unsuited already. Continuing!'), Name(id='encoding_iana', ctx=Load()), Name(id='encoding_soft_failed', ctx=Load())], keywords=[])), Continue()], orelse=[]), Assign(targets=[Name(id='r_', ctx=Store())], value=Call(func=Name(id='range', ctx=Load()), args=[IfExp(test=UnaryOp(op=Not(), operand=Name(id='bom_or_sig_available', ctx=Load())), body=Constant(value=0), orelse=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sig_payload', ctx=Load())], keywords=[])), Name(id='length', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='length', ctx=Load()), op=Div(), right=Name(id='steps', ctx=Load()))], keywords=[])], keywords=[])), AnnAssign(target=Name(id='multi_byte_bonus', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=BoolOp(op=And(), values=[Name(id='is_multi_byte_decoder', ctx=Load()), Compare(left=Name(id='decoded_payload', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='decoded_payload', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Name(id='length', ctx=Load())])]), simple=1), If(test=Name(id='multi_byte_bonus', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='Code page %s is a multi byte encoding table and it appear that at least one character was encoded using n-bytes.'), Name(id='encoding_iana', ctx=Load())], keywords=[]))], orelse=[]), AnnAssign(target=Name(id='max_chunk_gave_up', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='r_', ctx=Load())], keywords=[]), op=Div(), right=Constant(value=4))], keywords=[]), simple=1), Assign(targets=[Name(id='max_chunk_gave_up', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Name(id='max_chunk_gave_up', ctx=Load()), Constant(value=2)], keywords=[])), AnnAssign(target=Name(id='early_stop_count', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Constant(value=0), simple=1), Assign(targets=[Name(id='lazy_str_hard_failure', ctx=Store())], value=Constant(value=False)), AnnAssign(target=Name(id='md_chunks', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='md_ratios', ctx=Store())], value=List(elts=[], ctx=Load())), Try(body=[For(target=Name(id='chunk', ctx=Store()), iter=Call(func=Name(id='cut_sequence_chunks', ctx=Load()), args=[Name(id='sequences', ctx=Load()), Name(id='encoding_iana', ctx=Load()), Name(id='r_', ctx=Load()), Name(id='chunk_size', ctx=Load()), Name(id='bom_or_sig_available', ctx=Load()), Name(id='strip_sig_or_bom', ctx=Load()), Name(id='sig_payload', ctx=Load()), Name(id='is_multi_byte_decoder', ctx=Load()), Name(id='decoded_payload', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='md_chunks', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='chunk', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='md_ratios', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='mess_ratio', ctx=Load()), args=[Name(id='chunk', ctx=Load()), Name(id='threshold', ctx=Load()), BoolOp(op=And(), values=[Compare(left=Name(id='explain', ctx=Load()), ops=[Is()], comparators=[Constant(value=True)]), Compare(left=Constant(value=1), ops=[LtE(), LtE()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='cp_isolation', ctx=Load())], keywords=[]), Constant(value=2)])])], keywords=[])], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='md_ratios', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), ops=[GtE()], comparators=[Name(id='threshold', ctx=Load())]), body=[AugAssign(target=Name(id='early_stop_count', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='early_stop_count', ctx=Load()), ops=[GtE()], comparators=[Name(id='max_chunk_gave_up', ctx=Load())]), BoolOp(op=And(), values=[Name(id='bom_or_sig_available', ctx=Load()), Compare(left=Name(id='strip_sig_or_bom', ctx=Load()), ops=[Is()], comparators=[Constant(value=False)])])]), body=[Break()], orelse=[])], orelse=[])], handlers=[ExceptHandler(type=Name(id='UnicodeDecodeError', ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='LazyStr Loading: After MD chunk decode, code page %s does not fit given bytes sequence at ALL. %s'), Name(id='encoding_iana', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='early_stop_count', ctx=Store())], value=Name(id='max_chunk_gave_up', ctx=Load())), Assign(targets=[Name(id='lazy_str_hard_failure', ctx=Store())], value=Constant(value=True))])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='lazy_str_hard_failure', ctx=Load())), Name(id='is_too_large_sequence', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='is_multi_byte_decoder', ctx=Load()))]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='sequences', ctx=Load()), slice=Slice(lower=Call(func=Name(id='int', ctx=Load()), args=[Constant(value=50000.0)], keywords=[])), ctx=Load()), attr='decode', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load())], keywords=[keyword(arg='errors', value=Constant(value='strict'))]))], handlers=[ExceptHandler(type=Name(id='UnicodeDecodeError', ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='LazyStr Loading: After final lookup, code page %s does not fit given bytes sequence at ALL. %s'), Name(id='encoding_iana', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='tested_but_hard_failure', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load())], keywords=[])), Continue()])], orelse=[], finalbody=[])], orelse=[]), AnnAssign(target=Name(id='mean_mess_ratio', ctx=Store()), annotation=Name(id='float', ctx=Load()), value=IfExp(test=Name(id='md_ratios', ctx=Load()), body=BinOp(left=Call(func=Name(id='sum', ctx=Load()), args=[Name(id='md_ratios', ctx=Load())], keywords=[]), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='md_ratios', ctx=Load())], keywords=[])), orelse=Constant(value=0.0)), simple=1), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='mean_mess_ratio', ctx=Load()), ops=[GtE()], comparators=[Name(id='threshold', ctx=Load())]), Compare(left=Name(id='early_stop_count', ctx=Load()), ops=[GtE()], comparators=[Name(id='max_chunk_gave_up', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='tested_but_soft_failure', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='%s was excluded because of initial chaos probing. Gave up %i time(s). Computed mean chaos is %f %%.'), Name(id='encoding_iana', ctx=Load()), Name(id='early_stop_count', ctx=Load()), Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='mean_mess_ratio', ctx=Load()), op=Mult(), right=Constant(value=100))], keywords=[keyword(arg='ndigits', value=Constant(value=3))])], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='enable_fallback', ctx=Load()), Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='ascii'), Constant(value='utf_8'), Name(id='specified_encoding', ctx=Load())], ctx=Load())]), UnaryOp(op=Not(), operand=Name(id='lazy_str_hard_failure', ctx=Load()))]), body=[Assign(targets=[Name(id='fallback_entry', ctx=Store())], value=Call(func=Name(id='CharsetMatch', ctx=Load()), args=[Name(id='sequences', ctx=Load()), Name(id='encoding_iana', ctx=Load()), Name(id='threshold', ctx=Load()), Constant(value=False), List(elts=[], ctx=Load()), Name(id='decoded_payload', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[Eq()], comparators=[Name(id='specified_encoding', ctx=Load())]), body=[Assign(targets=[Name(id='fallback_specified', ctx=Store())], value=Name(id='fallback_entry', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[Eq()], comparators=[Constant(value='ascii')]), body=[Assign(targets=[Name(id='fallback_ascii', ctx=Store())], value=Name(id='fallback_entry', ctx=Load()))], orelse=[Assign(targets=[Name(id='fallback_u8', ctx=Store())], value=Name(id='fallback_entry', ctx=Load()))])])], orelse=[]), Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='%s passed initial chaos probing. Mean measured chaos is %f %%'), Name(id='encoding_iana', ctx=Load()), Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='mean_mess_ratio', ctx=Load()), op=Mult(), right=Constant(value=100))], keywords=[keyword(arg='ndigits', value=Constant(value=3))])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='is_multi_byte_decoder', ctx=Load())), body=[AnnAssign(target=Name(id='target_languages', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='encoding_languages', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load())], keywords=[]), simple=1)], orelse=[Assign(targets=[Name(id='target_languages', ctx=Store())], value=Call(func=Name(id='mb_encoding_languages', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load())], keywords=[]))]), If(test=Name(id='target_languages', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Call(func=Attribute(value=Constant(value='{} should target any language(s) of {}'), attr='format', ctx=Load()), args=[Name(id='encoding_iana', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='target_languages', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='cd_ratios', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='ascii')]), body=[For(target=Name(id='chunk', ctx=Store()), iter=Name(id='md_chunks', ctx=Load()), body=[Assign(targets=[Name(id='chunk_languages', ctx=Store())], value=Call(func=Name(id='coherence_ratio', ctx=Load()), args=[Name(id='chunk', ctx=Load()), Name(id='language_threshold', ctx=Load()), IfExp(test=Name(id='target_languages', ctx=Load()), body=Call(func=Attribute(value=Constant(value=','), attr='join', ctx=Load()), args=[Name(id='target_languages', ctx=Load())], keywords=[]), orelse=Constant(value=None))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cd_ratios', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='chunk_languages', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='cd_ratios_merged', ctx=Store())], value=Call(func=Name(id='merge_coherence_ratios', ctx=Load()), args=[Name(id='cd_ratios', ctx=Load())], keywords=[])), If(test=Name(id='cd_ratios_merged', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Call(func=Attribute(value=Constant(value='We detected language {} using {}'), attr='format', ctx=Load()), args=[Name(id='cd_ratios_merged', ctx=Load()), Name(id='encoding_iana', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='results', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='CharsetMatch', ctx=Load()), args=[Name(id='sequences', ctx=Load()), Name(id='encoding_iana', ctx=Load()), Name(id='mean_mess_ratio', ctx=Load()), Name(id='bom_or_sig_available', ctx=Load()), Name(id='cd_ratios_merged', ctx=Load()), Name(id='decoded_payload', ctx=Load())], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[In()], comparators=[List(elts=[Name(id='specified_encoding', ctx=Load()), Constant(value='ascii'), Constant(value='utf_8')], ctx=Load())]), Compare(left=Name(id='mean_mess_ratio', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0.1)])]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Encoding detection: %s is most likely the one.'), Name(id='encoding_iana', ctx=Load())], keywords=[])), If(test=Name(id='explain', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='removeHandler', ctx=Load()), args=[Name(id='explain_handler', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='setLevel', ctx=Load()), args=[Name(id='previous_logger_level', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='CharsetMatches', ctx=Load()), args=[List(elts=[Subscript(value=Name(id='results', ctx=Load()), slice=Name(id='encoding_iana', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='encoding_iana', ctx=Load()), ops=[Eq()], comparators=[Name(id='sig_encoding', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Encoding detection: %s is most likely the one as we detected a BOM or SIG within the beginning of the sequence.'), Name(id='encoding_iana', ctx=Load())], keywords=[])), If(test=Name(id='explain', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='removeHandler', ctx=Load()), args=[Name(id='explain_handler', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='setLevel', ctx=Load()), args=[Name(id='previous_logger_level', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='CharsetMatches', ctx=Load()), args=[List(elts=[Subscript(value=Name(id='results', ctx=Load()), slice=Name(id='encoding_iana', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='results', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=0)]), body=[If(test=BoolOp(op=Or(), values=[Name(id='fallback_u8', ctx=Load()), Name(id='fallback_ascii', ctx=Load()), Name(id='fallback_specified', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='TRACE', ctx=Load()), Constant(value='Nothing got out of the detection process. Using ASCII/UTF-8/Specified fallback.')], keywords=[]))], orelse=[]), If(test=Name(id='fallback_specified', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Encoding detection: %s will be used as a fallback match'), Attribute(value=Name(id='fallback_specified', ctx=Load()), attr='encoding', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='fallback_specified', ctx=Load())], keywords=[]))], orelse=[If(test=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Name(id='fallback_u8', ctx=Load()), Compare(left=Name(id='fallback_ascii', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), BoolOp(op=And(), values=[Name(id='fallback_u8', ctx=Load()), Name(id='fallback_ascii', ctx=Load()), Compare(left=Attribute(value=Name(id='fallback_u8', ctx=Load()), attr='fingerprint', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='fallback_ascii', ctx=Load()), attr='fingerprint', ctx=Load())])]), Compare(left=Name(id='fallback_u8', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Encoding detection: utf_8 will be used as a fallback match')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='fallback_u8', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='fallback_ascii', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Encoding detection: ascii will be used as a fallback match')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='fallback_ascii', ctx=Load())], keywords=[]))], orelse=[])])])], orelse=[]), If(test=Name(id='results', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Encoding detection: Found %s as plausible (best-candidate) for content. With %i alternatives.'), Attribute(value=Call(func=Attribute(value=Name(id='results', ctx=Load()), attr='best', ctx=Load()), args=[], keywords=[]), attr='encoding', ctx=Load()), BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='results', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Encoding detection: Unable to determine any suitable charset.')], keywords=[]))]), If(test=Name(id='explain', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='removeHandler', ctx=Load()), args=[Name(id='explain_handler', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='setLevel', ctx=Load()), args=[Name(id='previous_logger_level', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='results', ctx=Load()))], decorator_list=[], returns=Name(id='CharsetMatches', ctx=Load())), FunctionDef(name='from_fp', args=arguments(posonlyargs=[], args=[arg(arg='fp', annotation=Name(id='BinaryIO', ctx=Load())), arg(arg='steps', annotation=Name(id='int', ctx=Load())), arg(arg='chunk_size', annotation=Name(id='int', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='cp_isolation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='cp_exclusion', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='preemptive_behaviour', annotation=Name(id='bool', ctx=Load())), arg(arg='explain', annotation=Name(id='bool', ctx=Load())), arg(arg='language_threshold', annotation=Name(id='float', ctx=Load())), arg(arg='enable_fallback', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=5), Constant(value=512), Constant(value=0.2), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=False), Constant(value=0.1), Constant(value=True)]), body=[Expr(value=Constant(value='\n    Same thing than the function from_bytes but using a file pointer that is already ready.\n    Will not close the file pointer.\n    ')), Return(value=Call(func=Name(id='from_bytes', ctx=Load()), args=[Call(func=Attribute(value=Name(id='fp', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]), Name(id='steps', ctx=Load()), Name(id='chunk_size', ctx=Load()), Name(id='threshold', ctx=Load()), Name(id='cp_isolation', ctx=Load()), Name(id='cp_exclusion', ctx=Load()), Name(id='preemptive_behaviour', ctx=Load()), Name(id='explain', ctx=Load()), Name(id='language_threshold', ctx=Load()), Name(id='enable_fallback', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='CharsetMatches', ctx=Load())), FunctionDef(name='from_path', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bytes', ctx=Load()), Name(id='PathLike', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='steps', annotation=Name(id='int', ctx=Load())), arg(arg='chunk_size', annotation=Name(id='int', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='cp_isolation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='cp_exclusion', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='preemptive_behaviour', annotation=Name(id='bool', ctx=Load())), arg(arg='explain', annotation=Name(id='bool', ctx=Load())), arg(arg='language_threshold', annotation=Name(id='float', ctx=Load())), arg(arg='enable_fallback', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=5), Constant(value=512), Constant(value=0.2), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=False), Constant(value=0.1), Constant(value=True)]), body=[Expr(value=Constant(value='\n    Same thing than the function from_bytes but with one extra step. Opening and reading given file path in binary mode.\n    Can raise IOError.\n    ')), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='fp', ctx=Store()))], body=[Return(value=Call(func=Name(id='from_fp', ctx=Load()), args=[Name(id='fp', ctx=Load()), Name(id='steps', ctx=Load()), Name(id='chunk_size', ctx=Load()), Name(id='threshold', ctx=Load()), Name(id='cp_isolation', ctx=Load()), Name(id='cp_exclusion', ctx=Load()), Name(id='preemptive_behaviour', ctx=Load()), Name(id='explain', ctx=Load()), Name(id='language_threshold', ctx=Load()), Name(id='enable_fallback', ctx=Load())], keywords=[]))])], decorator_list=[], returns=Name(id='CharsetMatches', ctx=Load())), FunctionDef(name='is_binary', args=arguments(posonlyargs=[], args=[arg(arg='fp_or_path_or_payload', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='PathLike', ctx=Load()), Name(id='str', ctx=Load()), Name(id='BinaryIO', ctx=Load()), Name(id='bytes', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='steps', annotation=Name(id='int', ctx=Load())), arg(arg='chunk_size', annotation=Name(id='int', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='cp_isolation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='cp_exclusion', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='preemptive_behaviour', annotation=Name(id='bool', ctx=Load())), arg(arg='explain', annotation=Name(id='bool', ctx=Load())), arg(arg='language_threshold', annotation=Name(id='float', ctx=Load())), arg(arg='enable_fallback', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=5), Constant(value=512), Constant(value=0.2), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=False), Constant(value=0.1), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Detect if the given input (file, bytes, or path) points to a binary file. aka. not a string.\n    Based on the same main heuristic algorithms and default kwargs at the sole exception that fallbacks match\n    are disabled to be stricter around ASCII-compatible but unlikely to be a string.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='fp_or_path_or_payload', ctx=Load()), Tuple(elts=[Name(id='str', ctx=Load()), Name(id='PathLike', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='guesses', ctx=Store())], value=Call(func=Name(id='from_path', ctx=Load()), args=[Name(id='fp_or_path_or_payload', ctx=Load())], keywords=[keyword(arg='steps', value=Name(id='steps', ctx=Load())), keyword(arg='chunk_size', value=Name(id='chunk_size', ctx=Load())), keyword(arg='threshold', value=Name(id='threshold', ctx=Load())), keyword(arg='cp_isolation', value=Name(id='cp_isolation', ctx=Load())), keyword(arg='cp_exclusion', value=Name(id='cp_exclusion', ctx=Load())), keyword(arg='preemptive_behaviour', value=Name(id='preemptive_behaviour', ctx=Load())), keyword(arg='explain', value=Name(id='explain', ctx=Load())), keyword(arg='language_threshold', value=Name(id='language_threshold', ctx=Load())), keyword(arg='enable_fallback', value=Name(id='enable_fallback', ctx=Load()))]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='fp_or_path_or_payload', ctx=Load()), Tuple(elts=[Name(id='bytes', ctx=Load()), Name(id='bytearray', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='guesses', ctx=Store())], value=Call(func=Name(id='from_bytes', ctx=Load()), args=[Name(id='fp_or_path_or_payload', ctx=Load())], keywords=[keyword(arg='steps', value=Name(id='steps', ctx=Load())), keyword(arg='chunk_size', value=Name(id='chunk_size', ctx=Load())), keyword(arg='threshold', value=Name(id='threshold', ctx=Load())), keyword(arg='cp_isolation', value=Name(id='cp_isolation', ctx=Load())), keyword(arg='cp_exclusion', value=Name(id='cp_exclusion', ctx=Load())), keyword(arg='preemptive_behaviour', value=Name(id='preemptive_behaviour', ctx=Load())), keyword(arg='explain', value=Name(id='explain', ctx=Load())), keyword(arg='language_threshold', value=Name(id='language_threshold', ctx=Load())), keyword(arg='enable_fallback', value=Name(id='enable_fallback', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='guesses', ctx=Store())], value=Call(func=Name(id='from_fp', ctx=Load()), args=[Name(id='fp_or_path_or_payload', ctx=Load())], keywords=[keyword(arg='steps', value=Name(id='steps', ctx=Load())), keyword(arg='chunk_size', value=Name(id='chunk_size', ctx=Load())), keyword(arg='threshold', value=Name(id='threshold', ctx=Load())), keyword(arg='cp_isolation', value=Name(id='cp_isolation', ctx=Load())), keyword(arg='cp_exclusion', value=Name(id='cp_exclusion', ctx=Load())), keyword(arg='preemptive_behaviour', value=Name(id='preemptive_behaviour', ctx=Load())), keyword(arg='explain', value=Name(id='explain', ctx=Load())), keyword(arg='language_threshold', value=Name(id='language_threshold', ctx=Load())), keyword(arg='enable_fallback', value=Name(id='enable_fallback', ctx=Load()))]))])]), Return(value=UnaryOp(op=Not(), operand=Name(id='guesses', ctx=Load())))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], type_ignores=[])