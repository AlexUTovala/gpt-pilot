Module(body=[Expr(value=Constant(value='psutil is a cross-platform library for retrieving information on\nrunning processes and system utilization (CPU, memory, disks, network,\nsensors) in Python. Supported platforms:\n\n - Linux\n - Windows\n - macOS\n - FreeBSD\n - OpenBSD\n - NetBSD\n - Sun Solaris\n - AIX\n\nWorks with Python versions 2.7 and 3.6+.\n')), ImportFrom(module='__future__', names=[alias(name='division')], level=0), Import(names=[alias(name='collections')]), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='datetime')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='os')]), Import(names=[alias(name='signal')]), Import(names=[alias(name='subprocess')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='threading')]), Import(names=[alias(name='time')]), Try(body=[Import(names=[alias(name='pwd')])], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Assign(targets=[Name(id='pwd', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), ImportFrom(names=[alias(name='_common')], level=1), ImportFrom(module='_common', names=[alias(name='AIX')], level=1), ImportFrom(module='_common', names=[alias(name='BSD')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_CLOSE')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_CLOSE_WAIT')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_CLOSING')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_ESTABLISHED')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_FIN_WAIT1')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_FIN_WAIT2')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_LAST_ACK')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_LISTEN')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_NONE')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_SYN_RECV')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_SYN_SENT')], level=1), ImportFrom(module='_common', names=[alias(name='CONN_TIME_WAIT')], level=1), ImportFrom(module='_common', names=[alias(name='FREEBSD')], level=1), ImportFrom(module='_common', names=[alias(name='LINUX')], level=1), ImportFrom(module='_common', names=[alias(name='MACOS')], level=1), ImportFrom(module='_common', names=[alias(name='NETBSD')], level=1), ImportFrom(module='_common', names=[alias(name='NIC_DUPLEX_FULL')], level=1), ImportFrom(module='_common', names=[alias(name='NIC_DUPLEX_HALF')], level=1), ImportFrom(module='_common', names=[alias(name='NIC_DUPLEX_UNKNOWN')], level=1), ImportFrom(module='_common', names=[alias(name='OPENBSD')], level=1), ImportFrom(module='_common', names=[alias(name='OSX')], level=1), ImportFrom(module='_common', names=[alias(name='POSIX')], level=1), ImportFrom(module='_common', names=[alias(name='POWER_TIME_UNKNOWN')], level=1), ImportFrom(module='_common', names=[alias(name='POWER_TIME_UNLIMITED')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_DEAD')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_DISK_SLEEP')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_IDLE')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_LOCKED')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_PARKED')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_RUNNING')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_SLEEPING')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_STOPPED')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_TRACING_STOP')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_WAITING')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_WAKING')], level=1), ImportFrom(module='_common', names=[alias(name='STATUS_ZOMBIE')], level=1), ImportFrom(module='_common', names=[alias(name='SUNOS')], level=1), ImportFrom(module='_common', names=[alias(name='WINDOWS')], level=1), ImportFrom(module='_common', names=[alias(name='AccessDenied')], level=1), ImportFrom(module='_common', names=[alias(name='Error')], level=1), ImportFrom(module='_common', names=[alias(name='NoSuchProcess')], level=1), ImportFrom(module='_common', names=[alias(name='TimeoutExpired')], level=1), ImportFrom(module='_common', names=[alias(name='ZombieProcess')], level=1), ImportFrom(module='_common', names=[alias(name='memoize_when_activated')], level=1), ImportFrom(module='_common', names=[alias(name='wrap_numbers', asname='_wrap_numbers')], level=1), ImportFrom(module='_compat', names=[alias(name='PY3', asname='_PY3')], level=1), ImportFrom(module='_compat', names=[alias(name='PermissionError')], level=1), ImportFrom(module='_compat', names=[alias(name='ProcessLookupError')], level=1), ImportFrom(module='_compat', names=[alias(name='SubprocessTimeoutExpired', asname='_SubprocessTimeoutExpired')], level=1), ImportFrom(module='_compat', names=[alias(name='long')], level=1), If(test=Name(id='LINUX', ctx=Load()), body=[Assign(targets=[Name(id='PROCFS_PATH', ctx=Store())], value=Constant(value='/proc')), ImportFrom(names=[alias(name='_pslinux', asname='_psplatform')], level=1), ImportFrom(module='_pslinux', names=[alias(name='IOPRIO_CLASS_BE')], level=1), ImportFrom(module='_pslinux', names=[alias(name='IOPRIO_CLASS_IDLE')], level=1), ImportFrom(module='_pslinux', names=[alias(name='IOPRIO_CLASS_NONE')], level=1), ImportFrom(module='_pslinux', names=[alias(name='IOPRIO_CLASS_RT')], level=1)], orelse=[If(test=Name(id='WINDOWS', ctx=Load()), body=[ImportFrom(names=[alias(name='_pswindows', asname='_psplatform')], level=1), ImportFrom(module='_psutil_windows', names=[alias(name='ABOVE_NORMAL_PRIORITY_CLASS')], level=1), ImportFrom(module='_psutil_windows', names=[alias(name='BELOW_NORMAL_PRIORITY_CLASS')], level=1), ImportFrom(module='_psutil_windows', names=[alias(name='HIGH_PRIORITY_CLASS')], level=1), ImportFrom(module='_psutil_windows', names=[alias(name='IDLE_PRIORITY_CLASS')], level=1), ImportFrom(module='_psutil_windows', names=[alias(name='NORMAL_PRIORITY_CLASS')], level=1), ImportFrom(module='_psutil_windows', names=[alias(name='REALTIME_PRIORITY_CLASS')], level=1), ImportFrom(module='_pswindows', names=[alias(name='CONN_DELETE_TCB')], level=1), ImportFrom(module='_pswindows', names=[alias(name='IOPRIO_HIGH')], level=1), ImportFrom(module='_pswindows', names=[alias(name='IOPRIO_LOW')], level=1), ImportFrom(module='_pswindows', names=[alias(name='IOPRIO_NORMAL')], level=1), ImportFrom(module='_pswindows', names=[alias(name='IOPRIO_VERYLOW')], level=1)], orelse=[If(test=Name(id='MACOS', ctx=Load()), body=[ImportFrom(names=[alias(name='_psosx', asname='_psplatform')], level=1)], orelse=[If(test=Name(id='BSD', ctx=Load()), body=[ImportFrom(names=[alias(name='_psbsd', asname='_psplatform')], level=1)], orelse=[If(test=Name(id='SUNOS', ctx=Load()), body=[ImportFrom(names=[alias(name='_pssunos', asname='_psplatform')], level=1), ImportFrom(module='_pssunos', names=[alias(name='CONN_BOUND')], level=1), ImportFrom(module='_pssunos', names=[alias(name='CONN_IDLE')], level=1), Assign(targets=[Name(id='PROCFS_PATH', ctx=Store())], value=Constant(value='/proc'))], orelse=[If(test=Name(id='AIX', ctx=Load()), body=[ImportFrom(names=[alias(name='_psaix', asname='_psplatform')], level=1), Assign(targets=[Name(id='PROCFS_PATH', ctx=Store())], value=Constant(value='/proc'))], orelse=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[BinOp(left=Constant(value='platform %s is not supported'), op=Mod(), right=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()))], keywords=[]))])])])])])]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Error'), Constant(value='NoSuchProcess'), Constant(value='ZombieProcess'), Constant(value='AccessDenied'), Constant(value='TimeoutExpired'), Constant(value='version_info'), Constant(value='__version__'), Constant(value='STATUS_RUNNING'), Constant(value='STATUS_IDLE'), Constant(value='STATUS_SLEEPING'), Constant(value='STATUS_DISK_SLEEP'), Constant(value='STATUS_STOPPED'), Constant(value='STATUS_TRACING_STOP'), Constant(value='STATUS_ZOMBIE'), Constant(value='STATUS_DEAD'), Constant(value='STATUS_WAKING'), Constant(value='STATUS_LOCKED'), Constant(value='STATUS_WAITING'), Constant(value='STATUS_LOCKED'), Constant(value='STATUS_PARKED'), Constant(value='CONN_ESTABLISHED'), Constant(value='CONN_SYN_SENT'), Constant(value='CONN_SYN_RECV'), Constant(value='CONN_FIN_WAIT1'), Constant(value='CONN_FIN_WAIT2'), Constant(value='CONN_TIME_WAIT'), Constant(value='CONN_CLOSE'), Constant(value='CONN_CLOSE_WAIT'), Constant(value='CONN_LAST_ACK'), Constant(value='CONN_LISTEN'), Constant(value='CONN_CLOSING'), Constant(value='CONN_NONE'), Constant(value='AF_LINK'), Constant(value='NIC_DUPLEX_FULL'), Constant(value='NIC_DUPLEX_HALF'), Constant(value='NIC_DUPLEX_UNKNOWN'), Constant(value='POWER_TIME_UNKNOWN'), Constant(value='POWER_TIME_UNLIMITED'), Constant(value='BSD'), Constant(value='FREEBSD'), Constant(value='LINUX'), Constant(value='NETBSD'), Constant(value='OPENBSD'), Constant(value='MACOS'), Constant(value='OSX'), Constant(value='POSIX'), Constant(value='SUNOS'), Constant(value='WINDOWS'), Constant(value='AIX'), Constant(value='Process'), Constant(value='Popen'), Constant(value='pid_exists'), Constant(value='pids'), Constant(value='process_iter'), Constant(value='wait_procs'), Constant(value='virtual_memory'), Constant(value='swap_memory'), Constant(value='cpu_times'), Constant(value='cpu_percent'), Constant(value='cpu_times_percent'), Constant(value='cpu_count'), Constant(value='cpu_stats'), Constant(value='net_io_counters'), Constant(value='net_connections'), Constant(value='net_if_addrs'), Constant(value='net_if_stats'), Constant(value='disk_io_counters'), Constant(value='disk_partitions'), Constant(value='disk_usage'), Constant(value='users'), Constant(value='boot_time')], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='__extra__all__', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), Constant(value='rlimit')], keywords=[]), body=[ImportFrom(names=[alias(name='_psutil_posix')], level=1), Assign(targets=[Name(id='_globals', ctx=Store())], value=Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='_name', ctx=Store())], value=Constant(value=None)), For(target=Name(id='_name', ctx=Store()), iter=Call(func=Name(id='dir', ctx=Load()), args=[Name(id='_psutil_posix', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='_name', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='RLIM')], keywords=[]), Call(func=Attribute(value=Name(id='_name', ctx=Load()), attr='isupper', ctx=Load()), args=[], keywords=[])]), body=[Assign(targets=[Subscript(value=Name(id='_globals', ctx=Load()), slice=Name(id='_name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='_psutil_posix', ctx=Load()), Name(id='_name', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='_name', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Delete(targets=[Name(id='_globals', ctx=Del()), Name(id='_name', ctx=Del())])], orelse=[]), Assign(targets=[Name(id='AF_LINK', ctx=Store())], value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='AF_LINK', ctx=Load())), Assign(targets=[Name(id='__author__', ctx=Store())], value=Constant(value="Giampaolo Rodola'")), Assign(targets=[Name(id='__version__', ctx=Store())], value=Constant(value='5.9.6')), Assign(targets=[Name(id='version_info', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='int', ctx=Load()), args=[Name(id='num', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='num', ctx=Store()), iter=Call(func=Attribute(value=Name(id='__version__', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='_timer', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='time', ctx=Load()), Constant(value='monotonic'), Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_TOTAL_PHYMEM', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='_LOWEST_PID', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='_SENTINEL', ctx=Store())], value=Call(func=Name(id='object', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='__version__', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='.'), Constant(value='')], keywords=[])], keywords=[]), ops=[NotEq()], comparators=[Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cext', ctx=Load()), Constant(value='version'), Constant(value=None)], keywords=[])]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=BinOp(left=Constant(value='version conflict: %r C extension '), op=Mod(), right=Attribute(value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cext', ctx=Load()), attr='__file__', ctx=Load()))), AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=Constant(value='module was built for another version of psutil')), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cext', ctx=Load()), Constant(value='version')], keywords=[]), body=[AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=BinOp(left=Constant(value=' (%s instead of %s)'), op=Mod(), right=Tuple(elts=[Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[ListComp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cext', ctx=Load()), attr='version', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]), Name(id='__version__', ctx=Load())], ctx=Load())))], orelse=[AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=BinOp(left=Constant(value=' (different than %s)'), op=Mod(), right=Name(id='__version__', ctx=Load())))]), AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=BinOp(left=Constant(value="; you may try to 'pip uninstall psutil', manually remove %s"), op=Mod(), right=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cext', ctx=Load()), Constant(value='__file__'), Constant(value='the existing psutil install directory')], keywords=[]))), AugAssign(target=Name(id='msg', ctx=Store()), op=Add(), value=Constant(value=' or clean the virtual env somehow, then reinstall')), Raise(exc=Call(func=Name(id='ImportError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='_psplatform', ctx=Load()), Constant(value='ppid_map')], keywords=[]), body=[Assign(targets=[Name(id='_ppid_map', ctx=Store())], value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='ppid_map', ctx=Load()))], orelse=[FunctionDef(name='_ppid_map', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a {pid: ppid, ...} dict for all running processes in\n        one shot. Used to speed up Process.children().\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='pid', ctx=Store()), iter=Call(func=Name(id='pids', ctx=Load()), args=[], keywords=[]), body=[Try(body=[Assign(targets=[Subscript(value=Name(id='ret', ctx=Load()), slice=Name(id='pid', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[]), attr='ppid', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='NoSuchProcess', ctx=Load()), Name(id='ZombieProcess', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[])]), FunctionDef(name='_pprint_secs', args=arguments(posonlyargs=[], args=[arg(arg='secs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Format seconds in a human readable form.')), Assign(targets=[Name(id='now', ctx=Store())], value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='secs_ago', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='now', ctx=Load()), op=Sub(), right=Name(id='secs', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='fmt', ctx=Store())], value=IfExp(test=Compare(left=Name(id='secs_ago', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=BinOp(left=Constant(value=60), op=Mult(), right=Constant(value=60)), op=Mult(), right=Constant(value=24))]), body=Constant(value='%H:%M:%S'), orelse=Constant(value='%Y-%m-%d %H:%M:%S'))), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='datetime', ctx=Load()), attr='datetime', ctx=Load()), attr='fromtimestamp', ctx=Load()), args=[Name(id='secs', ctx=Load())], keywords=[]), attr='strftime', ctx=Load()), args=[Name(id='fmt', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='Process', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Represents an OS process with the given PID.\n    If PID is omitted current process PID (os.getpid()) is used.\n    Raise NoSuchProcess if PID does not exist.\n\n    Note that most of the methods of this class do not make sure\n    the PID of the process being queried has been reused over time.\n    That means you might end up retrieving an information referring\n    to another process in case the original one this instance\n    refers to is gone in the meantime.\n\n    The only exceptions for which process identity is pre-emptively\n    checked and guaranteed are:\n\n     - parent()\n     - children()\n     - nice() (set)\n     - ionice() (set)\n     - rlimit() (set)\n     - cpu_affinity (set)\n     - suspend()\n     - resume()\n     - send_signal()\n     - terminate()\n     - kill()\n\n    To prevent this problem for all other methods you can:\n     - use is_running() before querying the process\n     - if you're continuously iterating over a set of Process\n       instances use process_iter() which pre-emptively checks\n       process identity for every yielded instance\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pid')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_init', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_init', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pid'), arg(arg='_ignore_nsp')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[If(test=Compare(left=Name(id='pid', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='pid', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='getpid', ctx=Load()), args=[], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='_PY3', ctx=Load())), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pid', ctx=Load()), Tuple(elts=[Name(id='int', ctx=Load()), Name(id='long', ctx=Load())], ctx=Load())], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Constant(value='pid must be an integer (got %r)'), op=Mod(), right=Name(id='pid', ctx=Load()))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='pid', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='pid must be a positive integer (got %s)'), op=Mod(), right=Name(id='pid', ctx=Load()))], keywords=[]))], orelse=[]), Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cext', ctx=Load()), attr='check_pid_range', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OverflowError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='NoSuchProcess', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[keyword(arg='msg', value=BinOp(left=Constant(value='process PID out of range (got %s)'), op=Mod(), right=Name(id='pid', ctx=Load())))]))])], orelse=[], finalbody=[])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_pid', ctx=Store())], value=Name(id='pid', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exe', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_create_time', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gone', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_pid_reused', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_hash', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_lock', ctx=Store())], value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='RLock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ppid', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Store())], value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_sys_cpu_times', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_proc_cpu_times', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exitcode', ctx=Store())], value=Name(id='_SENTINEL', ctx=Load())), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='create_time', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AccessDenied', ctx=Load()), body=[Pass()]), ExceptHandler(type=Name(id='ZombieProcess', ctx=Load()), body=[Pass()]), ExceptHandler(type=Name(id='NoSuchProcess', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Name(id='_ignore_nsp', ctx=Load())), body=[Raise(exc=Call(func=Name(id='NoSuchProcess', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[keyword(arg='msg', value=Constant(value='process PID not found'))]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gone', ctx=Store())], value=Constant(value=True))])])], orelse=[], finalbody=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ident', ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_create_time', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='info', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='OrderedDict', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='info', ctx=Load()), slice=Constant(value='pid'), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load())), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='info', ctx=Load()), slice=Constant(value='name'), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()))], orelse=[]), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='oneshot', ctx=Load()), args=[], keywords=[]))], body=[Try(body=[Assign(targets=[Subscript(value=Name(id='info', ctx=Load()), slice=Constant(value='name'), ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='info', ctx=Load()), slice=Constant(value='status'), ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='status', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ZombieProcess', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='info', ctx=Load()), slice=Constant(value='status'), ctx=Store())], value=Constant(value='zombie'))]), ExceptHandler(type=Name(id='NoSuchProcess', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='info', ctx=Load()), slice=Constant(value='status'), ctx=Store())], value=Constant(value='terminated'))]), ExceptHandler(type=Name(id='AccessDenied', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_exitcode', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Name(id='_SENTINEL', ctx=Load()), Constant(value=None)], ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='info', ctx=Load()), slice=Constant(value='exitcode'), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_exitcode', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_create_time', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='info', ctx=Load()), slice=Constant(value='started'), ctx=Store())], value=Call(func=Name(id='_pprint_secs', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_create_time', ctx=Load())], keywords=[]))], orelse=[]), Return(value=BinOp(left=Constant(value='%s.%s(%s)'), op=Mod(), right=Tuple(elts=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__module__', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[ListComp(elt=BinOp(left=Constant(value='%s=%r'), op=Mod(), right=Tuple(elts=[Name(id='k', ctx=Load()), Name(id='v', ctx=Load())], ctx=Load())), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='info', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])], ctx=Load())))])], decorator_list=[]), Assign(targets=[Name(id='__repr__', ctx=Store())], value=Name(id='__str__', ctx=Load())), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Process', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), If(test=BoolOp(op=Or(), values=[Name(id='OPENBSD', ctx=Load()), Name(id='NETBSD', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='pid1', ctx=Store()), Name(id='ctime1', ctx=Store())], ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ident', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='pid2', ctx=Store()), Name(id='ctime2', ctx=Store())], ctx=Store())], value=Attribute(value=Name(id='other', ctx=Load()), attr='_ident', ctx=Load())), If(test=Compare(left=Name(id='pid1', ctx=Load()), ops=[Eq()], comparators=[Name(id='pid2', ctx=Load())]), body=[If(test=BoolOp(op=And(), values=[Name(id='ctime1', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='ctime2', ctx=Load()))]), body=[Try(body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='status', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Name(id='STATUS_ZOMBIE', ctx=Load())]))], handlers=[ExceptHandler(type=Name(id='Error', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], orelse=[]), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_ident', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='other', ctx=Load()), attr='_ident', ctx=Load())]))], decorator_list=[]), FunctionDef(name='__ne__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=UnaryOp(op=Not(), operand=Compare(left=Name(id='self', ctx=Load()), ops=[Eq()], comparators=[Name(id='other', ctx=Load())])))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_hash', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_hash', ctx=Store())], value=Call(func=Name(id='hash', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_ident', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hash', ctx=Load()))], decorator_list=[]), FunctionDef(name='_raise_if_pid_reused', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Raises NoSuchProcess in case process PID has been reused.')), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_running', ctx=Load()), args=[], keywords=[])), Attribute(value=Name(id='self', ctx=Load()), attr='_pid_reused', ctx=Load())]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='process no longer exists and its PID has been reused')), Raise(exc=Call(func=Name(id='NoSuchProcess', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())], keywords=[keyword(arg='msg', value=Name(id='msg', ctx=Load()))]))], orelse=[])], decorator_list=[]), FunctionDef(name='pid', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The process PID.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_pid', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='oneshot', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Utility context manager which considerably speeds up the\n        retrieval of multiple process information at the same time.\n\n        Internally different process info (e.g. name, ppid, uids,\n        gids, ...) may be fetched by using the same routine, but\n        only one information is returned and the others are discarded.\n        When using this context manager the internal routine is\n        executed once (in the example below on name()) and the\n        other info are cached.\n\n        The cache is cleared when exiting the context manager block.\n        The advice is to use this every time you retrieve more than\n        one information about the process. If you're lucky, you'll\n        get a hell of a speedup.\n\n        >>> import psutil\n        >>> p = psutil.Process()\n        >>> with p.oneshot():\n        ...     p.name()  # collect multiple info\n        ...     p.cpu_times()  # return cached value\n        ...     p.cpu_percent()  # return cached value\n        ...     p.create_time()  # return cached value\n        ...\n        >>>\n        ")), With(items=[withitem(context_expr=Attribute(value=Name(id='self', ctx=Load()), attr='_lock', ctx=Load()))], body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='_cache')], keywords=[]), body=[Expr(value=Yield())], orelse=[Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='cpu_times', ctx=Load()), attr='cache_activate', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='memory_info', ctx=Load()), attr='cache_activate', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ppid', ctx=Load()), attr='cache_activate', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Name(id='POSIX', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='uids', ctx=Load()), attr='cache_activate', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='oneshot_enter', ctx=Load()), args=[], keywords=[])), Expr(value=Yield())], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='cpu_times', ctx=Load()), attr='cache_deactivate', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='memory_info', ctx=Load()), attr='cache_deactivate', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ppid', ctx=Load()), attr='cache_deactivate', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), If(test=Name(id='POSIX', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='uids', ctx=Load()), attr='cache_deactivate', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='oneshot_exit', ctx=Load()), args=[], keywords=[]))])])])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='as_dict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='attrs'), arg(arg='ad_value')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Utility method returning process information as a\n        hashable dictionary.\n        If *attrs* is specified it must be a list of strings\n        reflecting available Process class' attribute names\n        (e.g. ['cpu_times', 'name']) else all public (read\n        only) attributes are assumed.\n        *ad_value* is the value which gets assigned in case\n        AccessDenied or ZombieProcess exception is raised when\n        retrieving that particular process information.\n        ")), Assign(targets=[Name(id='valid_names', ctx=Store())], value=Name(id='_as_dict_attrnames', ctx=Load())), If(test=Compare(left=Name(id='attrs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='attrs', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load()), Name(id='set', ctx=Load()), Name(id='frozenset', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Constant(value='invalid attrs type %s'), op=Mod(), right=Call(func=Name(id='type', ctx=Load()), args=[Name(id='attrs', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='attrs', ctx=Load())], keywords=[])), Assign(targets=[Name(id='invalid_names', ctx=Store())], value=BinOp(left=Name(id='attrs', ctx=Load()), op=Sub(), right=Name(id='valid_names', ctx=Load()))), If(test=Name(id='invalid_names', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='invalid attr name%s %s'), op=Mod(), right=Tuple(elts=[IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='invalid_names', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=Constant(value='s'), orelse=Constant(value='')), Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='repr', ctx=Load()), Name(id='invalid_names', ctx=Load())], keywords=[])], keywords=[])], ctx=Load()))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='retdict', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='ls', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='attrs', ctx=Load()), Name(id='valid_names', ctx=Load())])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='oneshot', ctx=Load()), args=[], keywords=[]))], body=[For(target=Name(id='name', ctx=Store()), iter=Name(id='ls', ctx=Load()), body=[Try(body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Constant(value='pid')]), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()))], orelse=[Assign(targets=[Name(id='meth', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='meth', ctx=Load()), args=[], keywords=[]))])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AccessDenied', ctx=Load()), Name(id='ZombieProcess', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Name(id='ad_value', ctx=Load()))]), ExceptHandler(type=Name(id='NotImplementedError', ctx=Load()), body=[If(test=Name(id='attrs', ctx=Load()), body=[Raise()], orelse=[]), Continue()])], orelse=[], finalbody=[]), Assign(targets=[Subscript(value=Name(id='retdict', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Name(id='ret', ctx=Load()))], orelse=[])]), Return(value=Name(id='retdict', ctx=Load()))], decorator_list=[]), FunctionDef(name='parent', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the parent process as a Process object pre-emptively\n        checking whether PID has been reused.\n        If no parent is known return None.\n        ')), Assign(targets=[Name(id='lowest_pid', ctx=Store())], value=IfExp(test=Compare(left=Name(id='_LOWEST_PID', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='_LOWEST_PID', ctx=Load()), orelse=Subscript(value=Call(func=Name(id='pids', ctx=Load()), args=[], keywords=[]), slice=Constant(value=0), ctx=Load()))), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()), ops=[Eq()], comparators=[Name(id='lowest_pid', ctx=Load())]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='ppid', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='ppid', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='ppid', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='ctime', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='create_time', ctx=Load()), args=[], keywords=[])), Try(body=[Assign(targets=[Name(id='parent', ctx=Store())], value=Call(func=Name(id='Process', ctx=Load()), args=[Name(id='ppid', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='parent', ctx=Load()), attr='create_time', ctx=Load()), args=[], keywords=[]), ops=[LtE()], comparators=[Name(id='ctime', ctx=Load())]), body=[Return(value=Name(id='parent', ctx=Load()))], orelse=[])], handlers=[ExceptHandler(type=Name(id='NoSuchProcess', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='parents', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the parents of this process as a list of Process\n        instances. If no parents are known return an empty list.\n        ')), Assign(targets=[Name(id='parents', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='proc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parent', ctx=Load()), args=[], keywords=[])), While(test=Compare(left=Name(id='proc', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='parents', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='proc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='proc', ctx=Store())], value=Call(func=Attribute(value=Name(id='proc', ctx=Load()), attr='parent', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='parents', ctx=Load()))], decorator_list=[]), FunctionDef(name='is_running', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return whether this process is running.\n        It also checks if PID has been reused by another process in\n        which case return False.\n        ')), If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_gone', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_pid_reused', ctx=Load())]), body=[Return(value=Constant(value=False))], orelse=[]), Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_pid_reused', ctx=Store())], value=Compare(left=Name(id='self', ctx=Load()), ops=[NotEq()], comparators=[Call(func=Name(id='Process', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load())], keywords=[])])), Return(value=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_pid_reused', ctx=Load())))], handlers=[ExceptHandler(type=Name(id='ZombieProcess', ctx=Load()), body=[Return(value=Constant(value=True))]), ExceptHandler(type=Name(id='NoSuchProcess', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gone', ctx=Store())], value=Constant(value=True)), Return(value=Constant(value=False))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='ppid', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The process parent PID.\n        On Windows the return value is cached after first call.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), If(test=Name(id='POSIX', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='ppid', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ppid', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_ppid', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='ppid', ctx=Load()), args=[], keywords=[])])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ppid', ctx=Load()))])], decorator_list=[Name(id='memoize_when_activated', ctx=Load())]), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The process name. The return value is cached after first call.')), If(test=BoolOp(op=And(), values=[Name(id='WINDOWS', ctx=Load()), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='name', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='POSIX', ctx=Load()), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), ops=[GtE()], comparators=[Constant(value=15)])]), body=[Try(body=[Assign(targets=[Name(id='cmdline', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='cmdline', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AccessDenied', ctx=Load()), Name(id='ZombieProcess', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[If(test=Name(id='cmdline', ctx=Load()), body=[Assign(targets=[Name(id='extended_name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Subscript(value=Name(id='cmdline', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='extended_name', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Name(id='extended_name', ctx=Load()))], orelse=[])], orelse=[])], finalbody=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='_name', ctx=Store())], value=Name(id='name', ctx=Load())), Return(value=Name(id='name', ctx=Load()))], decorator_list=[]), FunctionDef(name='exe', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The process executable as an absolute path.\n        May also be an empty string.\n        The return value is cached after first call.\n        ')), FunctionDef(name='guess_it', args=arguments(posonlyargs=[], args=[arg(arg='fallback')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='cmdline', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='cmdline', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='cmdline', ctx=Load()), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='os', ctx=Load()), Constant(value='access')], keywords=[]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='os', ctx=Load()), Constant(value='X_OK')], keywords=[])]), body=[Assign(targets=[Name(id='exe', ctx=Store())], value=Subscript(value=Name(id='cmdline', ctx=Load()), slice=Constant(value=0), ctx=Load())), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isabs', ctx=Load()), args=[Name(id='exe', ctx=Load())], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='exe', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='access', ctx=Load()), args=[Name(id='exe', ctx=Load()), Attribute(value=Name(id='os', ctx=Load()), attr='X_OK', ctx=Load())], keywords=[])]), body=[Return(value=Name(id='exe', ctx=Load()))], orelse=[])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='fallback', ctx=Load()), Name(id='AccessDenied', ctx=Load())], keywords=[]), body=[Raise(exc=Name(id='fallback', ctx=Load()))], orelse=[]), Return(value=Name(id='fallback', ctx=Load()))], decorator_list=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_exe', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Try(body=[Assign(targets=[Name(id='exe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='exe', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AccessDenied', ctx=Load()), name='err', body=[Return(value=Call(func=Name(id='guess_it', ctx=Load()), args=[], keywords=[keyword(arg='fallback', value=Name(id='err', ctx=Load()))]))])], orelse=[If(test=UnaryOp(op=Not(), operand=Name(id='exe', ctx=Load())), body=[Try(body=[Assign(targets=[Name(id='exe', ctx=Store())], value=Call(func=Name(id='guess_it', ctx=Load()), args=[], keywords=[keyword(arg='fallback', value=Name(id='exe', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='AccessDenied', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exe', ctx=Store())], value=Name(id='exe', ctx=Load()))], finalbody=[])], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_exe', ctx=Load()))], decorator_list=[]), FunctionDef(name='cmdline', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The command line this process has been called with.')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='cmdline', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='status', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The process current status as a STATUS_* constant.')), Try(body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='status', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ZombieProcess', ctx=Load()), body=[Return(value=Name(id='STATUS_ZOMBIE', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='username', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The name of the user that owns the process.\n        On UNIX this is calculated by using *real* process uid.\n        ')), If(test=Name(id='POSIX', ctx=Load()), body=[If(test=Compare(left=Name(id='pwd', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ImportError', ctx=Load()), args=[Constant(value='requires pwd module shipped with standard python')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='real_uid', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='uids', ctx=Load()), args=[], keywords=[]), attr='real', ctx=Load())), Try(body=[Return(value=Attribute(value=Call(func=Attribute(value=Name(id='pwd', ctx=Load()), attr='getpwuid', ctx=Load()), args=[Name(id='real_uid', ctx=Load())], keywords=[]), attr='pw_name', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='real_uid', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], orelse=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='username', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='create_time', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The process creation time as a floating point number\n        expressed in seconds since the epoch.\n        The return value is cached after first call.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_create_time', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_create_time', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='create_time', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_create_time', ctx=Load()))], decorator_list=[]), FunctionDef(name='cwd', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Process current working directory as an absolute path.')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='cwd', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='nice', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Get or set process niceness (priority).')), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='nice_get', ctx=Load()), args=[], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='nice_set', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))])], decorator_list=[]), If(test=Name(id='POSIX', ctx=Load()), body=[FunctionDef(name='uids', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return process UIDs as a (real, effective, saved)\n            namedtuple.\n            ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='uids', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='memoize_when_activated', ctx=Load())]), FunctionDef(name='gids', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return process GIDs as a (real, effective, saved)\n            namedtuple.\n            ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='gids', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='terminal', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The terminal associated with this process, if any,\n            else None.\n            ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='terminal', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='num_fds', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the number of file descriptors opened by this\n            process (POSIX only).\n            ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='num_fds', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), Constant(value='io_counters')], keywords=[]), body=[FunctionDef(name='io_counters', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return process I/O statistics as a\n            (read_count, write_count, read_bytes, write_bytes)\n            namedtuple.\n            Those are the number of read/write calls performed and the\n            amount of bytes read and written by the process.\n            ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='io_counters', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), Constant(value='ionice_get')], keywords=[]), body=[FunctionDef(name='ionice', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ioclass'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Get or set process I/O niceness (priority).\n\n            On Linux *ioclass* is one of the IOPRIO_CLASS_* constants.\n            *value* is a number which goes from 0 to 7. The higher the\n            value, the lower the I/O priority of the process.\n\n            On Windows only *ioclass* is used and it can be set to 2\n            (normal), 1 (low) or 0 (very low).\n\n            Available on Linux and Windows > Vista only.\n            ')), If(test=Compare(left=Name(id='ioclass', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="'ioclass' argument must be specified")], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='ionice_get', ctx=Load()), args=[], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='ionice_set', ctx=Load()), args=[Name(id='ioclass', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))])], decorator_list=[])], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), Constant(value='rlimit')], keywords=[]), body=[FunctionDef(name='rlimit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resource'), arg(arg='limits')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Get or set process resource limits as a (soft, hard)\n            tuple.\n\n            *resource* is one of the RLIMIT_* constants.\n            *limits* is supposed to be a (soft, hard) tuple.\n\n            See "man prlimit" for further info.\n            Available on Linux and FreeBSD only.\n            ')), If(test=Compare(left=Name(id='limits', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='rlimit', ctx=Load()), args=[Name(id='resource', ctx=Load()), Name(id='limits', ctx=Load())], keywords=[]))], decorator_list=[])], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), Constant(value='cpu_affinity_get')], keywords=[]), body=[FunctionDef(name='cpu_affinity', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cpus')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Get or set process CPU affinity.\n            If specified, *cpus* must be a list of CPUs for which you\n            want to set the affinity (e.g. [0, 1]).\n            If an empty list is passed, all egible CPUs are assumed\n            (and set).\n            (Windows, Linux and BSD only).\n            ')), If(test=Compare(left=Name(id='cpus', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='cpu_affinity_get', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='cpus', ctx=Load())), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), Constant(value='_get_eligible_cpus')], keywords=[]), body=[Assign(targets=[Name(id='cpus', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='_get_eligible_cpus', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='cpus', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[keyword(arg='percpu', value=Constant(value=True))])], keywords=[])], keywords=[])], keywords=[]))])], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='cpu_affinity_set', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='cpus', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))])], decorator_list=[])], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), Constant(value='cpu_num')], keywords=[]), body=[FunctionDef(name='cpu_num', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return what CPU this process is currently running on.\n            The returned number should be <= psutil.cpu_count()\n            and <= len(psutil.cpu_percent(percpu=True)).\n            It may be used in conjunction with\n            psutil.cpu_percent(percpu=True) to observe the system\n            workload distributed across CPUs.\n            ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='cpu_num', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), Constant(value='environ')], keywords=[]), body=[FunctionDef(name='environ', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='The environment variables of the process as a dict.  Note: this\n            might not reflect changes made after the process started.\n            ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='environ', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], orelse=[]), If(test=Name(id='WINDOWS', ctx=Load()), body=[FunctionDef(name='num_handles', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the number of handles opened by this process\n            (Windows only).\n            ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='num_handles', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], orelse=[]), FunctionDef(name='num_ctx_switches', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the number of voluntary and involuntary context\n        switches performed by this process.\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='num_ctx_switches', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='num_threads', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the number of threads used by this process.')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='num_threads', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), Constant(value='threads')], keywords=[]), body=[FunctionDef(name='threads', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return threads opened by process as a list of\n            (id, user_time, system_time) namedtuples representing\n            thread id and thread CPU times (user/system).\n            On OpenBSD this method requires root access.\n            ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='threads', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], orelse=[]), FunctionDef(name='children', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='recursive')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value="Return the children of this process as a list of Process\n        instances, pre-emptively checking whether PID has been reused.\n        If *recursive* is True return all the parent descendants.\n\n        Example (A == this process):\n\n         A \n            \n             B (child) \n                          X (grandchild) \n                                             Y (great grandchild)\n             C (child)\n             D (child)\n\n        >>> import psutil\n        >>> p = psutil.Process()\n        >>> p.children()\n        B, C, D\n        >>> p.children(recursive=True)\n        B, X, Y, C, D\n\n        Note that in the example above if process X disappears\n        process Y won't be listed as the reference to process A\n        is lost.\n        ")), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ppid_map', ctx=Store())], value=Call(func=Name(id='_ppid_map', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ret', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='recursive', ctx=Load())), body=[For(target=Tuple(elts=[Name(id='pid', ctx=Store()), Name(id='ppid', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='ppid_map', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='ppid', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load())]), body=[Try(body=[Assign(targets=[Name(id='child', ctx=Store())], value=Call(func=Name(id='Process', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='create_time', ctx=Load()), args=[], keywords=[]), ops=[LtE()], comparators=[Call(func=Attribute(value=Name(id='child', ctx=Load()), attr='create_time', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='child', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='NoSuchProcess', ctx=Load()), Name(id='ZombieProcess', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='reverse_ppid_map', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='defaultdict', ctx=Load()), args=[Name(id='list', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='pid', ctx=Store()), Name(id='ppid', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='ppid_map', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='reverse_ppid_map', ctx=Load()), slice=Name(id='ppid', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='seen', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='stack', ctx=Store())], value=List(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load())], ctx=Load())), While(test=Name(id='stack', ctx=Load()), body=[Assign(targets=[Name(id='pid', ctx=Store())], value=Call(func=Attribute(value=Name(id='stack', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='pid', ctx=Load()), ops=[In()], comparators=[Name(id='seen', ctx=Load())]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[])), For(target=Name(id='child_pid', ctx=Store()), iter=Subscript(value=Name(id='reverse_ppid_map', ctx=Load()), slice=Name(id='pid', ctx=Load()), ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='child', ctx=Store())], value=Call(func=Name(id='Process', ctx=Load()), args=[Name(id='child_pid', ctx=Load())], keywords=[])), Assign(targets=[Name(id='intime', ctx=Store())], value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='create_time', ctx=Load()), args=[], keywords=[]), ops=[LtE()], comparators=[Call(func=Attribute(value=Name(id='child', ctx=Load()), attr='create_time', ctx=Load()), args=[], keywords=[])])), If(test=Name(id='intime', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='child', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='stack', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='child_pid', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='NoSuchProcess', ctx=Load()), Name(id='ZombieProcess', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[])], orelse=[])]), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[]), FunctionDef(name='cpu_percent', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='interval')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Return a float representing the current process CPU\n        utilization as a percentage.\n\n        When *interval* is 0.0 or None (default) compares process times\n        to system CPU times elapsed since last call, returning\n        immediately (non-blocking). That means that the first time\n        this is called it will return a meaningful 0.0 value.\n\n        When *interval* is > 0.0 compares process times to system CPU\n        times elapsed before and after the interval (blocking).\n\n        In this case is recommended for accuracy that this function\n        be called with at least 0.1 seconds between calls.\n\n        A value > 100.0 can be returned in case of processes running\n        multiple threads on different CPU cores.\n\n        The returned value is explicitly NOT split evenly between\n        all available logical CPUs. This means that a busy loop process\n        running on a system with 2 logical CPUs will be reported as\n        having 100% CPU utilization instead of 50%.\n\n        Examples:\n\n          >>> import psutil\n          >>> p = psutil.Process(os.getpid())\n          >>> # blocking\n          >>> p.cpu_percent(interval=1)\n          2.0\n          >>> # non-blocking (percentage since last call)\n          >>> p.cpu_percent(interval=None)\n          2.9\n          >>>\n        ')), Assign(targets=[Name(id='blocking', ctx=Store())], value=BoolOp(op=And(), values=[Compare(left=Name(id='interval', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='interval', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0.0)])])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='interval', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='interval', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='interval is not positive (got %r)'), op=Mod(), right=Name(id='interval', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='num_cpus', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Name(id='cpu_count', ctx=Load()), args=[], keywords=[]), Constant(value=1)])), FunctionDef(name='timer', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Call(func=Name(id='_timer', ctx=Load()), args=[], keywords=[]), op=Mult(), right=Name(id='num_cpus', ctx=Load())))], decorator_list=[]), If(test=Name(id='blocking', ctx=Load()), body=[Assign(targets=[Name(id='st1', ctx=Store())], value=Call(func=Name(id='timer', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='pt1', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='cpu_times', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='sleep', ctx=Load()), args=[Name(id='interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='st2', ctx=Store())], value=Call(func=Name(id='timer', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='pt2', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='cpu_times', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='st1', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_last_sys_cpu_times', ctx=Load())), Assign(targets=[Name(id='pt1', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_last_proc_cpu_times', ctx=Load())), Assign(targets=[Name(id='st2', ctx=Store())], value=Call(func=Name(id='timer', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='pt2', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='cpu_times', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='st1', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='pt1', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_sys_cpu_times', ctx=Store())], value=Name(id='st2', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_proc_cpu_times', ctx=Store())], value=Name(id='pt2', ctx=Load())), Return(value=Constant(value=0.0))], orelse=[])]), Assign(targets=[Name(id='delta_proc', ctx=Store())], value=BinOp(left=BinOp(left=Attribute(value=Name(id='pt2', ctx=Load()), attr='user', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='pt1', ctx=Load()), attr='user', ctx=Load())), op=Add(), right=BinOp(left=Attribute(value=Name(id='pt2', ctx=Load()), attr='system', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='pt1', ctx=Load()), attr='system', ctx=Load())))), Assign(targets=[Name(id='delta_time', ctx=Store())], value=BinOp(left=Name(id='st2', ctx=Load()), op=Sub(), right=Name(id='st1', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_sys_cpu_times', ctx=Store())], value=Name(id='st2', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_proc_cpu_times', ctx=Store())], value=Name(id='pt2', ctx=Load())), Try(body=[Assign(targets=[Name(id='overall_cpus_percent', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='delta_proc', ctx=Load()), op=Div(), right=Name(id='delta_time', ctx=Load())), op=Mult(), right=Constant(value=100)))], handlers=[ExceptHandler(type=Name(id='ZeroDivisionError', ctx=Load()), body=[Return(value=Constant(value=0.0))])], orelse=[Assign(targets=[Name(id='single_cpu_percent', ctx=Store())], value=BinOp(left=Name(id='overall_cpus_percent', ctx=Load()), op=Mult(), right=Name(id='num_cpus', ctx=Load()))), Return(value=Call(func=Name(id='round', ctx=Load()), args=[Name(id='single_cpu_percent', ctx=Load()), Constant(value=1)], keywords=[]))], finalbody=[])], decorator_list=[]), FunctionDef(name='cpu_times', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a (user, system, children_user, children_system)\n        namedtuple representing the accumulated process time, in\n        seconds.\n        This is similar to os.times() but per-process.\n        On macOS and Windows children_user and children_system are\n        always set to 0.\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='cpu_times', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='memoize_when_activated', ctx=Load())]), FunctionDef(name='memory_info', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a namedtuple with variable fields depending on the\n        platform, representing memory information about the process.\n\n        The "portable" fields available on all platforms are `rss` and `vms`.\n\n        All numbers are expressed in bytes.\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='memory_info', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='memoize_when_activated', ctx=Load())]), FunctionDef(name='memory_info_ex', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='memory_info', ctx=Load()), args=[], keywords=[]))], decorator_list=[Call(func=Attribute(value=Name(id='_common', ctx=Load()), attr='deprecated_method', ctx=Load()), args=[], keywords=[keyword(arg='replacement', value=Constant(value='memory_info'))])]), FunctionDef(name='memory_full_info', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='This method returns the same information as memory_info(),\n        plus, on some platform (Linux, macOS, Windows), also provides\n        additional metrics (USS, PSS and swap).\n        The additional metrics provide a better representation of actual\n        process memory usage.\n\n        Namely USS is the memory which is unique to a process and which\n        would be freed if the process was terminated right now.\n\n        It does so by passing through the whole process address.\n        As such it usually requires higher user privileges than\n        memory_info() and is considerably slower.\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='memory_full_info', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='memory_percent', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='memtype')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='rss')]), body=[Expr(value=Constant(value='Compare process memory to total physical system memory and\n        calculate process memory utilization as a percentage.\n        *memtype* argument is a string that dictates what type of\n        process memory you want to compare against (defaults to "rss").\n        The list of available strings can be obtained like this:\n\n        >>> psutil.Process().memory_info()._fields\n        (\'rss\', \'vms\', \'shared\', \'text\', \'lib\', \'data\', \'dirty\', \'uss\', \'pss\')\n        ')), Assign(targets=[Name(id='valid_types', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='pfullmem', ctx=Load()), attr='_fields', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='memtype', ctx=Load()), ops=[NotIn()], comparators=[Name(id='valid_types', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='invalid memtype %r; valid types are %r'), op=Mod(), right=Tuple(elts=[Name(id='memtype', ctx=Load()), Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='valid_types', ctx=Load())], keywords=[])], ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='fun', ctx=Store())], value=IfExp(test=Compare(left=Name(id='memtype', ctx=Load()), ops=[In()], comparators=[Attribute(value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='pmem', ctx=Load()), attr='_fields', ctx=Load())]), body=Attribute(value=Name(id='self', ctx=Load()), attr='memory_info', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='memory_full_info', ctx=Load()))), Assign(targets=[Name(id='metrics', ctx=Store())], value=Call(func=Name(id='fun', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='metrics', ctx=Load()), Name(id='memtype', ctx=Load())], keywords=[])), Assign(targets=[Name(id='total_phymem', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='_TOTAL_PHYMEM', ctx=Load()), Attribute(value=Call(func=Name(id='virtual_memory', ctx=Load()), args=[], keywords=[]), attr='total', ctx=Load())])), If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='total_phymem', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value="can't calculate process memory percent because total physical system memory is not positive (%r)"), op=Mod(), right=Name(id='total_phymem', ctx=Load()))], keywords=[]))], orelse=[]), Return(value=BinOp(left=BinOp(left=Name(id='value', ctx=Load()), op=Div(), right=Call(func=Name(id='float', ctx=Load()), args=[Name(id='total_phymem', ctx=Load())], keywords=[])), op=Mult(), right=Constant(value=100)))], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='Process', ctx=Load()), Constant(value='memory_maps')], keywords=[]), body=[FunctionDef(name='memory_maps', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='grouped')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value="Return process' mapped memory regions as a list of namedtuples\n            whose fields are variable depending on the platform.\n\n            If *grouped* is True the mapped regions with the same 'path'\n            are grouped together and the different memory fields are summed.\n\n            If *grouped* is False every mapped region is shown as a single\n            entity and the namedtuple will also include the mapped region's\n            address space ('addr') and permission set ('perms').\n            ")), Assign(targets=[Name(id='it', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='memory_maps', ctx=Load()), args=[], keywords=[])), If(test=Name(id='grouped', ctx=Load()), body=[Assign(targets=[Name(id='d', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='tupl', ctx=Store()), iter=Name(id='it', ctx=Load()), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Subscript(value=Name(id='tupl', ctx=Load()), slice=Constant(value=2), ctx=Load())), Assign(targets=[Name(id='nums', ctx=Store())], value=Subscript(value=Name(id='tupl', ctx=Load()), slice=Slice(lower=Constant(value=3)), ctx=Load())), Try(body=[Assign(targets=[Subscript(value=Name(id='d', ctx=Load()), slice=Name(id='path', ctx=Load()), ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='y')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=BinOp(left=Name(id='x', ctx=Load()), op=Add(), right=Name(id='y', ctx=Load()))), Subscript(value=Name(id='d', ctx=Load()), slice=Name(id='path', ctx=Load()), ctx=Load()), Name(id='nums', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='d', ctx=Load()), slice=Name(id='path', ctx=Load()), ctx=Store())], value=Name(id='nums', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[]), Assign(targets=[Name(id='nt', ctx=Store())], value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='pmmap_grouped', ctx=Load())), Return(value=ListComp(elt=Call(func=Name(id='nt', ctx=Load()), args=[Name(id='path', ctx=Load()), Starred(value=Subscript(value=Name(id='d', ctx=Load()), slice=Name(id='path', ctx=Load()), ctx=Load()), ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='path', ctx=Store()), iter=Name(id='d', ctx=Load()), ifs=[], is_async=0)]))], orelse=[Assign(targets=[Name(id='nt', ctx=Store())], value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='pmmap_ext', ctx=Load())), Return(value=ListComp(elt=Call(func=Name(id='nt', ctx=Load()), args=[Starred(value=Name(id='x', ctx=Load()), ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='it', ctx=Load()), ifs=[], is_async=0)]))])], decorator_list=[])], orelse=[]), FunctionDef(name='open_files', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return files opened by process as a list of\n        (path, fd) namedtuples including the absolute file name\n        and file descriptor number.\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='open_files', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='connections', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='kind')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='inet')]), body=[Expr(value=Constant(value='Return socket connections opened by process as a list of\n        (fd, family, type, laddr, raddr, status) namedtuples.\n        The *kind* parameter filters for connections that match the\n        following criteria:\n\n        +------------+----------------------------------------------------+\n        | Kind Value | Connections using                                  |\n        +------------+----------------------------------------------------+\n        | inet       | IPv4 and IPv6                                      |\n        | inet4      | IPv4                                               |\n        | inet6      | IPv6                                               |\n        | tcp        | TCP                                                |\n        | tcp4       | TCP over IPv4                                      |\n        | tcp6       | TCP over IPv6                                      |\n        | udp        | UDP                                                |\n        | udp4       | UDP over IPv4                                      |\n        | udp6       | UDP over IPv6                                      |\n        | unix       | UNIX socket (both UDP and TCP protocols)           |\n        | all        | the sum of all the possible families and protocols |\n        +------------+----------------------------------------------------+\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='connections', ctx=Load()), args=[Name(id='kind', ctx=Load())], keywords=[]))], decorator_list=[]), If(test=Name(id='POSIX', ctx=Load()), body=[FunctionDef(name='_send_signal', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='sig')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=UnaryOp(op=Not(), operand=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)])), msg=Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='preventing sending signal to process with PID 0 as it would affect every process in the process group of the calling process (os.getpid()) instead of PID 0')], keywords=[]))], orelse=[]), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='kill', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()), Name(id='sig', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ProcessLookupError', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Name(id='OPENBSD', ctx=Load()), Call(func=Name(id='pid_exists', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='ZombieProcess', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_ppid', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gone', ctx=Store())], value=Constant(value=True)), Raise(exc=Call(func=Name(id='NoSuchProcess', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())], keywords=[]))])]), ExceptHandler(type=Name(id='PermissionError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='AccessDenied', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[])], orelse=[]), FunctionDef(name='send_signal', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='sig')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Send a signal *sig* to process pre-emptively checking\n        whether PID has been reused (see signal module constants) .\n        On Windows only SIGTERM is valid and is treated as an alias\n        for kill().\n        ')), If(test=Name(id='POSIX', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_send_signal', ctx=Load()), args=[Name(id='sig', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='sig', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='signal', ctx=Load()), attr='SIGTERM', ctx=Load())]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_running', ctx=Load()), args=[], keywords=[]))]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=Constant(value='process no longer exists')), Raise(exc=Call(func=Name(id='NoSuchProcess', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pid', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())], keywords=[keyword(arg='msg', value=Name(id='msg', ctx=Load()))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='send_signal', ctx=Load()), args=[Name(id='sig', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='suspend', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Suspend process execution with SIGSTOP pre-emptively checking\n        whether PID has been reused.\n        On Windows this has the effect of suspending all process threads.\n        ')), If(test=Name(id='POSIX', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_send_signal', ctx=Load()), args=[Attribute(value=Name(id='signal', ctx=Load()), attr='SIGSTOP', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='suspend', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='resume', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Resume process execution with SIGCONT pre-emptively checking\n        whether PID has been reused.\n        On Windows this has the effect of resuming all process threads.\n        ')), If(test=Name(id='POSIX', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_send_signal', ctx=Load()), args=[Attribute(value=Name(id='signal', ctx=Load()), attr='SIGCONT', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='resume', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='terminate', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Terminate the process with SIGTERM pre-emptively checking\n        whether PID has been reused.\n        On Windows this is an alias for kill().\n        ')), If(test=Name(id='POSIX', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_send_signal', ctx=Load()), args=[Attribute(value=Name(id='signal', ctx=Load()), attr='SIGTERM', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='kill', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='kill', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Kill the current process with SIGKILL pre-emptively checking\n        whether PID has been reused.\n        ')), If(test=Name(id='POSIX', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_send_signal', ctx=Load()), args=[Attribute(value=Name(id='signal', ctx=Load()), attr='SIGKILL', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_if_pid_reused', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='kill', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='wait', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value="Wait for process to terminate and, if process is a children\n        of os.getpid(), also return its exit code, else None.\n        On Windows there's no such limitation (exit code is always\n        returned).\n\n        If the process is already terminated immediately return None\n        instead of raising NoSuchProcess.\n\n        If *timeout* (in seconds) is specified and process is still\n        alive raise TimeoutExpired.\n\n        To wait for multiple Process(es) use psutil.wait_procs().\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='timeout', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Compare(left=Name(id='timeout', ctx=Load()), ops=[GtE()], comparators=[Constant(value=0)]))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='timeout must be a positive integer')], keywords=[]))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_exitcode', ctx=Load()), ops=[IsNot()], comparators=[Name(id='_SENTINEL', ctx=Load())]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_exitcode', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exitcode', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_proc', ctx=Load()), attr='wait', ctx=Load()), args=[Name(id='timeout', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_exitcode', ctx=Load()))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='_as_dict_attrnames', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[ListComp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='dir', ctx=Load()), args=[Name(id='Process', ctx=Load())], keywords=[]), ifs=[BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_')], keywords=[])), Compare(left=Name(id='x', ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='send_signal'), Constant(value='suspend'), Constant(value='resume'), Constant(value='terminate'), Constant(value='kill'), Constant(value='wait'), Constant(value='is_running'), Constant(value='as_dict'), Constant(value='parent'), Constant(value='parents'), Constant(value='children'), Constant(value='rlimit'), Constant(value='memory_info_ex'), Constant(value='oneshot')], ctx=Load())])])], is_async=0)])], keywords=[])), ClassDef(name='Popen', bases=[Name(id='Process', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Same as subprocess.Popen, but in addition it provides all\n    psutil.Process methods in a single class.\n    For the following methods which are common to both classes, psutil\n    implementation takes precedence:\n\n    * send_signal()\n    * terminate()\n    * kill()\n\n    This is done in order to avoid killing another process in case its\n    PID has been reused, fixing BPO-6973.\n\n      >>> import psutil\n      >>> from subprocess import PIPE\n      >>> p = psutil.Popen(["python", "-c", "print \'hi\'"], stdout=PIPE)\n      >>> p.name()\n      \'python\'\n      >>> p.uids()\n      user(real=1000, effective=1000, saved=1000)\n      >>> p.username()\n      \'giampaolo\'\n      >>> p.communicate()\n      (\'hi\', None)\n      >>> p.terminate()\n      >>> p.wait(timeout=2)\n      0\n      >>>\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='__subproc', ctx=Store())], value=Call(func=Attribute(value=Name(id='subprocess', ctx=Load()), attr='Popen', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_init', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__subproc', ctx=Load()), attr='pid', ctx=Load())], keywords=[keyword(arg='_ignore_nsp', value=Constant(value=True))]))], decorator_list=[]), FunctionDef(name='__dir__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[BinOp(left=Call(func=Name(id='dir', ctx=Load()), args=[Name(id='Popen', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='dir', ctx=Load()), args=[Attribute(value=Name(id='subprocess', ctx=Load()), attr='Popen', ctx=Load())], keywords=[]))], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__subproc', ctx=Load()), Constant(value='__enter__')], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__subproc', ctx=Load()), attr='__enter__', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__subproc', ctx=Load()), Constant(value='__exit__')], keywords=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__subproc', ctx=Load()), attr='__exit__', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='stdout', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stdout', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='stderr', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stderr', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[]), Try(body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='stdin', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stdin', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[])], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='wait', ctx=Load()), args=[], keywords=[]))])])], decorator_list=[]), FunctionDef(name='__getattribute__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__getattribute__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Try(body=[Return(value=Call(func=Attribute(value=Name(id='object', ctx=Load()), attr='__getattribute__', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='__subproc', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='AttributeError', ctx=Load()), args=[BinOp(left=Constant(value="%s instance has no attribute '%s'"), op=Mod(), right=Tuple(elts=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), Name(id='name', ctx=Load())], ctx=Load()))], keywords=[]))])], orelse=[], finalbody=[])])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='wait', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[If(test=Compare(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__subproc', ctx=Load()), attr='returncode', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__subproc', ctx=Load()), attr='returncode', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='Popen', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='wait', ctx=Load()), args=[Name(id='timeout', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__subproc', ctx=Load()), attr='returncode', ctx=Store())], value=Name(id='ret', ctx=Load())), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[])], decorator_list=[]), FunctionDef(name='pids', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a list of current running PIDs.')), Global(names=['_LOWEST_PID']), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='pids', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='_LOWEST_PID', ctx=Store())], value=Subscript(value=Name(id='ret', ctx=Load()), slice=Constant(value=0), ctx=Load())), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[]), FunctionDef(name='pid_exists', args=arguments(posonlyargs=[], args=[arg(arg='pid')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return True if given PID exists in the current process list.\n    This is faster than doing "pid in psutil.pids()" and\n    should be preferred.\n    ')), If(test=Compare(left=Name(id='pid', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Return(value=Constant(value=False))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='pid', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), Name(id='POSIX', ctx=Load())]), body=[Return(value=Compare(left=Name(id='pid', ctx=Load()), ops=[In()], comparators=[Call(func=Name(id='pids', ctx=Load()), args=[], keywords=[])]))], orelse=[Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='pid_exists', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[]))])])], decorator_list=[]), Assign(targets=[Name(id='_pmap', ctx=Store())], value=Dict(keys=[], values=[])), FunctionDef(name='process_iter', args=arguments(posonlyargs=[], args=[arg(arg='attrs'), arg(arg='ad_value')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Return a generator yielding a Process instance for all\n    running processes.\n\n    Every new Process instance is only created once and then cached\n    into an internal table which is updated every time this is used.\n\n    Cached Process instances are checked for identity so that you're\n    safe in case a PID has been reused by another process, in which\n    case the cached instance is updated.\n\n    The sorting order in which processes are yielded is based on\n    their PIDs.\n\n    *attrs* and *ad_value* have the same meaning as in\n    Process.as_dict(). If *attrs* is specified as_dict() is called\n    and the resulting dict is stored as a 'info' attribute attached\n    to returned Process instance.\n    If *attrs* is an empty list it will retrieve all process info\n    (slow).\n    ")), Global(names=['_pmap']), FunctionDef(name='add', args=arguments(posonlyargs=[], args=[arg(arg='pid')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='proc', ctx=Store())], value=Call(func=Name(id='Process', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='attrs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='proc', ctx=Load()), attr='info', ctx=Store())], value=Call(func=Attribute(value=Name(id='proc', ctx=Load()), attr='as_dict', ctx=Load()), args=[], keywords=[keyword(arg='attrs', value=Name(id='attrs', ctx=Load())), keyword(arg='ad_value', value=Name(id='ad_value', ctx=Load()))]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='pmap', ctx=Load()), slice=Attribute(value=Name(id='proc', ctx=Load()), attr='pid', ctx=Load()), ctx=Store())], value=Name(id='proc', ctx=Load())), Return(value=Name(id='proc', ctx=Load()))], decorator_list=[]), FunctionDef(name='remove', args=arguments(posonlyargs=[], args=[arg(arg='pid')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='pmap', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='pid', ctx=Load()), Constant(value=None)], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='pmap', ctx=Store())], value=Call(func=Attribute(value=Name(id='_pmap', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Name(id='pids', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pmap', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='new_pids', ctx=Store())], value=BinOp(left=Name(id='a', ctx=Load()), op=Sub(), right=Name(id='b', ctx=Load()))), Assign(targets=[Name(id='gone_pids', ctx=Store())], value=BinOp(left=Name(id='b', ctx=Load()), op=Sub(), right=Name(id='a', ctx=Load()))), For(target=Name(id='pid', ctx=Store()), iter=Name(id='gone_pids', ctx=Load()), body=[Expr(value=Call(func=Name(id='remove', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Name(id='ls', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pmap', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[]), op=Add(), right=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='dict', ctx=Load()), attr='fromkeys', ctx=Load()), args=[Name(id='new_pids', ctx=Load())], keywords=[]), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[]))], keywords=[])), For(target=Tuple(elts=[Name(id='pid', ctx=Store()), Name(id='proc', ctx=Store())], ctx=Store()), iter=Name(id='ls', ctx=Load()), body=[Try(body=[If(test=Compare(left=Name(id='proc', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Call(func=Name(id='add', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[])))], orelse=[If(test=Call(func=Attribute(value=Name(id='proc', ctx=Load()), attr='is_running', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='attrs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='proc', ctx=Load()), attr='info', ctx=Store())], value=Call(func=Attribute(value=Name(id='proc', ctx=Load()), attr='as_dict', ctx=Load()), args=[], keywords=[keyword(arg='attrs', value=Name(id='attrs', ctx=Load())), keyword(arg='ad_value', value=Name(id='ad_value', ctx=Load()))]))], orelse=[]), Expr(value=Yield(value=Name(id='proc', ctx=Load())))], orelse=[Expr(value=Yield(value=Call(func=Name(id='add', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[])))])])], handlers=[ExceptHandler(type=Name(id='NoSuchProcess', ctx=Load()), body=[Expr(value=Call(func=Name(id='remove', ctx=Load()), args=[Name(id='pid', ctx=Load())], keywords=[]))]), ExceptHandler(type=Name(id='AccessDenied', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='proc', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='pid', ctx=Load()), ops=[In()], comparators=[Name(id='pmap', ctx=Load())])]), body=[Try(body=[Expr(value=Yield(value=Subscript(value=Name(id='pmap', ctx=Load()), slice=Name(id='pid', ctx=Load()), ctx=Load())))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[Raise()])])], orelse=[], finalbody=[])], orelse=[])], handlers=[], orelse=[], finalbody=[Assign(targets=[Name(id='_pmap', ctx=Store())], value=Name(id='pmap', ctx=Load()))])], decorator_list=[]), FunctionDef(name='wait_procs', args=arguments(posonlyargs=[], args=[arg(arg='procs'), arg(arg='timeout'), arg(arg='callback')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Convenience function which waits for a list of processes to\n    terminate.\n\n    Return a (gone, alive) tuple indicating which processes\n    are gone and which ones are still alive.\n\n    The gone ones will have a new *returncode* attribute indicating\n    process exit status (may be None).\n\n    *callback* is a function which gets called every time a process\n    terminates (a Process instance is passed as callback argument).\n\n    Function will return as soon as all processes terminate or when\n    *timeout* occurs.\n    Differently from Process.wait() it will not raise TimeoutExpired if\n    *timeout* occurs.\n\n    Typical use case is:\n\n     - send SIGTERM to a list of processes\n     - give them some time to terminate\n     - send SIGKILL to those ones which are still alive\n\n    Example:\n\n    >>> def on_terminate(proc):\n    ...     print("process {} terminated".format(proc))\n    ...\n    >>> for p in procs:\n    ...    p.terminate()\n    ...\n    >>> gone, alive = wait_procs(procs, timeout=3, callback=on_terminate)\n    >>> for p in alive:\n    ...     p.kill()\n    ')), FunctionDef(name='check_gone', args=arguments(posonlyargs=[], args=[arg(arg='proc'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='returncode', ctx=Store())], value=Call(func=Attribute(value=Name(id='proc', ctx=Load()), attr='wait', ctx=Load()), args=[], keywords=[keyword(arg='timeout', value=Name(id='timeout', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='TimeoutExpired', ctx=Load()), body=[Pass()]), ExceptHandler(type=Name(id='_SubprocessTimeoutExpired', ctx=Load()), body=[Pass()])], orelse=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='returncode', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='proc', ctx=Load()), attr='is_running', ctx=Load()), args=[], keywords=[]))]), body=[Assign(targets=[Attribute(value=Name(id='proc', ctx=Load()), attr='returncode', ctx=Store())], value=Name(id='returncode', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='gone', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='proc', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='callback', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='callback', ctx=Load()), args=[Name(id='proc', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], finalbody=[])], decorator_list=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='timeout', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Compare(left=Name(id='timeout', ctx=Load()), ops=[GtE()], comparators=[Constant(value=0)]))]), body=[Assign(targets=[Name(id='msg', ctx=Store())], value=BinOp(left=Constant(value='timeout must be a positive integer, got %s'), op=Mod(), right=Name(id='timeout', ctx=Load()))), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='gone', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='alive', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='procs', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='callback', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='callback', ctx=Load())], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[BinOp(left=Constant(value='callback %r is not a callable'), op=Mod(), right=Name(id='callable', ctx=Load()))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='timeout', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='deadline', ctx=Store())], value=BinOp(left=Call(func=Name(id='_timer', ctx=Load()), args=[], keywords=[]), op=Add(), right=Name(id='timeout', ctx=Load())))], orelse=[]), While(test=Name(id='alive', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='timeout', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='timeout', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)])]), body=[Break()], orelse=[]), For(target=Name(id='proc', ctx=Store()), iter=Name(id='alive', ctx=Load()), body=[Assign(targets=[Name(id='max_timeout', ctx=Store())], value=BinOp(left=Constant(value=1.0), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='alive', ctx=Load())], keywords=[]))), If(test=Compare(left=Name(id='timeout', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='timeout', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=Name(id='deadline', ctx=Load()), op=Sub(), right=Call(func=Name(id='_timer', ctx=Load()), args=[], keywords=[])), Name(id='max_timeout', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='timeout', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)]), body=[Break()], orelse=[]), Expr(value=Call(func=Name(id='check_gone', ctx=Load()), args=[Name(id='proc', ctx=Load()), Name(id='timeout', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='check_gone', ctx=Load()), args=[Name(id='proc', ctx=Load()), Name(id='max_timeout', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Name(id='alive', ctx=Store())], value=BinOp(left=Name(id='alive', ctx=Load()), op=Sub(), right=Name(id='gone', ctx=Load())))], orelse=[]), If(test=Name(id='alive', ctx=Load()), body=[For(target=Name(id='proc', ctx=Store()), iter=Name(id='alive', ctx=Load()), body=[Expr(value=Call(func=Name(id='check_gone', ctx=Load()), args=[Name(id='proc', ctx=Load()), Constant(value=0)], keywords=[]))], orelse=[]), Assign(targets=[Name(id='alive', ctx=Store())], value=BinOp(left=Name(id='alive', ctx=Load()), op=Sub(), right=Name(id='gone', ctx=Load())))], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='list', ctx=Load()), args=[Name(id='gone', ctx=Load())], keywords=[]), Call(func=Name(id='list', ctx=Load()), args=[Name(id='alive', ctx=Load())], keywords=[])], ctx=Load()))], decorator_list=[]), FunctionDef(name='cpu_count', args=arguments(posonlyargs=[], args=[arg(arg='logical')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Return the number of logical CPUs in the system (same as\n    os.cpu_count() in Python 3.4).\n\n    If *logical* is False return the number of physical cores only\n    (e.g. hyper thread CPUs are excluded).\n\n    Return None if undetermined.\n\n    The return value is cached after first call.\n    If desired cache can be cleared like this:\n\n    >>> psutil.cpu_count.cache_clear()\n    ')), If(test=Name(id='logical', ctx=Load()), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cpu_count_logical', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cpu_count_cores', ctx=Load()), args=[], keywords=[]))]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='ret', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='ret', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)])]), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Constant(value=None))], orelse=[]), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[]), FunctionDef(name='cpu_times', args=arguments(posonlyargs=[], args=[arg(arg='percpu')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value="Return system-wide CPU times as a namedtuple.\n    Every CPU time represents the seconds the CPU has spent in the\n    given mode. The namedtuple's fields availability varies depending on the\n    platform:\n\n     - user\n     - system\n     - idle\n     - nice (UNIX)\n     - iowait (Linux)\n     - irq (Linux, FreeBSD)\n     - softirq (Linux)\n     - steal (Linux >= 2.6.11)\n     - guest (Linux >= 2.6.24)\n     - guest_nice (Linux >= 3.2.0)\n\n    When *percpu* is True return a list of namedtuples for each CPU.\n    First element of the list refers to first CPU, second element\n    to second CPU and so on.\n    The order of the list is consistent across calls.\n    ")), If(test=UnaryOp(op=Not(), operand=Name(id='percpu', ctx=Load())), body=[Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cpu_times', ctx=Load()), args=[], keywords=[]))], orelse=[Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='per_cpu_times', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), Try(body=[Assign(targets=[Name(id='_last_cpu_times', ctx=Store())], value=Dict(keys=[Attribute(value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='current_thread', ctx=Load()), args=[], keywords=[]), attr='ident', ctx=Load())], values=[Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[])]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Assign(targets=[Name(id='_last_cpu_times', ctx=Store())], value=Dict(keys=[], values=[]))])], orelse=[], finalbody=[]), Try(body=[Assign(targets=[Name(id='_last_per_cpu_times', ctx=Store())], value=Dict(keys=[Attribute(value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='current_thread', ctx=Load()), args=[], keywords=[]), attr='ident', ctx=Load())], values=[Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[keyword(arg='percpu', value=Constant(value=True))])]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Assign(targets=[Name(id='_last_per_cpu_times', ctx=Store())], value=Dict(keys=[], values=[]))])], orelse=[], finalbody=[]), FunctionDef(name='_cpu_tot_time', args=arguments(posonlyargs=[], args=[arg(arg='times')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Given a cpu_time() ntuple calculates the total CPU time\n    (including idle time).\n    ')), Assign(targets=[Name(id='tot', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Name(id='times', ctx=Load())], keywords=[])), If(test=Name(id='LINUX', ctx=Load()), body=[AugAssign(target=Name(id='tot', ctx=Store()), op=Sub(), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='times', ctx=Load()), Constant(value='guest'), Constant(value=0)], keywords=[])), AugAssign(target=Name(id='tot', ctx=Store()), op=Sub(), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='times', ctx=Load()), Constant(value='guest_nice'), Constant(value=0)], keywords=[]))], orelse=[]), Return(value=Name(id='tot', ctx=Load()))], decorator_list=[]), FunctionDef(name='_cpu_busy_time', args=arguments(posonlyargs=[], args=[arg(arg='times')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Given a cpu_time() ntuple calculates the busy CPU time.\n    We do so by subtracting all idle CPU times.\n    ')), Assign(targets=[Name(id='busy', ctx=Store())], value=Call(func=Name(id='_cpu_tot_time', ctx=Load()), args=[Name(id='times', ctx=Load())], keywords=[])), AugAssign(target=Name(id='busy', ctx=Store()), op=Sub(), value=Attribute(value=Name(id='times', ctx=Load()), attr='idle', ctx=Load())), AugAssign(target=Name(id='busy', ctx=Store()), op=Sub(), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='times', ctx=Load()), Constant(value='iowait'), Constant(value=0)], keywords=[])), Return(value=Name(id='busy', ctx=Load()))], decorator_list=[]), FunctionDef(name='_cpu_times_deltas', args=arguments(posonlyargs=[], args=[arg(arg='t1'), arg(arg='t2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Attribute(value=Name(id='t1', ctx=Load()), attr='_fields', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='t2', ctx=Load()), attr='_fields', ctx=Load())]), msg=Tuple(elts=[Name(id='t1', ctx=Load()), Name(id='t2', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='field_deltas', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='field', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='scputimes', ctx=Load()), attr='_fields', ctx=Load()), body=[Assign(targets=[Name(id='field_delta', ctx=Store())], value=BinOp(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='t2', ctx=Load()), Name(id='field', ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='t1', ctx=Load()), Name(id='field', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='field_delta', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), Name(id='field_delta', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='field_deltas', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='field_delta', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='scputimes', ctx=Load()), args=[Starred(value=Name(id='field_deltas', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='cpu_percent', args=arguments(posonlyargs=[], args=[arg(arg='interval'), arg(arg='percpu')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='Return a float representing the current system-wide CPU\n    utilization as a percentage.\n\n    When *interval* is > 0.0 compares system CPU times elapsed before\n    and after the interval (blocking).\n\n    When *interval* is 0.0 or None compares system CPU times elapsed\n    since last call or module import, returning immediately (non\n    blocking). That means the first time this is called it will\n    return a meaningless 0.0 value which you should ignore.\n    In this case is recommended for accuracy that this function be\n    called with at least 0.1 seconds between calls.\n\n    When *percpu* is True returns a list of floats representing the\n    utilization as a percentage for each CPU.\n    First element of the list refers to first CPU, second element\n    to second CPU and so on.\n    The order of the list is consistent across calls.\n\n    Examples:\n\n      >>> # blocking, system-wide\n      >>> psutil.cpu_percent(interval=1)\n      2.0\n      >>>\n      >>> # blocking, per-cpu\n      >>> psutil.cpu_percent(interval=1, percpu=True)\n      [2.0, 1.0]\n      >>>\n      >>> # non-blocking (percentage since last call)\n      >>> psutil.cpu_percent(interval=None)\n      2.9\n      >>>\n    ')), Assign(targets=[Name(id='tid', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='current_thread', ctx=Load()), args=[], keywords=[]), attr='ident', ctx=Load())), Assign(targets=[Name(id='blocking', ctx=Store())], value=BoolOp(op=And(), values=[Compare(left=Name(id='interval', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='interval', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0.0)])])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='interval', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='interval', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='interval is not positive (got %r)'), op=Mod(), right=Name(id='interval', ctx=Load()))], keywords=[]))], orelse=[]), FunctionDef(name='calculate', args=arguments(posonlyargs=[], args=[arg(arg='t1'), arg(arg='t2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='times_delta', ctx=Store())], value=Call(func=Name(id='_cpu_times_deltas', ctx=Load()), args=[Name(id='t1', ctx=Load()), Name(id='t2', ctx=Load())], keywords=[])), Assign(targets=[Name(id='all_delta', ctx=Store())], value=Call(func=Name(id='_cpu_tot_time', ctx=Load()), args=[Name(id='times_delta', ctx=Load())], keywords=[])), Assign(targets=[Name(id='busy_delta', ctx=Store())], value=Call(func=Name(id='_cpu_busy_time', ctx=Load()), args=[Name(id='times_delta', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='busy_perc', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='busy_delta', ctx=Load()), op=Div(), right=Name(id='all_delta', ctx=Load())), op=Mult(), right=Constant(value=100)))], handlers=[ExceptHandler(type=Name(id='ZeroDivisionError', ctx=Load()), body=[Return(value=Constant(value=0.0))])], orelse=[Return(value=Call(func=Name(id='round', ctx=Load()), args=[Name(id='busy_perc', ctx=Load()), Constant(value=1)], keywords=[]))], finalbody=[])], decorator_list=[]), If(test=UnaryOp(op=Not(), operand=Name(id='percpu', ctx=Load())), body=[If(test=Name(id='blocking', ctx=Load()), body=[Assign(targets=[Name(id='t1', ctx=Store())], value=Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='sleep', ctx=Load()), args=[Name(id='interval', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='t1', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='_last_cpu_times', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='tid', ctx=Load())], keywords=[]), Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[])]))]), Assign(targets=[Subscript(value=Name(id='_last_cpu_times', ctx=Load()), slice=Name(id='tid', ctx=Load()), ctx=Store())], value=Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='calculate', ctx=Load()), args=[Name(id='t1', ctx=Load()), Subscript(value=Name(id='_last_cpu_times', ctx=Load()), slice=Name(id='tid', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='ret', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Name(id='blocking', ctx=Load()), body=[Assign(targets=[Name(id='tot1', ctx=Store())], value=Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[keyword(arg='percpu', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='sleep', ctx=Load()), args=[Name(id='interval', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='tot1', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='_last_per_cpu_times', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='tid', ctx=Load())], keywords=[]), Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[keyword(arg='percpu', value=Constant(value=True))])]))]), Assign(targets=[Subscript(value=Name(id='_last_per_cpu_times', ctx=Load()), slice=Name(id='tid', ctx=Load()), ctx=Store())], value=Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[keyword(arg='percpu', value=Constant(value=True))])), For(target=Tuple(elts=[Name(id='t1', ctx=Store()), Name(id='t2', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='tot1', ctx=Load()), Subscript(value=Name(id='_last_per_cpu_times', ctx=Load()), slice=Name(id='tid', ctx=Load()), ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='calculate', ctx=Load()), args=[Name(id='t1', ctx=Load()), Name(id='t2', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='ret', ctx=Load()))])], decorator_list=[]), Assign(targets=[Name(id='_last_cpu_times_2', ctx=Store())], value=Call(func=Attribute(value=Name(id='_last_cpu_times', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='_last_per_cpu_times_2', ctx=Store())], value=Call(func=Attribute(value=Name(id='_last_per_cpu_times', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), FunctionDef(name='cpu_times_percent', args=arguments(posonlyargs=[], args=[arg(arg='interval'), arg(arg='percpu')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="Same as cpu_percent() but provides utilization percentages\n    for each specific CPU time as is returned by cpu_times().\n    For instance, on Linux we'll get:\n\n      >>> cpu_times_percent()\n      cpupercent(user=4.8, nice=0.0, system=4.8, idle=90.5, iowait=0.0,\n                 irq=0.0, softirq=0.0, steal=0.0, guest=0.0, guest_nice=0.0)\n      >>>\n\n    *interval* and *percpu* arguments have the same meaning as in\n    cpu_percent().\n    ")), Assign(targets=[Name(id='tid', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='current_thread', ctx=Load()), args=[], keywords=[]), attr='ident', ctx=Load())), Assign(targets=[Name(id='blocking', ctx=Store())], value=BoolOp(op=And(), values=[Compare(left=Name(id='interval', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='interval', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0.0)])])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='interval', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='interval', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='interval is not positive (got %r)'), op=Mod(), right=Name(id='interval', ctx=Load()))], keywords=[]))], orelse=[]), FunctionDef(name='calculate', args=arguments(posonlyargs=[], args=[arg(arg='t1'), arg(arg='t2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='nums', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='times_delta', ctx=Store())], value=Call(func=Name(id='_cpu_times_deltas', ctx=Load()), args=[Name(id='t1', ctx=Load()), Name(id='t2', ctx=Load())], keywords=[])), Assign(targets=[Name(id='all_delta', ctx=Store())], value=Call(func=Name(id='_cpu_tot_time', ctx=Load()), args=[Name(id='times_delta', ctx=Load())], keywords=[])), Assign(targets=[Name(id='scale', ctx=Store())], value=BinOp(left=Constant(value=100.0), op=Div(), right=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=1), Name(id='all_delta', ctx=Load())], keywords=[]))), For(target=Name(id='field_delta', ctx=Store()), iter=Name(id='times_delta', ctx=Load()), body=[Assign(targets=[Name(id='field_perc', ctx=Store())], value=BinOp(left=Name(id='field_delta', ctx=Load()), op=Mult(), right=Name(id='scale', ctx=Load()))), Assign(targets=[Name(id='field_perc', ctx=Store())], value=Call(func=Name(id='round', ctx=Load()), args=[Name(id='field_perc', ctx=Load()), Constant(value=1)], keywords=[])), Assign(targets=[Name(id='field_perc', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0.0), Name(id='field_perc', ctx=Load())], keywords=[]), Constant(value=100.0)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='nums', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='field_perc', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='scputimes', ctx=Load()), args=[Starred(value=Name(id='nums', ctx=Load()), ctx=Load())], keywords=[]))], decorator_list=[]), If(test=UnaryOp(op=Not(), operand=Name(id='percpu', ctx=Load())), body=[If(test=Name(id='blocking', ctx=Load()), body=[Assign(targets=[Name(id='t1', ctx=Store())], value=Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='sleep', ctx=Load()), args=[Name(id='interval', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='t1', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='_last_cpu_times_2', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='tid', ctx=Load())], keywords=[]), Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[])]))]), Assign(targets=[Subscript(value=Name(id='_last_cpu_times_2', ctx=Load()), slice=Name(id='tid', ctx=Load()), ctx=Store())], value=Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='calculate', ctx=Load()), args=[Name(id='t1', ctx=Load()), Subscript(value=Name(id='_last_cpu_times_2', ctx=Load()), slice=Name(id='tid', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='ret', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Name(id='blocking', ctx=Load()), body=[Assign(targets=[Name(id='tot1', ctx=Store())], value=Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[keyword(arg='percpu', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='sleep', ctx=Load()), args=[Name(id='interval', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='tot1', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='_last_per_cpu_times_2', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='tid', ctx=Load())], keywords=[]), Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[keyword(arg='percpu', value=Constant(value=True))])]))]), Assign(targets=[Subscript(value=Name(id='_last_per_cpu_times_2', ctx=Load()), slice=Name(id='tid', ctx=Load()), ctx=Store())], value=Call(func=Name(id='cpu_times', ctx=Load()), args=[], keywords=[keyword(arg='percpu', value=Constant(value=True))])), For(target=Tuple(elts=[Name(id='t1', ctx=Store()), Name(id='t2', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='tot1', ctx=Load()), Subscript(value=Name(id='_last_per_cpu_times_2', ctx=Load()), slice=Name(id='tid', ctx=Load()), ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='calculate', ctx=Load()), args=[Name(id='t1', ctx=Load()), Name(id='t2', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='ret', ctx=Load()))])], decorator_list=[]), FunctionDef(name='cpu_stats', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return CPU statistics.')), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cpu_stats', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='_psplatform', ctx=Load()), Constant(value='cpu_freq')], keywords=[]), body=[FunctionDef(name='cpu_freq', args=arguments(posonlyargs=[], args=[arg(arg='percpu')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Return CPU frequency as a namedtuple including current,\n        min and max frequency expressed in Mhz.\n\n        If *percpu* is True and the system supports per-cpu frequency\n        retrieval (Linux only) a list of frequencies is returned for\n        each CPU. If not a list with one element is returned.\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cpu_freq', ctx=Load()), args=[], keywords=[])), If(test=Name(id='percpu', ctx=Load()), body=[Return(value=Name(id='ret', ctx=Load()))], orelse=[Assign(targets=[Name(id='num_cpus', ctx=Store())], value=Call(func=Name(id='float', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='ret', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='num_cpus', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Constant(value=None))], orelse=[If(test=Compare(left=Name(id='num_cpus', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Subscript(value=Name(id='ret', ctx=Load()), slice=Constant(value=0), ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='currs', ctx=Store()), Name(id='mins', ctx=Store()), Name(id='maxs', ctx=Store())], ctx=Store())], value=Tuple(elts=[Constant(value=0.0), Constant(value=0.0), Constant(value=0.0)], ctx=Load())), Assign(targets=[Name(id='set_none', ctx=Store())], value=Constant(value=False)), For(target=Name(id='cpu', ctx=Store()), iter=Name(id='ret', ctx=Load()), body=[AugAssign(target=Name(id='currs', ctx=Store()), op=Add(), value=Attribute(value=Name(id='cpu', ctx=Load()), attr='current', ctx=Load())), If(test=BoolOp(op=And(), values=[Name(id='LINUX', ctx=Load()), Compare(left=Attribute(value=Name(id='cpu', ctx=Load()), attr='min', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Name(id='set_none', ctx=Store())], value=Constant(value=True)), Continue()], orelse=[]), AugAssign(target=Name(id='mins', ctx=Store()), op=Add(), value=Attribute(value=Name(id='cpu', ctx=Load()), attr='min', ctx=Load())), AugAssign(target=Name(id='maxs', ctx=Store()), op=Add(), value=Attribute(value=Name(id='cpu', ctx=Load()), attr='max', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='current', ctx=Store())], value=BinOp(left=Name(id='currs', ctx=Load()), op=Div(), right=Name(id='num_cpus', ctx=Load()))), If(test=Name(id='set_none', ctx=Load()), body=[Assign(targets=[Name(id='min_', ctx=Store()), Name(id='max_', ctx=Store())], value=Constant(value=None))], orelse=[Assign(targets=[Name(id='min_', ctx=Store())], value=BinOp(left=Name(id='mins', ctx=Load()), op=Div(), right=Name(id='num_cpus', ctx=Load()))), Assign(targets=[Name(id='max_', ctx=Store())], value=BinOp(left=Name(id='maxs', ctx=Load()), op=Div(), right=Name(id='num_cpus', ctx=Load())))]), Return(value=Call(func=Attribute(value=Name(id='_common', ctx=Load()), attr='scpufreq', ctx=Load()), args=[Name(id='current', ctx=Load()), Name(id='min_', ctx=Load()), Name(id='max_', ctx=Load())], keywords=[]))])])])], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='cpu_freq')], keywords=[]))], orelse=[]), If(test=BoolOp(op=Or(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='os', ctx=Load()), Constant(value='getloadavg')], keywords=[]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='_psplatform', ctx=Load()), Constant(value='getloadavg')], keywords=[])]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='os', ctx=Load()), Constant(value='getloadavg')], keywords=[]), body=[Assign(targets=[Name(id='getloadavg', ctx=Store())], value=Attribute(value=Name(id='os', ctx=Load()), attr='getloadavg', ctx=Load()))], orelse=[Assign(targets=[Name(id='getloadavg', ctx=Store())], value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='getloadavg', ctx=Load()))]), Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='getloadavg')], keywords=[]))], orelse=[]), FunctionDef(name='virtual_memory', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return statistics about system memory usage as a namedtuple\n    including the following fields, expressed in bytes:\n\n     - total:\n       total physical memory available.\n\n     - available:\n       the memory that can be given instantly to processes without the\n       system going into swap.\n       This is calculated by summing different memory values depending\n       on the platform and it is supposed to be used to monitor actual\n       memory usage in a cross platform fashion.\n\n     - percent:\n       the percentage usage calculated as (total - available) / total * 100\n\n     - used:\n        memory used, calculated differently depending on the platform and\n        designed for informational purposes only:\n        macOS: active + wired\n        BSD: active + wired + cached\n        Linux: total - free\n\n     - free:\n       memory not being used at all (zeroed) that is readily available;\n       note that this doesn't reflect the actual memory available\n       (use 'available' instead)\n\n    Platform-specific fields:\n\n     - active (UNIX):\n       memory currently in use or very recently used, and so it is in RAM.\n\n     - inactive (UNIX):\n       memory that is marked as not used.\n\n     - buffers (BSD, Linux):\n       cache for things like file system metadata.\n\n     - cached (BSD, macOS):\n       cache for various things.\n\n     - wired (macOS, BSD):\n       memory that is marked to always stay in RAM. It is never moved to disk.\n\n     - shared (BSD):\n       memory that may be simultaneously accessed by multiple processes.\n\n    The sum of 'used' and 'available' does not necessarily equal total.\n    On Windows 'available' and 'free' are the same.\n    ")), Global(names=['_TOTAL_PHYMEM']), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='virtual_memory', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='_TOTAL_PHYMEM', ctx=Store())], value=Attribute(value=Name(id='ret', ctx=Load()), attr='total', ctx=Load())), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[]), FunctionDef(name='swap_memory', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return system swap memory statistics as a namedtuple including\n    the following fields:\n\n     - total:   total swap memory in bytes\n     - used:    used swap memory in bytes\n     - free:    free swap memory in bytes\n     - percent: the percentage usage\n     - sin:     no. of bytes the system has swapped in from disk (cumulative)\n     - sout:    no. of bytes the system has swapped out from disk (cumulative)\n\n    'sin' and 'sout' on Windows are meaningless and always set to 0.\n    ")), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='swap_memory', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='disk_usage', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return disk usage statistics about the given *path* as a\n    namedtuple including total, used and free space expressed in bytes\n    plus the percentage usage.\n    ')), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='disk_usage', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='disk_partitions', args=arguments(posonlyargs=[], args=[arg(arg='all')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value="Return mounted partitions as a list of\n    (device, mountpoint, fstype, opts) namedtuple.\n    'opts' field is a raw string separated by commas indicating mount\n    options which may vary depending on the platform.\n\n    If *all* parameter is False return physical devices only and ignore\n    all others.\n    ")), FunctionDef(name='pathconf', args=arguments(posonlyargs=[], args=[arg(arg='path'), arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='pathconf', ctx=Load()), args=[Name(id='path', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='OSError', ctx=Load()), Name(id='AttributeError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], decorator_list=[]), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='disk_partitions', ctx=Load()), args=[Name(id='all', ctx=Load())], keywords=[])), If(test=Name(id='POSIX', ctx=Load()), body=[Assign(targets=[Name(id='new', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='item', ctx=Store()), iter=Name(id='ret', ctx=Load()), body=[Assign(targets=[Name(id='nt', ctx=Store())], value=Call(func=Attribute(value=Name(id='item', ctx=Load()), attr='_replace', ctx=Load()), args=[], keywords=[keyword(arg='maxfile', value=Call(func=Name(id='pathconf', ctx=Load()), args=[Attribute(value=Name(id='item', ctx=Load()), attr='mountpoint', ctx=Load()), Constant(value='PC_NAME_MAX')], keywords=[])), keyword(arg='maxpath', value=Call(func=Name(id='pathconf', ctx=Load()), args=[Attribute(value=Name(id='item', ctx=Load()), attr='mountpoint', ctx=Load()), Constant(value='PC_PATH_MAX')], keywords=[]))])), Expr(value=Call(func=Attribute(value=Name(id='new', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='nt', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='new', ctx=Load()))], orelse=[Return(value=Name(id='ret', ctx=Load()))])], decorator_list=[]), FunctionDef(name='disk_io_counters', args=arguments(posonlyargs=[], args=[arg(arg='perdisk'), arg(arg='nowrap')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=True)]), body=[Expr(value=Constant(value='Return system disk I/O statistics as a namedtuple including\n    the following fields:\n\n     - read_count:  number of reads\n     - write_count: number of writes\n     - read_bytes:  number of bytes read\n     - write_bytes: number of bytes written\n     - read_time:   time spent reading from disk (in ms)\n     - write_time:  time spent writing to disk (in ms)\n\n    Platform specific:\n\n     - busy_time: (Linux, FreeBSD) time spent doing actual I/Os (in ms)\n     - read_merged_count (Linux): number of merged reads\n     - write_merged_count (Linux): number of merged writes\n\n    If *perdisk* is True return the same information for every\n    physical disk installed on the system as a dictionary\n    with partition names as the keys and the namedtuple\n    described above as the values.\n\n    If *nowrap* is True it detects and adjust the numbers which overflow\n    and wrap (restart from 0) and add "old value" to "new value" so that\n    the returned numbers will always be increasing or remain the same,\n    but never decrease.\n    "disk_io_counters.cache_clear()" can be used to invalidate the\n    cache.\n\n    On recent Windows versions \'diskperf -y\' command may need to be\n    executed first otherwise this function won\'t find any disk.\n    ')), Assign(targets=[Name(id='kwargs', ctx=Store())], value=IfExp(test=Name(id='LINUX', ctx=Load()), body=Call(func=Name(id='dict', ctx=Load()), args=[], keywords=[keyword(arg='perdisk', value=Name(id='perdisk', ctx=Load()))]), orelse=Dict(keys=[], values=[]))), Assign(targets=[Name(id='rawdict', ctx=Store())], value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='disk_io_counters', ctx=Load()), args=[], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), If(test=UnaryOp(op=Not(), operand=Name(id='rawdict', ctx=Load())), body=[Return(value=IfExp(test=Name(id='perdisk', ctx=Load()), body=Dict(keys=[], values=[]), orelse=Constant(value=None)))], orelse=[]), If(test=Name(id='nowrap', ctx=Load()), body=[Assign(targets=[Name(id='rawdict', ctx=Store())], value=Call(func=Name(id='_wrap_numbers', ctx=Load()), args=[Name(id='rawdict', ctx=Load()), Constant(value='psutil.disk_io_counters')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nt', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='_psplatform', ctx=Load()), Constant(value='sdiskio'), Attribute(value=Name(id='_common', ctx=Load()), attr='sdiskio', ctx=Load())], keywords=[])), If(test=Name(id='perdisk', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='disk', ctx=Store()), Name(id='fields', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='rawdict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='rawdict', ctx=Load()), slice=Name(id='disk', ctx=Load()), ctx=Store())], value=Call(func=Name(id='nt', ctx=Load()), args=[Starred(value=Name(id='fields', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='rawdict', ctx=Load()))], orelse=[Return(value=Call(func=Name(id='nt', ctx=Load()), args=[Starred(value=GeneratorExp(elt=Call(func=Name(id='sum', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Call(func=Attribute(value=Name(id='rawdict', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), ctx=Load())], keywords=[]), ifs=[], is_async=0)]), ctx=Load())], keywords=[]))])], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='disk_io_counters', ctx=Load()), attr='cache_clear', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Attribute(value=Name(id='_wrap_numbers', ctx=Load()), attr='cache_clear', ctx=Load()), Constant(value='psutil.disk_io_counters')], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='disk_io_counters', ctx=Load()), attr='cache_clear', ctx=Load()), attr='__doc__', ctx=Store())], value=Constant(value='Clears nowrap argument cache')), FunctionDef(name='net_io_counters', args=arguments(posonlyargs=[], args=[arg(arg='pernic'), arg(arg='nowrap')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=True)]), body=[Expr(value=Constant(value='Return network I/O statistics as a namedtuple including\n    the following fields:\n\n     - bytes_sent:   number of bytes sent\n     - bytes_recv:   number of bytes received\n     - packets_sent: number of packets sent\n     - packets_recv: number of packets received\n     - errin:        total number of errors while receiving\n     - errout:       total number of errors while sending\n     - dropin:       total number of incoming packets which were dropped\n     - dropout:      total number of outgoing packets which were dropped\n                     (always 0 on macOS and BSD)\n\n    If *pernic* is True return the same information for every\n    network interface installed on the system as a dictionary\n    with network interface names as the keys and the namedtuple\n    described above as the values.\n\n    If *nowrap* is True it detects and adjust the numbers which overflow\n    and wrap (restart from 0) and add "old value" to "new value" so that\n    the returned numbers will always be increasing or remain the same,\n    but never decrease.\n    "net_io_counters.cache_clear()" can be used to invalidate the\n    cache.\n    ')), Assign(targets=[Name(id='rawdict', ctx=Store())], value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='net_io_counters', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='rawdict', ctx=Load())), body=[Return(value=IfExp(test=Name(id='pernic', ctx=Load()), body=Dict(keys=[], values=[]), orelse=Constant(value=None)))], orelse=[]), If(test=Name(id='nowrap', ctx=Load()), body=[Assign(targets=[Name(id='rawdict', ctx=Store())], value=Call(func=Name(id='_wrap_numbers', ctx=Load()), args=[Name(id='rawdict', ctx=Load()), Constant(value='psutil.net_io_counters')], keywords=[]))], orelse=[]), If(test=Name(id='pernic', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='nic', ctx=Store()), Name(id='fields', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='rawdict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='rawdict', ctx=Load()), slice=Name(id='nic', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='_common', ctx=Load()), attr='snetio', ctx=Load()), args=[Starred(value=Name(id='fields', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='rawdict', ctx=Load()))], orelse=[Return(value=Call(func=Attribute(value=Name(id='_common', ctx=Load()), attr='snetio', ctx=Load()), args=[Starred(value=ListComp(elt=Call(func=Name(id='sum', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Call(func=Attribute(value=Name(id='rawdict', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), ctx=Load())], keywords=[]), ifs=[], is_async=0)]), ctx=Load())], keywords=[]))])], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='net_io_counters', ctx=Load()), attr='cache_clear', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Attribute(value=Name(id='_wrap_numbers', ctx=Load()), attr='cache_clear', ctx=Load()), Constant(value='psutil.net_io_counters')], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='net_io_counters', ctx=Load()), attr='cache_clear', ctx=Load()), attr='__doc__', ctx=Store())], value=Constant(value='Clears nowrap argument cache')), FunctionDef(name='net_connections', args=arguments(posonlyargs=[], args=[arg(arg='kind')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='inet')]), body=[Expr(value=Constant(value="Return system-wide socket connections as a list of\n    (fd, family, type, laddr, raddr, status, pid) namedtuples.\n    In case of limited privileges 'fd' and 'pid' may be set to -1\n    and None respectively.\n    The *kind* parameter filters for connections that fit the\n    following criteria:\n\n    +------------+----------------------------------------------------+\n    | Kind Value | Connections using                                  |\n    +------------+----------------------------------------------------+\n    | inet       | IPv4 and IPv6                                      |\n    | inet4      | IPv4                                               |\n    | inet6      | IPv6                                               |\n    | tcp        | TCP                                                |\n    | tcp4       | TCP over IPv4                                      |\n    | tcp6       | TCP over IPv6                                      |\n    | udp        | UDP                                                |\n    | udp4       | UDP over IPv4                                      |\n    | udp6       | UDP over IPv6                                      |\n    | unix       | UNIX socket (both UDP and TCP protocols)           |\n    | all        | the sum of all the possible families and protocols |\n    +------------+----------------------------------------------------+\n\n    On macOS this function requires root privileges.\n    ")), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='net_connections', ctx=Load()), args=[Name(id='kind', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='net_if_addrs', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the addresses associated to each NIC (network interface\n    card) installed on the system as a dictionary whose keys are the\n    NIC names and value is a list of namedtuples for each address\n    assigned to the NIC. Each namedtuple includes 5 fields:\n\n     - family: can be either socket.AF_INET, socket.AF_INET6 or\n               psutil.AF_LINK, which refers to a MAC address.\n     - address: is the primary address and it is always set.\n     - netmask: and \'broadcast\' and \'ptp\' may be None.\n     - ptp: stands for "point to point" and references the\n            destination address on a point to point interface\n            (typically a VPN).\n     - broadcast: and *ptp* are mutually exclusive.\n\n    Note: you can have more than one address of the same family\n    associated with each interface.\n    ')), Assign(targets=[Name(id='has_enums', ctx=Store())], value=Name(id='_PY3', ctx=Load())), If(test=Name(id='has_enums', ctx=Load()), body=[Import(names=[alias(name='socket')])], orelse=[]), Assign(targets=[Name(id='rawlist', ctx=Store())], value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='net_if_addrs', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='rawlist', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=1), ctx=Load())))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='defaultdict', ctx=Load()), args=[Name(id='list', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='fam', ctx=Store()), Name(id='addr', ctx=Store()), Name(id='mask', ctx=Store()), Name(id='broadcast', ctx=Store()), Name(id='ptp', ctx=Store())], ctx=Store()), iter=Name(id='rawlist', ctx=Load()), body=[If(test=Name(id='has_enums', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='fam', ctx=Store())], value=Call(func=Attribute(value=Name(id='socket', ctx=Load()), attr='AddressFamily', ctx=Load()), args=[Name(id='fam', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Name(id='WINDOWS', ctx=Load()), Compare(left=Name(id='fam', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))])]), body=[Assign(targets=[Name(id='fam', ctx=Store())], value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='AF_LINK', ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='_psplatform', ctx=Load()), Constant(value='AF_LINK')], keywords=[]), Compare(left=Name(id='fam', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='AF_LINK', ctx=Load())])]), body=[Assign(targets=[Name(id='fam', ctx=Store())], value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='AF_LINK', ctx=Load()))], orelse=[])])])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='fam', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='_psplatform', ctx=Load()), attr='AF_LINK', ctx=Load())]), body=[Assign(targets=[Name(id='separator', ctx=Store())], value=IfExp(test=Name(id='POSIX', ctx=Load()), body=Constant(value=':'), orelse=Constant(value='-'))), While(test=Compare(left=Call(func=Attribute(value=Name(id='addr', ctx=Load()), attr='count', ctx=Load()), args=[Name(id='separator', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=5)]), body=[AugAssign(target=Name(id='addr', ctx=Store()), op=Add(), value=BinOp(left=Constant(value='%s00'), op=Mod(), right=Name(id='separator', ctx=Load())))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='ret', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='_common', ctx=Load()), attr='snicaddr', ctx=Load()), args=[Name(id='fam', ctx=Load()), Name(id='addr', ctx=Load()), Name(id='mask', ctx=Load()), Name(id='broadcast', ctx=Load()), Name(id='ptp', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='dict', ctx=Load()), args=[Name(id='ret', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='net_if_stats', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return information about each NIC (network interface card)\n    installed on the system as a dictionary whose keys are the\n    NIC names and value is a namedtuple with the following fields:\n\n     - isup: whether the interface is up (bool)\n     - duplex: can be either NIC_DUPLEX_FULL, NIC_DUPLEX_HALF or\n               NIC_DUPLEX_UNKNOWN\n     - speed: the NIC speed expressed in mega bits (MB); if it can't\n              be determined (e.g. 'localhost') it will be set to 0.\n     - mtu: the maximum transmission unit expressed in bytes.\n    ")), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='net_if_stats', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='_psplatform', ctx=Load()), Constant(value='sensors_temperatures')], keywords=[]), body=[FunctionDef(name='sensors_temperatures', args=arguments(posonlyargs=[], args=[arg(arg='fahrenheit')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Return hardware temperatures. Each entry is a namedtuple\n        representing a certain hardware sensor (it may be a CPU, an\n        hard disk or something else, depending on the OS and its\n        configuration).\n        All temperatures are expressed in celsius unless *fahrenheit*\n        is set to True.\n        ')), FunctionDef(name='convert', args=arguments(posonlyargs=[], args=[arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='n', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=IfExp(test=Name(id='fahrenheit', ctx=Load()), body=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id='float', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), op=Mult(), right=Constant(value=9)), op=Div(), right=Constant(value=5)), op=Add(), right=Constant(value=32)), orelse=Name(id='n', ctx=Load())))], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='defaultdict', ctx=Load()), args=[Name(id='list', ctx=Load())], keywords=[])), Assign(targets=[Name(id='rawdict', ctx=Store())], value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='sensors_temperatures', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='values', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='rawdict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[While(test=Name(id='values', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='label', ctx=Store()), Name(id='current', ctx=Store()), Name(id='high', ctx=Store()), Name(id='critical', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='values', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value=0)], keywords=[])), Assign(targets=[Name(id='current', ctx=Store())], value=Call(func=Name(id='convert', ctx=Load()), args=[Name(id='current', ctx=Load())], keywords=[])), Assign(targets=[Name(id='high', ctx=Store())], value=Call(func=Name(id='convert', ctx=Load()), args=[Name(id='high', ctx=Load())], keywords=[])), Assign(targets=[Name(id='critical', ctx=Store())], value=Call(func=Name(id='convert', ctx=Load()), args=[Name(id='critical', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='high', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='critical', ctx=Load()))]), body=[Assign(targets=[Name(id='critical', ctx=Store())], value=Name(id='high', ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Name(id='critical', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='high', ctx=Load()))]), body=[Assign(targets=[Name(id='high', ctx=Store())], value=Name(id='critical', ctx=Load()))], orelse=[])]), Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='ret', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='_common', ctx=Load()), attr='shwtemp', ctx=Load()), args=[Name(id='label', ctx=Load()), Name(id='current', ctx=Load()), Name(id='high', ctx=Load()), Name(id='critical', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='dict', ctx=Load()), args=[Name(id='ret', ctx=Load())], keywords=[]))], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='sensors_temperatures')], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='_psplatform', ctx=Load()), Constant(value='sensors_fans')], keywords=[]), body=[FunctionDef(name='sensors_fans', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return fans speed. Each entry is a namedtuple\n        representing a certain hardware sensor.\n        All speed are expressed in RPM (rounds per minute).\n        ')), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='sensors_fans', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='sensors_fans')], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='_psplatform', ctx=Load()), Constant(value='sensors_battery')], keywords=[]), body=[FunctionDef(name='sensors_battery', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return battery information. If no battery is installed\n        returns None.\n\n         - percent: battery power left as a percentage.\n         - secsleft: a rough approximation of how many seconds are left\n                     before the battery runs out of power. May be\n                     POWER_TIME_UNLIMITED or POWER_TIME_UNLIMITED.\n         - power_plugged: True if the AC power cable is connected.\n        ')), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='sensors_battery', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='__all__', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='sensors_battery')], keywords=[]))], orelse=[]), FunctionDef(name='boot_time', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the system boot time expressed in seconds since the epoch.')), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='boot_time', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='users', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return users currently connected on the system as a list of\n    namedtuples including the following fields.\n\n     - user: the name of the user\n     - terminal: the tty or pseudo-tty associated with the user, if any.\n     - host: the host name associated with the entry, if any.\n     - started: the creation time as a floating point number expressed in\n       seconds since the epoch.\n    ')), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='users', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), If(test=Name(id='WINDOWS', ctx=Load()), body=[FunctionDef(name='win_service_iter', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a generator yielding a WindowsService instance for all\n        Windows services installed.\n        ')), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='win_service_iter', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='win_service_get', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get a Windows service by *name*.\n        Raise NoSuchProcess if no service with such name exists.\n        ')), Return(value=Call(func=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='win_service_get', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[])], orelse=[]), FunctionDef(name='_set_debug', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Enable or disable PSUTIL_DEBUG option, which prints debugging\n    messages to stderr.\n    ')), Import(names=[alias(name='psutil._common')]), Assign(targets=[Attribute(value=Attribute(value=Name(id='psutil', ctx=Load()), attr='_common', ctx=Load()), attr='PSUTIL_DEBUG', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='_psplatform', ctx=Load()), attr='cext', ctx=Load()), attr='set_debug', ctx=Load()), args=[Call(func=Name(id='bool', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='test', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='_common', names=[alias(name='bytes2human')], level=1), ImportFrom(module='_compat', names=[alias(name='get_terminal_size')], level=1), Assign(targets=[Name(id='today_day', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='datetime', ctx=Load()), attr='date', ctx=Load()), attr='today', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='templ', ctx=Store())], value=Constant(value='%-10s %5s %5s %7s %7s %5s %6s %6s %6s  %s')), Assign(targets=[Name(id='attrs', ctx=Store())], value=List(elts=[Constant(value='pid'), Constant(value='memory_percent'), Constant(value='name'), Constant(value='cmdline'), Constant(value='cpu_times'), Constant(value='create_time'), Constant(value='memory_info'), Constant(value='status'), Constant(value='nice'), Constant(value='username')], ctx=Load())), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=Name(id='templ', ctx=Load()), op=Mod(), right=Tuple(elts=[Constant(value='USER'), Constant(value='PID'), Constant(value='%MEM'), Constant(value='VSZ'), Constant(value='RSS'), Constant(value='NICE'), Constant(value='STATUS'), Constant(value='START'), Constant(value='TIME'), Constant(value='CMDLINE')], ctx=Load()))], keywords=[])), For(target=Name(id='p', ctx=Store()), iter=Call(func=Name(id='process_iter', ctx=Load()), args=[Name(id='attrs', ctx=Load())], keywords=[keyword(arg='ad_value', value=Constant(value=None))]), body=[If(test=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='create_time'), ctx=Load()), body=[Assign(targets=[Name(id='ctime', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='datetime', ctx=Load()), attr='datetime', ctx=Load()), attr='fromtimestamp', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='create_time'), ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='ctime', ctx=Load()), attr='date', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Name(id='today_day', ctx=Load())]), body=[Assign(targets=[Name(id='ctime', ctx=Store())], value=Call(func=Attribute(value=Name(id='ctime', ctx=Load()), attr='strftime', ctx=Load()), args=[Constant(value='%H:%M')], keywords=[]))], orelse=[Assign(targets=[Name(id='ctime', ctx=Store())], value=Call(func=Attribute(value=Name(id='ctime', ctx=Load()), attr='strftime', ctx=Load()), args=[Constant(value='%b%d')], keywords=[]))])], orelse=[Assign(targets=[Name(id='ctime', ctx=Store())], value=Constant(value=''))]), If(test=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='cpu_times'), ctx=Load()), body=[Assign(targets=[Name(id='cputime', ctx=Store())], value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='strftime', ctx=Load()), args=[Constant(value='%M:%S'), Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='localtime', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='cpu_times'), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='cputime', ctx=Store())], value=Constant(value=''))]), Assign(targets=[Name(id='user', ctx=Store())], value=BoolOp(op=Or(), values=[Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='username'), ctx=Load()), Constant(value='')])), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='user', ctx=Load())), Name(id='POSIX', ctx=Load())]), body=[Try(body=[Assign(targets=[Name(id='user', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='uids', ctx=Load()), args=[], keywords=[]), slice=Constant(value=0), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Error', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='user', ctx=Load()), Name(id='WINDOWS', ctx=Load()), Compare(left=Constant(value='\\'), ops=[In()], comparators=[Name(id='user', ctx=Load())])]), body=[Assign(targets=[Name(id='user', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='user', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\\')], keywords=[]), slice=Constant(value=1), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='user', ctx=Store())], value=Subscript(value=Name(id='user', ctx=Load()), slice=Slice(upper=Constant(value=9)), ctx=Load())), Assign(targets=[Name(id='vms', ctx=Store())], value=IfExp(test=Compare(left=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='memory_info'), ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Call(func=Name(id='bytes2human', ctx=Load()), args=[Attribute(value=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='memory_info'), ctx=Load()), attr='vms', ctx=Load())], keywords=[]), orelse=Constant(value=''))), Assign(targets=[Name(id='rss', ctx=Store())], value=IfExp(test=Compare(left=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='memory_info'), ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Call(func=Name(id='bytes2human', ctx=Load()), args=[Attribute(value=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='memory_info'), ctx=Load()), attr='rss', ctx=Load())], keywords=[]), orelse=Constant(value=''))), Assign(targets=[Name(id='memp', ctx=Store())], value=IfExp(test=Compare(left=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='memory_percent'), ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Call(func=Name(id='round', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='memory_percent'), ctx=Load()), Constant(value=1)], keywords=[]), orelse=Constant(value=''))), Assign(targets=[Name(id='nice', ctx=Store())], value=IfExp(test=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='nice'), ctx=Load()), body=Call(func=Name(id='int', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='nice'), ctx=Load())], keywords=[]), orelse=Constant(value=''))), If(test=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='cmdline'), ctx=Load()), body=[Assign(targets=[Name(id='cmdline', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='cmdline'), ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='cmdline', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='name'), ctx=Load()))]), Assign(targets=[Name(id='status', ctx=Store())], value=IfExp(test=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='status'), ctx=Load()), body=Subscript(value=Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='status'), ctx=Load()), slice=Slice(upper=Constant(value=5)), ctx=Load()), orelse=Constant(value=''))), Assign(targets=[Name(id='line', ctx=Store())], value=BinOp(left=Name(id='templ', ctx=Load()), op=Mod(), right=Tuple(elts=[Subscript(value=Name(id='user', ctx=Load()), slice=Slice(upper=Constant(value=10)), ctx=Load()), Subscript(value=Attribute(value=Name(id='p', ctx=Load()), attr='info', ctx=Load()), slice=Constant(value='pid'), ctx=Load()), Name(id='memp', ctx=Load()), Name(id='vms', ctx=Load()), Name(id='rss', ctx=Load()), Name(id='nice', ctx=Load()), Name(id='status', ctx=Load()), Name(id='ctime', ctx=Load()), Name(id='cputime', ctx=Load()), Name(id='cmdline', ctx=Load())], ctx=Load()))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Subscript(value=Name(id='line', ctx=Load()), slice=Slice(upper=Subscript(value=Call(func=Name(id='get_terminal_size', ctx=Load()), args=[], keywords=[]), slice=Constant(value=0), ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), Delete(targets=[Name(id='memoize_when_activated', ctx=Del()), Name(id='division', ctx=Del())]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Lt()], comparators=[Constant(value=3)]), body=[Delete(targets=[Name(id='num', ctx=Del()), Name(id='x', ctx=Del())])], orelse=[]), If(test=Compare(left=Name(id='__name__', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__main__')]), body=[Expr(value=Call(func=Name(id='test', ctx=Load()), args=[], keywords=[]))], orelse=[])], type_ignores=[])