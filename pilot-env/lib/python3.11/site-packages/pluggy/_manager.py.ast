Module(body=[ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), Import(names=[alias(name='importlib.metadata')]), Import(names=[alias(name='inspect')]), Import(names=[alias(name='types')]), Import(names=[alias(name='warnings')]), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='cast')], level=0), ImportFrom(module='typing', names=[alias(name='Final')], level=0), ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='Mapping')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(names=[alias(name='_tracing')], level=1), ImportFrom(module='_callers', names=[alias(name='_multicall')], level=1), ImportFrom(module='_hooks', names=[alias(name='_HookImplFunction')], level=1), ImportFrom(module='_hooks', names=[alias(name='_Namespace')], level=1), ImportFrom(module='_hooks', names=[alias(name='_Plugin')], level=1), ImportFrom(module='_hooks', names=[alias(name='_SubsetHookCaller')], level=1), ImportFrom(module='_hooks', names=[alias(name='HookCaller')], level=1), ImportFrom(module='_hooks', names=[alias(name='HookImpl')], level=1), ImportFrom(module='_hooks', names=[alias(name='HookimplOpts')], level=1), ImportFrom(module='_hooks', names=[alias(name='HookRelay')], level=1), ImportFrom(module='_hooks', names=[alias(name='HookspecOpts')], level=1), ImportFrom(module='_hooks', names=[alias(name='normalize_hookimpl_opts')], level=1), ImportFrom(module='_result', names=[alias(name='Result')], level=1), Assign(targets=[Name(id='_BeforeTrace', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='HookImpl', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='_AfterTrace', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Subscript(value=Name(id='Result', ctx=Load()), slice=Name(id='Any', ctx=Load()), ctx=Load()), Name(id='str', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='HookImpl', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load())), FunctionDef(name='_warn_for_function', args=arguments(posonlyargs=[], args=[arg(arg='warning', annotation=Name(id='Warning', ctx=Load())), arg(arg='function', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Attribute(value=Name(id='types', ctx=Load()), attr='FunctionType', ctx=Load()), Name(id='function', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn_explicit', ctx=Load()), args=[Name(id='warning', ctx=Load()), Call(func=Name(id='type', ctx=Load()), args=[Name(id='warning', ctx=Load())], keywords=[])], keywords=[keyword(arg='lineno', value=Attribute(value=Attribute(value=Name(id='func', ctx=Load()), attr='__code__', ctx=Load()), attr='co_firstlineno', ctx=Load())), keyword(arg='filename', value=Attribute(value=Attribute(value=Name(id='func', ctx=Load()), attr='__code__', ctx=Load()), attr='co_filename', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), ClassDef(name='PluginValidationError', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Plugin failed validation.\n\n    :param plugin: The plugin which failed validation.\n    :param message: Error message.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin', annotation=Name(id='_Plugin', ctx=Load())), arg(arg='message', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='message', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='plugin', ctx=Store())], value=Name(id='plugin', ctx=Load()))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='DistFacade', bases=[], keywords=[], body=[Expr(value=Constant(value='Emulate a pkg_resources Distribution')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist', annotation=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='metadata', ctx=Load()), attr='Distribution', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_dist', ctx=Store())], value=Name(id='dist', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='project_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata', ctx=Load()), slice=Constant(value='name'), ctx=Load()), simple=1), Return(value=Name(id='name', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='attr', annotation=Name(id='str', ctx=Load())), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_dist', ctx=Load()), Name(id='attr', ctx=Load()), Name(id='default', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__dir__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[BinOp(left=Call(func=Name(id='dir', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_dist', ctx=Load())], keywords=[]), op=Add(), right=List(elts=[Constant(value='_dist'), Constant(value='project_name')], ctx=Load()))], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='PluginManager', bases=[], keywords=[], body=[Expr(value=Constant(value="Core class which manages registration of plugin objects and 1:N hook\n    calling.\n\n    You can register new hooks by calling :meth:`add_hookspecs(module_or_class)\n    <PluginManager.add_hookspecs>`.\n\n    You can register plugin objects (which contain hook implementations) by\n    calling :meth:`register(plugin) <PluginManager.register>`.\n\n    For debugging purposes you can call :meth:`PluginManager.enable_tracing`\n    which will subsequently send debug information to the trace helper.\n\n    :param project_name:\n        The short project name. Prefer snake case. Make sure it's unique!\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='project_name', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Store()), annotation=Subscript(value=Name(id='Final', ctx=Load()), slice=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='_Plugin', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_plugin_distinfo', ctx=Store()), annotation=Subscript(value=Name(id='Final', ctx=Load()), slice=Subscript(value=Name(id='list', ctx=Load()), slice=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='_Plugin', ctx=Load()), Name(id='DistFacade', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='hook', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Call(func=Name(id='HookRelay', ctx=Load()), args=[], keywords=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='trace', ctx=Store()), annotation=Subscript(value=Name(id='Final', ctx=Load()), slice=Attribute(value=Name(id='_tracing', ctx=Load()), attr='TagTracerSub', ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='_tracing', ctx=Load()), attr='TagTracer', ctx=Load()), args=[], keywords=[]), attr='get', ctx=Load()), args=[Constant(value='pluginmanage')], keywords=[]), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_inner_hookexec', ctx=Store())], value=Name(id='_multicall', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_hookexec', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='hook_name', annotation=Name(id='str', ctx=Load())), arg(arg='methods', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='HookImpl', ctx=Load()), ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='firstresult', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_inner_hookexec', ctx=Load()), args=[Name(id='hook_name', ctx=Load()), Name(id='methods', ctx=Load()), Name(id='kwargs', ctx=Load()), Name(id='firstresult', ctx=Load())], keywords=[]))], decorator_list=[], returns=BinOp(left=Name(id='object', ctx=Load()), op=BitOr(), right=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()))), FunctionDef(name='register', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin', annotation=Name(id='_Plugin', ctx=Load())), arg(arg='name', annotation=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Register a plugin and return its name.\n\n        :param name:\n            The name under which to register the plugin. If not specified, a\n            name is generated using :func:`get_canonical_name`.\n\n        :returns:\n            The plugin name. If the name is blocked from registering, returns\n            ``None``.\n\n        If the plugin is already registered, raises a :exc:`ValueError`.\n        ')), Assign(targets=[Name(id='plugin_name', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='name', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_canonical_name', ctx=Load()), args=[Name(id='plugin', ctx=Load())], keywords=[])])), If(test=Compare(left=Name(id='plugin_name', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load())]), body=[If(test=Compare(left=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='plugin_name', ctx=Load()), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='Plugin name already registered: %s=%s\n%s'), op=Mod(), right=Tuple(elts=[Name(id='plugin_name', ctx=Load()), Name(id='plugin', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='plugin', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='Plugin already registered under a different name: %s=%s\n%s'), op=Mod(), right=Tuple(elts=[Name(id='plugin_name', ctx=Load()), Name(id='plugin', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), slice=Name(id='plugin_name', ctx=Load()), ctx=Store())], value=Name(id='plugin', ctx=Load())), For(target=Name(id='name', ctx=Store()), iter=Call(func=Name(id='dir', ctx=Load()), args=[Name(id='plugin', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='hookimpl_opts', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parse_hookimpl_opts', ctx=Load()), args=[Name(id='plugin', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='hookimpl_opts', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='normalize_hookimpl_opts', ctx=Load()), args=[Name(id='hookimpl_opts', ctx=Load())], keywords=[])), AnnAssign(target=Name(id='method', ctx=Store()), annotation=Subscript(value=Name(id='_HookImplFunction', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='plugin', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]), simple=1), Assign(targets=[Name(id='hookimpl', ctx=Store())], value=Call(func=Name(id='HookImpl', ctx=Load()), args=[Name(id='plugin', ctx=Load()), Name(id='plugin_name', ctx=Load()), Name(id='method', ctx=Load()), Name(id='hookimpl_opts', ctx=Load())], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='hookimpl_opts', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='specname')], keywords=[]), Name(id='name', ctx=Load())])), AnnAssign(target=Name(id='hook', ctx=Store()), annotation=BinOp(left=Name(id='HookCaller', ctx=Load()), op=BitOr(), right=Constant(value=None)), value=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='hook', ctx=Load()), Name(id='name', ctx=Load()), Constant(value=None)], keywords=[]), simple=1), If(test=Compare(left=Name(id='hook', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='hook', ctx=Store())], value=Call(func=Name(id='HookCaller', ctx=Load()), args=[Name(id='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_hookexec', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='hook', ctx=Load()), Name(id='name', ctx=Load()), Name(id='hook', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Attribute(value=Name(id='hook', ctx=Load()), attr='has_spec', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_verify_hook', ctx=Load()), args=[Name(id='hook', ctx=Load()), Name(id='hookimpl', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='hook', ctx=Load()), attr='_maybe_apply_history', ctx=Load()), args=[Name(id='hookimpl', ctx=Load())], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='hook', ctx=Load()), attr='_add_hookimpl', ctx=Load()), args=[Name(id='hookimpl', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='plugin_name', ctx=Load()))], decorator_list=[], returns=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Constant(value=None))), FunctionDef(name='parse_hookimpl_opts', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin', annotation=Name(id='_Plugin', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Try to obtain a hook implementation from an item with the given name\n        in the given plugin which is being searched for hook impls.\n\n        :returns:\n            The parsed hookimpl options, or None to skip the given item.\n\n        This method can be overridden by ``PluginManager`` subclasses to\n        customize how hook implementation are picked up. By default, returns the\n        options for items decorated with :class:`HookimplMarker`.\n        ')), AnnAssign(target=Name(id='method', ctx=Store()), annotation=Name(id='object', ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='plugin', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]), simple=1), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='isroutine', ctx=Load()), args=[Name(id='method', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=None))], orelse=[]), Try(body=[AnnAssign(target=Name(id='res', ctx=Store()), annotation=BinOp(left=Name(id='HookimplOpts', ctx=Load()), op=BitOr(), right=Constant(value=None)), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='method', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), op=Add(), right=Constant(value='_impl')), Constant(value=None)], keywords=[]), simple=1)], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Assign(targets=[Name(id='res', ctx=Store())], value=Dict(keys=[], values=[]))])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='res', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='res', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]))]), body=[Assign(targets=[Name(id='res', ctx=Store())], value=Constant(value=None))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=BinOp(left=Name(id='HookimplOpts', ctx=Load()), op=BitOr(), right=Constant(value=None))), FunctionDef(name='unregister', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin', annotation=BinOp(left=Name(id='_Plugin', ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='name', annotation=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Unregister a plugin and all of its hook implementations.\n\n        The plugin can be specified either by the plugin object or the plugin\n        name. If both are specified, they must agree.\n\n        Returns the unregistered plugin, or ``None`` if not found.\n        ')), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assert(test=Compare(left=Name(id='plugin', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), msg=Constant(value='one of name or plugin needs to be specified')), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_name', ctx=Load()), args=[Name(id='plugin', ctx=Load())], keywords=[])), Assert(test=Compare(left=Name(id='name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), msg=Constant(value='plugin is not registered'))], orelse=[]), If(test=Compare(left=Name(id='plugin', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='plugin', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_plugin', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='plugin', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[])], orelse=[]), Assign(targets=[Name(id='hookcallers', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_hookcallers', ctx=Load()), args=[Name(id='plugin', ctx=Load())], keywords=[])), If(test=Name(id='hookcallers', ctx=Load()), body=[For(target=Name(id='hookcaller', ctx=Store()), iter=Name(id='hookcallers', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='hookcaller', ctx=Load()), attr='_remove_plugin', ctx=Load()), args=[Name(id='plugin', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), body=[Assert(test=Compare(left=Name(id='name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Del())])], orelse=[]), Return(value=Name(id='plugin', ctx=Load()))], decorator_list=[], returns=BinOp(left=Name(id='Any', ctx=Load()), op=BitOr(), right=Constant(value=None))), FunctionDef(name='set_blocked', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Block registrations of the given name, unregister if already registered.')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='unregister', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load()))])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Constant(value=None))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='is_blocked', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return whether the given plugin name is blocked.')), Return(value=BoolOp(op=And(), values=[Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load())]), Compare(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='add_hookspecs', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='module_or_class', annotation=Name(id='_Namespace', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add new hook specifications defined in the given ``module_or_class``.\n\n        Functions are recognized as hook specifications if they have been\n        decorated with a matching :class:`HookspecMarker`.\n        ')), Assign(targets=[Name(id='names', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='name', ctx=Store()), iter=Call(func=Name(id='dir', ctx=Load()), args=[Name(id='module_or_class', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='spec_opts', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parse_hookspec_opts', ctx=Load()), args=[Name(id='module_or_class', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='spec_opts', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AnnAssign(target=Name(id='hc', ctx=Store()), annotation=BinOp(left=Name(id='HookCaller', ctx=Load()), op=BitOr(), right=Constant(value=None)), value=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='hook', ctx=Load()), Name(id='name', ctx=Load()), Constant(value=None)], keywords=[]), simple=1), If(test=Compare(left=Name(id='hc', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='hc', ctx=Store())], value=Call(func=Name(id='HookCaller', ctx=Load()), args=[Name(id='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_hookexec', ctx=Load()), Name(id='module_or_class', ctx=Load()), Name(id='spec_opts', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='hook', ctx=Load()), Name(id='name', ctx=Load()), Name(id='hc', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='hc', ctx=Load()), attr='set_specification', ctx=Load()), args=[Name(id='module_or_class', ctx=Load()), Name(id='spec_opts', ctx=Load())], keywords=[])), For(target=Name(id='hookfunction', ctx=Store()), iter=Call(func=Attribute(value=Name(id='hc', ctx=Load()), attr='get_hookimpls', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_verify_hook', ctx=Load()), args=[Name(id='hc', ctx=Load()), Name(id='hookfunction', ctx=Load())], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='names', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='names', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='did not find any '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), conversion=114), Constant(value=' hooks in '), FormattedValue(value=Name(id='module_or_class', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='parse_hookspec_opts', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='module_or_class', annotation=Name(id='_Namespace', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Try to obtain a hook specification from an item with the given name\n        in the given module or class which is being searched for hook specs.\n\n        :returns:\n            The parsed hookspec options for defining a hook, or None to skip the\n            given item.\n\n        This method can be overridden by ``PluginManager`` subclasses to\n        customize how hook specifications are picked up. By default, returns the\n        options for items decorated with :class:`HookspecMarker`.\n        ')), Assign(targets=[Name(id='method', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='module_or_class', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])), AnnAssign(target=Name(id='opts', ctx=Store()), annotation=BinOp(left=Name(id='HookspecOpts', ctx=Load()), op=BitOr(), right=Constant(value=None)), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='method', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), op=Add(), right=Constant(value='_spec')), Constant(value=None)], keywords=[]), simple=1), Return(value=Name(id='opts', ctx=Load()))], decorator_list=[], returns=BinOp(left=Name(id='HookspecOpts', ctx=Load()), op=BitOr(), right=Constant(value=None))), FunctionDef(name='get_plugins', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a set of all registered plugin objects.')), Return(value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='set', ctx=Load()), slice=Name(id='Any', ctx=Load()), ctx=Load())), FunctionDef(name='is_registered', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin', annotation=Name(id='_Plugin', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return whether the plugin is already registered.')), Return(value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='plugin', ctx=Load()), ops=[Eq()], comparators=[Name(id='val', ctx=Load())]), generators=[comprehension(target=Name(id='val', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='get_canonical_name', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin', annotation=Name(id='_Plugin', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a canonical name for a plugin object.\n\n        Note that a plugin may be registered under a different name\n        specified by the caller of :meth:`register(plugin, name) <register>`.\n        To obtain the name of a registered plugin use :meth:`get_name(plugin)\n        <get_name>` instead.\n        ')), AnnAssign(target=Name(id='name', ctx=Store()), annotation=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Constant(value=None)), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='plugin', ctx=Load()), Constant(value='__name__'), Constant(value=None)], keywords=[]), simple=1), Return(value=BoolOp(op=Or(), values=[Name(id='name', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='id', ctx=Load()), args=[Name(id='plugin', ctx=Load())], keywords=[])], keywords=[])]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='get_plugin', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the plugin registered under the given name, if any.')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[], returns=BinOp(left=Name(id='Any', ctx=Load()), op=BitOr(), right=Constant(value=None))), FunctionDef(name='has_plugin', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return whether a plugin with the given name is registered.')), Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_plugin', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='get_name', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin', annotation=Name(id='_Plugin', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the name the plugin is registered under, or ``None`` if\n        is isn't.")), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='val', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='plugin', ctx=Load()), ops=[Eq()], comparators=[Name(id='val', ctx=Load())]), body=[Return(value=Name(id='name', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Constant(value=None))), FunctionDef(name='_verify_hook', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='hook', annotation=Name(id='HookCaller', ctx=Load())), arg(arg='hookimpl', annotation=Name(id='HookImpl', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='hook', ctx=Load()), attr='is_historic', ctx=Load()), args=[], keywords=[]), BoolOp(op=Or(), values=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='hookwrapper', ctx=Load()), Attribute(value=Name(id='hookimpl', ctx=Load()), attr='wrapper', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='PluginValidationError', ctx=Load()), args=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin', ctx=Load()), BinOp(left=Constant(value='Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin_name', ctx=Load()), Attribute(value=Name(id='hook', ctx=Load()), attr='name', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Assert(test=Compare(left=Attribute(value=Name(id='hook', ctx=Load()), attr='spec', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), If(test=Attribute(value=Attribute(value=Name(id='hook', ctx=Load()), attr='spec', ctx=Load()), attr='warn_on_impl', ctx=Load()), body=[Expr(value=Call(func=Name(id='_warn_for_function', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='hook', ctx=Load()), attr='spec', ctx=Load()), attr='warn_on_impl', ctx=Load()), Attribute(value=Name(id='hookimpl', ctx=Load()), attr='function', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='notinspec', ctx=Store())], value=BinOp(left=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='argnames', ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='hook', ctx=Load()), attr='spec', ctx=Load()), attr='argnames', ctx=Load())], keywords=[]))), If(test=Name(id='notinspec', ctx=Load()), body=[Raise(exc=Call(func=Name(id='PluginValidationError', ctx=Load()), args=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin', ctx=Load()), BinOp(left=Constant(value='Plugin %r for hook %r\nhookimpl definition: %s\nArgument(s) %s are declared in the hookimpl but can not be found in the hookspec'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin_name', ctx=Load()), Attribute(value=Name(id='hook', ctx=Load()), attr='name', ctx=Load()), Call(func=Name(id='_formatdef', ctx=Load()), args=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='function', ctx=Load())], keywords=[]), Name(id='notinspec', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='wrapper', ctx=Load()), Attribute(value=Name(id='hookimpl', ctx=Load()), attr='hookwrapper', ctx=Load())]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='isgeneratorfunction', ctx=Load()), args=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='function', ctx=Load())], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='PluginValidationError', ctx=Load()), args=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin', ctx=Load()), BinOp(left=Constant(value='Plugin %r for hook %r\nhookimpl definition: %s\nDeclared as wrapper=True or hookwrapper=True but function is not a generator function'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin_name', ctx=Load()), Attribute(value=Name(id='hook', ctx=Load()), attr='name', ctx=Load()), Call(func=Name(id='_formatdef', ctx=Load()), args=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='function', ctx=Load())], keywords=[])], ctx=Load()))], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='wrapper', ctx=Load()), Attribute(value=Name(id='hookimpl', ctx=Load()), attr='hookwrapper', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='PluginValidationError', ctx=Load()), args=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin', ctx=Load()), BinOp(left=Constant(value='Plugin %r for hook %r\nhookimpl definition: %s\nThe wrapper=True and hookwrapper=True options are mutually exclusive'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin_name', ctx=Load()), Attribute(value=Name(id='hook', ctx=Load()), attr='name', ctx=Load()), Call(func=Name(id='_formatdef', ctx=Load()), args=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='function', ctx=Load())], keywords=[])], ctx=Load()))], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='check_pending', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Verify that all hooks which have not been verified against a\n        hook specification are optional, otherwise raise\n        :exc:`PluginValidationError`.')), For(target=Name(id='name', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='hook', ctx=Load()), attr='__dict__', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='name', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[NotEq()], comparators=[Constant(value='_')]), body=[AnnAssign(target=Name(id='hook', ctx=Store()), annotation=Name(id='HookCaller', ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='hook', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]), simple=1), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='hook', ctx=Load()), attr='has_spec', ctx=Load()), args=[], keywords=[])), body=[For(target=Name(id='hookimpl', ctx=Store()), iter=Call(func=Attribute(value=Name(id='hook', ctx=Load()), attr='get_hookimpls', ctx=Load()), args=[], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='hookimpl', ctx=Load()), attr='optionalhook', ctx=Load())), body=[Raise(exc=Call(func=Name(id='PluginValidationError', ctx=Load()), args=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin', ctx=Load()), BinOp(left=Constant(value='unknown hook %r in plugin %r'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='load_setuptools_entrypoints', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='group', annotation=Name(id='str', ctx=Load())), arg(arg='name', annotation=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Load modules from querying the specified setuptools ``group``.\n\n        :param group:\n            Entry point group to load plugins.\n        :param name:\n            If given, loads only plugins with the given ``name``.\n\n        :return:\n            The number of plugins loaded by this call.\n        ')), Assign(targets=[Name(id='count', ctx=Store())], value=Constant(value=0)), For(target=Name(id='dist', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='importlib', ctx=Load()), attr='metadata', ctx=Load()), attr='distributions', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[For(target=Name(id='ep', ctx=Store()), iter=Attribute(value=Name(id='dist', ctx=Load()), attr='entry_points', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='ep', ctx=Load()), attr='group', ctx=Load()), ops=[NotEq()], comparators=[Name(id='group', ctx=Load())]), BoolOp(op=And(), values=[Compare(left=Name(id='name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()), ops=[NotEq()], comparators=[Name(id='name', ctx=Load())])]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_plugin', ctx=Load()), args=[Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_blocked', ctx=Load()), args=[Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load())], keywords=[])]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='plugin', ctx=Store())], value=Call(func=Attribute(value=Name(id='ep', ctx=Load()), attr='load', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='register', ctx=Load()), args=[Name(id='plugin', ctx=Load())], keywords=[keyword(arg='name', value=Attribute(value=Name(id='ep', ctx=Load()), attr='name', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_plugin_distinfo', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='plugin', ctx=Load()), Call(func=Name(id='DistFacade', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[])], ctx=Load())], keywords=[])), AugAssign(target=Name(id='count', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[]), Return(value=Name(id='count', ctx=Load()))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='list_plugin_distinfo', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a list of (plugin, distinfo) pairs for all\n        setuptools-registered plugins.')), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_plugin_distinfo', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='_Plugin', ctx=Load()), Name(id='DistFacade', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='list_name_plugin', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a list of (name, plugin) pairs for all registered plugins.')), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_name2plugin', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='_Plugin', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='get_hookcallers', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin', annotation=Name(id='_Plugin', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get all hook callers for the specified plugin.\n\n        :returns:\n            The hook callers, or ``None`` if ``plugin`` is not registered in\n            this plugin manager.\n        ')), If(test=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_name', ctx=Load()), args=[Name(id='plugin', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='hookcallers', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='hookcaller', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='hook', ctx=Load()), attr='__dict__', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), body=[For(target=Name(id='hookimpl', ctx=Store()), iter=Call(func=Attribute(value=Name(id='hookcaller', ctx=Load()), attr='get_hookimpls', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Attribute(value=Name(id='hookimpl', ctx=Load()), attr='plugin', ctx=Load()), ops=[Is()], comparators=[Name(id='plugin', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='hookcallers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='hookcaller', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='hookcallers', ctx=Load()))], decorator_list=[], returns=BinOp(left=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='HookCaller', ctx=Load()), ctx=Load()), op=BitOr(), right=Constant(value=None))), FunctionDef(name='add_hookcall_monitoring', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='before', annotation=Name(id='_BeforeTrace', ctx=Load())), arg(arg='after', annotation=Name(id='_AfterTrace', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add before/after tracing functions for all hooks.\n\n        Returns an undo function which, when called, removes the added tracers.\n\n        ``before(hook_name, hook_impls, kwargs)`` will be called ahead\n        of all hook calls and receive a hookcaller instance, a list\n        of HookImpl instances and the keyword arguments for the hook call.\n\n        ``after(outcome, hook_name, hook_impls, kwargs)`` receives the\n        same arguments as ``before`` but also a :class:`~pluggy.Result` object\n        which represents the result of the overall hook call.\n        ')), Assign(targets=[Name(id='oldcall', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_inner_hookexec', ctx=Load())), FunctionDef(name='traced_hookexec', args=arguments(posonlyargs=[], args=[arg(arg='hook_name', annotation=Name(id='str', ctx=Load())), arg(arg='hook_impls', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='HookImpl', ctx=Load()), ctx=Load())), arg(arg='caller_kwargs', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='firstresult', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Name(id='before', ctx=Load()), args=[Name(id='hook_name', ctx=Load()), Name(id='hook_impls', ctx=Load()), Name(id='caller_kwargs', ctx=Load())], keywords=[])), Assign(targets=[Name(id='outcome', ctx=Store())], value=Call(func=Attribute(value=Name(id='Result', ctx=Load()), attr='from_call', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='oldcall', ctx=Load()), args=[Name(id='hook_name', ctx=Load()), Name(id='hook_impls', ctx=Load()), Name(id='caller_kwargs', ctx=Load()), Name(id='firstresult', ctx=Load())], keywords=[]))], keywords=[])), Expr(value=Call(func=Name(id='after', ctx=Load()), args=[Name(id='outcome', ctx=Load()), Name(id='hook_name', ctx=Load()), Name(id='hook_impls', ctx=Load()), Name(id='caller_kwargs', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='outcome', ctx=Load()), attr='get_result', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=BinOp(left=Name(id='object', ctx=Load()), op=BitOr(), right=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_inner_hookexec', ctx=Store())], value=Name(id='traced_hookexec', ctx=Load())), FunctionDef(name='undo', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_inner_hookexec', ctx=Store())], value=Name(id='oldcall', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), Return(value=Name(id='undo', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load())), FunctionDef(name='enable_tracing', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Enable tracing of hook calls.\n\n        Returns an undo function which, when called, removes the added tracing.\n        ')), Assign(targets=[Name(id='hooktrace', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='trace', ctx=Load()), attr='root', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='hook')], keywords=[])), FunctionDef(name='before', args=arguments(posonlyargs=[], args=[arg(arg='hook_name', annotation=Name(id='str', ctx=Load())), arg(arg='methods', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='HookImpl', ctx=Load()), ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AugAssign(target=Attribute(value=Attribute(value=Name(id='hooktrace', ctx=Load()), attr='root', ctx=Load()), attr='indent', ctx=Store()), op=Add(), value=Constant(value=1)), Expr(value=Call(func=Name(id='hooktrace', ctx=Load()), args=[Name(id='hook_name', ctx=Load()), Name(id='kwargs', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='after', args=arguments(posonlyargs=[], args=[arg(arg='outcome', annotation=Subscript(value=Name(id='Result', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load())), arg(arg='hook_name', annotation=Name(id='str', ctx=Load())), arg(arg='methods', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='HookImpl', ctx=Load()), ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='outcome', ctx=Load()), attr='exception', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='hooktrace', ctx=Load()), args=[Constant(value='finish'), Name(id='hook_name', ctx=Load()), Constant(value='-->'), Call(func=Attribute(value=Name(id='outcome', ctx=Load()), attr='get_result', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Attribute(value=Name(id='hooktrace', ctx=Load()), attr='root', ctx=Load()), attr='indent', ctx=Store()), op=Sub(), value=Constant(value=1))], decorator_list=[], returns=Constant(value=None)), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add_hookcall_monitoring', ctx=Load()), args=[Name(id='before', ctx=Load()), Name(id='after', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load())), FunctionDef(name='subset_hook_caller', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='remove_plugins', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='_Plugin', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a proxy :class:`~pluggy.HookCaller` instance for the named\n        method which manages calls to all registered plugins except the ones\n        from remove_plugins.')), AnnAssign(target=Name(id='orig', ctx=Store()), annotation=Name(id='HookCaller', ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='hook', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]), simple=1), Assign(targets=[Name(id='plugins_to_remove', ctx=Store())], value=SetComp(elt=Name(id='plug', ctx=Load()), generators=[comprehension(target=Name(id='plug', ctx=Store()), iter=Name(id='remove_plugins', ctx=Load()), ifs=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='plug', ctx=Load()), Name(id='name', ctx=Load())], keywords=[])], is_async=0)])), If(test=Name(id='plugins_to_remove', ctx=Load()), body=[Return(value=Call(func=Name(id='_SubsetHookCaller', ctx=Load()), args=[Name(id='orig', ctx=Load()), Name(id='plugins_to_remove', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='orig', ctx=Load()))], decorator_list=[], returns=Name(id='HookCaller', ctx=Load()))], decorator_list=[]), FunctionDef(name='_formatdef', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='func', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), FormattedValue(value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='signature', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), conversion=-1)]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], type_ignores=[])