Module(body=[Expr(value=Constant(value='\nInternal hook annotation, representation and calling machinery.\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), Import(names=[alias(name='inspect')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='warnings')]), ImportFrom(module='types', names=[alias(name='ModuleType')], level=0), ImportFrom(module='typing', names=[alias(name='AbstractSet')], level=0), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='Final')], level=0), ImportFrom(module='typing', names=[alias(name='final')], level=0), ImportFrom(module='typing', names=[alias(name='Generator')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Mapping')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='overload')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING')], level=0), ImportFrom(module='typing', names=[alias(name='TypedDict')], level=0), ImportFrom(module='typing', names=[alias(name='TypeVar')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), ImportFrom(module='_result', names=[alias(name='Result')], level=1), Assign(targets=[Name(id='_T', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_T')], keywords=[])), Assign(targets=[Name(id='_F', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_F')], keywords=[keyword(arg='bound', value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))])), Assign(targets=[Name(id='_Namespace', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ModuleType', ctx=Load()), Name(id='type', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='_Plugin', ctx=Store())], value=Name(id='object', ctx=Load())), Assign(targets=[Name(id='_HookExec', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Constant(value='HookImpl'), ctx=Load()), Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='object', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='_HookImplFunction', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='_T', ctx=Load()), Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Constant(value=None), Subscript(value=Name(id='Result', ctx=Load()), slice=Name(id='_T', ctx=Load()), ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='HookspecOpts', bases=[Name(id='TypedDict', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Options for a hook specification.')), AnnAssign(target=Name(id='firstresult', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), AnnAssign(target=Name(id='historic', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), AnnAssign(target=Name(id='warn_on_impl', ctx=Store()), annotation=BinOp(left=Name(id='Warning', ctx=Load()), op=BitOr(), right=Constant(value=None)), simple=1)], decorator_list=[]), ClassDef(name='HookimplOpts', bases=[Name(id='TypedDict', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Options for a hook implementation.')), AnnAssign(target=Name(id='wrapper', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), AnnAssign(target=Name(id='hookwrapper', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), AnnAssign(target=Name(id='optionalhook', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), AnnAssign(target=Name(id='tryfirst', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), AnnAssign(target=Name(id='trylast', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), AnnAssign(target=Name(id='specname', ctx=Store()), annotation=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Constant(value=None)), simple=1)], decorator_list=[]), ClassDef(name='HookspecMarker', bases=[], keywords=[], body=[Expr(value=Constant(value='Decorator for marking functions as hook specifications.\n\n    Instantiate it with a project_name to get a decorator.\n    Calling :meth:`PluginManager.add_hookspecs` later will discover all marked\n    functions if the :class:`PluginManager` uses the same project name.\n    ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='project_name')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='project_name', ctx=Load()), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='function', annotation=Name(id='_F', ctx=Load())), arg(arg='firstresult', annotation=Name(id='bool', ctx=Load())), arg(arg='historic', annotation=Name(id='bool', ctx=Load())), arg(arg='warn_on_impl', annotation=BinOp(left=Name(id='Warning', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Name(id='_F', ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='function', annotation=Constant(value=None)), arg(arg='firstresult', annotation=Name(id='bool', ctx=Load())), arg(arg='historic', annotation=Name(id='bool', ctx=Load())), arg(arg='warn_on_impl', annotation=BinOp(left=Name(id='Warning', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='_F', ctx=Load())], ctx=Load()), Name(id='_F', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='function', annotation=BinOp(left=Name(id='_F', ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='firstresult', annotation=Name(id='bool', ctx=Load())), arg(arg='historic', annotation=Name(id='bool', ctx=Load())), arg(arg='warn_on_impl', annotation=BinOp(left=Name(id='Warning', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value="If passed a function, directly sets attributes on the function\n        which will make it discoverable to :meth:`PluginManager.add_hookspecs`.\n\n        If passed no function, returns a decorator which can be applied to a\n        function later using the attributes supplied.\n\n        :param firstresult:\n            If ``True``, the 1:N hook call (N being the number of registered\n            hook implementation functions) will stop at I<=N when the I'th\n            function returns a non-``None`` result. See :ref:`firstresult`.\n\n        :param historic:\n            If ``True``, every call to the hook will be memorized and replayed\n            on plugins registered after the call was made. See :ref:`historic`.\n\n        :param warn_on_impl:\n            If given, every implementation of this hook will trigger the given\n            warning. See :ref:`warn_on_impl`.\n        ")), FunctionDef(name='setattr_hookspec_opts', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Name(id='_F', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[Name(id='historic', ctx=Load()), Name(id='firstresult', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot have a historic firstresult hook')], keywords=[]))], orelse=[]), AnnAssign(target=Name(id='opts', ctx=Store()), annotation=Name(id='HookspecOpts', ctx=Load()), value=Dict(keys=[Constant(value='firstresult'), Constant(value='historic'), Constant(value='warn_on_impl')], values=[Name(id='firstresult', ctx=Load()), Name(id='historic', ctx=Load()), Name(id='warn_on_impl', ctx=Load())]), simple=1), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='func', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), op=Add(), right=Constant(value='_spec')), Name(id='opts', ctx=Load())], keywords=[])), Return(value=Name(id='func', ctx=Load()))], decorator_list=[], returns=Name(id='_F', ctx=Load())), If(test=Compare(left=Name(id='function', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='setattr_hookspec_opts', ctx=Load()), args=[Name(id='function', ctx=Load())], keywords=[]))], orelse=[Return(value=Name(id='setattr_hookspec_opts', ctx=Load()))])], decorator_list=[], returns=BinOp(left=Name(id='_F', ctx=Load()), op=BitOr(), right=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='_F', ctx=Load())], ctx=Load()), Name(id='_F', ctx=Load())], ctx=Load()), ctx=Load())))], decorator_list=[Name(id='final', ctx=Load())]), ClassDef(name='HookimplMarker', bases=[], keywords=[], body=[Expr(value=Constant(value='Decorator for marking functions as hook implementations.\n\n    Instantiate it with a ``project_name`` to get a decorator.\n    Calling :meth:`PluginManager.register` later will discover all marked\n    functions if the :class:`PluginManager` uses the same project name.\n    ')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='project_name')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='project_name', ctx=Load()), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='function', annotation=Name(id='_F', ctx=Load())), arg(arg='hookwrapper', annotation=Name(id='bool', ctx=Load())), arg(arg='optionalhook', annotation=Name(id='bool', ctx=Load())), arg(arg='tryfirst', annotation=Name(id='bool', ctx=Load())), arg(arg='trylast', annotation=Name(id='bool', ctx=Load())), arg(arg='specname', annotation=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='wrapper', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Name(id='_F', ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='function', annotation=Constant(value=None)), arg(arg='hookwrapper', annotation=Name(id='bool', ctx=Load())), arg(arg='optionalhook', annotation=Name(id='bool', ctx=Load())), arg(arg='tryfirst', annotation=Name(id='bool', ctx=Load())), arg(arg='trylast', annotation=Name(id='bool', ctx=Load())), arg(arg='specname', annotation=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='wrapper', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis), Constant(value=Ellipsis)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='overload', ctx=Load())], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='_F', ctx=Load())], ctx=Load()), Name(id='_F', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='function', annotation=BinOp(left=Name(id='_F', ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='hookwrapper', annotation=Name(id='bool', ctx=Load())), arg(arg='optionalhook', annotation=Name(id='bool', ctx=Load())), arg(arg='tryfirst', annotation=Name(id='bool', ctx=Load())), arg(arg='trylast', annotation=Name(id='bool', ctx=Load())), arg(arg='specname', annotation=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='wrapper', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=False), Constant(value=False), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='If passed a function, directly sets attributes on the function\n        which will make it discoverable to :meth:`PluginManager.register`.\n\n        If passed no function, returns a decorator which can be applied to a\n        function later using the attributes supplied.\n\n        :param optionalhook:\n            If ``True``, a missing matching hook specification will not result\n            in an error (by default it is an error if no matching spec is\n            found). See :ref:`optionalhook`.\n\n        :param tryfirst:\n            If ``True``, this hook implementation will run as early as possible\n            in the chain of N hook implementations for a specification. See\n            :ref:`callorder`.\n\n        :param trylast:\n            If ``True``, this hook implementation will run as late as possible\n            in the chain of N hook implementations for a specification. See\n            :ref:`callorder`.\n\n        :param wrapper:\n            If ``True`` ("new-style hook wrapper"), the hook implementation\n            needs to execute exactly one ``yield``. The code before the\n            ``yield`` is run early before any non-hook-wrapper function is run.\n            The code after the ``yield`` is run after all non-hook-wrapper\n            functions have run. The ``yield`` receives the result value of the\n            inner calls, or raises the exception of inner calls (including\n            earlier hook wrapper calls). The return value of the function\n            becomes the return value of the hook, and a raised exception becomes\n            the exception of the hook. See :ref:`hookwrapper`.\n\n        :param hookwrapper:\n            If ``True`` ("old-style hook wrapper"), the hook implementation\n            needs to execute exactly one ``yield``. The code before the\n            ``yield`` is run early before any non-hook-wrapper function is run.\n            The code after the ``yield`` is run after all non-hook-wrapper\n            function have run  The ``yield`` receives a :class:`Result` object\n            representing the exception or result outcome of the inner calls\n            (including earlier hook wrapper calls). This option is mutually\n            exclusive with ``wrapper``. See :ref:`old_style_hookwrapper`.\n\n        :param specname:\n            If provided, the given name will be used instead of the function\n            name when matching this hook implementation to a hook specification\n            during registration. See :ref:`specname`.\n\n        .. versionadded:: 1.2.0\n            The ``wrapper`` parameter.\n        ')), FunctionDef(name='setattr_hookimpl_opts', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Name(id='_F', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='opts', ctx=Store()), annotation=Name(id='HookimplOpts', ctx=Load()), value=Dict(keys=[Constant(value='wrapper'), Constant(value='hookwrapper'), Constant(value='optionalhook'), Constant(value='tryfirst'), Constant(value='trylast'), Constant(value='specname')], values=[Name(id='wrapper', ctx=Load()), Name(id='hookwrapper', ctx=Load()), Name(id='optionalhook', ctx=Load()), Name(id='tryfirst', ctx=Load()), Name(id='trylast', ctx=Load()), Name(id='specname', ctx=Load())]), simple=1), Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='func', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), op=Add(), right=Constant(value='_impl')), Name(id='opts', ctx=Load())], keywords=[])), Return(value=Name(id='func', ctx=Load()))], decorator_list=[], returns=Name(id='_F', ctx=Load())), If(test=Compare(left=Name(id='function', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='setattr_hookimpl_opts', ctx=Load()))], orelse=[Return(value=Call(func=Name(id='setattr_hookimpl_opts', ctx=Load()), args=[Name(id='function', ctx=Load())], keywords=[]))])], decorator_list=[], returns=BinOp(left=Name(id='_F', ctx=Load()), op=BitOr(), right=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='_F', ctx=Load())], ctx=Load()), Name(id='_F', ctx=Load())], ctx=Load()), ctx=Load())))], decorator_list=[Name(id='final', ctx=Load())]), FunctionDef(name='normalize_hookimpl_opts', args=arguments(posonlyargs=[], args=[arg(arg='opts', annotation=Name(id='HookimplOpts', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='opts', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='tryfirst'), Constant(value=False)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='opts', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='trylast'), Constant(value=False)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='opts', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='wrapper'), Constant(value=False)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='opts', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='hookwrapper'), Constant(value=False)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='opts', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='optionalhook'), Constant(value=False)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='opts', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='specname'), Constant(value=None)], keywords=[]))], decorator_list=[], returns=Constant(value=None)), Assign(targets=[Name(id='_PYPY', ctx=Store())], value=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='sys', ctx=Load()), Constant(value='pypy_version_info')], keywords=[])), FunctionDef(name='varnames', args=arguments(posonlyargs=[], args=[arg(arg='func', annotation=Name(id='object', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return tuple of positional and keywrord argument names for a function,\n    method, class or callable.\n\n    In case of a class, its ``__init__`` method is considered.\n    For methods the ``self`` parameter is not included.\n    ')), If(test=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='isclass', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), body=[Try(body=[Assign(targets=[Name(id='func', ctx=Store())], value=Attribute(value=Name(id='func', ctx=Load()), attr='__init__', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Return(value=Tuple(elts=[Tuple(elts=[], ctx=Load()), Tuple(elts=[], ctx=Load())], ctx=Load()))])], orelse=[], finalbody=[])], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='isroutine', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[])), body=[Try(body=[Assign(targets=[Name(id='func', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__call__'), Name(id='func', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Return(value=Tuple(elts=[Tuple(elts=[], ctx=Load()), Tuple(elts=[], ctx=Load())], ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])]), Try(body=[Assign(targets=[Name(id='sig', ctx=Store())], value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='signature', ctx=Load()), args=[IfExp(test=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='ismethod', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), body=Attribute(value=Name(id='func', ctx=Load()), attr='__func__', ctx=Load()), orelse=Name(id='func', ctx=Load()))], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Return(value=Tuple(elts=[Tuple(elts=[], ctx=Load()), Tuple(elts=[], ctx=Load())], ctx=Load()))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='_valid_param_kinds', ctx=Store())], value=Tuple(elts=[Attribute(value=Attribute(value=Name(id='inspect', ctx=Load()), attr='Parameter', ctx=Load()), attr='POSITIONAL_ONLY', ctx=Load()), Attribute(value=Attribute(value=Name(id='inspect', ctx=Load()), attr='Parameter', ctx=Load()), attr='POSITIONAL_OR_KEYWORD', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='_valid_params', ctx=Store())], value=DictComp(key=Name(id='name', ctx=Load()), value=Name(id='param', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='param', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='sig', ctx=Load()), attr='parameters', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Compare(left=Attribute(value=Name(id='param', ctx=Load()), attr='kind', ctx=Load()), ops=[In()], comparators=[Name(id='_valid_param_kinds', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='args', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='_valid_params', ctx=Load())], keywords=[])), Assign(targets=[Name(id='defaults', ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='param', ctx=Load()), attr='default', ctx=Load()), generators=[comprehension(target=Name(id='param', ctx=Store()), iter=Call(func=Attribute(value=Name(id='_valid_params', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), ifs=[Compare(left=Attribute(value=Name(id='param', ctx=Load()), attr='default', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='param', ctx=Load()), attr='empty', ctx=Load())])], is_async=0)])], keywords=[]), Constant(value=None)])), If(test=Name(id='defaults', ctx=Load()), body=[Assign(targets=[Name(id='index', ctx=Store())], value=UnaryOp(op=USub(), operand=Call(func=Name(id='len', ctx=Load()), args=[Name(id='defaults', ctx=Load())], keywords=[]))), Assign(targets=[Tuple(elts=[Name(id='args', ctx=Store()), Name(id='kwargs', ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='args', ctx=Load()), slice=Slice(upper=Name(id='index', ctx=Load())), ctx=Load()), Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Name(id='index', ctx=Load())), ctx=Load())], keywords=[])], ctx=Load()))], orelse=[Assign(targets=[Name(id='kwargs', ctx=Store())], value=Tuple(elts=[], ctx=Load()))]), If(test=UnaryOp(op=Not(), operand=Name(id='_PYPY', ctx=Load())), body=[AnnAssign(target=Name(id='implicit_names', ctx=Store()), annotation=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), value=Tuple(elts=[Constant(value='self')], ctx=Load()), simple=1)], orelse=[Assign(targets=[Name(id='implicit_names', ctx=Store())], value=Tuple(elts=[Constant(value='self'), Constant(value='obj')], ctx=Load()))]), If(test=Name(id='args', ctx=Load()), body=[AnnAssign(target=Name(id='qualname', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__qualname__'), Constant(value='')], keywords=[]), simple=1), If(test=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='ismethod', ctx=Load()), args=[Name(id='func', ctx=Load())], keywords=[]), BoolOp(op=And(), values=[Compare(left=Constant(value='.'), ops=[In()], comparators=[Name(id='qualname', ctx=Load())]), Compare(left=Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[In()], comparators=[Name(id='implicit_names', ctx=Load())])])]), body=[Assign(targets=[Name(id='args', ctx=Store())], value=Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='args', ctx=Load()), Name(id='kwargs', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='HookRelay', bases=[], keywords=[], body=[Expr(value=Constant(value='Hook holder object for performing 1:N hook calls where N is the number\n    of registered plugins.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='__dict__')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=':meta private:'))], decorator_list=[], returns=Constant(value=None)), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[FunctionDef(name='__getattr__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Name(id='HookCaller', ctx=Load()))], orelse=[])], decorator_list=[Name(id='final', ctx=Load())]), Assign(targets=[Name(id='_HookRelay', ctx=Store())], value=Name(id='HookRelay', ctx=Load())), Assign(targets=[Name(id='_CallHistory', ctx=Store())], value=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Any', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), ClassDef(name='HookCaller', bases=[], keywords=[], body=[Expr(value=Constant(value='A caller of all registered implementations of a hook specification.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='name'), Constant(value='spec'), Constant(value='_hookexec'), Constant(value='_hookimpls'), Constant(value='_call_history')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='hook_execute', annotation=Name(id='_HookExec', ctx=Load())), arg(arg='specmodule_or_class', annotation=BinOp(left=Name(id='_Namespace', ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='spec_opts', annotation=BinOp(left=Name(id='HookspecOpts', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=':meta private:')), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='name', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_hookexec', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='hook_execute', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Store()), annotation=Subscript(value=Name(id='Final', ctx=Load()), slice=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='HookImpl', ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_call_history', ctx=Store()), annotation=BinOp(left=Name(id='_CallHistory', ctx=Load()), op=BitOr(), right=Constant(value=None)), value=Constant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Store()), annotation=BinOp(left=Name(id='HookSpec', ctx=Load()), op=BitOr(), right=Constant(value=None)), value=Constant(value=None), simple=0), If(test=Compare(left=Name(id='specmodule_or_class', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assert(test=Compare(left=Name(id='spec_opts', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_specification', ctx=Load()), args=[Name(id='specmodule_or_class', ctx=Load()), Name(id='spec_opts', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='has_spec', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='set_specification', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='specmodule_or_class', annotation=Name(id='_Namespace', ctx=Load())), arg(arg='spec_opts', annotation=Name(id='HookspecOpts', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Hook '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), attr='name', ctx=Load()), conversion=114), Constant(value=' is already registered within namespace '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), attr='namespace', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Store())], value=Call(func=Name(id='HookSpec', ctx=Load()), args=[Name(id='specmodule_or_class', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Name(id='spec_opts', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='spec_opts', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='historic')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_call_history', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='is_historic', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether this caller is :ref:`historic <historic>`.')), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_call_history', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_remove_plugin', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin', annotation=Name(id='_Plugin', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='method', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Attribute(value=Name(id='method', ctx=Load()), attr='plugin', ctx=Load()), ops=[Eq()], comparators=[Name(id='plugin', ctx=Load())]), body=[Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Del())]), Return()], orelse=[])], orelse=[]), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='plugin '), FormattedValue(value=Name(id='plugin', ctx=Load()), conversion=114), Constant(value=' not found')])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_hookimpls', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get all registered hook implementations for this hook.')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='HookImpl', ctx=Load()), ctx=Load())), FunctionDef(name='_add_hookimpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='hookimpl', annotation=Name(id='HookImpl', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add an implementation to the callback chain.')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='method', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='method', ctx=Load()), attr='hookwrapper', ctx=Load()), Attribute(value=Name(id='method', ctx=Load()), attr='wrapper', ctx=Load())]), body=[Assign(targets=[Name(id='splitpoint', ctx=Store())], value=Name(id='i', ctx=Load())), Break()], orelse=[])], orelse=[Assign(targets=[Name(id='splitpoint', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load())], keywords=[]))]), If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='hookimpl', ctx=Load()), attr='hookwrapper', ctx=Load()), Attribute(value=Name(id='hookimpl', ctx=Load()), attr='wrapper', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='splitpoint', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load())], keywords=[])], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Tuple(elts=[Constant(value=0), Name(id='splitpoint', ctx=Load())], ctx=Load()))]), If(test=Attribute(value=Name(id='hookimpl', ctx=Load()), attr='trylast', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load()), attr='insert', ctx=Load()), args=[Name(id='start', ctx=Load()), Name(id='hookimpl', ctx=Load())], keywords=[]))], orelse=[If(test=Attribute(value=Name(id='hookimpl', ctx=Load()), attr='tryfirst', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load()), attr='insert', ctx=Load()), args=[Name(id='end', ctx=Load()), Name(id='hookimpl', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='i', ctx=Store())], value=BinOp(left=Name(id='end', ctx=Load()), op=Sub(), right=Constant(value=1))), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[GtE()], comparators=[Name(id='start', ctx=Load())]), Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), attr='tryfirst', ctx=Load())]), body=[AugAssign(target=Name(id='i', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load()), attr='insert', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), Name(id='hookimpl', ctx=Load())], keywords=[]))])])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<HookCaller '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=114), Constant(value='>')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_verify_all_args_are_provided', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='kwargs', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), body=[For(target=Name(id='argname', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), attr='argnames', ctx=Load()), body=[If(test=Compare(left=Name(id='argname', ctx=Load()), ops=[NotIn()], comparators=[Name(id='kwargs', ctx=Load())]), body=[Assign(targets=[Name(id='notincall', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='repr', ctx=Load()), args=[Name(id='argname', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='argname', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), attr='argnames', ctx=Load()), ifs=[Compare(left=Name(id='argname', ctx=Load()), ops=[NotIn()], comparators=[Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])])], is_async=0)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Argument(s) {} which are declared in the hookspec cannot be found in this hook call'), attr='format', ctx=Load()), args=[Name(id='notincall', ctx=Load())], keywords=[])], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Break()], orelse=[])], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='object', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Call the hook.\n\n        Only accepts keyword arguments, which should match the hook\n        specification.\n\n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        ')), Assert(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_historic', ctx=Load()), args=[], keywords=[])), msg=Constant(value='Cannot directly call a historic hook - use call_historic instead.')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_verify_all_args_are_provided', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[])), Assign(targets=[Name(id='firstresult', ctx=Store())], value=IfExp(test=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), body=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), attr='opts', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='firstresult'), Constant(value=False)], keywords=[]), orelse=Constant(value=False))), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_hookexec', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load()), Name(id='kwargs', ctx=Load()), Name(id='firstresult', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='call_historic', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='result_callback', annotation=BinOp(left=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='Any', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='kwargs', annotation=BinOp(left=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Call the hook with given ``kwargs`` for all registered plugins and\n        for all plugins which will be registered afterwards, see\n        :ref:`historic`.\n\n        :param result_callback:\n            If provided, will be called for each non-``None`` result obtained\n            from a hook implementation.\n        ')), Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_call_history', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='kwargs', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='kwargs', ctx=Load()), Dict(keys=[], values=[])])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_verify_all_args_are_provided', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_call_history', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='kwargs', ctx=Load()), Name(id='result_callback', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_hookexec', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=False)], keywords=[])), If(test=Compare(left=Name(id='result_callback', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return()], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='res', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[For(target=Name(id='x', ctx=Store()), iter=Name(id='res', ctx=Load()), body=[Expr(value=Call(func=Name(id='result_callback', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='call_extra', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='methods', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='kwargs', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Call the hook with some additional temporarily participating\n        methods using the specified ``kwargs`` as call parameters, see\n        :ref:`call_extra`.')), Assert(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_historic', ctx=Load()), args=[], keywords=[])), msg=Constant(value='Cannot directly call a historic hook - use call_historic instead.')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_verify_all_args_are_provided', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[])), AnnAssign(target=Name(id='opts', ctx=Store()), annotation=Name(id='HookimplOpts', ctx=Load()), value=Dict(keys=[Constant(value='wrapper'), Constant(value='hookwrapper'), Constant(value='optionalhook'), Constant(value='trylast'), Constant(value='tryfirst'), Constant(value='specname')], values=[Constant(value=False), Constant(value=False), Constant(value=False), Constant(value=False), Constant(value=False), Constant(value=None)]), simple=1), Assign(targets=[Name(id='hookimpls', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hookimpls', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), For(target=Name(id='method', ctx=Store()), iter=Name(id='methods', ctx=Load()), body=[Assign(targets=[Name(id='hookimpl', ctx=Store())], value=Call(func=Name(id='HookImpl', ctx=Load()), args=[Constant(value=None), Constant(value='<temp>'), Name(id='method', ctx=Load()), Name(id='opts', ctx=Load())], keywords=[])), Assign(targets=[Name(id='i', ctx=Store())], value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='hookimpls', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[GtE()], comparators=[Constant(value=0)]), Attribute(value=Subscript(value=Name(id='hookimpls', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), attr='tryfirst', ctx=Load()), UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Attribute(value=Subscript(value=Name(id='hookimpls', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), attr='hookwrapper', ctx=Load()), Attribute(value=Subscript(value=Name(id='hookimpls', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), attr='wrapper', ctx=Load())]))]), body=[AugAssign(target=Name(id='i', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='hookimpls', ctx=Load()), attr='insert', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), Name(id='hookimpl', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='firstresult', ctx=Store())], value=IfExp(test=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), body=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='spec', ctx=Load()), attr='opts', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='firstresult'), Constant(value=False)], keywords=[]), orelse=Constant(value=False))), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_hookexec', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Name(id='hookimpls', ctx=Load()), Name(id='kwargs', ctx=Load()), Name(id='firstresult', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='_maybe_apply_history', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='method', annotation=Name(id='HookImpl', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Apply call history to a new hookimpl if it is marked as historic.')), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_historic', ctx=Load()), args=[], keywords=[]), body=[Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_call_history', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), For(target=Tuple(elts=[Name(id='kwargs', ctx=Store()), Name(id='result_callback', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_call_history', ctx=Load()), body=[Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_hookexec', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), List(elts=[Name(id='method', ctx=Load())], ctx=Load()), Name(id='kwargs', ctx=Load()), Constant(value=False)], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='res', ctx=Load()), Compare(left=Name(id='result_callback', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Assert(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='res', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='result_callback', ctx=Load()), args=[Subscript(value=Name(id='res', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), Assign(targets=[Name(id='_HookCaller', ctx=Store())], value=Name(id='HookCaller', ctx=Load())), ClassDef(name='_SubsetHookCaller', bases=[Name(id='HookCaller', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A proxy to another HookCaller which manages calls to all registered\n    plugins except the ones from remove_plugins.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='_orig'), Constant(value='_remove_plugins')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='orig', annotation=Name(id='HookCaller', ctx=Load())), arg(arg='remove_plugins', annotation=Subscript(value=Name(id='AbstractSet', ctx=Load()), slice=Name(id='_Plugin', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_orig', ctx=Store())], value=Name(id='orig', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_remove_plugins', ctx=Store())], value=Name(id='remove_plugins', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Attribute(value=Name(id='orig', ctx=Load()), attr='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_hookexec', ctx=Store())], value=Attribute(value=Name(id='orig', ctx=Load()), attr='_hookexec', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_hookimpls', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=ListComp(elt=Name(id='impl', ctx=Load()), generators=[comprehension(target=Name(id='impl', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_orig', ctx=Load()), attr='_hookimpls', ctx=Load()), ifs=[Compare(left=Attribute(value=Name(id='impl', ctx=Load()), attr='plugin', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_remove_plugins', ctx=Load())])], is_async=0)]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='HookImpl', ctx=Load()), ctx=Load())), FunctionDef(name='spec', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_orig', ctx=Load()), attr='spec', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=BinOp(left=Name(id='HookSpec', ctx=Load()), op=BitOr(), right=Constant(value=None))), FunctionDef(name='_call_history', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_orig', ctx=Load()), attr='_call_history', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=BinOp(left=Name(id='_CallHistory', ctx=Load()), op=BitOr(), right=Constant(value=None))), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<_SubsetHookCaller '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=114), Constant(value='>')]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='HookImpl', bases=[], keywords=[], body=[Expr(value=Constant(value='A hook implementation in a :class:`HookCaller`.')), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='function'), Constant(value='argnames'), Constant(value='kwargnames'), Constant(value='plugin'), Constant(value='opts'), Constant(value='plugin_name'), Constant(value='wrapper'), Constant(value='hookwrapper'), Constant(value='optionalhook'), Constant(value='tryfirst'), Constant(value='trylast')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='plugin', annotation=Name(id='_Plugin', ctx=Load())), arg(arg='plugin_name', annotation=Name(id='str', ctx=Load())), arg(arg='function', annotation=Subscript(value=Name(id='_HookImplFunction', ctx=Load()), slice=Name(id='object', ctx=Load()), ctx=Load())), arg(arg='hook_impl_opts', annotation=Name(id='HookimplOpts', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=':meta private:')), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='function', ctx=Load()), simple=0), Assign(targets=[Tuple(elts=[Name(id='argnames', ctx=Store()), Name(id='kwargnames', ctx=Store())], ctx=Store())], value=Call(func=Name(id='varnames', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Load())], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='argnames', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='argnames', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='kwargnames', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='kwargnames', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='plugin', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='plugin', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='opts', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='hook_impl_opts', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='plugin_name', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Name(id='plugin_name', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='wrapper', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Subscript(value=Name(id='hook_impl_opts', ctx=Load()), slice=Constant(value='wrapper'), ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='hookwrapper', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Subscript(value=Name(id='hook_impl_opts', ctx=Load()), slice=Constant(value='hookwrapper'), ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='optionalhook', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Subscript(value=Name(id='hook_impl_opts', ctx=Load()), slice=Constant(value='optionalhook'), ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='tryfirst', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Subscript(value=Name(id='hook_impl_opts', ctx=Load()), slice=Constant(value='tryfirst'), ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='trylast', ctx=Store()), annotation=Name(id='Final', ctx=Load()), value=Subscript(value=Name(id='hook_impl_opts', ctx=Load()), slice=Constant(value='trylast'), ctx=Load()), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<HookImpl plugin_name='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='plugin_name', ctx=Load()), conversion=114), Constant(value=', plugin='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='plugin', ctx=Load()), conversion=114), Constant(value='>')]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[Name(id='final', ctx=Load())]), ClassDef(name='HookSpec', bases=[], keywords=[], body=[Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='namespace'), Constant(value='function'), Constant(value='name'), Constant(value='argnames'), Constant(value='kwargnames'), Constant(value='opts'), Constant(value='warn_on_impl')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='namespace', annotation=Name(id='_Namespace', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='opts', annotation=Name(id='HookspecOpts', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='namespace', ctx=Store())], value=Name(id='namespace', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Store()), annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Name(id='object', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='namespace', ctx=Load()), Name(id='name', ctx=Load())], keywords=[]), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='argnames', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='kwargnames', ctx=Store())], ctx=Store())], value=Call(func=Name(id='varnames', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='function', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='opts', ctx=Store())], value=Name(id='opts', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='warn_on_impl', ctx=Store())], value=Call(func=Attribute(value=Name(id='opts', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='warn_on_impl')], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[Name(id='final', ctx=Load())])], type_ignores=[])