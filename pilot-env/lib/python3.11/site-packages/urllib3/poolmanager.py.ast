Module(body=[ImportFrom(module='__future__', names=[alias(name='absolute_import')], level=0), Import(names=[alias(name='collections')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='logging')]), ImportFrom(module='_collections', names=[alias(name='RecentlyUsedContainer')], level=1), ImportFrom(module='connectionpool', names=[alias(name='HTTPConnectionPool'), alias(name='HTTPSConnectionPool'), alias(name='port_by_scheme')], level=1), ImportFrom(module='exceptions', names=[alias(name='LocationValueError'), alias(name='MaxRetryError'), alias(name='ProxySchemeUnknown'), alias(name='ProxySchemeUnsupported'), alias(name='URLSchemeUnknown')], level=1), ImportFrom(module='packages', names=[alias(name='six')], level=1), ImportFrom(module='packages.six.moves.urllib.parse', names=[alias(name='urljoin')], level=1), ImportFrom(module='request', names=[alias(name='RequestMethods')], level=1), ImportFrom(module='util.proxy', names=[alias(name='connection_requires_http_tunnel')], level=1), ImportFrom(module='util.retry', names=[alias(name='Retry')], level=1), ImportFrom(module='util.url', names=[alias(name='parse_url')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='PoolManager'), Constant(value='ProxyManager'), Constant(value='proxy_from_url')], ctx=Load())), Assign(targets=[Name(id='log', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='SSL_KEYWORDS', ctx=Store())], value=Tuple(elts=[Constant(value='key_file'), Constant(value='cert_file'), Constant(value='cert_reqs'), Constant(value='ca_certs'), Constant(value='ssl_version'), Constant(value='ca_cert_dir'), Constant(value='ssl_context'), Constant(value='key_password')], ctx=Load())), Assign(targets=[Name(id='_key_fields', ctx=Store())], value=Tuple(elts=[Constant(value='key_scheme'), Constant(value='key_host'), Constant(value='key_port'), Constant(value='key_timeout'), Constant(value='key_retries'), Constant(value='key_strict'), Constant(value='key_block'), Constant(value='key_source_address'), Constant(value='key_key_file'), Constant(value='key_key_password'), Constant(value='key_cert_file'), Constant(value='key_cert_reqs'), Constant(value='key_ca_certs'), Constant(value='key_ssl_version'), Constant(value='key_ca_cert_dir'), Constant(value='key_ssl_context'), Constant(value='key_maxsize'), Constant(value='key_headers'), Constant(value='key__proxy'), Constant(value='key__proxy_headers'), Constant(value='key__proxy_config'), Constant(value='key_socket_options'), Constant(value='key__socks_options'), Constant(value='key_assert_hostname'), Constant(value='key_assert_fingerprint'), Constant(value='key_server_hostname')], ctx=Load())), Assign(targets=[Name(id='PoolKey', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='namedtuple', ctx=Load()), args=[Constant(value='PoolKey'), Name(id='_key_fields', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_proxy_config_fields', ctx=Store())], value=Tuple(elts=[Constant(value='ssl_context'), Constant(value='use_forwarding_for_https')], ctx=Load())), Assign(targets=[Name(id='ProxyConfig', ctx=Store())], value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='namedtuple', ctx=Load()), args=[Constant(value='ProxyConfig'), Name(id='_proxy_config_fields', ctx=Load())], keywords=[])), FunctionDef(name='_default_key_normalizer', args=arguments(posonlyargs=[], args=[arg(arg='key_class'), arg(arg='request_context')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Create a pool key out of a request context dictionary.\n\n    According to RFC 3986, both the scheme and host are case-insensitive.\n    Therefore, this function normalizes both before constructing the pool\n    key for an HTTPS request. If you wish to change this behaviour, provide\n    alternate callables to ``key_fn_by_scheme``.\n\n    :param key_class:\n        The class to use when constructing the key. This should be a namedtuple\n        with the ``scheme`` and ``host`` keys at a minimum.\n    :type  key_class: namedtuple\n    :param request_context:\n        A dictionary-like object that contain the context for a request.\n    :type  request_context: dict\n\n    :return: A namedtuple that can be used as a connection pool key.\n    :rtype:  PoolKey\n    ')), Assign(targets=[Name(id='context', ctx=Store())], value=Call(func=Attribute(value=Name(id='request_context', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='context', ctx=Load()), slice=Constant(value='scheme'), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='context', ctx=Load()), slice=Constant(value='scheme'), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='context', ctx=Load()), slice=Constant(value='host'), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='context', ctx=Load()), slice=Constant(value='host'), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), For(target=Name(id='key', ctx=Store()), iter=Tuple(elts=[Constant(value='headers'), Constant(value='_proxy_headers'), Constant(value='_socks_options')], ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='key', ctx=Load()), ops=[In()], comparators=[Name(id='context', ctx=Load())]), Compare(left=Subscript(value=Name(id='context', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Subscript(value=Name(id='context', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Name(id='context', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='socket_opts', ctx=Store())], value=Call(func=Attribute(value=Name(id='context', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='socket_options')], keywords=[])), If(test=Compare(left=Name(id='socket_opts', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='context', ctx=Load()), slice=Constant(value='socket_options'), ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='socket_opts', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='key', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='context', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='context', ctx=Load()), slice=BinOp(left=Constant(value='key_'), op=Add(), right=Name(id='key', ctx=Load())), ctx=Store())], value=Call(func=Attribute(value=Name(id='context', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='field', ctx=Store()), iter=Attribute(value=Name(id='key_class', ctx=Load()), attr='_fields', ctx=Load()), body=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[NotIn()], comparators=[Name(id='context', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='context', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Store())], value=Constant(value=None))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='key_class', ctx=Load()), args=[], keywords=[keyword(value=Name(id='context', ctx=Load()))]))], decorator_list=[]), Assign(targets=[Name(id='key_fn_by_scheme', ctx=Store())], value=Dict(keys=[Constant(value='http'), Constant(value='https')], values=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Name(id='_default_key_normalizer', ctx=Load()), Name(id='PoolKey', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Name(id='_default_key_normalizer', ctx=Load()), Name(id='PoolKey', ctx=Load())], keywords=[])])), Assign(targets=[Name(id='pool_classes_by_scheme', ctx=Store())], value=Dict(keys=[Constant(value='http'), Constant(value='https')], values=[Name(id='HTTPConnectionPool', ctx=Load()), Name(id='HTTPSConnectionPool', ctx=Load())])), ClassDef(name='PoolManager', bases=[Name(id='RequestMethods', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n\n    :param \\**connection_pool_kw:\n        Additional parameters are used to create fresh\n        :class:`urllib3.connectionpool.ConnectionPool` instances.\n\n    Example::\n\n        >>> manager = PoolManager(num_pools=2)\n        >>> r = manager.request('GET', 'http://google.com/')\n        >>> r = manager.request('GET', 'http://google.com/mail')\n        >>> r = manager.request('GET', 'http://yahoo.com/')\n        >>> len(manager.pools)\n        2\n\n    ")), Assign(targets=[Name(id='proxy', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='proxy_config', ctx=Store())], value=Constant(value=None)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='num_pools'), arg(arg='headers')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='connection_pool_kw'), defaults=[Constant(value=10), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='RequestMethods', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='headers', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='connection_pool_kw', ctx=Store())], value=Name(id='connection_pool_kw', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pools', ctx=Store())], value=Call(func=Name(id='RecentlyUsedContainer', ctx=Load()), args=[Name(id='num_pools', ctx=Load())], keywords=[keyword(arg='dispose_func', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='p')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='p', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[])))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pool_classes_by_scheme', ctx=Store())], value=Name(id='pool_classes_by_scheme', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='key_fn_by_scheme', ctx=Store())], value=Call(func=Attribute(value=Name(id='key_fn_by_scheme', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exc_type'), arg(arg='exc_val'), arg(arg='exc_tb')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='_new_pool', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='scheme'), arg(arg='host'), arg(arg='port'), arg(arg='request_context')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and\n        any additional pool keyword arguments.\n\n        If ``request_context`` is provided, it is provided as keyword arguments\n        to the pool class used. This method is used to actually create the\n        connection pools handed out by :meth:`connection_from_url` and\n        companion methods. It is intended to be overridden for customization.\n        ')), Assign(targets=[Name(id='pool_cls', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='pool_classes_by_scheme', ctx=Load()), slice=Name(id='scheme', ctx=Load()), ctx=Load())), If(test=Compare(left=Name(id='request_context', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='request_context', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='connection_pool_kw', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))], orelse=[]), For(target=Name(id='key', ctx=Store()), iter=Tuple(elts=[Constant(value='scheme'), Constant(value='host'), Constant(value='port')], ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='request_context', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='key', ctx=Load()), Constant(value=None)], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='scheme', ctx=Load()), ops=[Eq()], comparators=[Constant(value='http')]), body=[For(target=Name(id='kw', ctx=Store()), iter=Name(id='SSL_KEYWORDS', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='request_context', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='kw', ctx=Load()), Constant(value=None)], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='pool_cls', ctx=Load()), args=[Name(id='host', ctx=Load()), Name(id='port', ctx=Load())], keywords=[keyword(value=Name(id='request_context', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='clear', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Empty our store of pools and direct them all to close.\n\n        This will not affect in-flight connections, but they will not be\n        re-used after completion.\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pools', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='connection_from_host', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='host'), arg(arg='port'), arg(arg='scheme'), arg(arg='pool_kwargs')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value='http'), Constant(value=None)]), body=[Expr(value=Constant(value="\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.\n\n        If ``port`` isn't given, it will be derived from the ``scheme`` using\n        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is\n        provided, it is merged with the instance's ``connection_pool_kw``\n        variable and used to create the new connection pool, if one is\n        needed.\n        ")), If(test=UnaryOp(op=Not(), operand=Name(id='host', ctx=Load())), body=[Raise(exc=Call(func=Name(id='LocationValueError', ctx=Load()), args=[Constant(value='No host specified.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='request_context', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_merge_pool_kwargs', ctx=Load()), args=[Name(id='pool_kwargs', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='request_context', ctx=Load()), slice=Constant(value='scheme'), ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='scheme', ctx=Load()), Constant(value='http')])), If(test=UnaryOp(op=Not(), operand=Name(id='port', ctx=Load())), body=[Assign(targets=[Name(id='port', ctx=Store())], value=Call(func=Attribute(value=Name(id='port_by_scheme', ctx=Load()), attr='get', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Name(id='request_context', ctx=Load()), slice=Constant(value='scheme'), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), Constant(value=80)], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='request_context', ctx=Load()), slice=Constant(value='port'), ctx=Store())], value=Name(id='port', ctx=Load())), Assign(targets=[Subscript(value=Name(id='request_context', ctx=Load()), slice=Constant(value='host'), ctx=Store())], value=Name(id='host', ctx=Load())), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='connection_from_context', ctx=Load()), args=[Name(id='request_context', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='connection_from_context', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='request_context')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.\n\n        ``request_context`` must at least contain the ``scheme`` key and its\n        value must be a key in ``key_fn_by_scheme`` instance variable.\n        ')), Assign(targets=[Name(id='scheme', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='request_context', ctx=Load()), slice=Constant(value='scheme'), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='pool_key_constructor', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='key_fn_by_scheme', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='scheme', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='pool_key_constructor', ctx=Load())), body=[Raise(exc=Call(func=Name(id='URLSchemeUnknown', ctx=Load()), args=[Name(id='scheme', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='pool_key', ctx=Store())], value=Call(func=Name(id='pool_key_constructor', ctx=Load()), args=[Name(id='request_context', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='connection_from_pool_key', ctx=Load()), args=[Name(id='pool_key', ctx=Load())], keywords=[keyword(arg='request_context', value=Name(id='request_context', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='connection_from_pool_key', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pool_key'), arg(arg='request_context')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.\n\n        ``pool_key`` should be a namedtuple that only contains immutable\n        objects. At a minimum it must have the ``scheme``, ``host``, and\n        ``port`` fields.\n        ')), With(items=[withitem(context_expr=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pools', ctx=Load()), attr='lock', ctx=Load()))], body=[Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pools', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='pool_key', ctx=Load())], keywords=[])), If(test=Name(id='pool', ctx=Load()), body=[Return(value=Name(id='pool', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='scheme', ctx=Store())], value=Subscript(value=Name(id='request_context', ctx=Load()), slice=Constant(value='scheme'), ctx=Load())), Assign(targets=[Name(id='host', ctx=Store())], value=Subscript(value=Name(id='request_context', ctx=Load()), slice=Constant(value='host'), ctx=Load())), Assign(targets=[Name(id='port', ctx=Store())], value=Subscript(value=Name(id='request_context', ctx=Load()), slice=Constant(value='port'), ctx=Load())), Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_new_pool', ctx=Load()), args=[Name(id='scheme', ctx=Load()), Name(id='host', ctx=Load()), Name(id='port', ctx=Load())], keywords=[keyword(arg='request_context', value=Name(id='request_context', ctx=Load()))])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='pools', ctx=Load()), slice=Name(id='pool_key', ctx=Load()), ctx=Store())], value=Name(id='pool', ctx=Load()))]), Return(value=Name(id='pool', ctx=Load()))], decorator_list=[]), FunctionDef(name='connection_from_url', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='url'), arg(arg='pool_kwargs')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Similar to :func:`urllib3.connectionpool.connection_from_url`.\n\n        If ``pool_kwargs`` is not provided and a new pool needs to be\n        constructed, ``self.connection_pool_kw`` is used to initialize\n        the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``\n        is provided, it is used instead. Note that if a new pool does not\n        need to be created for the request, the provided ``pool_kwargs`` are\n        not used.\n        ')), Assign(targets=[Name(id='u', ctx=Store())], value=Call(func=Name(id='parse_url', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='connection_from_host', ctx=Load()), args=[Attribute(value=Name(id='u', ctx=Load()), attr='host', ctx=Load())], keywords=[keyword(arg='port', value=Attribute(value=Name(id='u', ctx=Load()), attr='port', ctx=Load())), keyword(arg='scheme', value=Attribute(value=Name(id='u', ctx=Load()), attr='scheme', ctx=Load())), keyword(arg='pool_kwargs', value=Name(id='pool_kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_merge_pool_kwargs', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='override')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Merge a dictionary of override values for self.connection_pool_kw.\n\n        This does not modify self.connection_pool_kw and returns a new dict.\n        Any keys in the override dictionary with a value of ``None`` are\n        removed from the merged dictionary.\n        ')), Assign(targets=[Name(id='base_pool_kwargs', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='connection_pool_kw', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), If(test=Name(id='override', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='override', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Try(body=[Delete(targets=[Subscript(value=Name(id='base_pool_kwargs', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Del())])], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[Assign(targets=[Subscript(value=Name(id='base_pool_kwargs', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load()))])], orelse=[])], orelse=[]), Return(value=Name(id='base_pool_kwargs', ctx=Load()))], decorator_list=[]), FunctionDef(name='_proxy_requires_url_absolute_form', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parsed_url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Indicates if the proxy requires the complete destination URL in the\n        request.  Normally this is only needed when not using an HTTP CONNECT\n        tunnel.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=UnaryOp(op=Not(), operand=Call(func=Name(id='connection_requires_http_tunnel', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='proxy_config', ctx=Load()), Attribute(value=Name(id='parsed_url', ctx=Load()), attr='scheme', ctx=Load())], keywords=[])))], decorator_list=[]), FunctionDef(name='_validate_proxy_scheme_url_selection', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='url_scheme')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Validates that were not attempting to do TLS in TLS connections on\n        Python2 or with unsupported SSL implementations.\n        ')), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='url_scheme', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='https')])]), body=[Return()], orelse=[]), If(test=Compare(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), attr='scheme', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='https')]), body=[Return()], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='six', ctx=Load()), attr='PY2', ctx=Load()), UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy_config', ctx=Load()), attr='use_forwarding_for_https', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ProxySchemeUnsupported', ctx=Load()), args=[Constant(value="Contacting HTTPS destinations through HTTPS proxies 'via CONNECT tunnels' is not supported in Python 2")], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='urlopen', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='method'), arg(arg='url'), arg(arg='redirect')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n        Same as :meth:`urllib3.HTTPConnectionPool.urlopen`\n        with custom cross-host redirect logic and only sends the request-uri\n        portion of the ``url``.\n\n        The given ``url`` parameter must be absolute, such that an appropriate\n        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n        ')), Assign(targets=[Name(id='u', ctx=Store())], value=Call(func=Name(id='parse_url', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_proxy_scheme_url_selection', ctx=Load()), args=[Attribute(value=Name(id='u', ctx=Load()), attr='scheme', ctx=Load())], keywords=[])), Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='connection_from_host', ctx=Load()), args=[Attribute(value=Name(id='u', ctx=Load()), attr='host', ctx=Load())], keywords=[keyword(arg='port', value=Attribute(value=Name(id='u', ctx=Load()), attr='port', ctx=Load())), keyword(arg='scheme', value=Attribute(value=Name(id='u', ctx=Load()), attr='scheme', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='assert_same_host'), ctx=Store())], value=Constant(value=False)), Assign(targets=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='redirect'), ctx=Store())], value=Constant(value=False)), If(test=Compare(left=Constant(value='headers'), ops=[NotIn()], comparators=[Name(id='kw', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='headers'), ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_proxy_requires_url_absolute_form', ctx=Load()), args=[Name(id='u', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='urlopen', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='url', ctx=Load())], keywords=[keyword(value=Name(id='kw', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='urlopen', ctx=Load()), args=[Name(id='method', ctx=Load()), Attribute(value=Name(id='u', ctx=Load()), attr='request_uri', ctx=Load())], keywords=[keyword(value=Name(id='kw', ctx=Load()))]))]), Assign(targets=[Name(id='redirect_location', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='redirect', ctx=Load()), Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='get_redirect_location', ctx=Load()), args=[], keywords=[])])), If(test=UnaryOp(op=Not(), operand=Name(id='redirect_location', ctx=Load())), body=[Return(value=Name(id='response', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='redirect_location', ctx=Store())], value=Call(func=Name(id='urljoin', ctx=Load()), args=[Name(id='url', ctx=Load()), Name(id='redirect_location', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='response', ctx=Load()), attr='status', ctx=Load()), ops=[Eq()], comparators=[Constant(value=303)]), body=[Assign(targets=[Name(id='method', ctx=Store())], value=Constant(value='GET'))], orelse=[]), Assign(targets=[Name(id='retries', ctx=Store())], value=Call(func=Attribute(value=Name(id='kw', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='retries')], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='retries', ctx=Load()), Name(id='Retry', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='retries', ctx=Store())], value=Call(func=Attribute(value=Name(id='Retry', ctx=Load()), attr='from_int', ctx=Load()), args=[Name(id='retries', ctx=Load())], keywords=[keyword(arg='redirect', value=Name(id='redirect', ctx=Load()))]))], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='retries', ctx=Load()), attr='remove_headers_on_redirect', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='is_same_host', ctx=Load()), args=[Name(id='redirect_location', ctx=Load())], keywords=[]))]), body=[Assign(targets=[Name(id='headers', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='six', ctx=Load()), attr='iterkeys', ctx=Load()), args=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='headers'), ctx=Load())], keywords=[])], keywords=[])), For(target=Name(id='header', ctx=Store()), iter=Name(id='headers', ctx=Load()), body=[If(test=Compare(left=Call(func=Attribute(value=Name(id='header', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[Attribute(value=Name(id='retries', ctx=Load()), attr='remove_headers_on_redirect', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='headers'), ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='header', ctx=Load()), Constant(value=None)], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Try(body=[Assign(targets=[Name(id='retries', ctx=Store())], value=Call(func=Attribute(value=Name(id='retries', ctx=Load()), attr='increment', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='url', ctx=Load())], keywords=[keyword(arg='response', value=Name(id='response', ctx=Load())), keyword(arg='_pool', value=Name(id='conn', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='MaxRetryError', ctx=Load()), body=[If(test=Attribute(value=Name(id='retries', ctx=Load()), attr='raise_on_redirect', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='drain_conn', ctx=Load()), args=[], keywords=[])), Raise()], orelse=[]), Return(value=Name(id='response', ctx=Load()))])], orelse=[], finalbody=[]), Assign(targets=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='retries'), ctx=Store())], value=Name(id='retries', ctx=Load())), Assign(targets=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='redirect'), ctx=Store())], value=Name(id='redirect', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='info', ctx=Load()), args=[Constant(value='Redirecting %s -> %s'), Name(id='url', ctx=Load()), Name(id='redirect_location', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='drain_conn', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='urlopen', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='redirect_location', ctx=Load())], keywords=[keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='ProxyManager', bases=[Name(id='PoolManager', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Behaves just like :class:`PoolManager`, but sends all requests through\n    the defined proxy, using the CONNECT method for HTTPS URLs.\n\n    :param proxy_url:\n        The URL of the proxy to be used.\n\n    :param proxy_headers:\n        A dictionary containing headers that will be sent to the proxy. In case\n        of HTTP they are being sent with each request, while in the\n        HTTPS/CONNECT case they are sent only once. Could be used for proxy\n        authentication.\n\n    :param proxy_ssl_context:\n        The proxy SSL context is used to establish the TLS connection to the\n        proxy when using HTTPS proxies.\n\n    :param use_forwarding_for_https:\n        (Defaults to False) If set to True will forward requests to the HTTPS\n        proxy to be made on behalf of the client instead of creating a TLS\n        tunnel via the CONNECT method. **Enabling this flag means that request\n        and response headers and content will be visible from the HTTPS proxy**\n        whereas tunneling keeps request and response headers and content\n        private.  IP address, target hostname, SNI, and port are always visible\n        to an HTTPS proxy even when this flag is disabled.\n\n    Example:\n        >>> proxy = urllib3.ProxyManager('http://localhost:3128/')\n        >>> r1 = proxy.request('GET', 'http://google.com/')\n        >>> r2 = proxy.request('GET', 'http://httpbin.org/')\n        >>> len(proxy.pools)\n        1\n        >>> r3 = proxy.request('GET', 'https://httpbin.org/')\n        >>> r4 = proxy.request('GET', 'https://twitter.com/')\n        >>> len(proxy.pools)\n        3\n\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='proxy_url'), arg(arg='num_pools'), arg(arg='headers'), arg(arg='proxy_headers'), arg(arg='proxy_ssl_context'), arg(arg='use_forwarding_for_https')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='connection_pool_kw'), defaults=[Constant(value=10), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='proxy_url', ctx=Load()), Name(id='HTTPConnectionPool', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='proxy_url', ctx=Store())], value=BinOp(left=Constant(value='%s://%s:%i'), op=Mod(), right=Tuple(elts=[Attribute(value=Name(id='proxy_url', ctx=Load()), attr='scheme', ctx=Load()), Attribute(value=Name(id='proxy_url', ctx=Load()), attr='host', ctx=Load()), Attribute(value=Name(id='proxy_url', ctx=Load()), attr='port', ctx=Load())], ctx=Load())))], orelse=[]), Assign(targets=[Name(id='proxy', ctx=Store())], value=Call(func=Name(id='parse_url', ctx=Load()), args=[Name(id='proxy_url', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='proxy', ctx=Load()), attr='scheme', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value='http'), Constant(value='https')], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ProxySchemeUnknown', ctx=Load()), args=[Attribute(value=Name(id='proxy', ctx=Load()), attr='scheme', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='proxy', ctx=Load()), attr='port', ctx=Load())), body=[Assign(targets=[Name(id='port', ctx=Store())], value=Call(func=Attribute(value=Name(id='port_by_scheme', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='proxy', ctx=Load()), attr='scheme', ctx=Load()), Constant(value=80)], keywords=[])), Assign(targets=[Name(id='proxy', ctx=Store())], value=Call(func=Attribute(value=Name(id='proxy', ctx=Load()), attr='_replace', ctx=Load()), args=[], keywords=[keyword(arg='port', value=Name(id='port', ctx=Load()))]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Store())], value=Name(id='proxy', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy_headers', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='proxy_headers', ctx=Load()), Dict(keys=[], values=[])])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy_ssl_context', ctx=Store())], value=Name(id='proxy_ssl_context', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy_config', ctx=Store())], value=Call(func=Name(id='ProxyConfig', ctx=Load()), args=[Name(id='proxy_ssl_context', ctx=Load()), Name(id='use_forwarding_for_https', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='connection_pool_kw', ctx=Load()), slice=Constant(value='_proxy'), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load())), Assign(targets=[Subscript(value=Name(id='connection_pool_kw', ctx=Load()), slice=Constant(value='_proxy_headers'), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy_headers', ctx=Load())), Assign(targets=[Subscript(value=Name(id='connection_pool_kw', ctx=Load()), slice=Constant(value='_proxy_config'), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy_config', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='ProxyManager', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='num_pools', ctx=Load()), Name(id='headers', ctx=Load())], keywords=[keyword(value=Name(id='connection_pool_kw', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='connection_from_host', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='host'), arg(arg='port'), arg(arg='scheme'), arg(arg='pool_kwargs')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value='http'), Constant(value=None)]), body=[If(test=Compare(left=Name(id='scheme', ctx=Load()), ops=[Eq()], comparators=[Constant(value='https')]), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='ProxyManager', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='connection_from_host', ctx=Load()), args=[Name(id='host', ctx=Load()), Name(id='port', ctx=Load()), Name(id='scheme', ctx=Load())], keywords=[keyword(arg='pool_kwargs', value=Name(id='pool_kwargs', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='ProxyManager', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='connection_from_host', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), attr='host', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), attr='port', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), attr='scheme', ctx=Load())], keywords=[keyword(arg='pool_kwargs', value=Name(id='pool_kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_set_proxy_headers', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='url'), arg(arg='headers')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Sets headers needed by proxies: specifically, the Accept and Host\n        headers. Only sets headers not provided by the user.\n        ')), Assign(targets=[Name(id='headers_', ctx=Store())], value=Dict(keys=[Constant(value='Accept')], values=[Constant(value='*/*')])), Assign(targets=[Name(id='netloc', ctx=Store())], value=Attribute(value=Call(func=Name(id='parse_url', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[]), attr='netloc', ctx=Load())), If(test=Name(id='netloc', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='headers_', ctx=Load()), slice=Constant(value='Host'), ctx=Store())], value=Name(id='netloc', ctx=Load()))], orelse=[]), If(test=Name(id='headers', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='headers_', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='headers', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='headers_', ctx=Load()))], decorator_list=[]), FunctionDef(name='urlopen', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='method'), arg(arg='url'), arg(arg='redirect')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.')), Assign(targets=[Name(id='u', ctx=Store())], value=Call(func=Name(id='parse_url', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='connection_requires_http_tunnel', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='proxy_config', ctx=Load()), Attribute(value=Name(id='u', ctx=Load()), attr='scheme', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='headers', ctx=Store())], value=Call(func=Attribute(value=Name(id='kw', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='headers'), Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='kw', ctx=Load()), slice=Constant(value='headers'), ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_set_proxy_headers', ctx=Load()), args=[Name(id='url', ctx=Load()), Name(id='headers', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='ProxyManager', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='urlopen', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='url', ctx=Load())], keywords=[keyword(arg='redirect', value=Name(id='redirect', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='proxy_from_url', args=arguments(posonlyargs=[], args=[arg(arg='url')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Return(value=Call(func=Name(id='ProxyManager', ctx=Load()), args=[], keywords=[keyword(arg='proxy_url', value=Name(id='url', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))]))], decorator_list=[])], type_ignores=[])