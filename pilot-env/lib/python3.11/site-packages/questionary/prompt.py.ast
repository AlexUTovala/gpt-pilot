Module(body=[ImportFrom(module='prompt_toolkit.output', names=[alias(name='ColorDepth')], level=0), ImportFrom(module='typing', names=[alias(name='Any'), alias(name='Dict'), alias(name='Optional'), alias(name='Iterable'), alias(name='Mapping')], level=0), ImportFrom(module='questionary', names=[alias(name='utils')], level=0), ImportFrom(module='questionary.constants', names=[alias(name='DEFAULT_KBI_MESSAGE')], level=0), ImportFrom(module='questionary.prompts', names=[alias(name='AVAILABLE_PROMPTS'), alias(name='prompt_by_name')], level=0), ClassDef(name='PromptParameterException', bases=[Name(id='ValueError', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='message', annotation=Name(id='str', ctx=Load())), arg(arg='errors', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='BaseException', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[BinOp(left=Constant(value='You must provide a `%s` value'), op=Mod(), right=Name(id='message', ctx=Load())), Name(id='errors', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), FunctionDef(name='prompt', args=arguments(posonlyargs=[], args=[arg(arg='questions', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='answers', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='patch_stdout', annotation=Name(id='bool', ctx=Load())), arg(arg='true_color', annotation=Name(id='bool', ctx=Load())), arg(arg='kbi_msg', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[Constant(value=None), Constant(value=False), Constant(value=False), Name(id='DEFAULT_KBI_MESSAGE', ctx=Load())]), body=[Expr(value=Constant(value='Prompt the user for input on all the questions.\n\n    Catches keyboard interrupts and prints a message.\n\n    See :func:`unsafe_prompt` for possible question configurations.\n\n    Args:\n        questions: A list of question configs representing questions to\n                   ask. A question config may have the following options:\n\n                   * type - The type of question.\n                   * name - An ID for the question (to identify it in the answers :obj:`dict`).\n\n                   * when - Callable to conditionally show the question. This function\n                     takes a :obj:`dict` representing the current answers.\n\n                   * filter - Function that the answer is passed to. The return value of this\n                     function is saved as the answer.\n\n                   Additional options correspond to the parameter names for\n                   particular question types.\n\n        answers: Default answers.\n\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n        kbi_msg: The message to be printed on a keyboard interrupt.\n        true_color: Use true color output.\n\n        color_depth: Color depth to use. If ``true_color`` is set to true then this\n                     value is ignored.\n\n        type: Default ``type`` value to use in question config.\n        filter: Default ``filter`` value to use in question config.\n        name: Default ``name`` value to use in question config.\n        when: Default ``when`` value to use in question config.\n        default: Default ``default`` value to use in question config.\n        kwargs: Additional options passed to every question.\n\n    Returns:\n        Dictionary of question answers.\n    ')), Try(body=[Return(value=Call(func=Name(id='unsafe_prompt', ctx=Load()), args=[Name(id='questions', ctx=Load()), Name(id='answers', ctx=Load()), Name(id='patch_stdout', ctx=Load()), Name(id='true_color', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='KeyboardInterrupt', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='kbi_msg', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='')], keywords=[])), Return(value=Dict(keys=[], values=[]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='unsafe_prompt', args=arguments(posonlyargs=[], args=[arg(arg='questions', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='answers', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='patch_stdout', annotation=Name(id='bool', ctx=Load())), arg(arg='true_color', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[Constant(value=None), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value="Prompt the user for input on all the questions.\n\n    Won't catch keyboard interrupts.\n\n    Args:\n        questions: A list of question configs representing questions to\n                   ask. A question config may have the following options:\n\n                   * type - The type of question.\n                   * name - An ID for the question (to identify it in the answers :obj:`dict`).\n\n                   * when - Callable to conditionally show the question. This function\n                     takes a :obj:`dict` representing the current answers.\n\n                   * filter - Function that the answer is passed to. The return value of this\n                     function is saved as the answer.\n\n                   Additional options correspond to the parameter names for\n                   particular question types.\n\n        answers: Default answers.\n\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n        true_color: Use true color output.\n\n        color_depth: Color depth to use. If ``true_color`` is set to true then this\n                     value is ignored.\n\n        type: Default ``type`` value to use in question config.\n        filter: Default ``filter`` value to use in question config.\n        name: Default ``name`` value to use in question config.\n        when: Default ``when`` value to use in question config.\n        default: Default ``default`` value to use in question config.\n        kwargs: Additional options passed to every question.\n\n    Returns:\n        Dictionary of question answers.\n\n    Raises:\n        KeyboardInterrupt: raised on keyboard interrupt\n    ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='questions', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='questions', ctx=Store())], value=List(elts=[Name(id='questions', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='answers', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='answers', ctx=Load()), Dict(keys=[], values=[])])], keywords=[])), For(target=Name(id='question_config', ctx=Store()), iter=Name(id='questions', ctx=Load()), body=[Assign(targets=[Name(id='question_config', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Name(id='question_config', ctx=Load())], keywords=[])), If(test=Compare(left=Constant(value='type'), ops=[NotIn()], comparators=[Name(id='question_config', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='PromptParameterException', ctx=Load()), args=[Constant(value='type')], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='name'), ops=[NotIn()], comparators=[Name(id='question_config', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='PromptParameterException', ctx=Load()), args=[Constant(value='name')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='choices', ctx=Store())], value=Call(func=Attribute(value=Name(id='question_config', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='choices')], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='choices', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Call(func=Name(id='callable', ctx=Load()), args=[Name(id='choices', ctx=Load())], keywords=[])]), body=[Assign(targets=[Subscript(value=Name(id='question_config', ctx=Load()), slice=Constant(value='choices'), ctx=Store())], value=Call(func=Name(id='choices', ctx=Load()), args=[Name(id='answers', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='_kwargs', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='_kwargs', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='question_config', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_type', ctx=Store())], value=Call(func=Attribute(value=Name(id='_kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='type')], keywords=[])), Assign(targets=[Name(id='_filter', ctx=Store())], value=Call(func=Attribute(value=Name(id='_kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='filter'), Constant(value=None)], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='_kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='name')], keywords=[])), Assign(targets=[Name(id='when', ctx=Store())], value=Call(func=Attribute(value=Name(id='_kwargs', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='when'), Constant(value=None)], keywords=[])), If(test=Name(id='true_color', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='_kwargs', ctx=Load()), slice=Constant(value='color_depth'), ctx=Store())], value=Attribute(value=Name(id='ColorDepth', ctx=Load()), attr='TRUE_COLOR', ctx=Load()))], orelse=[]), If(test=Name(id='when', ctx=Load()), body=[If(test=Call(func=Name(id='callable', ctx=Load()), args=[Subscript(value=Name(id='question_config', ctx=Load()), slice=Constant(value='when'), ctx=Load())], keywords=[]), body=[Try(body=[If(test=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Name(id='question_config', ctx=Load()), slice=Constant(value='when'), ctx=Load()), args=[Name(id='answers', ctx=Load())], keywords=[])), body=[Continue()], orelse=[])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="Problem in 'when' check of {} question: {}"), attr='format', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='e', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="'when' needs to be function that accepts a dict argument")], keywords=[]))])], orelse=[]), If(test=Name(id='_filter', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='_filter', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="'filter' needs to be function that accepts an argument")], keywords=[]))], orelse=[])], orelse=[]), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Call(func=Attribute(value=Name(id='question_config', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='default')], keywords=[])], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='_kwargs', ctx=Load()), slice=Constant(value='default'), ctx=Store())], value=Call(func=Subscript(value=Name(id='question_config', ctx=Load()), slice=Constant(value='default'), ctx=Load()), args=[Name(id='answers', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='create_question_func', ctx=Store())], value=Call(func=Name(id='prompt_by_name', ctx=Load()), args=[Name(id='_type', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='create_question_func', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="No question type '{}' found. Known question types are {}."), attr='format', ctx=Load()), args=[Name(id='_type', ctx=Load()), Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='AVAILABLE_PROMPTS', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='missing_args', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='utils', ctx=Load()), attr='missing_arguments', ctx=Load()), args=[Name(id='create_question_func', ctx=Load()), Name(id='_kwargs', ctx=Load())], keywords=[])], keywords=[])), If(test=Name(id='missing_args', ctx=Load()), body=[Raise(exc=Call(func=Name(id='PromptParameterException', ctx=Load()), args=[Subscript(value=Name(id='missing_args', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='question', ctx=Store())], value=Call(func=Name(id='create_question_func', ctx=Load()), args=[], keywords=[keyword(value=Name(id='_kwargs', ctx=Load()))])), Assign(targets=[Name(id='answer', ctx=Store())], value=Call(func=Attribute(value=Name(id='question', ctx=Load()), attr='unsafe_ask', ctx=Load()), args=[Name(id='patch_stdout', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='answer', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Name(id='_filter', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='answer', ctx=Store())], value=Call(func=Name(id='_filter', ctx=Load()), args=[Name(id='answer', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="Problem processing 'filter' of {} question: {}"), attr='format', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='e', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[]), Assign(targets=[Subscript(value=Name(id='answers', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Name(id='answer', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='answers', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()))], type_ignores=[])