Module(body=[Import(names=[alias(name='sys')]), ImportFrom(module='prompt_toolkit', names=[alias(name='Application')], level=0), Import(names=[alias(name='prompt_toolkit.patch_stdout')]), ImportFrom(module='questionary', names=[alias(name='utils')], level=0), ImportFrom(module='questionary.constants', names=[alias(name='DEFAULT_KBI_MESSAGE')], level=0), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ClassDef(name='Question', bases=[], keywords=[], body=[Expr(value=Constant(value='A question to be prompted.\n\n    This is an internal class. Questions should be created using the\n    predefined questions (e.g. text or password).')), AnnAssign(target=Name(id='application', ctx=Store()), annotation=Constant(value='Application[Any]'), simple=1), AnnAssign(target=Name(id='should_skip_question', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), AnnAssign(target=Name(id='default', ctx=Store()), annotation=Name(id='Any', ctx=Load()), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='application', annotation=Constant(value='Application[Any]'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='application', ctx=Store())], value=Name(id='application', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='should_skip_question', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='default', ctx=Store())], value=Constant(value=None))], decorator_list=[], returns=Constant(value=None)), AsyncFunctionDef(name='ask_async', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='patch_stdout', annotation=Name(id='bool', ctx=Load())), arg(arg='kbi_msg', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Name(id='DEFAULT_KBI_MESSAGE', ctx=Load())]), body=[Expr(value=Constant(value='Ask the question using asyncio and return user response.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n            kbi_msg: The message to be printed on a keyboard interrupt.\n\n        Returns:\n            `Any`: The answer from the question.\n        ')), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='should_skip_question', ctx=Load()), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='default', ctx=Load()))], orelse=[]), Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stdout', ctx=Load()), attr='flush', ctx=Load()), args=[], keywords=[])), Return(value=Await(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='unsafe_ask_async', ctx=Load()), args=[Name(id='patch_stdout', ctx=Load())], keywords=[])))], handlers=[ExceptHandler(type=Name(id='KeyboardInterrupt', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n{}\n'), attr='format', ctx=Load()), args=[Name(id='kbi_msg', ctx=Load())], keywords=[])], keywords=[])), Return(value=Constant(value=None))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='ask', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='patch_stdout', annotation=Name(id='bool', ctx=Load())), arg(arg='kbi_msg', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Name(id='DEFAULT_KBI_MESSAGE', ctx=Load())]), body=[Expr(value=Constant(value='Ask the question synchronously and return user response.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n            kbi_msg: The message to be printed on a keyboard interrupt.\n\n        Returns:\n            `Any`: The answer from the question.\n        ')), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='should_skip_question', ctx=Load()), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='default', ctx=Load()))], orelse=[]), Try(body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='unsafe_ask', ctx=Load()), args=[Name(id='patch_stdout', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='KeyboardInterrupt', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n{}\n'), attr='format', ctx=Load()), args=[Name(id='kbi_msg', ctx=Load())], keywords=[])], keywords=[])), Return(value=Constant(value=None))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='unsafe_ask', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='patch_stdout', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Ask the question synchronously and return user response.\n\n        Does not catch keyboard interrupts.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n        Returns:\n            `Any`: The answer from the question.\n        ')), If(test=Name(id='patch_stdout', ctx=Load()), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Attribute(value=Name(id='prompt_toolkit', ctx=Load()), attr='patch_stdout', ctx=Load()), attr='patch_stdout', ctx=Load()), args=[], keywords=[]))], body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='application', ctx=Load()), attr='run', ctx=Load()), args=[], keywords=[]))])], orelse=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='application', ctx=Load()), attr='run', ctx=Load()), args=[], keywords=[]))])], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='skip_if', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='condition', annotation=Name(id='bool', ctx=Load())), arg(arg='default', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Skip the question if flag is set and return the default instead.\n\n        Args:\n            condition: A conditional boolean value.\n            default: The default value to return.\n\n        Returns:\n            :class:`Question`: `self`.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='should_skip_question', ctx=Store())], value=Name(id='condition', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='default', ctx=Store())], value=Name(id='default', ctx=Load())), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='Question')), AsyncFunctionDef(name='unsafe_ask_async', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='patch_stdout', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Ask the question using asyncio and return user response.\n\n        Does not catch keyboard interrupts.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n        Returns:\n            `Any`: The answer from the question.\n        ')), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='utils', ctx=Load()), attr='ACTIVATED_ASYNC_MODE', ctx=Load())), body=[Expr(value=Await(value=Call(func=Attribute(value=Name(id='utils', ctx=Load()), attr='activate_prompt_toolkit_async_mode', ctx=Load()), args=[], keywords=[])))], orelse=[]), If(test=Name(id='patch_stdout', ctx=Load()), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Attribute(value=Name(id='prompt_toolkit', ctx=Load()), attr='patch_stdout', ctx=Load()), attr='patch_stdout', ctx=Load()), args=[], keywords=[]))], body=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='application', ctx=Load()), attr='run_async', ctx=Load()), args=[], keywords=[]))])], orelse=[Assign(targets=[Name(id='r', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='application', ctx=Load()), attr='run_async', ctx=Load()), args=[], keywords=[]))]), If(test=Call(func=Attribute(value=Name(id='utils', ctx=Load()), attr='is_prompt_toolkit_3', ctx=Load()), args=[], keywords=[]), body=[Return(value=Await(value=Name(id='r', ctx=Load())))], orelse=[Return(value=Await(value=Call(func=Attribute(value=Name(id='r', ctx=Load()), attr='to_asyncio_future', ctx=Load()), args=[], keywords=[])))])], decorator_list=[], returns=Name(id='Any', ctx=Load()))], decorator_list=[])], type_ignores=[])