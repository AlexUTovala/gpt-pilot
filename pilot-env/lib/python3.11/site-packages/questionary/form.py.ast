Module(body=[ImportFrom(module='typing', names=[alias(name='Any'), alias(name='Dict'), alias(name='NamedTuple'), alias(name='Sequence')], level=0), ImportFrom(module='questionary.constants', names=[alias(name='DEFAULT_KBI_MESSAGE')], level=0), ImportFrom(module='questionary.question', names=[alias(name='Question')], level=0), ClassDef(name='FormField', bases=[Name(id='NamedTuple', ctx=Load())], keywords=[], body=[AnnAssign(target=Name(id='key', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='question', ctx=Store()), annotation=Name(id='Question', ctx=Load()), simple=1)], decorator_list=[]), FunctionDef(name='form', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Question', ctx=Load())), defaults=[]), body=[Expr(value=Constant(value='Create a form with multiple questions.\n\n    The parameter name of a question will be the key for the answer in\n    the returned dict.\n\n    Args:\n        kwargs: Questions to ask in the form.\n    ')), Return(value=Call(func=Name(id='Form', ctx=Load()), args=[Starred(value=GeneratorExp(elt=Call(func=Name(id='FormField', ctx=Load()), args=[Name(id='k', ctx=Load()), Name(id='q', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='q', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]), ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='Form')), ClassDef(name='Form', bases=[], keywords=[], body=[Expr(value=Constant(value='Multi question prompts. Questions are asked one after another.\n\n    All the answers are returned as a dict with one entry per question.\n\n    This class should not be invoked directly, instead use :func:`form`.\n    ')), AnnAssign(target=Name(id='form_fields', ctx=Store()), annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='FormField', ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='form_fields', annotation=Name(id='FormField', ctx=Load())), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='form_fields', ctx=Store())], value=Name(id='form_fields', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='unsafe_ask', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='patch_stdout', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Ask the questions synchronously and return user response.\n\n        Does not catch keyboard interrupts.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n        Returns:\n            The answers from the form.\n        ')), Return(value=DictComp(key=Attribute(value=Name(id='f', ctx=Load()), attr='key', ctx=Load()), value=Call(func=Attribute(value=Attribute(value=Name(id='f', ctx=Load()), attr='question', ctx=Load()), attr='unsafe_ask', ctx=Load()), args=[Name(id='patch_stdout', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='form_fields', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), AsyncFunctionDef(name='unsafe_ask_async', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='patch_stdout', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Ask the questions using asyncio and return user response.\n\n        Does not catch keyboard interrupts.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n        Returns:\n            The answers from the form.\n        ')), Return(value=DictComp(key=Attribute(value=Name(id='f', ctx=Load()), attr='key', ctx=Load()), value=Await(value=Call(func=Attribute(value=Attribute(value=Name(id='f', ctx=Load()), attr='question', ctx=Load()), attr='unsafe_ask_async', ctx=Load()), args=[Name(id='patch_stdout', ctx=Load())], keywords=[])), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='form_fields', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='ask', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='patch_stdout', annotation=Name(id='bool', ctx=Load())), arg(arg='kbi_msg', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Name(id='DEFAULT_KBI_MESSAGE', ctx=Load())]), body=[Expr(value=Constant(value='Ask the questions synchronously and return user response.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n            kbi_msg: The message to be printed on a keyboard interrupt.\n\n        Returns:\n            The answers from the form.\n        ')), Try(body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='unsafe_ask', ctx=Load()), args=[Name(id='patch_stdout', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='KeyboardInterrupt', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='kbi_msg', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='')], keywords=[])), Return(value=Dict(keys=[], values=[]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), AsyncFunctionDef(name='ask_async', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='patch_stdout', annotation=Name(id='bool', ctx=Load())), arg(arg='kbi_msg', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Name(id='DEFAULT_KBI_MESSAGE', ctx=Load())]), body=[Expr(value=Constant(value='Ask the questions using asyncio and return user response.\n\n        Args:\n            patch_stdout: Ensure that the prompt renders correctly if other threads\n                          are printing to stdout.\n\n            kbi_msg: The message to be printed on a keyboard interrupt.\n\n        Returns:\n            The answers from the form.\n        ')), Try(body=[Return(value=Await(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='unsafe_ask_async', ctx=Load()), args=[Name(id='patch_stdout', ctx=Load())], keywords=[])))], handlers=[ExceptHandler(type=Name(id='KeyboardInterrupt', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='kbi_msg', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='')], keywords=[])), Return(value=Dict(keys=[], values=[]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])