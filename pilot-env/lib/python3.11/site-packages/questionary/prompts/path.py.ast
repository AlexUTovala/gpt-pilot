Module(body=[Import(names=[alias(name='os')]), ImportFrom(module='typing', names=[alias(name='Any'), alias(name='Callable'), alias(name='Iterable'), alias(name='List'), alias(name='Optional'), alias(name='Tuple')], level=0), ImportFrom(module='prompt_toolkit.completion', names=[alias(name='CompleteEvent'), alias(name='Completion'), alias(name='PathCompleter')], level=0), ImportFrom(module='prompt_toolkit.document', names=[alias(name='Document')], level=0), ImportFrom(module='prompt_toolkit.key_binding', names=[alias(name='KeyBindings')], level=0), ImportFrom(module='prompt_toolkit.key_binding.bindings.completion', names=[alias(name='display_completions_like_readline')], level=0), ImportFrom(module='prompt_toolkit.key_binding.key_processor', names=[alias(name='KeyPressEvent')], level=0), ImportFrom(module='prompt_toolkit.keys', names=[alias(name='Keys')], level=0), ImportFrom(module='prompt_toolkit.lexers', names=[alias(name='SimpleLexer')], level=0), ImportFrom(module='prompt_toolkit.shortcuts.prompt', names=[alias(name='CompleteStyle'), alias(name='PromptSession')], level=0), ImportFrom(module='prompt_toolkit.styles', names=[alias(name='Style'), alias(name='merge_styles')], level=0), ImportFrom(module='questionary.constants', names=[alias(name='DEFAULT_QUESTION_PREFIX'), alias(name='DEFAULT_STYLE')], level=0), ImportFrom(module='questionary.prompts.common', names=[alias(name='build_validator')], level=0), ImportFrom(module='questionary.question', names=[alias(name='Question')], level=0), ClassDef(name='GreatUXPathCompleter', bases=[Name(id='PathCompleter', ctx=Load())], keywords=[], body=[FunctionDef(name='get_completions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='document', annotation=Name(id='Document', ctx=Load())), arg(arg='complete_event', annotation=Name(id='CompleteEvent', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get completions.\n\n        Wraps :class:`prompt_toolkit.completion.PathCompleter`. Makes sure completions\n        for directories end with a path separator. Also make sure the right path\n        separator is used.')), Assign(targets=[Name(id='completions', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='GreatUXPathCompleter', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='get_completions', ctx=Load()), args=[Name(id='document', ctx=Load()), Name(id='complete_event', ctx=Load())], keywords=[])), For(target=Name(id='completion', ctx=Store()), iter=Name(id='completions', ctx=Load()), body=[Assign(targets=[Name(id='styled_display', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='completion', ctx=Load()), attr='display', ctx=Load()), slice=Constant(value=0), ctx=Load())), If(test=Compare(left=Subscript(value=Subscript(value=Name(id='styled_display', ctx=Load()), slice=Constant(value=1), ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), ops=[Eq()], comparators=[Constant(value='/')]), body=[Assign(targets=[Name(id='display_text', ctx=Store())], value=BinOp(left=Subscript(value=Subscript(value=Name(id='styled_display', ctx=Load()), slice=Constant(value=1), ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), op=Add(), right=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='sep', ctx=Load()))), Assign(targets=[Subscript(value=Attribute(value=Name(id='completion', ctx=Load()), attr='display', ctx=Load()), slice=Constant(value=0), ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='styled_display', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='display_text', ctx=Load())], ctx=Load())), AugAssign(target=Attribute(value=Name(id='completion', ctx=Load()), attr='text', ctx=Store()), op=Add(), value=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='sep', ctx=Load()))], orelse=[]), Expr(value=Yield(value=Name(id='completion', ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Completion', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='path', args=arguments(posonlyargs=[], args=[arg(arg='message', annotation=Name(id='str', ctx=Load())), arg(arg='default', annotation=Name(id='str', ctx=Load())), arg(arg='qmark', annotation=Name(id='str', ctx=Load())), arg(arg='validate', annotation=Name(id='Any', ctx=Load())), arg(arg='style', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Style', ctx=Load()), ctx=Load())), arg(arg='only_directories', annotation=Name(id='bool', ctx=Load())), arg(arg='file_filter', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='complete_style', annotation=Name(id='CompleteStyle', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs', annotation=Name(id='Any', ctx=Load())), defaults=[Constant(value=''), Name(id='DEFAULT_QUESTION_PREFIX', ctx=Load()), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None), Attribute(value=Name(id='CompleteStyle', ctx=Load()), attr='MULTI_COLUMN', ctx=Load())]), body=[Expr(value=Constant(value='A text input for a file or directory path with autocompletion enabled.\n\n    Example:\n        >>> import questionary\n        >>> questionary.path("What\'s the path to the projects version file?").ask()\n        ? What\'s the path to the projects version file? ./pyproject.toml\n        \'./pyproject.toml\'\n\n    .. image:: ../images/path.gif\n\n    This is just a really basic example, the prompt can be customised using the\n    parameters.\n\n    Args:\n        message: Question text.\n\n        default: Default return value (single value).\n\n        qmark: Question prefix displayed in front of the question.\n               By default this is a ``?``.\n\n        complete_style: How autocomplete menu would be shown, it could be ``COLUMN``\n                        ``MULTI_COLUMN`` or ``READLINE_LIKE`` from\n                        :class:`prompt_toolkit.shortcuts.CompleteStyle`.\n\n        validate: Require the entered value to pass a validation. The\n                  value can not be submitted until the validator accepts\n                  it (e.g. to check minimum password length).\n\n                  This can either be a function accepting the input and\n                  returning a boolean, or an class reference to a\n                  subclass of the prompt toolkit Validator class.\n\n        style: A custom color and style for the question parts. You can\n               configure colors as well as font types for different elements.\n\n        only_directories: Only show directories in auto completion\n\n        file_filter: Optional callable to filter suggested paths. Only paths\n                     where the passed callable evaluates to ``True`` will show up in\n                     the suggested paths. This does not validate the typed path, e.g.\n                     it is still possible for the user to enter a path manually, even\n                     though this filter evaluates to ``False``. If in addition to\n                     filtering suggestions you also want to validate the result, use\n                     ``validate`` in combination with the ``file_filter``.\n\n    Returns:\n        :class:`Question`: Question instance, ready to be prompted (using ``.ask()``).\n    ')), Assign(targets=[Name(id='merged_style', ctx=Store())], value=Call(func=Name(id='merge_styles', ctx=Load()), args=[List(elts=[Name(id='DEFAULT_STYLE', ctx=Load()), Name(id='style', ctx=Load())], ctx=Load())], keywords=[])), FunctionDef(name='get_prompt_tokens', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=List(elts=[Tuple(elts=[Constant(value='class:qmark'), Name(id='qmark', ctx=Load())], ctx=Load()), Tuple(elts=[Constant(value='class:question'), Call(func=Attribute(value=Constant(value=' {} '), attr='format', ctx=Load()), args=[Name(id='message', ctx=Load())], keywords=[])], ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), Assign(targets=[Name(id='validator', ctx=Store())], value=Call(func=Name(id='build_validator', ctx=Load()), args=[Name(id='validate', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bindings', ctx=Store())], value=Call(func=Name(id='KeyBindings', ctx=Load()), args=[], keywords=[])), FunctionDef(name='set_answer', args=arguments(posonlyargs=[], args=[arg(arg='event', annotation=Name(id='KeyPressEvent', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Attribute(value=Name(id='event', ctx=Load()), attr='current_buffer', ctx=Load()), attr='complete_state', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='event', ctx=Load()), attr='current_buffer', ctx=Load()), attr='complete_state', ctx=Store())], value=Constant(value=None))], orelse=[If(test=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='event', ctx=Load()), attr='app', ctx=Load()), attr='current_buffer', ctx=Load()), attr='validate', ctx=Load()), args=[], keywords=[keyword(arg='set_cursor', value=Constant(value=True))]), body=[Assign(targets=[Name(id='result_path', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Attribute(value=Name(id='event', ctx=Load()), attr='app', ctx=Load()), attr='current_buffer', ctx=Load()), attr='document', ctx=Load()), attr='text', ctx=Load())), If(test=Call(func=Attribute(value=Name(id='result_path', ctx=Load()), attr='endswith', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='sep', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='result_path', ctx=Store())], value=Subscript(value=Name(id='result_path', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='event', ctx=Load()), attr='app', ctx=Load()), attr='exit', ctx=Load()), args=[], keywords=[keyword(arg='result', value=Name(id='result_path', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='event', ctx=Load()), attr='app', ctx=Load()), attr='current_buffer', ctx=Load()), attr='append_to_history', ctx=Load()), args=[], keywords=[]))], orelse=[])])], decorator_list=[Call(func=Attribute(value=Name(id='bindings', ctx=Load()), attr='add', ctx=Load()), args=[Attribute(value=Name(id='Keys', ctx=Load()), attr='ControlM', ctx=Load())], keywords=[keyword(arg='eager', value=Constant(value=True))])]), FunctionDef(name='next_segment', args=arguments(posonlyargs=[], args=[arg(arg='event', annotation=Name(id='KeyPressEvent', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='b', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='event', ctx=Load()), attr='app', ctx=Load()), attr='current_buffer', ctx=Load())), If(test=Attribute(value=Name(id='b', ctx=Load()), attr='complete_state', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='b', ctx=Load()), attr='complete_state', ctx=Store())], value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='current_path', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='b', ctx=Load()), attr='document', ctx=Load()), attr='text', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='current_path', ctx=Load()), attr='endswith', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='sep', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='insert_text', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='sep', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='start_completion', ctx=Load()), args=[], keywords=[keyword(arg='select_first', value=Constant(value=False))]))], decorator_list=[Call(func=Attribute(value=Name(id='bindings', ctx=Load()), attr='add', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='sep', ctx=Load())], keywords=[keyword(arg='eager', value=Constant(value=True))])]), Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Name(id='PromptSession', ctx=Load()), args=[Name(id='get_prompt_tokens', ctx=Load())], keywords=[keyword(arg='lexer', value=Call(func=Name(id='SimpleLexer', ctx=Load()), args=[Constant(value='class:answer')], keywords=[])), keyword(arg='style', value=Name(id='merged_style', ctx=Load())), keyword(arg='completer', value=Call(func=Name(id='GreatUXPathCompleter', ctx=Load()), args=[], keywords=[keyword(arg='only_directories', value=Name(id='only_directories', ctx=Load())), keyword(arg='file_filter', value=Name(id='file_filter', ctx=Load())), keyword(arg='expanduser', value=Constant(value=True))])), keyword(arg='validator', value=Name(id='validator', ctx=Load())), keyword(arg='complete_style', value=Name(id='complete_style', ctx=Load())), keyword(arg='key_bindings', value=Name(id='bindings', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='p', ctx=Load()), attr='default_buffer', ctx=Load()), attr='reset', ctx=Load()), args=[Call(func=Name(id='Document', ctx=Load()), args=[Name(id='default', ctx=Load())], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='Question', ctx=Load()), args=[Attribute(value=Name(id='p', ctx=Load()), attr='app', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='Question', ctx=Load()))], type_ignores=[])