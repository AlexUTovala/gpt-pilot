Module(body=[Expr(value=Constant(value='\nType-annotation related support for the referencing library.\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Protocol'), alias(name='TypeVar')], level=0), Try(body=[ImportFrom(module='collections.abc', names=[alias(name='Mapping', asname='Mapping')], level=0), Expr(value=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[ImportFrom(module='typing', names=[alias(name='Mapping', asname='Mapping')], level=0)])], orelse=[], finalbody=[]), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='referencing._core', names=[alias(name='Resolved'), alias(name='Resolver'), alias(name='Resource')], level=0)], orelse=[]), Assign(targets=[Name(id='URI', ctx=Store())], value=Name(id='str', ctx=Load())), Assign(targets=[Name(id='D', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='D')], keywords=[])), ClassDef(name='Retrieve', bases=[Subscript(value=Name(id='Protocol', ctx=Load()), slice=Name(id='D', ctx=Load()), ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A retrieval callable, usable within a `Registry` for resource retrieval.\n\n    Does not make assumptions about where the resource might be coming from.\n    ')), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='uri', annotation=Name(id='URI', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Retrieve the resource with the given URI.\n\n        Raise `referencing.exceptions.NoSuchResource` if you wish to indicate\n        the retriever cannot lookup the given URI.\n        ')), Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Resource', ctx=Load()), slice=Name(id='D', ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='Anchor', bases=[Subscript(value=Name(id='Protocol', ctx=Load()), slice=Name(id='D', ctx=Load()), ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    An anchor within a `Resource`.\n\n    Beyond "simple" anchors, some specifications like JSON Schema\'s 2020\n    version have dynamic anchors.\n    ')), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the name of this anchor.\n        ')), Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='resolve', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='resolver', annotation=Subscript(value=Name(id='Resolver', ctx=Load()), slice=Name(id='D', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the resource for this anchor.\n        ')), Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Subscript(value=Name(id='Resolved', ctx=Load()), slice=Name(id='D', ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])