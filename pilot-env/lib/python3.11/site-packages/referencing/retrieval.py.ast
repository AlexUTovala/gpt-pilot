Module(body=[Expr(value=Constant(value='\nHelpers related to (dynamic) resource retrieval.\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='functools', names=[alias(name='lru_cache')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Callable'), alias(name='TypeVar')], level=0), Import(names=[alias(name='json')]), ImportFrom(module='referencing', names=[alias(name='Resource')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='referencing.typing', names=[alias(name='URI'), alias(name='D'), alias(name='Retrieve')], level=0)], orelse=[]), Assign(targets=[Name(id='_T', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='_T')], keywords=[])), FunctionDef(name='to_cached_resource', args=arguments(posonlyargs=[], args=[arg(arg='cache', annotation=BinOp(left=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Subscript(value=Name(id='Retrieve', ctx=Load()), slice=Name(id='D', ctx=Load()), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Retrieve', ctx=Load()), slice=Name(id='D', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='loads', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='_T', ctx=Load())], ctx=Load()), Name(id='D', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='from_contents', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='D', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Resource', ctx=Load()), slice=Name(id='D', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()), Attribute(value=Name(id='Resource', ctx=Load()), attr='from_contents', ctx=Load())]), body=[Expr(value=Constant(value='\n    Create a retriever which caches its return values from a simpler callable.\n\n    Takes a function which returns things like serialized JSON (strings) and\n    returns something suitable for passing to `Registry` as a retrieve\n    function.\n\n    This decorator both reduces a small bit of boilerplate for a common case\n    (deserializing JSON from strings and creating `Resource` objects from the\n    result) as well as makes the probable need for caching a bit easier.\n    Retrievers which otherwise do expensive operations (like hitting the\n    network) might otherwise be called repeatedly.\n\n    Examples\n    --------\n\n    .. testcode::\n\n        from referencing import Registry\n        from referencing.typing import URI\n        import referencing.retrieval\n\n\n        @referencing.retrieval.to_cached_resource()\n        def retrieve(uri: URI):\n            print(f"Retrieved {uri}")\n\n            # Normally, go get some expensive JSON from the network, a file ...\n            return \'\'\'\n                {\n                    "$schema": "https://json-schema.org/draft/2020-12/schema",\n                    "foo": "bar"\n                }\n            \'\'\'\n\n        one = Registry(retrieve=retrieve).get_or_retrieve("urn:example:foo")\n        print(one.value.contents["foo"])\n\n        # Retrieving the same URI again reuses the same value (and thus doesn\'t\n        # print another retrieval message here)\n        two = Registry(retrieve=retrieve).get_or_retrieve("urn:example:foo")\n        print(two.value.contents["foo"])\n\n    .. testoutput::\n\n        Retrieved urn:example:foo\n        bar\n        bar\n\n    ')), If(test=Compare(left=Name(id='cache', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='cache', ctx=Store())], value=Call(func=Name(id='lru_cache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=None))]))], orelse=[]), FunctionDef(name='decorator', args=arguments(posonlyargs=[], args=[arg(arg='retrieve', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='URI', ctx=Load())], ctx=Load()), Name(id='_T', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='cached_retrieve', args=arguments(posonlyargs=[], args=[arg(arg='uri', annotation=Name(id='URI', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Name(id='retrieve', ctx=Load()), args=[Name(id='uri', ctx=Load())], keywords=[])), Assign(targets=[Name(id='contents', ctx=Store())], value=Call(func=Name(id='loads', ctx=Load()), args=[Name(id='response', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='from_contents', ctx=Load()), args=[Name(id='contents', ctx=Load())], keywords=[]))], decorator_list=[Name(id='cache', ctx=Load())]), Return(value=Name(id='cached_retrieve', ctx=Load()))], decorator_list=[]), Return(value=Name(id='decorator', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='URI', ctx=Load())], ctx=Load()), Name(id='_T', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Retrieve', ctx=Load()), slice=Name(id='D', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], type_ignores=[])