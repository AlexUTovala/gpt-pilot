Module(body=[Expr(value=Constant(value='\ntyping.Protocol classes for jsonschema interfaces.\n')), ImportFrom(module='__future__', names=[alias(name='annotations')], level=0), ImportFrom(module='collections.abc', names=[alias(name='Mapping')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Any'), alias(name='ClassVar'), alias(name='Iterable'), alias(name='Protocol'), alias(name='runtime_checkable')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='jsonschema', names=[alias(name='_typing')], level=0), Import(names=[alias(name='jsonschema')]), Import(names=[alias(name='jsonschema.validators')]), Import(names=[alias(name='referencing.jsonschema')])], orelse=[]), ImportFrom(module='jsonschema.exceptions', names=[alias(name='ValidationError')], level=0), ClassDef(name='Validator', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    The protocol to which all validator classes adhere.\n\n    Arguments:\n\n        schema:\n\n            The schema that the validator object will validate with.\n            It is assumed to be valid, and providing\n            an invalid schema can lead to undefined behavior. See\n            `Validator.check_schema` to validate a schema first.\n\n        registry:\n\n            a schema registry that will be used for looking up JSON references\n\n        resolver:\n\n            a resolver that will be used to resolve :kw:`$ref`\n            properties (JSON references). If unprovided, one will be created.\n\n            .. deprecated:: v4.18.0\n\n                `RefResolver <_RefResolver>` has been deprecated in favor of\n                `referencing`, and with it, this argument.\n\n        format_checker:\n\n            if provided, a checker which will be used to assert about\n            :kw:`format` properties present in the schema. If unprovided,\n            *no* format validation is done, and the presence of format\n            within schemas is strictly informational. Certain formats\n            require additional packages to be installed in order to assert\n            against instances. Ensure you've installed `jsonschema` with\n            its `extra (optional) dependencies <index:extras>` when\n            invoking ``pip``.\n\n    .. deprecated:: v4.12.0\n\n        Subclassing validator classes now explicitly warns this is not part of\n        their public API.\n    ")), AnnAssign(target=Name(id='META_SCHEMA', ctx=Store()), annotation=Subscript(value=Name(id='ClassVar', ctx=Load()), slice=Name(id='Mapping', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='VALIDATORS', ctx=Store()), annotation=Subscript(value=Name(id='ClassVar', ctx=Load()), slice=Name(id='Mapping', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='TYPE_CHECKER', ctx=Store()), annotation=Subscript(value=Name(id='ClassVar', ctx=Load()), slice=Attribute(value=Name(id='jsonschema', ctx=Load()), attr='TypeChecker', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='FORMAT_CHECKER', ctx=Store()), annotation=Subscript(value=Name(id='ClassVar', ctx=Load()), slice=Attribute(value=Name(id='jsonschema', ctx=Load()), attr='FormatChecker', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='ID_OF', ctx=Store()), annotation=Attribute(value=Name(id='_typing', ctx=Load()), attr='id_of', ctx=Load()), simple=1), AnnAssign(target=Name(id='schema', ctx=Store()), annotation=BinOp(left=Name(id='Mapping', ctx=Load()), op=BitOr(), right=Name(id='bool', ctx=Load())), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='schema', annotation=BinOp(left=Name(id='Mapping', ctx=Load()), op=BitOr(), right=Name(id='bool', ctx=Load()))), arg(arg='registry', annotation=Attribute(value=Attribute(value=Name(id='referencing', ctx=Load()), attr='jsonschema', ctx=Load()), attr='SchemaRegistry', ctx=Load())), arg(arg='format_checker', annotation=BinOp(left=Attribute(value=Name(id='jsonschema', ctx=Load()), attr='FormatChecker', ctx=Load()), op=BitOr(), right=Constant(value=None)))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='check_schema', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='schema', annotation=BinOp(left=Name(id='Mapping', ctx=Load()), op=BitOr(), right=Name(id='bool', ctx=Load())))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Validate the given schema against the validator's `META_SCHEMA`.\n\n        Raises:\n\n            `jsonschema.exceptions.SchemaError`:\n\n                if the schema is invalid\n        "))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='is_type', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instance', annotation=Name(id='Any', ctx=Load())), arg(arg='type', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Check if the instance is of the given (JSON Schema) type.\n\n        Arguments:\n\n            instance:\n\n                the value to check\n\n            type:\n\n                the name of a known (JSON Schema) type\n\n        Returns:\n\n            whether the instance is of the given type\n\n        Raises:\n\n            `jsonschema.exceptions.UnknownType`:\n\n                if ``type`` is not a known type\n        '))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='is_valid', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instance', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Check if the instance is valid under the current `schema`.\n\n        Returns:\n\n            whether the instance is valid or not\n\n        >>> schema = {"maxItems" : 2}\n        >>> Draft202012Validator(schema).is_valid([2, 3, 4])\n        False\n        '))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='iter_errors', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instance', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Lazily yield each of the validation errors in the given instance.\n\n        >>> schema = {\n        ...     "type" : "array",\n        ...     "items" : {"enum" : [1, 2, 3]},\n        ...     "maxItems" : 2,\n        ... }\n        >>> v = Draft202012Validator(schema)\n        >>> for error in sorted(v.iter_errors([2, 3, 4]), key=str):\n        ...     print(error.message)\n        4 is not one of [1, 2, 3]\n        [2, 3, 4] is too long\n\n        .. deprecated:: v4.0.0\n\n            Calling this function with a second schema argument is deprecated.\n            Use `Validator.evolve` instead.\n        '))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='ValidationError', ctx=Load()), ctx=Load())), FunctionDef(name='validate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instance', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Check if the instance is valid under the current `schema`.\n\n        Raises:\n\n            `jsonschema.exceptions.ValidationError`:\n\n                if the instance is invalid\n\n        >>> schema = {"maxItems" : 2}\n        >>> Draft202012Validator(schema).validate([2, 3, 4])\n        Traceback (most recent call last):\n            ...\n        ValidationError: [2, 3, 4] is too long\n        '))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='evolve', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='\n        Create a new validator like this one, but with given changes.\n\n        Preserves all other attributes, so can be used to e.g. create a\n        validator with a different schema but with the same :kw:`$ref`\n        resolution behavior.\n\n        >>> validator = Draft202012Validator({})\n        >>> validator.evolve(schema={"type": "number"})\n        Draft202012Validator(schema={\'type\': \'number\'}, format_checker=None)\n\n        The returned object satisfies the validator protocol, but may not\n        be of the same concrete class! In particular this occurs\n        when a :kw:`$ref` occurs to a schema with a different\n        :kw:`$schema` than this one (i.e. for a different draft).\n\n        >>> validator.evolve(\n        ...     schema={"$schema": Draft7Validator.META_SCHEMA["$id"]}\n        ... )\n        Draft7Validator(schema=..., format_checker=None)\n        '))], decorator_list=[], returns=Name(id='Validator', ctx=Load()))], decorator_list=[Name(id='runtime_checkable', ctx=Load())])], type_ignores=[])