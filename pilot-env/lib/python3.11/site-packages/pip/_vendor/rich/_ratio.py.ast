Module(body=[Import(names=[alias(name='sys')]), ImportFrom(module='fractions', names=[alias(name='Fraction')], level=0), ImportFrom(module='math', names=[alias(name='ceil')], level=0), ImportFrom(module='typing', names=[alias(name='cast'), alias(name='List'), alias(name='Optional'), alias(name='Sequence')], level=0), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[ImportFrom(module='typing', names=[alias(name='Protocol')], level=0)], orelse=[ImportFrom(module='pip._vendor.typing_extensions', names=[alias(name='Protocol')], level=0)]), ClassDef(name='Edge', bases=[Name(id='Protocol', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Any object that defines an edge (such as Layout).')), AnnAssign(target=Name(id='size', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), AnnAssign(target=Name(id='ratio', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Constant(value=1), simple=1), AnnAssign(target=Name(id='minimum_size', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Constant(value=1), simple=1)], decorator_list=[]), FunctionDef(name='ratio_resolve', args=arguments(posonlyargs=[], args=[arg(arg='total', annotation=Name(id='int', ctx=Load())), arg(arg='edges', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='Edge', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Divide total space to satisfy size, ratio, and minimum_size, constraints.\n\n    The returned list of integers should add up to total in most cases, unless it is\n    impossible to satisfy all the constraints. For instance, if there are two edges\n    with a minimum size of 20 each and `total` is 30 then the returned list will be\n    greater than total. In practice, this would mean that a Layout object would\n    clip the rows that would overflow the screen height.\n\n    Args:\n        total (int): Total number of characters.\n        edges (List[Edge]): Edges within total space.\n\n    Returns:\n        List[int]: Number of characters for each edge.\n    ')), Assign(targets=[Name(id='sizes', ctx=Store())], value=ListComp(elt=BoolOp(op=Or(), values=[Attribute(value=Name(id='edge', ctx=Load()), attr='size', ctx=Load()), Constant(value=None)]), generators=[comprehension(target=Name(id='edge', ctx=Store()), iter=Name(id='edges', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='_Fraction', ctx=Store())], value=Name(id='Fraction', ctx=Load())), While(test=Compare(left=Constant(value=None), ops=[In()], comparators=[Name(id='sizes', ctx=Load())]), body=[Assign(targets=[Name(id='flexible_edges', ctx=Store())], value=ListComp(elt=Tuple(elts=[Name(id='index', ctx=Load()), Name(id='edge', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='index', ctx=Store()), Tuple(elts=[Name(id='size', ctx=Store()), Name(id='edge', ctx=Store())], ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='sizes', ctx=Load()), Name(id='edges', ctx=Load())], keywords=[])], keywords=[]), ifs=[Compare(left=Name(id='size', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])], is_async=0)])), Assign(targets=[Name(id='remaining', ctx=Store())], value=BinOp(left=Name(id='total', ctx=Load()), op=Sub(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=Or(), values=[Name(id='size', ctx=Load()), Constant(value=0)]), generators=[comprehension(target=Name(id='size', ctx=Store()), iter=Name(id='sizes', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))), If(test=Compare(left=Name(id='remaining', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)]), body=[Return(value=ListComp(elt=IfExp(test=Compare(left=Name(id='size', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=BoolOp(op=Or(), values=[Attribute(value=Name(id='edge', ctx=Load()), attr='minimum_size', ctx=Load()), Constant(value=1)]), orelse=Name(id='size', ctx=Load())), generators=[comprehension(target=Tuple(elts=[Name(id='size', ctx=Store()), Name(id='edge', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='sizes', ctx=Load()), Name(id='edges', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], orelse=[]), Assign(targets=[Name(id='portion', ctx=Store())], value=Call(func=Name(id='_Fraction', ctx=Load()), args=[Name(id='remaining', ctx=Load()), Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=Or(), values=[Attribute(value=Name(id='edge', ctx=Load()), attr='ratio', ctx=Load()), Constant(value=1)]), generators=[comprehension(target=Tuple(elts=[Name(id='_', ctx=Store()), Name(id='edge', ctx=Store())], ctx=Store()), iter=Name(id='flexible_edges', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='edge', ctx=Store())], ctx=Store()), iter=Name(id='flexible_edges', ctx=Load()), body=[If(test=Compare(left=BinOp(left=Name(id='portion', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='edge', ctx=Load()), attr='ratio', ctx=Load())), ops=[LtE()], comparators=[Attribute(value=Name(id='edge', ctx=Load()), attr='minimum_size', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='sizes', ctx=Load()), slice=Name(id='index', ctx=Load()), ctx=Store())], value=Attribute(value=Name(id='edge', ctx=Load()), attr='minimum_size', ctx=Load())), Break()], orelse=[])], orelse=[Assign(targets=[Name(id='remainder', ctx=Store())], value=Call(func=Name(id='_Fraction', ctx=Load()), args=[Constant(value=0)], keywords=[])), For(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='edge', ctx=Store())], ctx=Store()), iter=Name(id='flexible_edges', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='size', ctx=Store()), Name(id='remainder', ctx=Store())], ctx=Store())], value=Call(func=Name(id='divmod', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='portion', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='edge', ctx=Load()), attr='ratio', ctx=Load())), op=Add(), right=Name(id='remainder', ctx=Load())), Constant(value=1)], keywords=[])), Assign(targets=[Subscript(value=Name(id='sizes', ctx=Load()), slice=Name(id='index', ctx=Load()), ctx=Store())], value=Name(id='size', ctx=Load()))], orelse=[]), Break()])], orelse=[]), Return(value=Call(func=Name(id='cast', ctx=Load()), args=[Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Name(id='sizes', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='ratio_reduce', args=arguments(posonlyargs=[], args=[arg(arg='total', annotation=Name(id='int', ctx=Load())), arg(arg='ratios', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='maximums', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='values', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Divide an integer total in to parts based on ratios.\n\n    Args:\n        total (int): The total to divide.\n        ratios (List[int]): A list of integer ratios.\n        maximums (List[int]): List of maximums values for each slot.\n        values (List[int]): List of values\n\n    Returns:\n        List[int]: A list of integers guaranteed to sum to total.\n    ')), Assign(targets=[Name(id='ratios', ctx=Store())], value=ListComp(elt=IfExp(test=Name(id='_max', ctx=Load()), body=Name(id='ratio', ctx=Load()), orelse=Constant(value=0)), generators=[comprehension(target=Tuple(elts=[Name(id='ratio', ctx=Store()), Name(id='_max', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ratios', ctx=Load()), Name(id='maximums', ctx=Load())], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='total_ratio', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Name(id='ratios', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='total_ratio', ctx=Load())), body=[Return(value=Subscript(value=Name(id='values', ctx=Load()), slice=Slice(), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='total_remaining', ctx=Store())], value=Name(id='total', ctx=Load())), AnnAssign(target=Name(id='result', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='append', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load())), For(target=Tuple(elts=[Name(id='ratio', ctx=Store()), Name(id='maximum', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ratios', ctx=Load()), Name(id='maximums', ctx=Load()), Name(id='values', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Name(id='ratio', ctx=Load()), Compare(left=Name(id='total_ratio', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)])]), body=[Assign(targets=[Name(id='distributed', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='maximum', ctx=Load()), Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='ratio', ctx=Load()), op=Mult(), right=Name(id='total_remaining', ctx=Load())), op=Div(), right=Name(id='total_ratio', ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='append', ctx=Load()), args=[BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='distributed', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='total_remaining', ctx=Store()), op=Sub(), value=Name(id='distributed', ctx=Load())), AugAssign(target=Name(id='total_ratio', ctx=Store()), op=Sub(), value=Name(id='ratio', ctx=Load()))], orelse=[Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), FunctionDef(name='ratio_distribute', args=arguments(posonlyargs=[], args=[arg(arg='total', annotation=Name(id='int', ctx=Load())), arg(arg='ratios', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='minimums', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Distribute an integer total in to parts based on ratios.\n\n    Args:\n        total (int): The total to divide.\n        ratios (List[int]): A list of integer ratios.\n        minimums (List[int]): List of minimum values for each slot.\n\n    Returns:\n        List[int]: A list of integers guaranteed to sum to total.\n    ')), If(test=Name(id='minimums', ctx=Load()), body=[Assign(targets=[Name(id='ratios', ctx=Store())], value=ListComp(elt=IfExp(test=Name(id='_min', ctx=Load()), body=Name(id='ratio', ctx=Load()), orelse=Constant(value=0)), generators=[comprehension(target=Tuple(elts=[Name(id='ratio', ctx=Store()), Name(id='_min', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ratios', ctx=Load()), Name(id='minimums', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], orelse=[]), Assign(targets=[Name(id='total_ratio', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Name(id='ratios', ctx=Load())], keywords=[])), Assert(test=Compare(left=Name(id='total_ratio', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), msg=Constant(value='Sum of ratios must be > 0')), Assign(targets=[Name(id='total_remaining', ctx=Store())], value=Name(id='total', ctx=Load())), AnnAssign(target=Name(id='distributed_total', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='append', ctx=Store())], value=Attribute(value=Name(id='distributed_total', ctx=Load()), attr='append', ctx=Load())), If(test=Compare(left=Name(id='minimums', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='_minimums', ctx=Store())], value=BinOp(left=List(elts=[Constant(value=0)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='ratios', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='_minimums', ctx=Store())], value=Name(id='minimums', ctx=Load()))]), For(target=Tuple(elts=[Name(id='ratio', ctx=Store()), Name(id='minimum', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ratios', ctx=Load()), Name(id='_minimums', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='total_ratio', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='distributed', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Name(id='minimum', ctx=Load()), Call(func=Name(id='ceil', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='ratio', ctx=Load()), op=Mult(), right=Name(id='total_remaining', ctx=Load())), op=Div(), right=Name(id='total_ratio', ctx=Load()))], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='distributed', ctx=Store())], value=Name(id='total_remaining', ctx=Load()))]), Expr(value=Call(func=Name(id='append', ctx=Load()), args=[Name(id='distributed', ctx=Load())], keywords=[])), AugAssign(target=Name(id='total_ratio', ctx=Store()), op=Sub(), value=Name(id='ratio', ctx=Load())), AugAssign(target=Name(id='total_remaining', ctx=Store()), op=Sub(), value=Name(id='distributed', ctx=Load()))], orelse=[]), Return(value=Name(id='distributed_total', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), If(test=Compare(left=Name(id='__name__', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__main__')]), body=[ImportFrom(module='dataclasses', names=[alias(name='dataclass')], level=0), ClassDef(name='E', bases=[], keywords=[], body=[AnnAssign(target=Name(id='size', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), AnnAssign(target=Name(id='ratio', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Constant(value=1), simple=1), AnnAssign(target=Name(id='minimum_size', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Constant(value=1), simple=1)], decorator_list=[Name(id='dataclass', ctx=Load())]), Assign(targets=[Name(id='resolved', ctx=Store())], value=Call(func=Name(id='ratio_resolve', ctx=Load()), args=[Constant(value=110), List(elts=[Call(func=Name(id='E', ctx=Load()), args=[Constant(value=None), Constant(value=1), Constant(value=1)], keywords=[]), Call(func=Name(id='E', ctx=Load()), args=[Constant(value=None), Constant(value=1), Constant(value=1)], keywords=[]), Call(func=Name(id='E', ctx=Load()), args=[Constant(value=None), Constant(value=1), Constant(value=1)], keywords=[])], ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Name(id='resolved', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], type_ignores=[])