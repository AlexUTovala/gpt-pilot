Module(body=[Import(names=[alias(name='abc')]), Import(names=[alias(name='random')]), Import(names=[alias(name='typing')]), ImportFrom(module='pip._vendor.tenacity', names=[alias(name='_utils')], level=0), If(test=Attribute(value=Name(id='typing', ctx=Load()), attr='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='pip._vendor.tenacity', names=[alias(name='RetryCallState')], level=0)], orelse=[]), ClassDef(name='wait_base', bases=[Attribute(value=Name(id='abc', ctx=Load()), attr='ABC', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Abstract base class for wait strategies.')), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='retry_state', annotation=Constant(value='RetryCallState'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Attribute(value=Name(id='abc', ctx=Load()), attr='abstractmethod', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='__add__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Constant(value='wait_base'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='wait_combine', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='wait_combine')), FunctionDef(name='__radd__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Constant(value='wait_base'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='other', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__add__', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='wait_combine'), Constant(value='wait_base')], ctx=Load()), ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='WaitBaseT', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='wait_base', ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Constant(value='RetryCallState')], ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='wait_fixed', bases=[Name(id='wait_base', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Wait strategy that waits a fixed amount of time between each retry.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='wait', annotation=Attribute(value=Name(id='_utils', ctx=Load()), attr='time_unit_type', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='wait_fixed', ctx=Store())], value=Call(func=Attribute(value=Name(id='_utils', ctx=Load()), attr='to_seconds', ctx=Load()), args=[Name(id='wait', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='retry_state', annotation=Constant(value='RetryCallState'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='wait_fixed', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load()))], decorator_list=[]), ClassDef(name='wait_none', bases=[Name(id='wait_fixed', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Wait strategy that doesn't wait at all before retrying.")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Constant(value=0)], keywords=[]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='wait_random', bases=[Name(id='wait_base', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Wait strategy that waits a random amount of time between min/max.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='min', annotation=Attribute(value=Name(id='_utils', ctx=Load()), attr='time_unit_type', ctx=Load())), arg(arg='max', annotation=Attribute(value=Name(id='_utils', ctx=Load()), attr='time_unit_type', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=1)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='wait_random_min', ctx=Store())], value=Call(func=Attribute(value=Name(id='_utils', ctx=Load()), attr='to_seconds', ctx=Load()), args=[Name(id='min', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='wait_random_max', ctx=Store())], value=Call(func=Attribute(value=Name(id='_utils', ctx=Load()), attr='to_seconds', ctx=Load()), args=[Name(id='max', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='retry_state', annotation=Constant(value='RetryCallState'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='wait_random_min', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='random', ctx=Load()), attr='random', ctx=Load()), args=[], keywords=[]), op=Mult(), right=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='wait_random_max', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='wait_random_min', ctx=Load())))))], decorator_list=[], returns=Name(id='float', ctx=Load()))], decorator_list=[]), ClassDef(name='wait_combine', bases=[Name(id='wait_base', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Combine several waiting strategies.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='strategies', annotation=Name(id='wait_base', ctx=Load())), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='wait_funcs', ctx=Store())], value=Name(id='strategies', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='retry_state', annotation=Constant(value='RetryCallState'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='x', ctx=Load()), args=[], keywords=[keyword(arg='retry_state', value=Name(id='retry_state', ctx=Load()))]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='wait_funcs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load()))], decorator_list=[]), ClassDef(name='wait_chain', bases=[Name(id='wait_base', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Chain two or more waiting strategies.\n\n    If all strategies are exhausted, the very last strategy is used\n    thereafter.\n\n    For example::\n\n        @retry(wait=wait_chain(*[wait_fixed(1) for i in range(3)] +\n                               [wait_fixed(2) for j in range(5)] +\n                               [wait_fixed(5) for k in range(4)))\n        def wait_chained():\n            print("Wait 1s for 3 attempts, 2s for 5 attempts and 5s\n                   thereafter.")\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='strategies', annotation=Name(id='wait_base', ctx=Load())), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='strategies', ctx=Store())], value=Name(id='strategies', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='retry_state', annotation=Constant(value='RetryCallState'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='wait_func_no', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='retry_state', ctx=Load()), attr='attempt_number', ctx=Load()), Constant(value=1)], keywords=[]), Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='strategies', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='wait_func', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='strategies', ctx=Load()), slice=BinOp(left=Name(id='wait_func_no', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load())), Return(value=Call(func=Name(id='wait_func', ctx=Load()), args=[], keywords=[keyword(arg='retry_state', value=Name(id='retry_state', ctx=Load()))]))], decorator_list=[], returns=Name(id='float', ctx=Load()))], decorator_list=[]), ClassDef(name='wait_incrementing', bases=[Name(id='wait_base', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Wait an incremental amount of time after each attempt.\n\n    Starting at a starting value and incrementing by a value for each attempt\n    (and restricting the upper limit to some maximum value).\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='start', annotation=Attribute(value=Name(id='_utils', ctx=Load()), attr='time_unit_type', ctx=Load())), arg(arg='increment', annotation=Attribute(value=Name(id='_utils', ctx=Load()), attr='time_unit_type', ctx=Load())), arg(arg='max', annotation=Attribute(value=Name(id='_utils', ctx=Load()), attr='time_unit_type', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=100), Attribute(value=Name(id='_utils', ctx=Load()), attr='MAX_WAIT', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='start', ctx=Store())], value=Call(func=Attribute(value=Name(id='_utils', ctx=Load()), attr='to_seconds', ctx=Load()), args=[Name(id='start', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='increment', ctx=Store())], value=Call(func=Attribute(value=Name(id='_utils', ctx=Load()), attr='to_seconds', ctx=Load()), args=[Name(id='increment', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Store())], value=Call(func=Attribute(value=Name(id='_utils', ctx=Load()), attr='to_seconds', ctx=Load()), args=[Name(id='max', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='retry_state', annotation=Constant(value='RetryCallState'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='start', ctx=Load()), op=Add(), right=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='increment', ctx=Load()), op=Mult(), right=BinOp(left=Attribute(value=Name(id='retry_state', ctx=Load()), attr='attempt_number', ctx=Load()), op=Sub(), right=Constant(value=1))))), Return(value=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), Call(func=Name(id='min', ctx=Load()), args=[Name(id='result', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load()))], decorator_list=[]), ClassDef(name='wait_exponential', bases=[Name(id='wait_base', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Wait strategy that applies exponential backoff.\n\n    It allows for a customized multiplier and an ability to restrict the\n    upper and lower limits to some maximum and minimum value.\n\n    The intervals are fixed (i.e. there is no jitter), so this strategy is\n    suitable for balancing retries against latency when a required resource is\n    unavailable for an unknown duration, but *not* suitable for resolving\n    contention between multiple processes for a shared resource. Use\n    wait_random_exponential for the latter case.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='multiplier', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='max', annotation=Attribute(value=Name(id='_utils', ctx=Load()), attr='time_unit_type', ctx=Load())), arg(arg='exp_base', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='min', annotation=Attribute(value=Name(id='_utils', ctx=Load()), attr='time_unit_type', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Attribute(value=Name(id='_utils', ctx=Load()), attr='MAX_WAIT', ctx=Load()), Constant(value=2), Constant(value=0)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='multiplier', ctx=Store())], value=Name(id='multiplier', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min', ctx=Store())], value=Call(func=Attribute(value=Name(id='_utils', ctx=Load()), attr='to_seconds', ctx=Load()), args=[Name(id='min', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Store())], value=Call(func=Attribute(value=Name(id='_utils', ctx=Load()), attr='to_seconds', ctx=Load()), args=[Name(id='max', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exp_base', ctx=Store())], value=Name(id='exp_base', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='retry_state', annotation=Constant(value='RetryCallState'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='exp', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='exp_base', ctx=Load()), op=Pow(), right=BinOp(left=Attribute(value=Name(id='retry_state', ctx=Load()), attr='attempt_number', ctx=Load()), op=Sub(), right=Constant(value=1)))), Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='multiplier', ctx=Load()), op=Mult(), right=Name(id='exp', ctx=Load())))], handlers=[ExceptHandler(type=Name(id='OverflowError', ctx=Load()), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Load()))])], orelse=[], finalbody=[]), Return(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), Attribute(value=Name(id='self', ctx=Load()), attr='min', ctx=Load())], keywords=[]), Call(func=Name(id='min', ctx=Load()), args=[Name(id='result', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load()))], decorator_list=[]), ClassDef(name='wait_random_exponential', bases=[Name(id='wait_exponential', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Random wait with exponentially widening window.\n\n    An exponential backoff strategy used to mediate contention between multiple\n    uncoordinated processes for a shared resource in distributed systems. This\n    is the sense in which "exponential backoff" is meant in e.g. Ethernet\n    networking, and corresponds to the "Full Jitter" algorithm described in\n    this blog post:\n\n    https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n\n    Each retry occurs at a random time in a geometrically expanding interval.\n    It allows for a custom multiplier and an ability to restrict the upper\n    limit of the random interval to some maximum value.\n\n    Example::\n\n        wait_random_exponential(multiplier=0.5,  # initial window 0.5s\n                                max=60)          # max 60s timeout\n\n    When waiting for an unavailable resource to become available again, as\n    opposed to trying to resolve contention for a shared resource, the\n    wait_exponential strategy (which uses a fixed interval) may be preferable.\n\n    ')), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='retry_state', annotation=Constant(value='RetryCallState'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='high', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__call__', ctx=Load()), args=[], keywords=[keyword(arg='retry_state', value=Name(id='retry_state', ctx=Load()))])), Return(value=Call(func=Attribute(value=Name(id='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Constant(value=0), Name(id='high', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load()))], decorator_list=[]), ClassDef(name='wait_exponential_jitter', bases=[Name(id='wait_base', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Wait strategy that applies exponential backoff and jitter.\n\n    It allows for a customized initial wait, maximum wait and jitter.\n\n    This implements the strategy described here:\n    https://cloud.google.com/storage/docs/retry-strategy\n\n    The wait time is min(initial * 2**n + random.uniform(0, jitter), maximum)\n    where n is the retry count.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='initial', annotation=Name(id='float', ctx=Load())), arg(arg='max', annotation=Name(id='float', ctx=Load())), arg(arg='exp_base', annotation=Name(id='float', ctx=Load())), arg(arg='jitter', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Attribute(value=Name(id='_utils', ctx=Load()), attr='MAX_WAIT', ctx=Load()), Constant(value=2), Constant(value=1)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial', ctx=Store())], value=Name(id='initial', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Store())], value=Name(id='max', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exp_base', ctx=Store())], value=Name(id='exp_base', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='jitter', ctx=Store())], value=Name(id='jitter', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='retry_state', annotation=Constant(value='RetryCallState'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='jitter', ctx=Store())], value=Call(func=Attribute(value=Name(id='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Constant(value=0), Attribute(value=Name(id='self', ctx=Load()), attr='jitter', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='exp', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='exp_base', ctx=Load()), op=Pow(), right=BinOp(left=Attribute(value=Name(id='retry_state', ctx=Load()), attr='attempt_number', ctx=Load()), op=Sub(), right=Constant(value=1)))), Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='initial', ctx=Load()), op=Mult(), right=Name(id='exp', ctx=Load())), op=Add(), right=Name(id='jitter', ctx=Load())))], handlers=[ExceptHandler(type=Name(id='OverflowError', ctx=Load()), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Load()))])], orelse=[], finalbody=[]), Return(value=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), Call(func=Name(id='min', ctx=Load()), args=[Name(id='result', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load()))], decorator_list=[])], type_ignores=[])