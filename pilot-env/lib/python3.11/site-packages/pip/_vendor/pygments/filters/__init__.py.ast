Module(body=[Expr(value=Constant(value='\n    pygments.filters\n    ~~~~~~~~~~~~~~~~\n\n    Module containing filter lookup functions and default\n    filters.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n')), Import(names=[alias(name='re')]), ImportFrom(module='pip._vendor.pygments.token', names=[alias(name='String'), alias(name='Comment'), alias(name='Keyword'), alias(name='Name'), alias(name='Error'), alias(name='Whitespace'), alias(name='string_to_tokentype')], level=0), ImportFrom(module='pip._vendor.pygments.filter', names=[alias(name='Filter')], level=0), ImportFrom(module='pip._vendor.pygments.util', names=[alias(name='get_list_opt'), alias(name='get_int_opt'), alias(name='get_bool_opt'), alias(name='get_choice_opt'), alias(name='ClassNotFound'), alias(name='OptionError')], level=0), ImportFrom(module='pip._vendor.pygments.plugin', names=[alias(name='find_plugin_filters')], level=0), FunctionDef(name='find_filter_class', args=arguments(posonlyargs=[], args=[arg(arg='filtername')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Lookup a filter by name. Return None if not found.')), If(test=Compare(left=Name(id='filtername', ctx=Load()), ops=[In()], comparators=[Name(id='FILTERS', ctx=Load())]), body=[Return(value=Subscript(value=Name(id='FILTERS', ctx=Load()), slice=Name(id='filtername', ctx=Load()), ctx=Load()))], orelse=[]), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='cls', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='find_plugin_filters', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Eq()], comparators=[Name(id='filtername', ctx=Load())]), body=[Return(value=Name(id='cls', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='get_filter_by_name', args=arguments(posonlyargs=[], args=[arg(arg='filtername')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='options'), defaults=[]), body=[Expr(value=Constant(value='Return an instantiated filter.\n\n    Options are passed to the filter initializer if wanted.\n    Raise a ClassNotFound if not found.\n    ')), Assign(targets=[Name(id='cls', ctx=Store())], value=Call(func=Name(id='find_filter_class', ctx=Load()), args=[Name(id='filtername', ctx=Load())], keywords=[])), If(test=Name(id='cls', ctx=Load()), body=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[], keywords=[keyword(value=Name(id='options', ctx=Load()))]))], orelse=[Raise(exc=Call(func=Name(id='ClassNotFound', ctx=Load()), args=[BinOp(left=Constant(value='filter %r not found'), op=Mod(), right=Name(id='filtername', ctx=Load()))], keywords=[]))])], decorator_list=[]), FunctionDef(name='get_all_filters', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a generator of all filter names.')), Expr(value=YieldFrom(value=Name(id='FILTERS', ctx=Load()))), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='find_plugin_filters', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Yield(value=Name(id='name', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='_replace_special', args=arguments(posonlyargs=[], args=[arg(arg='ttype'), arg(arg='value'), arg(arg='regex'), arg(arg='specialttype'), arg(arg='replacefunc')], kwonlyargs=[], kw_defaults=[], defaults=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='x', ctx=Load()))]), body=[Assign(targets=[Name(id='last', ctx=Store())], value=Constant(value=0)), For(target=Name(id='match', ctx=Store()), iter=Call(func=Attribute(value=Name(id='regex', ctx=Load()), attr='finditer', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Tuple(elts=[Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[])], ctx=Load())), If(test=Compare(left=Name(id='start', ctx=Load()), ops=[NotEq()], comparators=[Name(id='last', ctx=Load())]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Subscript(value=Name(id='value', ctx=Load()), slice=Slice(lower=Name(id='last', ctx=Load()), upper=Name(id='start', ctx=Load())), ctx=Load())], ctx=Load())))], orelse=[]), Expr(value=Yield(value=Tuple(elts=[Name(id='specialttype', ctx=Load()), Call(func=Name(id='replacefunc', ctx=Load()), args=[Subscript(value=Name(id='value', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='end', ctx=Load())), ctx=Load())], keywords=[])], ctx=Load()))), Assign(targets=[Name(id='last', ctx=Store())], value=Name(id='end', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='last', ctx=Load()), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Subscript(value=Name(id='value', ctx=Load()), slice=Slice(lower=Name(id='last', ctx=Load())), ctx=Load())], ctx=Load())))], orelse=[])], decorator_list=[]), ClassDef(name='CodeTagFilter', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Highlight special code tags in comments and docstrings.\n\n    Options accepted:\n\n    `codetags` : list of strings\n       A list of strings that are flagged as code tags.  The default is to\n       highlight ``XXX``, ``TODO``, ``FIXME``, ``BUG`` and ``NOTE``.\n\n    .. versionchanged:: 2.13\n       Now recognizes ``FIXME`` by default.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='options'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='Filter', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(value=Name(id='options', ctx=Load()))])), Assign(targets=[Name(id='tags', ctx=Store())], value=Call(func=Name(id='get_list_opt', ctx=Load()), args=[Name(id='options', ctx=Load()), Constant(value='codetags'), List(elts=[Constant(value='XXX'), Constant(value='TODO'), Constant(value='FIXME'), Constant(value='BUG'), Constant(value='NOTE')], ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='tag_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[BinOp(left=Constant(value='\\b(%s)\\b'), op=Mod(), right=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[ListComp(elt=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='tag', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='tag', ctx=Store()), iter=Name(id='tags', ctx=Load()), ifs=[Name(id='tag', ctx=Load())], is_async=0)])], keywords=[]))], keywords=[]))], decorator_list=[]), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lexer'), arg(arg='stream')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='regex', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='tag_re', ctx=Load())), For(target=Tuple(elts=[Name(id='ttype', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='stream', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='ttype', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='String', ctx=Load()), attr='Doc', ctx=Load())]), BoolOp(op=And(), values=[Compare(left=Name(id='ttype', ctx=Load()), ops=[In()], comparators=[Name(id='Comment', ctx=Load())]), Compare(left=Name(id='ttype', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='Comment', ctx=Load()), attr='Preproc', ctx=Load())])])]), body=[Expr(value=YieldFrom(value=Call(func=Name(id='_replace_special', ctx=Load()), args=[Name(id='ttype', ctx=Load()), Name(id='value', ctx=Load()), Name(id='regex', ctx=Load()), Attribute(value=Name(id='Comment', ctx=Load()), attr='Special', ctx=Load())], keywords=[])))], orelse=[Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load())))])], orelse=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='SymbolFilter', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Convert mathematical symbols such as \\<longrightarrow> in Isabelle\n    or \\longrightarrow in LaTeX into Unicode characters.\n\n    This is mostly useful for HTML or console output when you want to\n    approximate the source rendering you'd see in an IDE.\n\n    Options accepted:\n\n    `lang` : string\n       The symbol language. Must be one of ``'isabelle'`` or\n       ``'latex'``.  The default is ``'isabelle'``.\n    ")), Assign(targets=[Name(id='latex_symbols', ctx=Store())], value=Dict(keys=[Constant(value='\\alpha'), Constant(value='\\beta'), Constant(value='\\gamma'), Constant(value='\\delta'), Constant(value='\\varepsilon'), Constant(value='\\zeta'), Constant(value='\\eta'), Constant(value='\\vartheta'), Constant(value='\\iota'), Constant(value='\\kappa'), Constant(value='\\lambda'), Constant(value='\\mu'), Constant(value='\\nu'), Constant(value='\\xi'), Constant(value='\\pi'), Constant(value='\\varrho'), Constant(value='\\sigma'), Constant(value='\\tau'), Constant(value='\\upsilon'), Constant(value='\\varphi'), Constant(value='\\chi'), Constant(value='\\psi'), Constant(value='\\omega'), Constant(value='\\Gamma'), Constant(value='\\Delta'), Constant(value='\\Theta'), Constant(value='\\Lambda'), Constant(value='\\Xi'), Constant(value='\\Pi'), Constant(value='\\Sigma'), Constant(value='\\Upsilon'), Constant(value='\\Phi'), Constant(value='\\Psi'), Constant(value='\\Omega'), Constant(value='\\leftarrow'), Constant(value='\\longleftarrow'), Constant(value='\\rightarrow'), Constant(value='\\longrightarrow'), Constant(value='\\Leftarrow'), Constant(value='\\Longleftarrow'), Constant(value='\\Rightarrow'), Constant(value='\\Longrightarrow'), Constant(value='\\leftrightarrow'), Constant(value='\\longleftrightarrow'), Constant(value='\\Leftrightarrow'), Constant(value='\\Longleftrightarrow'), Constant(value='\\mapsto'), Constant(value='\\longmapsto'), Constant(value='\\relbar'), Constant(value='\\Relbar'), Constant(value='\\hookleftarrow'), Constant(value='\\hookrightarrow'), Constant(value='\\leftharpoondown'), Constant(value='\\rightharpoondown'), Constant(value='\\leftharpoonup'), Constant(value='\\rightharpoonup'), Constant(value='\\rightleftharpoons'), Constant(value='\\leadsto'), Constant(value='\\downharpoonleft'), Constant(value='\\downharpoonright'), Constant(value='\\upharpoonleft'), Constant(value='\\upharpoonright'), Constant(value='\\restriction'), Constant(value='\\uparrow'), Constant(value='\\Uparrow'), Constant(value='\\downarrow'), Constant(value='\\Downarrow'), Constant(value='\\updownarrow'), Constant(value='\\Updownarrow'), Constant(value='\\langle'), Constant(value='\\rangle'), Constant(value='\\lceil'), Constant(value='\\rceil'), Constant(value='\\lfloor'), Constant(value='\\rfloor'), Constant(value='\\flqq'), Constant(value='\\frqq'), Constant(value='\\bot'), Constant(value='\\top'), Constant(value='\\wedge'), Constant(value='\\bigwedge'), Constant(value='\\vee'), Constant(value='\\bigvee'), Constant(value='\\forall'), Constant(value='\\exists'), Constant(value='\\nexists'), Constant(value='\\neg'), Constant(value='\\Box'), Constant(value='\\Diamond'), Constant(value='\\vdash'), Constant(value='\\models'), Constant(value='\\dashv'), Constant(value='\\surd'), Constant(value='\\le'), Constant(value='\\ge'), Constant(value='\\ll'), Constant(value='\\gg'), Constant(value='\\lesssim'), Constant(value='\\gtrsim'), Constant(value='\\lessapprox'), Constant(value='\\gtrapprox'), Constant(value='\\in'), Constant(value='\\notin'), Constant(value='\\subset'), Constant(value='\\supset'), Constant(value='\\subseteq'), Constant(value='\\supseteq'), Constant(value='\\sqsubset'), Constant(value='\\sqsupset'), Constant(value='\\sqsubseteq'), Constant(value='\\sqsupseteq'), Constant(value='\\cap'), Constant(value='\\bigcap'), Constant(value='\\cup'), Constant(value='\\bigcup'), Constant(value='\\sqcup'), Constant(value='\\bigsqcup'), Constant(value='\\sqcap'), Constant(value='\\Bigsqcap'), Constant(value='\\setminus'), Constant(value='\\propto'), Constant(value='\\uplus'), Constant(value='\\bigplus'), Constant(value='\\sim'), Constant(value='\\doteq'), Constant(value='\\simeq'), Constant(value='\\approx'), Constant(value='\\asymp'), Constant(value='\\cong'), Constant(value='\\equiv'), Constant(value='\\Join'), Constant(value='\\bowtie'), Constant(value='\\prec'), Constant(value='\\succ'), Constant(value='\\preceq'), Constant(value='\\succeq'), Constant(value='\\parallel'), Constant(value='\\mid'), Constant(value='\\pm'), Constant(value='\\mp'), Constant(value='\\times'), Constant(value='\\div'), Constant(value='\\cdot'), Constant(value='\\star'), Constant(value='\\circ'), Constant(value='\\dagger'), Constant(value='\\ddagger'), Constant(value='\\lhd'), Constant(value='\\rhd'), Constant(value='\\unlhd'), Constant(value='\\unrhd'), Constant(value='\\triangleleft'), Constant(value='\\triangleright'), Constant(value='\\triangle'), Constant(value='\\triangleq'), Constant(value='\\oplus'), Constant(value='\\bigoplus'), Constant(value='\\otimes'), Constant(value='\\bigotimes'), Constant(value='\\odot'), Constant(value='\\bigodot'), Constant(value='\\ominus'), Constant(value='\\oslash'), Constant(value='\\dots'), Constant(value='\\cdots'), Constant(value='\\sum'), Constant(value='\\prod'), Constant(value='\\coprod'), Constant(value='\\infty'), Constant(value='\\int'), Constant(value='\\oint'), Constant(value='\\clubsuit'), Constant(value='\\diamondsuit'), Constant(value='\\heartsuit'), Constant(value='\\spadesuit'), Constant(value='\\aleph'), Constant(value='\\emptyset'), Constant(value='\\nabla'), Constant(value='\\partial'), Constant(value='\\flat'), Constant(value='\\natural'), Constant(value='\\sharp'), Constant(value='\\angle'), Constant(value='\\copyright'), Constant(value='\\textregistered'), Constant(value='\\textonequarter'), Constant(value='\\textonehalf'), Constant(value='\\textthreequarters'), Constant(value='\\textordfeminine'), Constant(value='\\textordmasculine'), Constant(value='\\euro'), Constant(value='\\pounds'), Constant(value='\\yen'), Constant(value='\\textcent'), Constant(value='\\textcurrency'), Constant(value='\\textdegree')], values=[Constant(value='α'), Constant(value='β'), Constant(value='γ'), Constant(value='δ'), Constant(value='ε'), Constant(value='ζ'), Constant(value='η'), Constant(value='θ'), Constant(value='ι'), Constant(value='κ'), Constant(value='λ'), Constant(value='μ'), Constant(value='ν'), Constant(value='ξ'), Constant(value='π'), Constant(value='ρ'), Constant(value='σ'), Constant(value='τ'), Constant(value='υ'), Constant(value='φ'), Constant(value='χ'), Constant(value='ψ'), Constant(value='ω'), Constant(value='Γ'), Constant(value='Δ'), Constant(value='Θ'), Constant(value='Λ'), Constant(value='Ξ'), Constant(value='Π'), Constant(value='Σ'), Constant(value='Υ'), Constant(value='Φ'), Constant(value='Ψ'), Constant(value='Ω'), Constant(value='←'), Constant(value='⟵'), Constant(value='→'), Constant(value='⟶'), Constant(value='⇐'), Constant(value='⟸'), Constant(value='⇒'), Constant(value='⟹'), Constant(value='↔'), Constant(value='⟷'), Constant(value='⇔'), Constant(value='⟺'), Constant(value='↦'), Constant(value='⟼'), Constant(value='─'), Constant(value='═'), Constant(value='↩'), Constant(value='↪'), Constant(value='↽'), Constant(value='⇁'), Constant(value='↼'), Constant(value='⇀'), Constant(value='⇌'), Constant(value='↝'), Constant(value='⇃'), Constant(value='⇂'), Constant(value='↿'), Constant(value='↾'), Constant(value='↾'), Constant(value='↑'), Constant(value='⇑'), Constant(value='↓'), Constant(value='⇓'), Constant(value='↕'), Constant(value='⇕'), Constant(value='⟨'), Constant(value='⟩'), Constant(value='⌈'), Constant(value='⌉'), Constant(value='⌊'), Constant(value='⌋'), Constant(value='«'), Constant(value='»'), Constant(value='⊥'), Constant(value='⊤'), Constant(value='∧'), Constant(value='⋀'), Constant(value='∨'), Constant(value='⋁'), Constant(value='∀'), Constant(value='∃'), Constant(value='∄'), Constant(value='¬'), Constant(value='□'), Constant(value='◇'), Constant(value='⊢'), Constant(value='⊨'), Constant(value='⊣'), Constant(value='√'), Constant(value='≤'), Constant(value='≥'), Constant(value='≪'), Constant(value='≫'), Constant(value='≲'), Constant(value='≳'), Constant(value='⪅'), Constant(value='⪆'), Constant(value='∈'), Constant(value='∉'), Constant(value='⊂'), Constant(value='⊃'), Constant(value='⊆'), Constant(value='⊇'), Constant(value='⊏'), Constant(value='⊐'), Constant(value='⊑'), Constant(value='⊒'), Constant(value='∩'), Constant(value='⋂'), Constant(value='∪'), Constant(value='⋃'), Constant(value='⊔'), Constant(value='⨆'), Constant(value='⊓'), Constant(value='⨅'), Constant(value='∖'), Constant(value='∝'), Constant(value='⊎'), Constant(value='⨄'), Constant(value='∼'), Constant(value='≐'), Constant(value='≃'), Constant(value='≈'), Constant(value='≍'), Constant(value='≅'), Constant(value='≡'), Constant(value='⋈'), Constant(value='⨝'), Constant(value='≺'), Constant(value='≻'), Constant(value='≼'), Constant(value='≽'), Constant(value='∥'), Constant(value='¦'), Constant(value='±'), Constant(value='∓'), Constant(value='×'), Constant(value='÷'), Constant(value='⋅'), Constant(value='⋆'), Constant(value='∘'), Constant(value='†'), Constant(value='‡'), Constant(value='⊲'), Constant(value='⊳'), Constant(value='⊴'), Constant(value='⊵'), Constant(value='◃'), Constant(value='▹'), Constant(value='△'), Constant(value='≜'), Constant(value='⊕'), Constant(value='⨁'), Constant(value='⊗'), Constant(value='⨂'), Constant(value='⊙'), Constant(value='⨀'), Constant(value='⊖'), Constant(value='⊘'), Constant(value='…'), Constant(value='⋯'), Constant(value='∑'), Constant(value='∏'), Constant(value='∐'), Constant(value='∞'), Constant(value='∫'), Constant(value='∮'), Constant(value='♣'), Constant(value='♢'), Constant(value='♡'), Constant(value='♠'), Constant(value='ℵ'), Constant(value='∅'), Constant(value='∇'), Constant(value='∂'), Constant(value='♭'), Constant(value='♮'), Constant(value='♯'), Constant(value='∠'), Constant(value='©'), Constant(value='®'), Constant(value='¼'), Constant(value='½'), Constant(value='¾'), Constant(value='ª'), Constant(value='º'), Constant(value='€'), Constant(value='£'), Constant(value='¥'), Constant(value='¢'), Constant(value='¤'), Constant(value='°')])), Assign(targets=[Name(id='isabelle_symbols', ctx=Store())], value=Dict(keys=[Constant(value='\\<zero>'), Constant(value='\\<one>'), Constant(value='\\<two>'), Constant(value='\\<three>'), Constant(value='\\<four>'), Constant(value='\\<five>'), Constant(value='\\<six>'), Constant(value='\\<seven>'), Constant(value='\\<eight>'), Constant(value='\\<nine>'), Constant(value='\\<A>'), Constant(value='\\<B>'), Constant(value='\\<C>'), Constant(value='\\<D>'), Constant(value='\\<E>'), Constant(value='\\<F>'), Constant(value='\\<G>'), Constant(value='\\<H>'), Constant(value='\\<I>'), Constant(value='\\<J>'), Constant(value='\\<K>'), Constant(value='\\<L>'), Constant(value='\\<M>'), Constant(value='\\<N>'), Constant(value='\\<O>'), Constant(value='\\<P>'), Constant(value='\\<Q>'), Constant(value='\\<R>'), Constant(value='\\<S>'), Constant(value='\\<T>'), Constant(value='\\<U>'), Constant(value='\\<V>'), Constant(value='\\<W>'), Constant(value='\\<X>'), Constant(value='\\<Y>'), Constant(value='\\<Z>'), Constant(value='\\<a>'), Constant(value='\\<b>'), Constant(value='\\<c>'), Constant(value='\\<d>'), Constant(value='\\<e>'), Constant(value='\\<f>'), Constant(value='\\<g>'), Constant(value='\\<h>'), Constant(value='\\<i>'), Constant(value='\\<j>'), Constant(value='\\<k>'), Constant(value='\\<l>'), Constant(value='\\<m>'), Constant(value='\\<n>'), Constant(value='\\<o>'), Constant(value='\\<p>'), Constant(value='\\<q>'), Constant(value='\\<r>'), Constant(value='\\<s>'), Constant(value='\\<t>'), Constant(value='\\<u>'), Constant(value='\\<v>'), Constant(value='\\<w>'), Constant(value='\\<x>'), Constant(value='\\<y>'), Constant(value='\\<z>'), Constant(value='\\<AA>'), Constant(value='\\<BB>'), Constant(value='\\<CC>'), Constant(value='\\<DD>'), Constant(value='\\<EE>'), Constant(value='\\<FF>'), Constant(value='\\<GG>'), Constant(value='\\<HH>'), Constant(value='\\<II>'), Constant(value='\\<JJ>'), Constant(value='\\<KK>'), Constant(value='\\<LL>'), Constant(value='\\<MM>'), Constant(value='\\<NN>'), Constant(value='\\<OO>'), Constant(value='\\<PP>'), Constant(value='\\<QQ>'), Constant(value='\\<RR>'), Constant(value='\\<SS>'), Constant(value='\\<TT>'), Constant(value='\\<UU>'), Constant(value='\\<VV>'), Constant(value='\\<WW>'), Constant(value='\\<XX>'), Constant(value='\\<YY>'), Constant(value='\\<ZZ>'), Constant(value='\\<aa>'), Constant(value='\\<bb>'), Constant(value='\\<cc>'), Constant(value='\\<dd>'), Constant(value='\\<ee>'), Constant(value='\\<ff>'), Constant(value='\\<gg>'), Constant(value='\\<hh>'), Constant(value='\\<ii>'), Constant(value='\\<jj>'), Constant(value='\\<kk>'), Constant(value='\\<ll>'), Constant(value='\\<mm>'), Constant(value='\\<nn>'), Constant(value='\\<oo>'), Constant(value='\\<pp>'), Constant(value='\\<qq>'), Constant(value='\\<rr>'), Constant(value='\\<ss>'), Constant(value='\\<tt>'), Constant(value='\\<uu>'), Constant(value='\\<vv>'), Constant(value='\\<ww>'), Constant(value='\\<xx>'), Constant(value='\\<yy>'), Constant(value='\\<zz>'), Constant(value='\\<alpha>'), Constant(value='\\<beta>'), Constant(value='\\<gamma>'), Constant(value='\\<delta>'), Constant(value='\\<epsilon>'), Constant(value='\\<zeta>'), Constant(value='\\<eta>'), Constant(value='\\<theta>'), Constant(value='\\<iota>'), Constant(value='\\<kappa>'), Constant(value='\\<lambda>'), Constant(value='\\<mu>'), Constant(value='\\<nu>'), Constant(value='\\<xi>'), Constant(value='\\<pi>'), Constant(value='\\<rho>'), Constant(value='\\<sigma>'), Constant(value='\\<tau>'), Constant(value='\\<upsilon>'), Constant(value='\\<phi>'), Constant(value='\\<chi>'), Constant(value='\\<psi>'), Constant(value='\\<omega>'), Constant(value='\\<Gamma>'), Constant(value='\\<Delta>'), Constant(value='\\<Theta>'), Constant(value='\\<Lambda>'), Constant(value='\\<Xi>'), Constant(value='\\<Pi>'), Constant(value='\\<Sigma>'), Constant(value='\\<Upsilon>'), Constant(value='\\<Phi>'), Constant(value='\\<Psi>'), Constant(value='\\<Omega>'), Constant(value='\\<bool>'), Constant(value='\\<complex>'), Constant(value='\\<nat>'), Constant(value='\\<rat>'), Constant(value='\\<real>'), Constant(value='\\<int>'), Constant(value='\\<leftarrow>'), Constant(value='\\<longleftarrow>'), Constant(value='\\<rightarrow>'), Constant(value='\\<longrightarrow>'), Constant(value='\\<Leftarrow>'), Constant(value='\\<Longleftarrow>'), Constant(value='\\<Rightarrow>'), Constant(value='\\<Longrightarrow>'), Constant(value='\\<leftrightarrow>'), Constant(value='\\<longleftrightarrow>'), Constant(value='\\<Leftrightarrow>'), Constant(value='\\<Longleftrightarrow>'), Constant(value='\\<mapsto>'), Constant(value='\\<longmapsto>'), Constant(value='\\<midarrow>'), Constant(value='\\<Midarrow>'), Constant(value='\\<hookleftarrow>'), Constant(value='\\<hookrightarrow>'), Constant(value='\\<leftharpoondown>'), Constant(value='\\<rightharpoondown>'), Constant(value='\\<leftharpoonup>'), Constant(value='\\<rightharpoonup>'), Constant(value='\\<rightleftharpoons>'), Constant(value='\\<leadsto>'), Constant(value='\\<downharpoonleft>'), Constant(value='\\<downharpoonright>'), Constant(value='\\<upharpoonleft>'), Constant(value='\\<upharpoonright>'), Constant(value='\\<restriction>'), Constant(value='\\<Colon>'), Constant(value='\\<up>'), Constant(value='\\<Up>'), Constant(value='\\<down>'), Constant(value='\\<Down>'), Constant(value='\\<updown>'), Constant(value='\\<Updown>'), Constant(value='\\<langle>'), Constant(value='\\<rangle>'), Constant(value='\\<lceil>'), Constant(value='\\<rceil>'), Constant(value='\\<lfloor>'), Constant(value='\\<rfloor>'), Constant(value='\\<lparr>'), Constant(value='\\<rparr>'), Constant(value='\\<lbrakk>'), Constant(value='\\<rbrakk>'), Constant(value='\\<lbrace>'), Constant(value='\\<rbrace>'), Constant(value='\\<guillemotleft>'), Constant(value='\\<guillemotright>'), Constant(value='\\<bottom>'), Constant(value='\\<top>'), Constant(value='\\<and>'), Constant(value='\\<And>'), Constant(value='\\<or>'), Constant(value='\\<Or>'), Constant(value='\\<forall>'), Constant(value='\\<exists>'), Constant(value='\\<nexists>'), Constant(value='\\<not>'), Constant(value='\\<box>'), Constant(value='\\<diamond>'), Constant(value='\\<turnstile>'), Constant(value='\\<Turnstile>'), Constant(value='\\<tturnstile>'), Constant(value='\\<TTurnstile>'), Constant(value='\\<stileturn>'), Constant(value='\\<surd>'), Constant(value='\\<le>'), Constant(value='\\<ge>'), Constant(value='\\<lless>'), Constant(value='\\<ggreater>'), Constant(value='\\<lesssim>'), Constant(value='\\<greatersim>'), Constant(value='\\<lessapprox>'), Constant(value='\\<greaterapprox>'), Constant(value='\\<in>'), Constant(value='\\<notin>'), Constant(value='\\<subset>'), Constant(value='\\<supset>'), Constant(value='\\<subseteq>'), Constant(value='\\<supseteq>'), Constant(value='\\<sqsubset>'), Constant(value='\\<sqsupset>'), Constant(value='\\<sqsubseteq>'), Constant(value='\\<sqsupseteq>'), Constant(value='\\<inter>'), Constant(value='\\<Inter>'), Constant(value='\\<union>'), Constant(value='\\<Union>'), Constant(value='\\<squnion>'), Constant(value='\\<Squnion>'), Constant(value='\\<sqinter>'), Constant(value='\\<Sqinter>'), Constant(value='\\<setminus>'), Constant(value='\\<propto>'), Constant(value='\\<uplus>'), Constant(value='\\<Uplus>'), Constant(value='\\<noteq>'), Constant(value='\\<sim>'), Constant(value='\\<doteq>'), Constant(value='\\<simeq>'), Constant(value='\\<approx>'), Constant(value='\\<asymp>'), Constant(value='\\<cong>'), Constant(value='\\<smile>'), Constant(value='\\<equiv>'), Constant(value='\\<frown>'), Constant(value='\\<Join>'), Constant(value='\\<bowtie>'), Constant(value='\\<prec>'), Constant(value='\\<succ>'), Constant(value='\\<preceq>'), Constant(value='\\<succeq>'), Constant(value='\\<parallel>'), Constant(value='\\<bar>'), Constant(value='\\<plusminus>'), Constant(value='\\<minusplus>'), Constant(value='\\<times>'), Constant(value='\\<div>'), Constant(value='\\<cdot>'), Constant(value='\\<star>'), Constant(value='\\<bullet>'), Constant(value='\\<circ>'), Constant(value='\\<dagger>'), Constant(value='\\<ddagger>'), Constant(value='\\<lhd>'), Constant(value='\\<rhd>'), Constant(value='\\<unlhd>'), Constant(value='\\<unrhd>'), Constant(value='\\<triangleleft>'), Constant(value='\\<triangleright>'), Constant(value='\\<triangle>'), Constant(value='\\<triangleq>'), Constant(value='\\<oplus>'), Constant(value='\\<Oplus>'), Constant(value='\\<otimes>'), Constant(value='\\<Otimes>'), Constant(value='\\<odot>'), Constant(value='\\<Odot>'), Constant(value='\\<ominus>'), Constant(value='\\<oslash>'), Constant(value='\\<dots>'), Constant(value='\\<cdots>'), Constant(value='\\<Sum>'), Constant(value='\\<Prod>'), Constant(value='\\<Coprod>'), Constant(value='\\<infinity>'), Constant(value='\\<integral>'), Constant(value='\\<ointegral>'), Constant(value='\\<clubsuit>'), Constant(value='\\<diamondsuit>'), Constant(value='\\<heartsuit>'), Constant(value='\\<spadesuit>'), Constant(value='\\<aleph>'), Constant(value='\\<emptyset>'), Constant(value='\\<nabla>'), Constant(value='\\<partial>'), Constant(value='\\<flat>'), Constant(value='\\<natural>'), Constant(value='\\<sharp>'), Constant(value='\\<angle>'), Constant(value='\\<copyright>'), Constant(value='\\<registered>'), Constant(value='\\<hyphen>'), Constant(value='\\<inverse>'), Constant(value='\\<onequarter>'), Constant(value='\\<onehalf>'), Constant(value='\\<threequarters>'), Constant(value='\\<ordfeminine>'), Constant(value='\\<ordmasculine>'), Constant(value='\\<section>'), Constant(value='\\<paragraph>'), Constant(value='\\<exclamdown>'), Constant(value='\\<questiondown>'), Constant(value='\\<euro>'), Constant(value='\\<pounds>'), Constant(value='\\<yen>'), Constant(value='\\<cent>'), Constant(value='\\<currency>'), Constant(value='\\<degree>'), Constant(value='\\<amalg>'), Constant(value='\\<mho>'), Constant(value='\\<lozenge>'), Constant(value='\\<wp>'), Constant(value='\\<wrong>'), Constant(value='\\<struct>'), Constant(value='\\<acute>'), Constant(value='\\<index>'), Constant(value='\\<dieresis>'), Constant(value='\\<cedilla>'), Constant(value='\\<hungarumlaut>'), Constant(value='\\<some>'), Constant(value='\\<newline>'), Constant(value='\\<open>'), Constant(value='\\<close>'), Constant(value='\\<here>'), Constant(value='\\<^sub>'), Constant(value='\\<^sup>'), Constant(value='\\<^bold>'), Constant(value='\\<^bsub>'), Constant(value='\\<^esub>'), Constant(value='\\<^bsup>'), Constant(value='\\<^esup>')], values=[Constant(value='𝟬'), Constant(value='𝟭'), Constant(value='𝟮'), Constant(value='𝟯'), Constant(value='𝟰'), Constant(value='𝟱'), Constant(value='𝟲'), Constant(value='𝟳'), Constant(value='𝟴'), Constant(value='𝟵'), Constant(value='𝒜'), Constant(value='ℬ'), Constant(value='𝒞'), Constant(value='𝒟'), Constant(value='ℰ'), Constant(value='ℱ'), Constant(value='𝒢'), Constant(value='ℋ'), Constant(value='ℐ'), Constant(value='𝒥'), Constant(value='𝒦'), Constant(value='ℒ'), Constant(value='ℳ'), Constant(value='𝒩'), Constant(value='𝒪'), Constant(value='𝒫'), Constant(value='𝒬'), Constant(value='ℛ'), Constant(value='𝒮'), Constant(value='𝒯'), Constant(value='𝒰'), Constant(value='𝒱'), Constant(value='𝒲'), Constant(value='𝒳'), Constant(value='𝒴'), Constant(value='𝒵'), Constant(value='𝖺'), Constant(value='𝖻'), Constant(value='𝖼'), Constant(value='𝖽'), Constant(value='𝖾'), Constant(value='𝖿'), Constant(value='𝗀'), Constant(value='𝗁'), Constant(value='𝗂'), Constant(value='𝗃'), Constant(value='𝗄'), Constant(value='𝗅'), Constant(value='𝗆'), Constant(value='𝗇'), Constant(value='𝗈'), Constant(value='𝗉'), Constant(value='𝗊'), Constant(value='𝗋'), Constant(value='𝗌'), Constant(value='𝗍'), Constant(value='𝗎'), Constant(value='𝗏'), Constant(value='𝗐'), Constant(value='𝗑'), Constant(value='𝗒'), Constant(value='𝗓'), Constant(value='𝔄'), Constant(value='𝔅'), Constant(value='ℭ'), Constant(value='𝔇'), Constant(value='𝔈'), Constant(value='𝔉'), Constant(value='𝔊'), Constant(value='ℌ'), Constant(value='ℑ'), Constant(value='𝔍'), Constant(value='𝔎'), Constant(value='𝔏'), Constant(value='𝔐'), Constant(value='𝔑'), Constant(value='𝔒'), Constant(value='𝔓'), Constant(value='𝔔'), Constant(value='ℜ'), Constant(value='𝔖'), Constant(value='𝔗'), Constant(value='𝔘'), Constant(value='𝔙'), Constant(value='𝔚'), Constant(value='𝔛'), Constant(value='𝔜'), Constant(value='ℨ'), Constant(value='𝔞'), Constant(value='𝔟'), Constant(value='𝔠'), Constant(value='𝔡'), Constant(value='𝔢'), Constant(value='𝔣'), Constant(value='𝔤'), Constant(value='𝔥'), Constant(value='𝔦'), Constant(value='𝔧'), Constant(value='𝔨'), Constant(value='𝔩'), Constant(value='𝔪'), Constant(value='𝔫'), Constant(value='𝔬'), Constant(value='𝔭'), Constant(value='𝔮'), Constant(value='𝔯'), Constant(value='𝔰'), Constant(value='𝔱'), Constant(value='𝔲'), Constant(value='𝔳'), Constant(value='𝔴'), Constant(value='𝔵'), Constant(value='𝔶'), Constant(value='𝔷'), Constant(value='α'), Constant(value='β'), Constant(value='γ'), Constant(value='δ'), Constant(value='ε'), Constant(value='ζ'), Constant(value='η'), Constant(value='θ'), Constant(value='ι'), Constant(value='κ'), Constant(value='λ'), Constant(value='μ'), Constant(value='ν'), Constant(value='ξ'), Constant(value='π'), Constant(value='ρ'), Constant(value='σ'), Constant(value='τ'), Constant(value='υ'), Constant(value='φ'), Constant(value='χ'), Constant(value='ψ'), Constant(value='ω'), Constant(value='Γ'), Constant(value='Δ'), Constant(value='Θ'), Constant(value='Λ'), Constant(value='Ξ'), Constant(value='Π'), Constant(value='Σ'), Constant(value='Υ'), Constant(value='Φ'), Constant(value='Ψ'), Constant(value='Ω'), Constant(value='𝔹'), Constant(value='ℂ'), Constant(value='ℕ'), Constant(value='ℚ'), Constant(value='ℝ'), Constant(value='ℤ'), Constant(value='←'), Constant(value='⟵'), Constant(value='→'), Constant(value='⟶'), Constant(value='⇐'), Constant(value='⟸'), Constant(value='⇒'), Constant(value='⟹'), Constant(value='↔'), Constant(value='⟷'), Constant(value='⇔'), Constant(value='⟺'), Constant(value='↦'), Constant(value='⟼'), Constant(value='─'), Constant(value='═'), Constant(value='↩'), Constant(value='↪'), Constant(value='↽'), Constant(value='⇁'), Constant(value='↼'), Constant(value='⇀'), Constant(value='⇌'), Constant(value='↝'), Constant(value='⇃'), Constant(value='⇂'), Constant(value='↿'), Constant(value='↾'), Constant(value='↾'), Constant(value='∷'), Constant(value='↑'), Constant(value='⇑'), Constant(value='↓'), Constant(value='⇓'), Constant(value='↕'), Constant(value='⇕'), Constant(value='⟨'), Constant(value='⟩'), Constant(value='⌈'), Constant(value='⌉'), Constant(value='⌊'), Constant(value='⌋'), Constant(value='⦇'), Constant(value='⦈'), Constant(value='⟦'), Constant(value='⟧'), Constant(value='⦃'), Constant(value='⦄'), Constant(value='«'), Constant(value='»'), Constant(value='⊥'), Constant(value='⊤'), Constant(value='∧'), Constant(value='⋀'), Constant(value='∨'), Constant(value='⋁'), Constant(value='∀'), Constant(value='∃'), Constant(value='∄'), Constant(value='¬'), Constant(value='□'), Constant(value='◇'), Constant(value='⊢'), Constant(value='⊨'), Constant(value='⊩'), Constant(value='⊫'), Constant(value='⊣'), Constant(value='√'), Constant(value='≤'), Constant(value='≥'), Constant(value='≪'), Constant(value='≫'), Constant(value='≲'), Constant(value='≳'), Constant(value='⪅'), Constant(value='⪆'), Constant(value='∈'), Constant(value='∉'), Constant(value='⊂'), Constant(value='⊃'), Constant(value='⊆'), Constant(value='⊇'), Constant(value='⊏'), Constant(value='⊐'), Constant(value='⊑'), Constant(value='⊒'), Constant(value='∩'), Constant(value='⋂'), Constant(value='∪'), Constant(value='⋃'), Constant(value='⊔'), Constant(value='⨆'), Constant(value='⊓'), Constant(value='⨅'), Constant(value='∖'), Constant(value='∝'), Constant(value='⊎'), Constant(value='⨄'), Constant(value='≠'), Constant(value='∼'), Constant(value='≐'), Constant(value='≃'), Constant(value='≈'), Constant(value='≍'), Constant(value='≅'), Constant(value='⌣'), Constant(value='≡'), Constant(value='⌢'), Constant(value='⋈'), Constant(value='⨝'), Constant(value='≺'), Constant(value='≻'), Constant(value='≼'), Constant(value='≽'), Constant(value='∥'), Constant(value='¦'), Constant(value='±'), Constant(value='∓'), Constant(value='×'), Constant(value='÷'), Constant(value='⋅'), Constant(value='⋆'), Constant(value='∙'), Constant(value='∘'), Constant(value='†'), Constant(value='‡'), Constant(value='⊲'), Constant(value='⊳'), Constant(value='⊴'), Constant(value='⊵'), Constant(value='◃'), Constant(value='▹'), Constant(value='△'), Constant(value='≜'), Constant(value='⊕'), Constant(value='⨁'), Constant(value='⊗'), Constant(value='⨂'), Constant(value='⊙'), Constant(value='⨀'), Constant(value='⊖'), Constant(value='⊘'), Constant(value='…'), Constant(value='⋯'), Constant(value='∑'), Constant(value='∏'), Constant(value='∐'), Constant(value='∞'), Constant(value='∫'), Constant(value='∮'), Constant(value='♣'), Constant(value='♢'), Constant(value='♡'), Constant(value='♠'), Constant(value='ℵ'), Constant(value='∅'), Constant(value='∇'), Constant(value='∂'), Constant(value='♭'), Constant(value='♮'), Constant(value='♯'), Constant(value='∠'), Constant(value='©'), Constant(value='®'), Constant(value='\xad'), Constant(value='¯'), Constant(value='¼'), Constant(value='½'), Constant(value='¾'), Constant(value='ª'), Constant(value='º'), Constant(value='§'), Constant(value='¶'), Constant(value='¡'), Constant(value='¿'), Constant(value='€'), Constant(value='£'), Constant(value='¥'), Constant(value='¢'), Constant(value='¤'), Constant(value='°'), Constant(value='⨿'), Constant(value='℧'), Constant(value='◊'), Constant(value='℘'), Constant(value='≀'), Constant(value='⋄'), Constant(value='´'), Constant(value='ı'), Constant(value='¨'), Constant(value='¸'), Constant(value='˝'), Constant(value='ϵ'), Constant(value='⏎'), Constant(value='‹'), Constant(value='›'), Constant(value='⌂'), Constant(value='⇩'), Constant(value='⇧'), Constant(value='❙'), Constant(value='⇘'), Constant(value='⇙'), Constant(value='⇗'), Constant(value='⇖')])), Assign(targets=[Name(id='lang_map', ctx=Store())], value=Dict(keys=[Constant(value='isabelle'), Constant(value='latex')], values=[Name(id='isabelle_symbols', ctx=Load()), Name(id='latex_symbols', ctx=Load())])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='options'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='Filter', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(value=Name(id='options', ctx=Load()))])), Assign(targets=[Name(id='lang', ctx=Store())], value=Call(func=Name(id='get_choice_opt', ctx=Load()), args=[Name(id='options', ctx=Load()), Constant(value='lang'), List(elts=[Constant(value='isabelle'), Constant(value='latex')], ctx=Load()), Constant(value='isabelle')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='symbols', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='lang_map', ctx=Load()), slice=Name(id='lang', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lexer'), arg(arg='stream')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Tuple(elts=[Name(id='ttype', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='stream', ctx=Load()), body=[If(test=Compare(left=Name(id='value', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='symbols', ctx=Load())]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='symbols', ctx=Load()), slice=Name(id='value', ctx=Load()), ctx=Load())], ctx=Load())))], orelse=[Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load())))])], orelse=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='KeywordCaseFilter', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Convert keywords to lowercase or uppercase or capitalize them, which\n    means first letter uppercase, rest lowercase.\n\n    This can be useful e.g. if you highlight Pascal code and want to adapt the\n    code to your styleguide.\n\n    Options accepted:\n\n    `case` : string\n       The casing to convert keywords to. Must be one of ``'lower'``,\n       ``'upper'`` or ``'capitalize'``.  The default is ``'lower'``.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='options'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='Filter', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(value=Name(id='options', ctx=Load()))])), Assign(targets=[Name(id='case', ctx=Store())], value=Call(func=Name(id='get_choice_opt', ctx=Load()), args=[Name(id='options', ctx=Load()), Constant(value='case'), List(elts=[Constant(value='lower'), Constant(value='upper'), Constant(value='capitalize')], ctx=Load()), Constant(value='lower')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='convert', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='case', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lexer'), arg(arg='stream')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Tuple(elts=[Name(id='ttype', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='stream', ctx=Load()), body=[If(test=Compare(left=Name(id='ttype', ctx=Load()), ops=[In()], comparators=[Name(id='Keyword', ctx=Load())]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])], ctx=Load())))], orelse=[Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load())))])], orelse=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='NameHighlightFilter', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Highlight a normal Name (and Name.*) token with a different token type.\n\n    Example::\n\n        filter = NameHighlightFilter(\n            names=[\'foo\', \'bar\', \'baz\'],\n            tokentype=Name.Function,\n        )\n\n    This would highlight the names "foo", "bar" and "baz"\n    as functions. `Name.Function` is the default token type.\n\n    Options accepted:\n\n    `names` : list of strings\n      A list of names that should be given the different token type.\n      There is no default.\n    `tokentype` : TokenType or string\n      A token type or a string containing a token type name that is\n      used for highlighting the strings in `names`.  The default is\n      `Name.Function`.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='options'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='Filter', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(value=Name(id='options', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='names', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Name(id='get_list_opt', ctx=Load()), args=[Name(id='options', ctx=Load()), Constant(value='names'), List(elts=[], ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='tokentype', ctx=Store())], value=Call(func=Attribute(value=Name(id='options', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='tokentype')], keywords=[])), If(test=Name(id='tokentype', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='tokentype', ctx=Store())], value=Call(func=Name(id='string_to_tokentype', ctx=Load()), args=[Name(id='tokentype', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='tokentype', ctx=Store())], value=Attribute(value=Name(id='Name', ctx=Load()), attr='Function', ctx=Load()))])], decorator_list=[]), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lexer'), arg(arg='stream')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Tuple(elts=[Name(id='ttype', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='stream', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='ttype', ctx=Load()), ops=[In()], comparators=[Name(id='Name', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='names', ctx=Load())])]), body=[Expr(value=Yield(value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='tokentype', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load())))], orelse=[Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load())))])], orelse=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='ErrorToken', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Pass()], decorator_list=[]), ClassDef(name='RaiseOnErrorTokenFilter', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raise an exception when the lexer generates an error token.\n\n    Options accepted:\n\n    `excclass` : Exception class\n      The exception class to raise.\n      The default is `pygments.filters.ErrorToken`.\n\n    .. versionadded:: 0.8\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='options'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='Filter', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(value=Name(id='options', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exception', ctx=Store())], value=Call(func=Attribute(value=Name(id='options', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='excclass'), Name(id='ErrorToken', ctx=Load())], keywords=[])), Try(body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='exception', ctx=Load()), Name(id='Exception', ctx=Load())], keywords=[])), body=[Raise(exc=Name(id='TypeError', ctx=Load()))], orelse=[])], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='OptionError', ctx=Load()), args=[Constant(value='excclass option is not an exception class')], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lexer'), arg(arg='stream')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Tuple(elts=[Name(id='ttype', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='stream', ctx=Load()), body=[If(test=Compare(left=Name(id='ttype', ctx=Load()), ops=[Is()], comparators=[Name(id='Error', ctx=Load())]), body=[Raise(exc=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='exception', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load())))], orelse=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='VisibleWhitespaceFilter', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Convert tabs, newlines and/or spaces to visible characters.\n\n    Options accepted:\n\n    `spaces` : string or bool\n      If this is a one-character string, spaces will be replaces by this string.\n      If it is another true value, spaces will be replaced by ``·`` (unicode\n      MIDDLE DOT).  If it is a false value, spaces will not be replaced.  The\n      default is ``False``.\n    `tabs` : string or bool\n      The same as for `spaces`, but the default replacement character is ``»``\n      (unicode RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK).  The default value\n      is ``False``.  Note: this will not work if the `tabsize` option for the\n      lexer is nonzero, as tabs will already have been expanded then.\n    `tabsize` : int\n      If tabs are to be replaced by this filter (see the `tabs` option), this\n      is the total number of characters that a tab should be expanded to.\n      The default is ``8``.\n    `newlines` : string or bool\n      The same as for `spaces`, but the default replacement character is ``¶``\n      (unicode PILCROW SIGN).  The default value is ``False``.\n    `wstokentype` : bool\n      If true, give whitespace the special `Whitespace` token type.  This allows\n      styling the visible whitespace differently (e.g. greyed out), but it can\n      disrupt background colors.  The default is ``True``.\n\n    .. versionadded:: 0.8\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='options'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='Filter', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(value=Name(id='options', ctx=Load()))])), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='default', ctx=Store())], ctx=Store()), iter=List(elts=[Tuple(elts=[Constant(value='spaces'), Constant(value='·')], ctx=Load()), Tuple(elts=[Constant(value='tabs'), Constant(value='»')], ctx=Load()), Tuple(elts=[Constant(value='newlines'), Constant(value='¶')], ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='opt', ctx=Store())], value=Call(func=Attribute(value=Name(id='options', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load()), Constant(value=False)], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='opt', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='opt', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)])]), body=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load()), Name(id='opt', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='name', ctx=Load()), BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Name(id='opt', ctx=Load()), Name(id='default', ctx=Load())]), Constant(value='')])], keywords=[]))])], orelse=[]), Assign(targets=[Name(id='tabsize', ctx=Store())], value=Call(func=Name(id='get_int_opt', ctx=Load()), args=[Name(id='options', ctx=Load()), Constant(value='tabsize'), Constant(value=8)], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='tabs', ctx=Load()), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='tabs', ctx=Store()), op=Add(), value=BinOp(left=Constant(value=' '), op=Mult(), right=BinOp(left=Name(id='tabsize', ctx=Load()), op=Sub(), right=Constant(value=1))))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='newlines', ctx=Load()), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='newlines', ctx=Store()), op=Add(), value=Constant(value='\n'))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='wstt', ctx=Store())], value=Call(func=Name(id='get_bool_opt', ctx=Load()), args=[Name(id='options', ctx=Load()), Constant(value='wstokentype'), Constant(value=True)], keywords=[]))], decorator_list=[]), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lexer'), arg(arg='stream')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='wstt', ctx=Load()), body=[Assign(targets=[Name(id='spaces', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='spaces', ctx=Load()), Constant(value=' ')])), Assign(targets=[Name(id='tabs', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='tabs', ctx=Load()), Constant(value='\t')])), Assign(targets=[Name(id='newlines', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='newlines', ctx=Load()), Constant(value='\n')])), Assign(targets=[Name(id='regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='\\s')], keywords=[])), FunctionDef(name='replacefunc', args=arguments(posonlyargs=[], args=[arg(arg='wschar')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='wschar', ctx=Load()), ops=[Eq()], comparators=[Constant(value=' ')]), body=[Return(value=Name(id='spaces', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='wschar', ctx=Load()), ops=[Eq()], comparators=[Constant(value='\t')]), body=[Return(value=Name(id='tabs', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='wschar', ctx=Load()), ops=[Eq()], comparators=[Constant(value='\n')]), body=[Return(value=Name(id='newlines', ctx=Load()))], orelse=[])])]), Return(value=Name(id='wschar', ctx=Load()))], decorator_list=[]), For(target=Tuple(elts=[Name(id='ttype', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='stream', ctx=Load()), body=[Expr(value=YieldFrom(value=Call(func=Name(id='_replace_special', ctx=Load()), args=[Name(id='ttype', ctx=Load()), Name(id='value', ctx=Load()), Name(id='regex', ctx=Load()), Name(id='Whitespace', ctx=Load()), Name(id='replacefunc', ctx=Load())], keywords=[])))], orelse=[])], orelse=[Assign(targets=[Tuple(elts=[Name(id='spaces', ctx=Store()), Name(id='tabs', ctx=Store()), Name(id='newlines', ctx=Store())], ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='spaces', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='tabs', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='newlines', ctx=Load())], ctx=Load())), For(target=Tuple(elts=[Name(id='ttype', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='stream', ctx=Load()), body=[If(test=Name(id='spaces', ctx=Load()), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=' '), Name(id='spaces', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='tabs', ctx=Load()), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='\t'), Name(id='tabs', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='newlines', ctx=Load()), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='\n'), Name(id='newlines', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load())))], orelse=[])])], decorator_list=[])], decorator_list=[]), ClassDef(name='GobbleFilter', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Gobbles source code lines (eats initial characters).\n\n    This filter drops the first ``n`` characters off every line of code.  This\n    may be useful when the source code fed to the lexer is indented by a fixed\n    amount of space that isn't desired in the output.\n\n    Options accepted:\n\n    `n` : int\n       The number of characters to gobble.\n\n    .. versionadded:: 1.2\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='options'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='Filter', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(value=Name(id='options', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='n', ctx=Store())], value=Call(func=Name(id='get_int_opt', ctx=Load()), args=[Name(id='options', ctx=Load()), Constant(value='n'), Constant(value=0)], keywords=[]))], decorator_list=[]), FunctionDef(name='gobble', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value'), arg(arg='left')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='left', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])]), body=[Return(value=Tuple(elts=[Subscript(value=Name(id='value', ctx=Load()), slice=Slice(lower=Name(id='left', ctx=Load())), ctx=Load()), Constant(value=0)], ctx=Load()))], orelse=[Return(value=Tuple(elts=[Constant(value=''), BinOp(left=Name(id='left', ctx=Load()), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], ctx=Load()))])], decorator_list=[]), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lexer'), arg(arg='stream')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='n', ctx=Load())), Assign(targets=[Name(id='left', ctx=Store())], value=Name(id='n', ctx=Load())), For(target=Tuple(elts=[Name(id='ttype', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='stream', ctx=Load()), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Tuple(elts=[Subscript(value=Name(id='parts', ctx=Load()), slice=Constant(value=0), ctx=Store()), Name(id='left', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='gobble', ctx=Load()), args=[Subscript(value=Name(id='parts', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='left', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=1), Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[])], keywords=[]), body=[Assign(targets=[Tuple(elts=[Subscript(value=Name(id='parts', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store()), Name(id='left', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='gobble', ctx=Load()), args=[Subscript(value=Name(id='parts', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), Name(id='n', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='')]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='ttype', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load())))], orelse=[])], orelse=[])], decorator_list=[])], decorator_list=[]), ClassDef(name='TokenMergeFilter', bases=[Name(id='Filter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Merges consecutive tokens with the same token type in the output\n    stream of a lexer.\n\n    .. versionadded:: 1.2\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='options'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='Filter', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(value=Name(id='options', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='filter', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='lexer'), arg(arg='stream')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='current_type', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='current_value', ctx=Store())], value=Constant(value=None)), For(target=Tuple(elts=[Name(id='ttype', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='stream', ctx=Load()), body=[If(test=Compare(left=Name(id='ttype', ctx=Load()), ops=[Is()], comparators=[Name(id='current_type', ctx=Load())]), body=[AugAssign(target=Name(id='current_value', ctx=Store()), op=Add(), value=Name(id='value', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='current_type', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='current_type', ctx=Load()), Name(id='current_value', ctx=Load())], ctx=Load())))], orelse=[]), Assign(targets=[Name(id='current_type', ctx=Store())], value=Name(id='ttype', ctx=Load())), Assign(targets=[Name(id='current_value', ctx=Store())], value=Name(id='value', ctx=Load()))])], orelse=[]), If(test=Compare(left=Name(id='current_type', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Tuple(elts=[Name(id='current_type', ctx=Load()), Name(id='current_value', ctx=Load())], ctx=Load())))], orelse=[])], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='FILTERS', ctx=Store())], value=Dict(keys=[Constant(value='codetagify'), Constant(value='keywordcase'), Constant(value='highlight'), Constant(value='raiseonerror'), Constant(value='whitespace'), Constant(value='gobble'), Constant(value='tokenmerge'), Constant(value='symbols')], values=[Name(id='CodeTagFilter', ctx=Load()), Name(id='KeywordCaseFilter', ctx=Load()), Name(id='NameHighlightFilter', ctx=Load()), Name(id='RaiseOnErrorTokenFilter', ctx=Load()), Name(id='VisibleWhitespaceFilter', ctx=Load()), Name(id='GobbleFilter', ctx=Load()), Name(id='TokenMergeFilter', ctx=Load()), Name(id='SymbolFilter', ctx=Load())]))], type_ignores=[])