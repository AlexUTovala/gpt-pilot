Module(body=[Expr(value=Constant(value='\nrequests.utils\n~~~~~~~~~~~~~~\n\nThis module provides utility functions that are used within Requests\nthat are also useful for external consumption.\n')), Import(names=[alias(name='codecs')]), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='io')]), Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), Import(names=[alias(name='socket')]), Import(names=[alias(name='struct')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='tempfile')]), Import(names=[alias(name='warnings')]), Import(names=[alias(name='zipfile')]), ImportFrom(module='collections', names=[alias(name='OrderedDict')], level=0), ImportFrom(module='pip._vendor.urllib3.util', names=[alias(name='make_headers'), alias(name='parse_url')], level=0), ImportFrom(names=[alias(name='certs')], level=1), ImportFrom(module='__version__', names=[alias(name='__version__')], level=1), ImportFrom(module='_internal_utils', names=[alias(name='_HEADER_VALIDATORS_BYTE'), alias(name='_HEADER_VALIDATORS_STR'), alias(name='HEADER_VALIDATORS'), alias(name='to_native_string')], level=1), ImportFrom(module='compat', names=[alias(name='Mapping'), alias(name='basestring'), alias(name='bytes'), alias(name='getproxies'), alias(name='getproxies_environment'), alias(name='integer_types')], level=1), ImportFrom(module='compat', names=[alias(name='parse_http_list', asname='_parse_list_header')], level=1), ImportFrom(module='compat', names=[alias(name='proxy_bypass'), alias(name='proxy_bypass_environment'), alias(name='quote'), alias(name='str'), alias(name='unquote'), alias(name='urlparse'), alias(name='urlunparse')], level=1), ImportFrom(module='cookies', names=[alias(name='cookiejar_from_dict')], level=1), ImportFrom(module='exceptions', names=[alias(name='FileModeWarning'), alias(name='InvalidHeader'), alias(name='InvalidURL'), alias(name='UnrewindableBodyError')], level=1), ImportFrom(module='structures', names=[alias(name='CaseInsensitiveDict')], level=1), Assign(targets=[Name(id='NETRC_FILES', ctx=Store())], value=Tuple(elts=[Constant(value='.netrc'), Constant(value='_netrc')], ctx=Load())), Assign(targets=[Name(id='DEFAULT_CA_BUNDLE_PATH', ctx=Store())], value=Call(func=Attribute(value=Name(id='certs', ctx=Load()), attr='where', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='DEFAULT_PORTS', ctx=Store())], value=Dict(keys=[Constant(value='http'), Constant(value='https')], values=[Constant(value=80), Constant(value=443)])), Assign(targets=[Name(id='DEFAULT_ACCEPT_ENCODING', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',\\s*'), Subscript(value=Call(func=Name(id='make_headers', ctx=Load()), args=[], keywords=[keyword(arg='accept_encoding', value=Constant(value=True))]), slice=Constant(value='accept-encoding'), ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='platform', ctx=Load()), ops=[Eq()], comparators=[Constant(value='win32')]), body=[FunctionDef(name='proxy_bypass_registry', args=arguments(posonlyargs=[], args=[arg(arg='host')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Import(names=[alias(name='winreg')])], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[]), Try(body=[Assign(targets=[Name(id='internetSettings', ctx=Store())], value=Call(func=Attribute(value=Name(id='winreg', ctx=Load()), attr='OpenKey', ctx=Load()), args=[Attribute(value=Name(id='winreg', ctx=Load()), attr='HKEY_CURRENT_USER', ctx=Load()), Constant(value='Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings')], keywords=[])), Assign(targets=[Name(id='proxyEnable', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Subscript(value=Call(func=Attribute(value=Name(id='winreg', ctx=Load()), attr='QueryValueEx', ctx=Load()), args=[Name(id='internetSettings', ctx=Load()), Constant(value='ProxyEnable')], keywords=[]), slice=Constant(value=0), ctx=Load())], keywords=[])), Assign(targets=[Name(id='proxyOverride', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='winreg', ctx=Load()), attr='QueryValueEx', ctx=Load()), args=[Name(id='internetSettings', ctx=Load()), Constant(value='ProxyOverride')], keywords=[]), slice=Constant(value=0), ctx=Load()))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='OSError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[]), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='proxyEnable', ctx=Load())), UnaryOp(op=Not(), operand=Name(id='proxyOverride', ctx=Load()))]), body=[Return(value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='proxyOverride', ctx=Store())], value=Call(func=Attribute(value=Name(id='proxyOverride', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=';')], keywords=[])), For(target=Name(id='test', ctx=Store()), iter=Name(id='proxyOverride', ctx=Load()), body=[If(test=Compare(left=Name(id='test', ctx=Load()), ops=[Eq()], comparators=[Constant(value='<local>')]), body=[If(test=Compare(left=Constant(value='.'), ops=[NotIn()], comparators=[Name(id='host', ctx=Load())]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Assign(targets=[Name(id='test', ctx=Store())], value=Call(func=Attribute(value=Name(id='test', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='.'), Constant(value='\\.')], keywords=[])), Assign(targets=[Name(id='test', ctx=Store())], value=Call(func=Attribute(value=Name(id='test', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='*'), Constant(value='.*')], keywords=[])), Assign(targets=[Name(id='test', ctx=Store())], value=Call(func=Attribute(value=Name(id='test', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='?'), Constant(value='.')], keywords=[])), If(test=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='test', ctx=Load()), Name(id='host', ctx=Load()), Attribute(value=Name(id='re', ctx=Load()), attr='I', ctx=Load())], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='proxy_bypass', args=arguments(posonlyargs=[], args=[arg(arg='host')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return True, if the host should be bypassed.\n\n        Checks proxy settings gathered from the environment, if specified,\n        or the registry.\n        ')), If(test=Call(func=Name(id='getproxies_environment', ctx=Load()), args=[], keywords=[]), body=[Return(value=Call(func=Name(id='proxy_bypass_environment', ctx=Load()), args=[Name(id='host', ctx=Load())], keywords=[]))], orelse=[Return(value=Call(func=Name(id='proxy_bypass_registry', ctx=Load()), args=[Name(id='host', ctx=Load())], keywords=[]))])], decorator_list=[])], orelse=[]), FunctionDef(name='dict_to_sequence', args=arguments(posonlyargs=[], args=[arg(arg='d')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns an internal sequence dictionary update.')), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='d', ctx=Load()), Constant(value='items')], keywords=[]), body=[Assign(targets=[Name(id='d', ctx=Store())], value=Call(func=Attribute(value=Name(id='d', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='d', ctx=Load()))], decorator_list=[]), FunctionDef(name='super_len', args=arguments(posonlyargs=[], args=[arg(arg='o')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='total_length', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='current_position', ctx=Store())], value=Constant(value=0)), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='o', ctx=Load()), Constant(value='__len__')], keywords=[]), body=[Assign(targets=[Name(id='total_length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='o', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='o', ctx=Load()), Constant(value='len')], keywords=[]), body=[Assign(targets=[Name(id='total_length', ctx=Store())], value=Attribute(value=Name(id='o', ctx=Load()), attr='len', ctx=Load()))], orelse=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='o', ctx=Load()), Constant(value='fileno')], keywords=[]), body=[Try(body=[Assign(targets=[Name(id='fileno', ctx=Store())], value=Call(func=Attribute(value=Name(id='o', ctx=Load()), attr='fileno', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Attribute(value=Name(id='io', ctx=Load()), attr='UnsupportedOperation', ctx=Load()), Name(id='AttributeError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[Assign(targets=[Name(id='total_length', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='fstat', ctx=Load()), args=[Name(id='fileno', ctx=Load())], keywords=[]), attr='st_size', ctx=Load())), If(test=Compare(left=Constant(value='b'), ops=[NotIn()], comparators=[Attribute(value=Name(id='o', ctx=Load()), attr='mode', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value="Requests has determined the content-length for this request using the binary size of the file: however, the file has been opened in text mode (i.e. without the 'b' flag in the mode). This may lead to an incorrect content-length. In Requests 3.0, support will be removed for files in text mode."), Name(id='FileModeWarning', ctx=Load())], keywords=[]))], orelse=[])], finalbody=[])], orelse=[])])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='o', ctx=Load()), Constant(value='tell')], keywords=[]), body=[Try(body=[Assign(targets=[Name(id='current_position', ctx=Store())], value=Call(func=Attribute(value=Name(id='o', ctx=Load()), attr='tell', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[If(test=Compare(left=Name(id='total_length', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='current_position', ctx=Store())], value=Name(id='total_length', ctx=Load()))], orelse=[])])], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='o', ctx=Load()), Constant(value='seek')], keywords=[]), Compare(left=Name(id='total_length', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='o', ctx=Load()), attr='seek', ctx=Load()), args=[Constant(value=0), Constant(value=2)], keywords=[])), Assign(targets=[Name(id='total_length', ctx=Store())], value=Call(func=Attribute(value=Name(id='o', ctx=Load()), attr='tell', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='o', ctx=Load()), attr='seek', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='current_position', ctx=Load()), Constant(value=0)])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Assign(targets=[Name(id='total_length', ctx=Store())], value=Constant(value=0))])], orelse=[], finalbody=[])], orelse=[])], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='total_length', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='total_length', ctx=Store())], value=Constant(value=0))], orelse=[]), Return(value=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), BinOp(left=Name(id='total_length', ctx=Load()), op=Sub(), right=Name(id='current_position', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='get_netrc_auth', args=arguments(posonlyargs=[], args=[arg(arg='url'), arg(arg='raise_errors')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Returns the Requests tuple auth for a given url from netrc.')), Assign(targets=[Name(id='netrc_file', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='NETRC')], keywords=[])), If(test=Compare(left=Name(id='netrc_file', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='netrc_locations', ctx=Store())], value=Tuple(elts=[Name(id='netrc_file', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Name(id='netrc_locations', ctx=Store())], value=GeneratorExp(elt=JoinedStr(values=[Constant(value='~/'), FormattedValue(value=Name(id='f', ctx=Load()), conversion=-1)]), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Name(id='NETRC_FILES', ctx=Load()), ifs=[], is_async=0)]))]), Try(body=[ImportFrom(module='netrc', names=[alias(name='NetrcParseError'), alias(name='netrc')], level=0), Assign(targets=[Name(id='netrc_path', ctx=Store())], value=Constant(value=None)), For(target=Name(id='f', ctx=Store()), iter=Name(id='netrc_locations', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='expanduser', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Return()])], orelse=[], finalbody=[]), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='loc', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='netrc_path', ctx=Store())], value=Name(id='loc', ctx=Load())), Break()], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='netrc_path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return()], orelse=[]), Assign(targets=[Name(id='ri', ctx=Store())], value=Call(func=Name(id='urlparse', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='splitstr', ctx=Store())], value=Constant(value=b':')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='url', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='splitstr', ctx=Store())], value=Call(func=Attribute(value=Name(id='splitstr', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value='ascii')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='host', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='ri', ctx=Load()), attr='netloc', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='splitstr', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), Try(body=[Assign(targets=[Name(id='_netrc', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='netrc', ctx=Load()), args=[Name(id='netrc_path', ctx=Load())], keywords=[]), attr='authenticators', ctx=Load()), args=[Name(id='host', ctx=Load())], keywords=[])), If(test=Name(id='_netrc', ctx=Load()), body=[Assign(targets=[Name(id='login_i', ctx=Store())], value=IfExp(test=Subscript(value=Name(id='_netrc', ctx=Load()), slice=Constant(value=0), ctx=Load()), body=Constant(value=0), orelse=Constant(value=1))), Return(value=Tuple(elts=[Subscript(value=Name(id='_netrc', ctx=Load()), slice=Name(id='login_i', ctx=Load()), ctx=Load()), Subscript(value=Name(id='_netrc', ctx=Load()), slice=Constant(value=2), ctx=Load())], ctx=Load()))], orelse=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='NetrcParseError', ctx=Load()), Name(id='OSError', ctx=Load())], ctx=Load()), body=[If(test=Name(id='raise_errors', ctx=Load()), body=[Raise()], orelse=[])])], orelse=[], finalbody=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ImportError', ctx=Load()), Name(id='AttributeError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='guess_filename', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Tries to guess the filename of the given object.')), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='obj', ctx=Load()), Constant(value='name'), Constant(value=None)], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='name', ctx=Load()), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='basestring', ctx=Load())], keywords=[]), Compare(left=Subscript(value=Name(id='name', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[NotEq()], comparators=[Constant(value='<')]), Compare(left=Subscript(value=Name(id='name', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), ops=[NotEq()], comparators=[Constant(value='>')])]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='extract_zipped_paths', args=arguments(posonlyargs=[], args=[arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Replace nonexistent paths that look like they refer to a member of a zip\n    archive with the location of an extracted copy of the target, or else\n    just return the provided path unchanged.\n    ')), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[]), body=[Return(value=Name(id='path', ctx=Load()))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='archive', ctx=Store()), Name(id='member', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), While(test=BoolOp(op=And(), values=[Name(id='archive', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='archive', ctx=Load())], keywords=[]))]), body=[Assign(targets=[Tuple(elts=[Name(id='archive', ctx=Store()), Name(id='prefix', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='archive', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='prefix', ctx=Load())), body=[Break()], orelse=[]), Assign(targets=[Name(id='member', ctx=Store())], value=Call(func=Attribute(value=Constant(value='/'), attr='join', ctx=Load()), args=[List(elts=[Name(id='prefix', ctx=Load()), Name(id='member', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='zipfile', ctx=Load()), attr='is_zipfile', ctx=Load()), args=[Name(id='archive', ctx=Load())], keywords=[])), body=[Return(value=Name(id='path', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='zip_file', ctx=Store())], value=Call(func=Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load()), args=[Name(id='archive', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='member', ctx=Load()), ops=[NotIn()], comparators=[Call(func=Attribute(value=Name(id='zip_file', ctx=Load()), attr='namelist', ctx=Load()), args=[], keywords=[])]), body=[Return(value=Name(id='path', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='tmp', ctx=Store())], value=Call(func=Attribute(value=Name(id='tempfile', ctx=Load()), attr='gettempdir', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='extracted_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='tmp', ctx=Load()), Subscript(value=Call(func=Attribute(value=Name(id='member', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='/')], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='extracted_path', ctx=Load())], keywords=[])), body=[With(items=[withitem(context_expr=Call(func=Name(id='atomic_open', ctx=Load()), args=[Name(id='extracted_path', ctx=Load())], keywords=[]), optional_vars=Name(id='file_handler', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='file_handler', ctx=Load()), attr='write', ctx=Load()), args=[Call(func=Attribute(value=Name(id='zip_file', ctx=Load()), attr='read', ctx=Load()), args=[Name(id='member', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[]), Return(value=Name(id='extracted_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='atomic_open', args=arguments(posonlyargs=[], args=[arg(arg='filename')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Write a file to the disk in an atomic fashion')), Assign(targets=[Tuple(elts=[Name(id='tmp_descriptor', ctx=Store()), Name(id='tmp_name', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='tempfile', ctx=Load()), attr='mkstemp', ctx=Load()), args=[], keywords=[keyword(arg='dir', value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]))])), Try(body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='fdopen', ctx=Load()), args=[Name(id='tmp_descriptor', ctx=Load()), Constant(value='wb')], keywords=[]), optional_vars=Name(id='tmp_handler', ctx=Store()))], body=[Expr(value=Yield(value=Name(id='tmp_handler', ctx=Load())))]), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='replace', ctx=Load()), args=[Name(id='tmp_name', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='BaseException', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='tmp_name', ctx=Load())], keywords=[])), Raise()])], orelse=[], finalbody=[])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='from_key_val_list', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Take an object and test to see if it can be represented as a\n    dictionary. Unless it can not be represented as such, return an\n    OrderedDict, e.g.,\n\n    ::\n\n        >>> from_key_val_list([('key', 'val')])\n        OrderedDict([('key', 'val')])\n        >>> from_key_val_list('string')\n        Traceback (most recent call last):\n        ...\n        ValueError: cannot encode objects that are not 2-tuples\n        >>> from_key_val_list({'key': 'val'})\n        OrderedDict([('key', 'val')])\n\n    :rtype: OrderedDict\n    ")), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bytes', ctx=Load()), Name(id='bool', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot encode objects that are not 2-tuples')], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='OrderedDict', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='to_key_val_list', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Take an object and test to see if it can be represented as a\n    dictionary. If it can be, return a list of tuples, e.g.,\n\n    ::\n\n        >>> to_key_val_list([('key', 'val')])\n        [('key', 'val')]\n        >>> to_key_val_list({'key': 'val'})\n        [('key', 'val')]\n        >>> to_key_val_list('string')\n        Traceback (most recent call last):\n        ...\n        ValueError: cannot encode objects that are not 2-tuples\n\n    :rtype: list\n    ")), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bytes', ctx=Load()), Name(id='bool', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot encode objects that are not 2-tuples')], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='Mapping', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='parse_list_header', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parse lists as described by RFC 2068 Section 2.\n\n    In particular, parse comma-separated lists where the elements of\n    the list may include quoted-strings.  A quoted-string could\n    contain a comma.  A non-quoted string could have quotes in the\n    middle.  Quotes are removed automatically after parsing.\n\n    It basically works like :func:`parse_set_header` just that items\n    may appear multiple times and case sensitivity is preserved.\n\n    The return value is a standard :class:`list`:\n\n    >>> parse_list_header(\'token, "quoted value"\')\n    [\'token\', \'quoted value\']\n\n    To create a header from the :class:`list` again, use the\n    :func:`dump_header` function.\n\n    :param value: a string with a list header.\n    :return: :class:`list`\n    :rtype: list\n    ')), Assign(targets=[Name(id='result', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='item', ctx=Store()), iter=Call(func=Name(id='_parse_list_header', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='item', ctx=Load()), slice=Slice(upper=Constant(value=1)), ctx=Load()), ops=[Eq(), Eq()], comparators=[Subscript(value=Name(id='item', ctx=Load()), slice=Slice(lower=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), Constant(value='"')]), body=[Assign(targets=[Name(id='item', ctx=Store())], value=Call(func=Name(id='unquote_header_value', ctx=Load()), args=[Subscript(value=Name(id='item', ctx=Load()), slice=Slice(lower=Constant(value=1), upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='parse_dict_header', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parse lists of key, value pairs as described by RFC 2068 Section 2 and\n    convert them into a python dict:\n\n    >>> d = parse_dict_header(\'foo="is a fish", bar="as well"\')\n    >>> type(d) is dict\n    True\n    >>> sorted(d.items())\n    [(\'bar\', \'as well\'), (\'foo\', \'is a fish\')]\n\n    If there is no value for a key it will be `None`:\n\n    >>> parse_dict_header(\'key_without_value\')\n    {\'key_without_value\': None}\n\n    To create a header from the :class:`dict` again, use the\n    :func:`dump_header` function.\n\n    :param value: a string with a dict header.\n    :return: :class:`dict`\n    :rtype: dict\n    ')), Assign(targets=[Name(id='result', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='item', ctx=Store()), iter=Call(func=Name(id='_parse_list_header', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Constant(value='='), ops=[NotIn()], comparators=[Name(id='item', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='result', ctx=Load()), slice=Name(id='item', ctx=Load()), ctx=Store())], value=Constant(value=None)), Continue()], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='item', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='='), Constant(value=1)], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='value', ctx=Load()), slice=Slice(upper=Constant(value=1)), ctx=Load()), ops=[Eq(), Eq()], comparators=[Subscript(value=Name(id='value', ctx=Load()), slice=Slice(lower=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), Constant(value='"')]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='unquote_header_value', ctx=Load()), args=[Subscript(value=Name(id='value', ctx=Load()), slice=Slice(lower=Constant(value=1), upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='result', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='unquote_header_value', args=arguments(posonlyargs=[], args=[arg(arg='value'), arg(arg='is_filename')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Unquotes a header value.  (Reversal of :func:`quote_header_value`).\n    This does not use the real unquoting but what browsers are actually\n    using for quoting.\n\n    :param value: the header value to unquote.\n    :rtype: str\n    ')), If(test=BoolOp(op=And(), values=[Name(id='value', ctx=Load()), Compare(left=Subscript(value=Name(id='value', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq(), Eq()], comparators=[Subscript(value=Name(id='value', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Constant(value='"')])]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Subscript(value=Name(id='value', ctx=Load()), slice=Slice(lower=Constant(value=1), upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='is_filename', ctx=Load())), Compare(left=Subscript(value=Name(id='value', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[NotEq()], comparators=[Constant(value='\\\\')])]), body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='\\\\'), Constant(value='\\')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='\\"'), Constant(value='"')], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='value', ctx=Load()))], decorator_list=[]), FunctionDef(name='dict_from_cookiejar', args=arguments(posonlyargs=[], args=[arg(arg='cj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns a key/value dictionary from a CookieJar.\n\n    :param cj: CookieJar object to extract cookies from.\n    :rtype: dict\n    ')), Assign(targets=[Name(id='cookie_dict', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='cookie', ctx=Store()), iter=Name(id='cj', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='cookie_dict', ctx=Load()), slice=Attribute(value=Name(id='cookie', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Attribute(value=Name(id='cookie', ctx=Load()), attr='value', ctx=Load()))], orelse=[]), Return(value=Name(id='cookie_dict', ctx=Load()))], decorator_list=[]), FunctionDef(name='add_dict_to_cookiejar', args=arguments(posonlyargs=[], args=[arg(arg='cj'), arg(arg='cookie_dict')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns a CookieJar from a key/value dictionary.\n\n    :param cj: CookieJar to insert cookies into.\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :rtype: CookieJar\n    ')), Return(value=Call(func=Name(id='cookiejar_from_dict', ctx=Load()), args=[Name(id='cookie_dict', ctx=Load()), Name(id='cj', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_encodings_from_content', args=arguments(posonlyargs=[], args=[arg(arg='content')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns encodings from given content string.\n\n    :param content: bytestring to extract encodings from.\n    ')), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='In requests 3.0, get_encodings_from_content will be removed. For more information, please see the discussion on issue #2266. (This warning should only appear once.)'), Name(id='DeprecationWarning', ctx=Load())], keywords=[])), Assign(targets=[Name(id='charset_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='<meta.*?charset=["\\\']*(.+?)["\\\'>]')], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='re', ctx=Load()), attr='I', ctx=Load()))])), Assign(targets=[Name(id='pragma_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='<meta.*?content=["\\\']*;?charset=(.+?)["\\\'>]')], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='re', ctx=Load()), attr='I', ctx=Load()))])), Assign(targets=[Name(id='xml_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^<\\?xml.*?encoding=["\\\']*(.+?)["\\\'>]')], keywords=[])), Return(value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='charset_re', ctx=Load()), attr='findall', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Attribute(value=Name(id='pragma_re', ctx=Load()), attr='findall', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[])), op=Add(), right=Call(func=Attribute(value=Name(id='xml_re', ctx=Load()), attr='findall', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[])))], decorator_list=[]), FunctionDef(name='_parse_content_type_header', args=arguments(posonlyargs=[], args=[arg(arg='header')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns content type and parameters from given header\n\n    :param header: string\n    :return: tuple containing content type and dictionary of\n         parameters\n    ')), Assign(targets=[Name(id='tokens', ctx=Store())], value=Call(func=Attribute(value=Name(id='header', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=';')], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='content_type', ctx=Store()), Name(id='params', ctx=Store())], ctx=Store())], value=Tuple(elts=[Call(func=Attribute(value=Subscript(value=Name(id='tokens', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), Subscript(value=Name(id='tokens', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], ctx=Load())), Assign(targets=[Name(id='params_dict', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='items_to_strip', ctx=Store())], value=Constant(value='"\' ')), For(target=Name(id='param', ctx=Store()), iter=Name(id='params', ctx=Load()), body=[Assign(targets=[Name(id='param', ctx=Store())], value=Call(func=Attribute(value=Name(id='param', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Name(id='param', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='param', ctx=Load()), Constant(value=True)], ctx=Load())), Assign(targets=[Name(id='index_of_equals', ctx=Store())], value=Call(func=Attribute(value=Name(id='param', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='=')], keywords=[])), If(test=Compare(left=Name(id='index_of_equals', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Assign(targets=[Name(id='key', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='param', ctx=Load()), slice=Slice(upper=Name(id='index_of_equals', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[Name(id='items_to_strip', ctx=Load())], keywords=[])), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='param', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='index_of_equals', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load()), attr='strip', ctx=Load()), args=[Name(id='items_to_strip', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='params_dict', ctx=Load()), slice=Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='content_type', ctx=Load()), Name(id='params_dict', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='get_encoding_from_headers', args=arguments(posonlyargs=[], args=[arg(arg='headers')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns encodings from given HTTP Header Dict.\n\n    :param headers: dictionary to extract encoding from.\n    :rtype: str\n    ')), Assign(targets=[Name(id='content_type', ctx=Store())], value=Call(func=Attribute(value=Name(id='headers', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='content-type')], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='content_type', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='content_type', ctx=Store()), Name(id='params', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_parse_content_type_header', ctx=Load()), args=[Name(id='content_type', ctx=Load())], keywords=[])), If(test=Compare(left=Constant(value='charset'), ops=[In()], comparators=[Name(id='params', ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Subscript(value=Name(id='params', ctx=Load()), slice=Constant(value='charset'), ctx=Load()), attr='strip', ctx=Load()), args=[Constant(value='\'"')], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='text'), ops=[In()], comparators=[Name(id='content_type', ctx=Load())]), body=[Return(value=Constant(value='ISO-8859-1'))], orelse=[]), If(test=Compare(left=Constant(value='application/json'), ops=[In()], comparators=[Name(id='content_type', ctx=Load())]), body=[Return(value=Constant(value='utf-8'))], orelse=[])], decorator_list=[]), FunctionDef(name='stream_decode_response_unicode', args=arguments(posonlyargs=[], args=[arg(arg='iterator'), arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Stream decodes an iterator.')), If(test=Compare(left=Attribute(value=Name(id='r', ctx=Load()), attr='encoding', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=YieldFrom(value=Name(id='iterator', ctx=Load()))), Return()], orelse=[]), Assign(targets=[Name(id='decoder', ctx=Store())], value=Call(func=Call(func=Attribute(value=Name(id='codecs', ctx=Load()), attr='getincrementaldecoder', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='encoding', ctx=Load())], keywords=[]), args=[], keywords=[keyword(arg='errors', value=Constant(value='replace'))])), For(target=Name(id='chunk', ctx=Store()), iter=Name(id='iterator', ctx=Load()), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Attribute(value=Name(id='decoder', ctx=Load()), attr='decode', ctx=Load()), args=[Name(id='chunk', ctx=Load())], keywords=[])), If(test=Name(id='rv', ctx=Load()), body=[Expr(value=Yield(value=Name(id='rv', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Attribute(value=Name(id='decoder', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value=b'')], keywords=[keyword(arg='final', value=Constant(value=True))])), If(test=Name(id='rv', ctx=Load()), body=[Expr(value=Yield(value=Name(id='rv', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='iter_slices', args=arguments(posonlyargs=[], args=[arg(arg='string'), arg(arg='slice_length')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterate over slices of a string.')), Assign(targets=[Name(id='pos', ctx=Store())], value=Constant(value=0)), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='slice_length', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='slice_length', ctx=Load()), ops=[LtE()], comparators=[Constant(value=0)])]), body=[Assign(targets=[Name(id='slice_length', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='string', ctx=Load())], keywords=[]))], orelse=[]), While(test=Compare(left=Name(id='pos', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='string', ctx=Load())], keywords=[])]), body=[Expr(value=Yield(value=Subscript(value=Name(id='string', ctx=Load()), slice=Slice(lower=Name(id='pos', ctx=Load()), upper=BinOp(left=Name(id='pos', ctx=Load()), op=Add(), right=Name(id='slice_length', ctx=Load()))), ctx=Load()))), AugAssign(target=Name(id='pos', ctx=Store()), op=Add(), value=Name(id='slice_length', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='get_unicode_from_response', args=arguments(posonlyargs=[], args=[arg(arg='r')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns the requested content back in unicode.\n\n    :param r: Response object to get unicode content from.\n\n    Tried:\n\n    1. charset from content-type\n    2. fall back and replace all unicode characters\n\n    :rtype: str\n    ')), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='In requests 3.0, get_unicode_from_response will be removed. For more information, please see the discussion on issue #2266. (This warning should only appear once.)'), Name(id='DeprecationWarning', ctx=Load())], keywords=[])), Assign(targets=[Name(id='tried_encodings', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='encoding', ctx=Store())], value=Call(func=Name(id='get_encoding_from_headers', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='headers', ctx=Load())], keywords=[])), If(test=Name(id='encoding', ctx=Load()), body=[Try(body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='content', ctx=Load()), Name(id='encoding', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='UnicodeError', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='tried_encodings', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='encoding', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], orelse=[]), Try(body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='r', ctx=Load()), attr='content', ctx=Load()), Name(id='encoding', ctx=Load())], keywords=[keyword(arg='errors', value=Constant(value='replace'))]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Return(value=Attribute(value=Name(id='r', ctx=Load()), attr='content', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), Assign(targets=[Name(id='UNRESERVED_SET', ctx=Store())], value=Call(func=Name(id='frozenset', ctx=Load()), args=[BinOp(left=Constant(value='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'), op=Add(), right=Constant(value='0123456789-._~'))], keywords=[])), FunctionDef(name='unquote_unreserved', args=arguments(posonlyargs=[], args=[arg(arg='uri')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Un-escape any percent-escape sequences in a URI that are unreserved\n    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n\n    :rtype: str\n    ')), Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='uri', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='%')], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=1), Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='h', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='parts', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), slice=Slice(lower=Constant(value=0), upper=Constant(value=2)), ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='h', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), Call(func=Attribute(value=Name(id='h', ctx=Load()), attr='isalnum', ctx=Load()), args=[], keywords=[])]), body=[Try(body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='chr', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='h', ctx=Load()), Constant(value=16)], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='InvalidURL', ctx=Load()), args=[JoinedStr(values=[Constant(value="Invalid percent-escape sequence: '"), FormattedValue(value=Name(id='h', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[]))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='c', ctx=Load()), ops=[In()], comparators=[Name(id='UNRESERVED_SET', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='parts', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store())], value=BinOp(left=Name(id='c', ctx=Load()), op=Add(), right=Subscript(value=Subscript(value=Name(id='parts', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), slice=Slice(lower=Constant(value=2)), ctx=Load())))], orelse=[Assign(targets=[Subscript(value=Name(id='parts', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store())], value=JoinedStr(values=[Constant(value='%'), FormattedValue(value=Subscript(value=Name(id='parts', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), conversion=-1)]))])], orelse=[Assign(targets=[Subscript(value=Name(id='parts', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store())], value=JoinedStr(values=[Constant(value='%'), FormattedValue(value=Subscript(value=Name(id='parts', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), conversion=-1)]))])], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='requote_uri', args=arguments(posonlyargs=[], args=[arg(arg='uri')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Re-quote the given URI.\n\n    This function passes the given URI through an unquote/quote cycle to\n    ensure that it is fully and consistently quoted.\n\n    :rtype: str\n    ')), Assign(targets=[Name(id='safe_with_percent', ctx=Store())], value=Constant(value="!#$%&'()*+,/:;=?@[]~")), Assign(targets=[Name(id='safe_without_percent', ctx=Store())], value=Constant(value="!#$&'()*+,/:;=?@[]~")), Try(body=[Return(value=Call(func=Name(id='quote', ctx=Load()), args=[Call(func=Name(id='unquote_unreserved', ctx=Load()), args=[Name(id='uri', ctx=Load())], keywords=[])], keywords=[keyword(arg='safe', value=Name(id='safe_with_percent', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='InvalidURL', ctx=Load()), body=[Return(value=Call(func=Name(id='quote', ctx=Load()), args=[Name(id='uri', ctx=Load())], keywords=[keyword(arg='safe', value=Name(id='safe_without_percent', ctx=Load()))]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='address_in_network', args=arguments(posonlyargs=[], args=[arg(arg='ip'), arg(arg='net')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n    ')), Assign(targets=[Name(id='ipaddr', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='struct', ctx=Load()), attr='unpack', ctx=Load()), args=[Constant(value='=L'), Call(func=Attribute(value=Name(id='socket', ctx=Load()), attr='inet_aton', ctx=Load()), args=[Name(id='ip', ctx=Load())], keywords=[])], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='netaddr', ctx=Store()), Name(id='bits', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='net', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='/')], keywords=[])), Assign(targets=[Name(id='netmask', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='struct', ctx=Load()), attr='unpack', ctx=Load()), args=[Constant(value='=L'), Call(func=Attribute(value=Name(id='socket', ctx=Load()), attr='inet_aton', ctx=Load()), args=[Call(func=Name(id='dotted_netmask', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='bits', ctx=Load())], keywords=[])], keywords=[])], keywords=[])], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='network', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Attribute(value=Name(id='struct', ctx=Load()), attr='unpack', ctx=Load()), args=[Constant(value='=L'), Call(func=Attribute(value=Name(id='socket', ctx=Load()), attr='inet_aton', ctx=Load()), args=[Name(id='netaddr', ctx=Load())], keywords=[])], keywords=[]), slice=Constant(value=0), ctx=Load()), op=BitAnd(), right=Name(id='netmask', ctx=Load()))), Return(value=Compare(left=BinOp(left=Name(id='ipaddr', ctx=Load()), op=BitAnd(), right=Name(id='netmask', ctx=Load())), ops=[Eq()], comparators=[BinOp(left=Name(id='network', ctx=Load()), op=BitAnd(), right=Name(id='netmask', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='dotted_netmask', args=arguments(posonlyargs=[], args=[arg(arg='mask')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Converts mask from /xx format to xxx.xxx.xxx.xxx\n\n    Example: if mask is 24 function returns 255.255.255.0\n\n    :rtype: str\n    ')), Assign(targets=[Name(id='bits', ctx=Store())], value=BinOp(left=Constant(value=4294967295), op=BitXor(), right=BinOp(left=BinOp(left=Constant(value=1), op=LShift(), right=BinOp(left=Constant(value=32), op=Sub(), right=Name(id='mask', ctx=Load()))), op=Sub(), right=Constant(value=1)))), Return(value=Call(func=Attribute(value=Name(id='socket', ctx=Load()), attr='inet_ntoa', ctx=Load()), args=[Call(func=Attribute(value=Name(id='struct', ctx=Load()), attr='pack', ctx=Load()), args=[Constant(value='>I'), Name(id='bits', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='is_ipv4_address', args=arguments(posonlyargs=[], args=[arg(arg='string_ip')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    :rtype: bool\n    ')), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='socket', ctx=Load()), attr='inet_aton', ctx=Load()), args=[Name(id='string_ip', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='is_valid_cidr', args=arguments(posonlyargs=[], args=[arg(arg='string_network')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Very simple check of the cidr format in no_proxy variable.\n\n    :rtype: bool\n    ')), If(test=Compare(left=Call(func=Attribute(value=Name(id='string_network', ctx=Load()), attr='count', ctx=Load()), args=[Constant(value='/')], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Try(body=[Assign(targets=[Name(id='mask', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Subscript(value=Call(func=Attribute(value=Name(id='string_network', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='/')], keywords=[]), slice=Constant(value=1), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='mask', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), Compare(left=Name(id='mask', ctx=Load()), ops=[Gt()], comparators=[Constant(value=32)])]), body=[Return(value=Constant(value=False))], orelse=[]), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='socket', ctx=Load()), attr='inet_aton', ctx=Load()), args=[Subscript(value=Call(func=Attribute(value=Name(id='string_network', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='/')], keywords=[]), slice=Constant(value=0), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[])], orelse=[Return(value=Constant(value=False))]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='set_environ', args=arguments(posonlyargs=[], args=[arg(arg='env_name'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Set the environment variable 'env_name' to 'value'\n\n    Save previous value, yield, and then restore the previous value stored in\n    the environment variable 'env_name'.\n\n    If 'value' is None, do nothing")), Assign(targets=[Name(id='value_changed', ctx=Store())], value=Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), If(test=Name(id='value_changed', ctx=Load()), body=[Assign(targets=[Name(id='old_value', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='env_name', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Name(id='env_name', ctx=Load()), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[]), Try(body=[Expr(value=Yield())], handlers=[], orelse=[], finalbody=[If(test=Name(id='value_changed', ctx=Load()), body=[If(test=Compare(left=Name(id='old_value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Delete(targets=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Name(id='env_name', ctx=Load()), ctx=Del())])], orelse=[Assign(targets=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Name(id='env_name', ctx=Load()), ctx=Store())], value=Name(id='old_value', ctx=Load()))])], orelse=[])])], decorator_list=[Attribute(value=Name(id='contextlib', ctx=Load()), attr='contextmanager', ctx=Load())]), FunctionDef(name='should_bypass_proxies', args=arguments(posonlyargs=[], args=[arg(arg='url'), arg(arg='no_proxy')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Returns whether we should bypass proxies or not.\n\n    :rtype: bool\n    ')), FunctionDef(name='get_proxy', args=arguments(posonlyargs=[], args=[arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), attr='get', ctx=Load()), args=[Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[])], keywords=[])]))], decorator_list=[]), Assign(targets=[Name(id='no_proxy_arg', ctx=Store())], value=Name(id='no_proxy', ctx=Load())), If(test=Compare(left=Name(id='no_proxy', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='no_proxy', ctx=Store())], value=Call(func=Name(id='get_proxy', ctx=Load()), args=[Constant(value='no_proxy')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Name(id='urlparse', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='parsed', ctx=Load()), attr='hostname', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=True))], orelse=[]), If(test=Name(id='no_proxy', ctx=Load()), body=[Assign(targets=[Name(id='no_proxy', ctx=Store())], value=GeneratorExp(elt=Name(id='host', ctx=Load()), generators=[comprehension(target=Name(id='host', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='no_proxy', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=' '), Constant(value='')], keywords=[]), attr='split', ctx=Load()), args=[Constant(value=',')], keywords=[]), ifs=[Name(id='host', ctx=Load())], is_async=0)])), If(test=Call(func=Name(id='is_ipv4_address', ctx=Load()), args=[Attribute(value=Name(id='parsed', ctx=Load()), attr='hostname', ctx=Load())], keywords=[]), body=[For(target=Name(id='proxy_ip', ctx=Store()), iter=Name(id='no_proxy', ctx=Load()), body=[If(test=Call(func=Name(id='is_valid_cidr', ctx=Load()), args=[Name(id='proxy_ip', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='address_in_network', ctx=Load()), args=[Attribute(value=Name(id='parsed', ctx=Load()), attr='hostname', ctx=Load()), Name(id='proxy_ip', ctx=Load())], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[If(test=Compare(left=Attribute(value=Name(id='parsed', ctx=Load()), attr='hostname', ctx=Load()), ops=[Eq()], comparators=[Name(id='proxy_ip', ctx=Load())]), body=[Return(value=Constant(value=True))], orelse=[])])], orelse=[])], orelse=[Assign(targets=[Name(id='host_with_port', ctx=Store())], value=Attribute(value=Name(id='parsed', ctx=Load()), attr='hostname', ctx=Load())), If(test=Attribute(value=Name(id='parsed', ctx=Load()), attr='port', ctx=Load()), body=[AugAssign(target=Name(id='host_with_port', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value=':'), FormattedValue(value=Attribute(value=Name(id='parsed', ctx=Load()), attr='port', ctx=Load()), conversion=-1)]))], orelse=[]), For(target=Name(id='host', ctx=Store()), iter=Name(id='no_proxy', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Call(func=Attribute(value=Attribute(value=Name(id='parsed', ctx=Load()), attr='hostname', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='host', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='host_with_port', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='host', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[])])], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='set_environ', ctx=Load()), args=[Constant(value='no_proxy'), Name(id='no_proxy_arg', ctx=Load())], keywords=[]))], body=[Try(body=[Assign(targets=[Name(id='bypass', ctx=Store())], value=Call(func=Name(id='proxy_bypass', ctx=Load()), args=[Attribute(value=Name(id='parsed', ctx=Load()), attr='hostname', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='TypeError', ctx=Load()), Attribute(value=Name(id='socket', ctx=Load()), attr='gaierror', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='bypass', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[])]), If(test=Name(id='bypass', ctx=Load()), body=[Return(value=Constant(value=True))], orelse=[]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='get_environ_proxies', args=arguments(posonlyargs=[], args=[arg(arg='url'), arg(arg='no_proxy')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Return a dict of environment proxies.\n\n    :rtype: dict\n    ')), If(test=Call(func=Name(id='should_bypass_proxies', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='no_proxy', value=Name(id='no_proxy', ctx=Load()))]), body=[Return(value=Dict(keys=[], values=[]))], orelse=[Return(value=Call(func=Name(id='getproxies', ctx=Load()), args=[], keywords=[]))])], decorator_list=[]), FunctionDef(name='select_proxy', args=arguments(posonlyargs=[], args=[arg(arg='url'), arg(arg='proxies')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Select a proxy for the url, if applicable.\n\n    :param url: The url being for the request\n    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n    ')), Assign(targets=[Name(id='proxies', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='proxies', ctx=Load()), Dict(keys=[], values=[])])), Assign(targets=[Name(id='urlparts', ctx=Store())], value=Call(func=Name(id='urlparse', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='urlparts', ctx=Load()), attr='hostname', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Attribute(value=Name(id='proxies', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='urlparts', ctx=Load()), attr='scheme', ctx=Load()), Call(func=Attribute(value=Name(id='proxies', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='all')], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='proxy_keys', ctx=Store())], value=List(elts=[BinOp(left=BinOp(left=Attribute(value=Name(id='urlparts', ctx=Load()), attr='scheme', ctx=Load()), op=Add(), right=Constant(value='://')), op=Add(), right=Attribute(value=Name(id='urlparts', ctx=Load()), attr='hostname', ctx=Load())), Attribute(value=Name(id='urlparts', ctx=Load()), attr='scheme', ctx=Load()), BinOp(left=Constant(value='all://'), op=Add(), right=Attribute(value=Name(id='urlparts', ctx=Load()), attr='hostname', ctx=Load())), Constant(value='all')], ctx=Load())), Assign(targets=[Name(id='proxy', ctx=Store())], value=Constant(value=None)), For(target=Name(id='proxy_key', ctx=Store()), iter=Name(id='proxy_keys', ctx=Load()), body=[If(test=Compare(left=Name(id='proxy_key', ctx=Load()), ops=[In()], comparators=[Name(id='proxies', ctx=Load())]), body=[Assign(targets=[Name(id='proxy', ctx=Store())], value=Subscript(value=Name(id='proxies', ctx=Load()), slice=Name(id='proxy_key', ctx=Load()), ctx=Load())), Break()], orelse=[])], orelse=[]), Return(value=Name(id='proxy', ctx=Load()))], decorator_list=[]), FunctionDef(name='resolve_proxies', args=arguments(posonlyargs=[], args=[arg(arg='request'), arg(arg='proxies'), arg(arg='trust_env')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='This method takes proxy information from a request and configuration\n    input to resolve a mapping of target proxies. This will consider settings\n    such a NO_PROXY to strip proxy configurations.\n\n    :param request: Request or PreparedRequest\n    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n    :param trust_env: Boolean declaring whether to trust environment configs\n\n    :rtype: dict\n    ')), Assign(targets=[Name(id='proxies', ctx=Store())], value=IfExp(test=Compare(left=Name(id='proxies', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='proxies', ctx=Load()), orelse=Dict(keys=[], values=[]))), Assign(targets=[Name(id='url', ctx=Store())], value=Attribute(value=Name(id='request', ctx=Load()), attr='url', ctx=Load())), Assign(targets=[Name(id='scheme', ctx=Store())], value=Attribute(value=Call(func=Name(id='urlparse', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[]), attr='scheme', ctx=Load())), Assign(targets=[Name(id='no_proxy', ctx=Store())], value=Call(func=Attribute(value=Name(id='proxies', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='no_proxy')], keywords=[])), Assign(targets=[Name(id='new_proxies', ctx=Store())], value=Call(func=Attribute(value=Name(id='proxies', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='trust_env', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Name(id='should_bypass_proxies', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='no_proxy', value=Name(id='no_proxy', ctx=Load()))]))]), body=[Assign(targets=[Name(id='environ_proxies', ctx=Store())], value=Call(func=Name(id='get_environ_proxies', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='no_proxy', value=Name(id='no_proxy', ctx=Load()))])), Assign(targets=[Name(id='proxy', ctx=Store())], value=Call(func=Attribute(value=Name(id='environ_proxies', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='scheme', ctx=Load()), Call(func=Attribute(value=Name(id='environ_proxies', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='all')], keywords=[])], keywords=[])), If(test=Name(id='proxy', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='new_proxies', ctx=Load()), attr='setdefault', ctx=Load()), args=[Name(id='scheme', ctx=Load()), Name(id='proxy', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='new_proxies', ctx=Load()))], decorator_list=[]), FunctionDef(name='default_user_agent', args=arguments(posonlyargs=[], args=[arg(arg='name')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='python-requests')]), body=[Expr(value=Constant(value='\n    Return a string representing the default user agent.\n\n    :rtype: str\n    ')), Return(value=JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='__version__', ctx=Load()), conversion=-1)]))], decorator_list=[]), FunctionDef(name='default_headers', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    :rtype: requests.structures.CaseInsensitiveDict\n    ')), Return(value=Call(func=Name(id='CaseInsensitiveDict', ctx=Load()), args=[Dict(keys=[Constant(value='User-Agent'), Constant(value='Accept-Encoding'), Constant(value='Accept'), Constant(value='Connection')], values=[Call(func=Name(id='default_user_agent', ctx=Load()), args=[], keywords=[]), Name(id='DEFAULT_ACCEPT_ENCODING', ctx=Load()), Constant(value='*/*'), Constant(value='keep-alive')])], keywords=[]))], decorator_list=[]), FunctionDef(name='parse_header_links', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a list of parsed link headers proxies.\n\n    i.e. Link: <http:/.../front.jpeg>; rel=front; type="image/jpeg",<http://.../back.jpeg>; rel=back;type="image/jpeg"\n\n    :rtype: list\n    ')), Assign(targets=[Name(id='links', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='replace_chars', ctx=Store())], value=Constant(value=' \'"')), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='strip', ctx=Load()), args=[Name(id='replace_chars', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='value', ctx=Load())), body=[Return(value=Name(id='links', ctx=Load()))], orelse=[]), For(target=Name(id='val', ctx=Store()), iter=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=', *<'), Name(id='value', ctx=Load())], keywords=[]), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='url', ctx=Store()), Name(id='params', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='val', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=';'), Constant(value=1)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='url', ctx=Store()), Name(id='params', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='val', ctx=Load()), Constant(value='')], ctx=Load()))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='link', ctx=Store())], value=Dict(keys=[Constant(value='url')], values=[Call(func=Attribute(value=Name(id='url', ctx=Load()), attr='strip', ctx=Load()), args=[Constant(value='<> \'"')], keywords=[])])), For(target=Name(id='param', ctx=Store()), iter=Call(func=Attribute(value=Name(id='params', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=';')], keywords=[]), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='param', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='=')], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Break()])], orelse=[], finalbody=[]), Assign(targets=[Subscript(value=Name(id='link', ctx=Load()), slice=Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='strip', ctx=Load()), args=[Name(id='replace_chars', ctx=Load())], keywords=[]), ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='strip', ctx=Load()), args=[Name(id='replace_chars', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='links', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='link', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='links', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_null', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\x00'), attr='encode', ctx=Load()), args=[Constant(value='ascii')], keywords=[])), Assign(targets=[Name(id='_null2', ctx=Store())], value=BinOp(left=Name(id='_null', ctx=Load()), op=Mult(), right=Constant(value=2))), Assign(targets=[Name(id='_null3', ctx=Store())], value=BinOp(left=Name(id='_null', ctx=Load()), op=Mult(), right=Constant(value=3))), FunctionDef(name='guess_json_utf', args=arguments(posonlyargs=[], args=[arg(arg='data')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    :rtype: str\n    ')), Assign(targets=[Name(id='sample', ctx=Store())], value=Subscript(value=Name(id='data', ctx=Load()), slice=Slice(upper=Constant(value=4)), ctx=Load())), If(test=Compare(left=Name(id='sample', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Attribute(value=Name(id='codecs', ctx=Load()), attr='BOM_UTF32_LE', ctx=Load()), Attribute(value=Name(id='codecs', ctx=Load()), attr='BOM_UTF32_BE', ctx=Load())], ctx=Load())]), body=[Return(value=Constant(value='utf-32'))], orelse=[]), If(test=Compare(left=Subscript(value=Name(id='sample', ctx=Load()), slice=Slice(upper=Constant(value=3)), ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='codecs', ctx=Load()), attr='BOM_UTF8', ctx=Load())]), body=[Return(value=Constant(value='utf-8-sig'))], orelse=[]), If(test=Compare(left=Subscript(value=Name(id='sample', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Attribute(value=Name(id='codecs', ctx=Load()), attr='BOM_UTF16_LE', ctx=Load()), Attribute(value=Name(id='codecs', ctx=Load()), attr='BOM_UTF16_BE', ctx=Load())], ctx=Load())]), body=[Return(value=Constant(value='utf-16'))], orelse=[]), Assign(targets=[Name(id='nullcount', ctx=Store())], value=Call(func=Attribute(value=Name(id='sample', ctx=Load()), attr='count', ctx=Load()), args=[Name(id='_null', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='nullcount', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Constant(value='utf-8'))], orelse=[]), If(test=Compare(left=Name(id='nullcount', ctx=Load()), ops=[Eq()], comparators=[Constant(value=2)]), body=[If(test=Compare(left=Subscript(value=Name(id='sample', ctx=Load()), slice=Slice(step=Constant(value=2)), ctx=Load()), ops=[Eq()], comparators=[Name(id='_null2', ctx=Load())]), body=[Return(value=Constant(value='utf-16-be'))], orelse=[]), If(test=Compare(left=Subscript(value=Name(id='sample', ctx=Load()), slice=Slice(lower=Constant(value=1), step=Constant(value=2)), ctx=Load()), ops=[Eq()], comparators=[Name(id='_null2', ctx=Load())]), body=[Return(value=Constant(value='utf-16-le'))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='nullcount', ctx=Load()), ops=[Eq()], comparators=[Constant(value=3)]), body=[If(test=Compare(left=Subscript(value=Name(id='sample', ctx=Load()), slice=Slice(upper=Constant(value=3)), ctx=Load()), ops=[Eq()], comparators=[Name(id='_null3', ctx=Load())]), body=[Return(value=Constant(value='utf-32-be'))], orelse=[]), If(test=Compare(left=Subscript(value=Name(id='sample', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), ops=[Eq()], comparators=[Name(id='_null3', ctx=Load())]), body=[Return(value=Constant(value='utf-32-le'))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='prepend_scheme_if_needed', args=arguments(posonlyargs=[], args=[arg(arg='url'), arg(arg='new_scheme')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Given a URL that may or may not have a scheme, prepend the given scheme.\n    Does not replace a present scheme with the one provided as an argument.\n\n    :rtype: str\n    ')), Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Name(id='parse_url', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='scheme', ctx=Store()), Name(id='auth', ctx=Store()), Name(id='host', ctx=Store()), Name(id='port', ctx=Store()), Name(id='path', ctx=Store()), Name(id='query', ctx=Store()), Name(id='fragment', ctx=Store())], ctx=Store())], value=Name(id='parsed', ctx=Load())), Assign(targets=[Name(id='netloc', ctx=Store())], value=Attribute(value=Name(id='parsed', ctx=Load()), attr='netloc', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='netloc', ctx=Load())), body=[Assign(targets=[Tuple(elts=[Name(id='netloc', ctx=Store()), Name(id='path', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='path', ctx=Load()), Name(id='netloc', ctx=Load())], ctx=Load()))], orelse=[]), If(test=Name(id='auth', ctx=Load()), body=[Assign(targets=[Name(id='netloc', ctx=Store())], value=Call(func=Attribute(value=Constant(value='@'), attr='join', ctx=Load()), args=[List(elts=[Name(id='auth', ctx=Load()), Name(id='netloc', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='scheme', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='scheme', ctx=Store())], value=Name(id='new_scheme', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Constant(value=''))], orelse=[]), Return(value=Call(func=Name(id='urlunparse', ctx=Load()), args=[Tuple(elts=[Name(id='scheme', ctx=Load()), Name(id='netloc', ctx=Load()), Name(id='path', ctx=Load()), Constant(value=''), Name(id='query', ctx=Load()), Name(id='fragment', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_auth_from_url', args=arguments(posonlyargs=[], args=[arg(arg='url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Given a url with authentication components, extract them into a tuple of\n    username,password.\n\n    :rtype: (str,str)\n    ')), Assign(targets=[Name(id='parsed', ctx=Store())], value=Call(func=Name(id='urlparse', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='auth', ctx=Store())], value=Tuple(elts=[Call(func=Name(id='unquote', ctx=Load()), args=[Attribute(value=Name(id='parsed', ctx=Load()), attr='username', ctx=Load())], keywords=[]), Call(func=Name(id='unquote', ctx=Load()), args=[Attribute(value=Name(id='parsed', ctx=Load()), attr='password', ctx=Load())], keywords=[])], ctx=Load()))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='AttributeError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='auth', ctx=Store())], value=Tuple(elts=[Constant(value=''), Constant(value='')], ctx=Load()))])], orelse=[], finalbody=[]), Return(value=Name(id='auth', ctx=Load()))], decorator_list=[]), FunctionDef(name='check_header_validity', args=arguments(posonlyargs=[], args=[arg(arg='header')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Verifies that header parts don't contain leading whitespace\n    reserved characters, or return characters.\n\n    :param header: tuple, in the format (name, value).\n    ")), Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Name(id='header', ctx=Load())), Expr(value=Call(func=Name(id='_validate_header_part', ctx=Load()), args=[Name(id='header', ctx=Load()), Name(id='name', ctx=Load()), Constant(value=0)], keywords=[])), Expr(value=Call(func=Name(id='_validate_header_part', ctx=Load()), args=[Name(id='header', ctx=Load()), Name(id='value', ctx=Load()), Constant(value=1)], keywords=[]))], decorator_list=[]), FunctionDef(name='_validate_header_part', args=arguments(posonlyargs=[], args=[arg(arg='header'), arg(arg='header_part'), arg(arg='header_validator_index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='header_part', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='validator', ctx=Store())], value=Subscript(value=Name(id='_HEADER_VALIDATORS_STR', ctx=Load()), slice=Name(id='header_validator_index', ctx=Load()), ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='header_part', ctx=Load()), Name(id='bytes', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='validator', ctx=Store())], value=Subscript(value=Name(id='_HEADER_VALIDATORS_BYTE', ctx=Load()), slice=Name(id='header_validator_index', ctx=Load()), ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='InvalidHeader', ctx=Load()), args=[JoinedStr(values=[Constant(value='Header part ('), FormattedValue(value=Name(id='header_part', ctx=Load()), conversion=114), Constant(value=') from '), FormattedValue(value=Name(id='header', ctx=Load()), conversion=-1), Constant(value=' must be of type str or bytes, not '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='header_part', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))])]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='validator', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='header_part', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='header_kind', ctx=Store())], value=IfExp(test=Compare(left=Name(id='header_validator_index', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=Constant(value='name'), orelse=Constant(value='value'))), Raise(exc=Call(func=Name(id='InvalidHeader', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid leading whitespace, reserved character(s), or returncharacter(s) in header '), FormattedValue(value=Name(id='header_kind', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='header_part', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='urldefragauth', args=arguments(posonlyargs=[], args=[arg(arg='url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Given a url remove the fragment and the authentication part.\n\n    :rtype: str\n    ')), Assign(targets=[Tuple(elts=[Name(id='scheme', ctx=Store()), Name(id='netloc', ctx=Store()), Name(id='path', ctx=Store()), Name(id='params', ctx=Store()), Name(id='query', ctx=Store()), Name(id='fragment', ctx=Store())], ctx=Store())], value=Call(func=Name(id='urlparse', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='netloc', ctx=Load())), body=[Assign(targets=[Tuple(elts=[Name(id='netloc', ctx=Store()), Name(id='path', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='path', ctx=Load()), Name(id='netloc', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='netloc', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='netloc', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='@'), Constant(value=1)], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), Return(value=Call(func=Name(id='urlunparse', ctx=Load()), args=[Tuple(elts=[Name(id='scheme', ctx=Load()), Name(id='netloc', ctx=Load()), Name(id='path', ctx=Load()), Name(id='params', ctx=Load()), Name(id='query', ctx=Load()), Constant(value='')], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='rewind_body', args=arguments(posonlyargs=[], args=[arg(arg='prepared_request')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Move file pointer back to its recorded starting position\n    so it can be read again on redirect.\n    ')), Assign(targets=[Name(id='body_seek', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='prepared_request', ctx=Load()), attr='body', ctx=Load()), Constant(value='seek'), Constant(value=None)], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='body_seek', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='prepared_request', ctx=Load()), attr='_body_position', ctx=Load()), Name(id='integer_types', ctx=Load())], keywords=[])]), body=[Try(body=[Expr(value=Call(func=Name(id='body_seek', ctx=Load()), args=[Attribute(value=Name(id='prepared_request', ctx=Load()), attr='_body_position', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='UnrewindableBodyError', ctx=Load()), args=[Constant(value='An error occurred when rewinding request body for redirect.')], keywords=[]))])], orelse=[], finalbody=[])], orelse=[Raise(exc=Call(func=Name(id='UnrewindableBodyError', ctx=Load()), args=[Constant(value='Unable to rewind request body for redirect.')], keywords=[]))])], decorator_list=[])], type_ignores=[])