Module(body=[ClassDef(name='AbstractProvider', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Delegate class to provide the required interface for the resolver.')), FunctionDef(name='identify', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requirement_or_candidate')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Given a requirement, return an identifier for it.\n\n        This is used to identify a requirement, e.g. whether two requirements\n        should have their specifier parts merged.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_preference', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='identifier'), arg(arg='resolutions'), arg(arg='candidates'), arg(arg='information'), arg(arg='backtrack_causes')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Produce a sort key for given requirement based on preference.\n\n        The preference is defined as "I think this requirement should be\n        resolved first". The lower the return value is, the more preferred\n        this group of arguments is.\n\n        :param identifier: An identifier as returned by ``identify()``. This\n            identifies the dependency matches which should be returned.\n        :param resolutions: Mapping of candidates currently pinned by the\n            resolver. Each key is an identifier, and the value is a candidate.\n            The candidate may conflict with requirements from ``information``.\n        :param candidates: Mapping of each dependency\'s possible candidates.\n            Each value is an iterator of candidates.\n        :param information: Mapping of requirement information of each package.\n            Each value is an iterator of *requirement information*.\n        :param backtrack_causes: Sequence of requirement information that were\n            the requirements that caused the resolver to most recently backtrack.\n\n        A *requirement information* instance is a named tuple with two members:\n\n        * ``requirement`` specifies a requirement contributing to the current\n          list of candidates.\n        * ``parent`` specifies the candidate that provides (depended on) the\n          requirement, or ``None`` to indicate a root requirement.\n\n        The preference could depend on various issues, including (not\n        necessarily in this order):\n\n        * Is this package pinned in the current resolution result?\n        * How relaxed is the requirement? Stricter ones should probably be\n          worked on first? (I don\'t know, actually.)\n        * How many possibilities are there to satisfy this requirement? Those\n          with few left should likely be worked on first, I guess?\n        * Are there any known conflicts for this requirement? We should\n          probably work on those with the most known conflicts.\n\n        A sortable value should be returned (this will be used as the ``key``\n        parameter of the built-in sorting function). The smaller the value is,\n        the more preferred this requirement is (i.e. the sorting function\n        is called with ``reverse=False``).\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[]), FunctionDef(name='find_matches', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='identifier'), arg(arg='requirements'), arg(arg='incompatibilities')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find all possible candidates that satisfy the given constraints.\n\n        :param identifier: An identifier as returned by ``identify()``. This\n            identifies the dependency matches of which should be returned.\n        :param requirements: A mapping of requirements that all returned\n            candidates must satisfy. Each key is an identifier, and the value\n            an iterator of requirements for that dependency.\n        :param incompatibilities: A mapping of known incompatibilities of\n            each dependency. Each key is an identifier, and the value an\n            iterator of incompatibilities known to the resolver. All\n            incompatibilities *must* be excluded from the return value.\n\n        This should try to get candidates based on the requirements\' types.\n        For VCS, local, and archive requirements, the one-and-only match is\n        returned, and for a "named" requirement, the index(es) should be\n        consulted to find concrete candidates for this requirement.\n\n        The return value should produce candidates ordered by preference; the\n        most preferred candidate should come first. The return type may be one\n        of the following:\n\n        * A callable that returns an iterator that yields candidates.\n        * An collection of candidates.\n        * An iterable of candidates. This will be consumed immediately into a\n          list of candidates.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[]), FunctionDef(name='is_satisfied_by', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requirement'), arg(arg='candidate')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether the given requirement can be satisfied by a candidate.\n\n        The candidate is guaranteed to have been generated from the\n        requirement.\n\n        A boolean should be returned to indicate whether ``candidate`` is a\n        viable solution to the requirement.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_dependencies', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='candidate')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get dependencies of a candidate.\n\n        This should return a collection of requirements that `candidate`\n        specifies as its dependencies.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='AbstractResolver', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The thing that performs the actual resolution work.')), Assign(targets=[Name(id='base_exception', ctx=Store())], value=Name(id='Exception', ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='provider'), arg(arg='reporter')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='provider', ctx=Store())], value=Name(id='provider', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='reporter', ctx=Store())], value=Name(id='reporter', ctx=Load()))], decorator_list=[]), FunctionDef(name='resolve', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requirements')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Take a collection of constraints, spit out the resolution result.\n\n        This returns a representation of the final resolution state, with one\n        guarenteed attribute ``mapping`` that contains resolved candidates as\n        values. The keys are their respective identifiers.\n\n        :param requirements: A collection of constraints.\n        :param kwargs: Additional keyword arguments that subclasses may accept.\n\n        :raises: ``self.base_exception`` or its subclass.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[])], decorator_list=[])], type_ignores=[])