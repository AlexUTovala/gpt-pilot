Module(body=[ImportFrom(module='__future__', names=[alias(name='absolute_import')], level=0), Import(names=[alias(name='email.utils')]), Import(names=[alias(name='mimetypes')]), Import(names=[alias(name='re')]), ImportFrom(module='packages', names=[alias(name='six')], level=1), FunctionDef(name='guess_content_type', args=arguments(posonlyargs=[], args=[arg(arg='filename'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='application/octet-stream')]), body=[Expr(value=Constant(value='\n    Guess the "Content-Type" of a file.\n\n    :param filename:\n        The filename to guess the "Content-Type" of using :mod:`mimetypes`.\n    :param default:\n        If no "Content-Type" can be guessed, default to `default`.\n    ')), If(test=Name(id='filename', ctx=Load()), body=[Return(value=BoolOp(op=Or(), values=[Subscript(value=Call(func=Attribute(value=Name(id='mimetypes', ctx=Load()), attr='guess_type', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), Name(id='default', ctx=Load())]))], orelse=[]), Return(value=Name(id='default', ctx=Load()))], decorator_list=[]), FunctionDef(name='format_header_param_rfc2231', args=arguments(posonlyargs=[], args=[arg(arg='name'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper function to format and quote a single header parameter using the\n    strategy defined in RFC 2231.\n\n    Particularly useful for header parameters which might contain\n    non-ASCII values, like file names. This follows\n    `RFC 2388 Section 4.4 <https://tools.ietf.org/html/rfc2388#section-4.4>`_.\n\n    :param name:\n        The name of the parameter, a string expected to be ASCII only.\n    :param value:\n        The value of the parameter, provided as ``bytes`` or `str``.\n    :ret:\n        An RFC-2231-formatted unicode string.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='six', ctx=Load()), attr='binary_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='ch', ctx=Load()), ops=[In()], comparators=[Name(id='value', ctx=Load())]), generators=[comprehension(target=Name(id='ch', ctx=Store()), iter=Constant(value='"\\\r\n'), ifs=[], is_async=0)])], keywords=[])), body=[Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=Constant(value='%s="%s"', kind='u'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load()))), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='encode', ctx=Load()), args=[Constant(value='ascii')], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='UnicodeEncodeError', ctx=Load()), Name(id='UnicodeDecodeError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[Return(value=Name(id='result', ctx=Load()))], finalbody=[])], orelse=[]), If(test=Attribute(value=Name(id='six', ctx=Load()), attr='PY2', ctx=Load()), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='encode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='email', ctx=Load()), attr='utils', ctx=Load()), attr='encode_rfc2231', ctx=Load()), args=[Name(id='value', ctx=Load()), Constant(value='utf-8')], keywords=[])), Assign(targets=[Name(id='value', ctx=Store())], value=BinOp(left=Constant(value='%s*=%s'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load()))), If(test=Attribute(value=Name(id='six', ctx=Load()), attr='PY2', ctx=Load()), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[]))], orelse=[]), Return(value=Name(id='value', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_HTML5_REPLACEMENTS', ctx=Store())], value=Dict(keys=[Constant(value='"', kind='u'), Constant(value='\\', kind='u')], values=[Constant(value='%22', kind='u'), Constant(value='\\\\', kind='u')])), Expr(value=Call(func=Attribute(value=Name(id='_HTML5_REPLACEMENTS', ctx=Load()), attr='update', ctx=Load()), args=[DictComp(key=Call(func=Attribute(value=Name(id='six', ctx=Load()), attr='unichr', ctx=Load()), args=[Name(id='cc', ctx=Load())], keywords=[]), value=Call(func=Attribute(value=Constant(value='%{:02X}', kind='u'), attr='format', ctx=Load()), args=[Name(id='cc', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='cc', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=0), BinOp(left=Constant(value=31), op=Add(), right=Constant(value=1))], keywords=[]), ifs=[Compare(left=Name(id='cc', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value=27)], ctx=Load())])], is_async=0)])], keywords=[])), FunctionDef(name='_replace_multiple', args=arguments(posonlyargs=[], args=[arg(arg='value'), arg(arg='needles_and_replacements')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='replacer', args=arguments(posonlyargs=[], args=[arg(arg='match')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Name(id='needles_and_replacements', ctx=Load()), slice=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=0)], keywords=[]), ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[ListComp(elt=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='needle', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='needle', ctx=Store()), iter=Call(func=Attribute(value=Name(id='needles_and_replacements', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='pattern', ctx=Load()), attr='sub', ctx=Load()), args=[Name(id='replacer', ctx=Load()), Name(id='value', ctx=Load())], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='format_header_param_html5', args=arguments(posonlyargs=[], args=[arg(arg='name'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper function to format and quote a single header parameter using the\n    HTML5 strategy.\n\n    Particularly useful for header parameters which might contain\n    non-ASCII values, like file names. This follows the `HTML5 Working Draft\n    Section 4.10.22.7`_ and matches the behavior of curl and modern browsers.\n\n    .. _HTML5 Working Draft Section 4.10.22.7:\n        https://w3c.github.io/html/sec-forms.html#multipart-form-data\n\n    :param name:\n        The name of the parameter, a string expected to be ASCII only.\n    :param value:\n        The value of the parameter, provided as ``bytes`` or `str``.\n    :ret:\n        A unicode string, stripped of troublesome characters.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='six', ctx=Load()), attr='binary_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='decode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='_replace_multiple', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='_HTML5_REPLACEMENTS', ctx=Load())], keywords=[])), Return(value=BinOp(left=Constant(value='%s="%s"', kind='u'), op=Mod(), right=Tuple(elts=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], ctx=Load())))], decorator_list=[]), Assign(targets=[Name(id='format_header_param', ctx=Store())], value=Name(id='format_header_param_html5', ctx=Load())), ClassDef(name='RequestField', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A data container for request body parameters.\n\n    :param name:\n        The name of this request field. Must be unicode.\n    :param data:\n        The data/value body.\n    :param filename:\n        An optional filename of the request field. Must be unicode.\n    :param headers:\n        An optional dict-like object of headers to initially use for the field.\n    :param header_formatter:\n        An optional callable that is used to encode and format the headers. By\n        default, this is :func:`format_header_param_html5`.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='data'), arg(arg='filename'), arg(arg='headers'), arg(arg='header_formatter')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Name(id='format_header_param_html5', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_filename', ctx=Store())], value=Name(id='filename', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='data', ctx=Store())], value=Name(id='data', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Store())], value=Dict(keys=[], values=[])), If(test=Name(id='headers', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Name(id='headers', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='header_formatter', ctx=Store())], value=Name(id='header_formatter', ctx=Load()))], decorator_list=[]), FunctionDef(name='from_tuples', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='fieldname'), arg(arg='value'), arg(arg='header_formatter')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='format_header_param_html5', ctx=Load())]), body=[Expr(value=Constant(value="\n        A :class:`~urllib3.fields.RequestField` factory from old-style tuple parameters.\n\n        Supports constructing :class:`~urllib3.fields.RequestField` from\n        parameter of key/value strings AND key/filetuple. A filetuple is a\n        (filename, data, MIME type) tuple where the MIME type is optional.\n        For example::\n\n            'foo': 'bar',\n            'fakefile': ('foofile.txt', 'contents of foofile'),\n            'realfile': ('barfile.txt', open('realfile').read()),\n            'typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),\n            'nonamefile': 'contents of nonamefile field',\n\n        Field names and filenames must be unicode.\n        ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=3)]), body=[Assign(targets=[Tuple(elts=[Name(id='filename', ctx=Store()), Name(id='data', ctx=Store()), Name(id='content_type', ctx=Store())], ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='filename', ctx=Store()), Name(id='data', ctx=Store())], ctx=Store())], value=Name(id='value', ctx=Load())), Assign(targets=[Name(id='content_type', ctx=Store())], value=Call(func=Name(id='guess_content_type', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]))])], orelse=[Assign(targets=[Name(id='filename', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='content_type', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='data', ctx=Store())], value=Name(id='value', ctx=Load()))]), Assign(targets=[Name(id='request_param', ctx=Store())], value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='fieldname', ctx=Load()), Name(id='data', ctx=Load())], keywords=[keyword(arg='filename', value=Name(id='filename', ctx=Load())), keyword(arg='header_formatter', value=Name(id='header_formatter', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='request_param', ctx=Load()), attr='make_multipart', ctx=Load()), args=[], keywords=[keyword(arg='content_type', value=Name(id='content_type', ctx=Load()))])), Return(value=Name(id='request_param', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='_render_part', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Overridable helper function to format a single header parameter. By\n        default, this calls ``self.header_formatter``.\n\n        :param name:\n            The name of the parameter, a string expected to be ASCII only.\n        :param value:\n            The value of the parameter, provided as a unicode string.\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='header_formatter', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_render_parts', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='header_parts')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Helper function to format and quote a single header.\n\n        Useful for single headers that are composed of multiple items. E.g.,\n        \'Content-Disposition\' fields.\n\n        :param header_parts:\n            A sequence of (k, v) tuples or a :class:`dict` of (k, v) to format\n            as `k1="v1"; k2="v2"; ...`.\n        ')), Assign(targets=[Name(id='parts', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='iterable', ctx=Store())], value=Name(id='header_parts', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='header_parts', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='iterable', ctx=Store())], value=Call(func=Attribute(value=Name(id='header_parts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))], orelse=[]), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='iterable', ctx=Load()), body=[If(test=Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='parts', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_render_part', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='value', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='; ', kind='u'), attr='join', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='render_headers', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Renders the headers for this request field.\n        ')), Assign(targets=[Name(id='lines', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='sort_keys', ctx=Store())], value=List(elts=[Constant(value='Content-Disposition'), Constant(value='Content-Type'), Constant(value='Content-Location')], ctx=Load())), For(target=Name(id='sort_key', ctx=Store()), iter=Name(id='sort_keys', ctx=Load()), body=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='sort_key', ctx=Load()), Constant(value=False)], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='%s: %s', kind='u'), op=Mod(), right=Tuple(elts=[Name(id='sort_key', ctx=Load()), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Load()), slice=Name(id='sort_key', ctx=Load()), ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[])], orelse=[]), For(target=Tuple(elts=[Name(id='header_name', ctx=Store()), Name(id='header_value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='header_name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='sort_keys', ctx=Load())]), body=[If(test=Name(id='header_value', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='%s: %s', kind='u'), op=Mod(), right=Tuple(elts=[Name(id='header_name', ctx=Load()), Name(id='header_value', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='\r\n', kind='u')], keywords=[])), Return(value=Call(func=Attribute(value=Constant(value='\r\n', kind='u'), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='make_multipart', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='content_disposition'), arg(arg='content_type'), arg(arg='content_location')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='\n        Makes this request field into a multipart request field.\n\n        This method overrides "Content-Disposition", "Content-Type" and\n        "Content-Location" headers to the request parameter.\n\n        :param content_type:\n            The \'Content-Type\' of the request body.\n        :param content_location:\n            The \'Content-Location\' of the request body.\n\n        ')), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Load()), slice=Constant(value='Content-Disposition'), ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='content_disposition', ctx=Load()), Constant(value='form-data', kind='u')])), AugAssign(target=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Load()), slice=Constant(value='Content-Disposition'), ctx=Store()), op=Add(), value=Call(func=Attribute(value=Constant(value='; ', kind='u'), attr='join', ctx=Load()), args=[List(elts=[Constant(value='', kind='u'), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_render_parts', ctx=Load()), args=[Tuple(elts=[Tuple(elts=[Constant(value='name', kind='u'), Attribute(value=Name(id='self', ctx=Load()), attr='_name', ctx=Load())], ctx=Load()), Tuple(elts=[Constant(value='filename', kind='u'), Attribute(value=Name(id='self', ctx=Load()), attr='_filename', ctx=Load())], ctx=Load())], ctx=Load())], keywords=[])], ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Load()), slice=Constant(value='Content-Type'), ctx=Store())], value=Name(id='content_type', ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Load()), slice=Constant(value='Content-Location'), ctx=Store())], value=Name(id='content_location', ctx=Load()))], decorator_list=[])], decorator_list=[])], type_ignores=[])