Module(body=[ImportFrom(module='__future__', names=[alias(name='absolute_import')], level=0), ImportFrom(module='email.errors', names=[alias(name='MultipartInvariantViolationDefect'), alias(name='StartBoundaryNotFoundDefect')], level=0), ImportFrom(module='exceptions', names=[alias(name='HeaderParsingError')], level=2), ImportFrom(module='packages.six.moves', names=[alias(name='http_client', asname='httplib')], level=2), FunctionDef(name='is_fp_closed', args=arguments(posonlyargs=[], args=[arg(arg='obj')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Checks whether a given file-like object is closed.\n\n    :param obj:\n        The file-like object to check.\n    ')), Try(body=[Return(value=Call(func=Attribute(value=Name(id='obj', ctx=Load()), attr='isclosed', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Try(body=[Return(value=Attribute(value=Name(id='obj', ctx=Load()), attr='closed', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Try(body=[Return(value=Compare(left=Attribute(value=Name(id='obj', ctx=Load()), attr='fp', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Unable to determine whether fp is closed.')], keywords=[]))], decorator_list=[]), FunctionDef(name='assert_header_parsing', args=arguments(posonlyargs=[], args=[arg(arg='headers')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Asserts whether all headers have been successfully parsed.\n    Extracts encountered errors from the result of parsing headers.\n\n    Only works on Python 3.\n\n    :param http.client.HTTPMessage headers: Headers to verify.\n\n    :raises urllib3.exceptions.HeaderParsingError:\n        If parsing errors are found.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='headers', ctx=Load()), Attribute(value=Name(id='httplib', ctx=Load()), attr='HTTPMessage', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='expected httplib.Message, got {0}.'), attr='format', ctx=Load()), args=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='headers', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='defects', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='headers', ctx=Load()), Constant(value='defects'), Constant(value=None)], keywords=[])), Assign(targets=[Name(id='get_payload', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='headers', ctx=Load()), Constant(value='get_payload'), Constant(value=None)], keywords=[])), Assign(targets=[Name(id='unparsed_data', ctx=Store())], value=Constant(value=None)), If(test=Name(id='get_payload', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='headers', ctx=Load()), attr='is_multipart', ctx=Load()), args=[], keywords=[])), body=[Assign(targets=[Name(id='payload', ctx=Store())], value=Call(func=Name(id='get_payload', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='payload', ctx=Load()), Tuple(elts=[Name(id='bytes', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='unparsed_data', ctx=Store())], value=Name(id='payload', ctx=Load()))], orelse=[])], orelse=[])], orelse=[]), If(test=Name(id='defects', ctx=Load()), body=[Assign(targets=[Name(id='defects', ctx=Store())], value=ListComp(elt=Name(id='defect', ctx=Load()), generators=[comprehension(target=Name(id='defect', ctx=Store()), iter=Name(id='defects', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='defect', ctx=Load()), Tuple(elts=[Name(id='StartBoundaryNotFoundDefect', ctx=Load()), Name(id='MultipartInvariantViolationDefect', ctx=Load())], ctx=Load())], keywords=[]))], is_async=0)]))], orelse=[]), If(test=BoolOp(op=Or(), values=[Name(id='defects', ctx=Load()), Name(id='unparsed_data', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='HeaderParsingError', ctx=Load()), args=[], keywords=[keyword(arg='defects', value=Name(id='defects', ctx=Load())), keyword(arg='unparsed_data', value=Name(id='unparsed_data', ctx=Load()))]))], orelse=[])], decorator_list=[]), FunctionDef(name='is_response_to_head', args=arguments(posonlyargs=[], args=[arg(arg='response')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Checks whether the request of a response has been a HEAD-request.\n    Handles the quirks of AppEngine.\n\n    :param http.client.HTTPResponse response:\n        Response to check if the originating request\n        used 'HEAD' as a method.\n    ")), Assign(targets=[Name(id='method', ctx=Store())], value=Attribute(value=Name(id='response', ctx=Load()), attr='_method', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Return(value=Compare(left=Name(id='method', ctx=Load()), ops=[Eq()], comparators=[Constant(value=3)]))], orelse=[]), Return(value=Compare(left=Call(func=Attribute(value=Name(id='method', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='HEAD')]))], decorator_list=[])], type_ignores=[])