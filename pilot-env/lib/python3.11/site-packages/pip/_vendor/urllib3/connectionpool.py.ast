Module(body=[ImportFrom(module='__future__', names=[alias(name='absolute_import')], level=0), Import(names=[alias(name='errno')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='re')]), Import(names=[alias(name='socket')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='warnings')]), ImportFrom(module='socket', names=[alias(name='error', asname='SocketError')], level=0), ImportFrom(module='socket', names=[alias(name='timeout', asname='SocketTimeout')], level=0), ImportFrom(module='connection', names=[alias(name='BaseSSLError'), alias(name='BrokenPipeError'), alias(name='DummyConnection'), alias(name='HTTPConnection'), alias(name='HTTPException'), alias(name='HTTPSConnection'), alias(name='VerifiedHTTPSConnection'), alias(name='port_by_scheme')], level=1), ImportFrom(module='exceptions', names=[alias(name='ClosedPoolError'), alias(name='EmptyPoolError'), alias(name='HeaderParsingError'), alias(name='HostChangedError'), alias(name='InsecureRequestWarning'), alias(name='LocationValueError'), alias(name='MaxRetryError'), alias(name='NewConnectionError'), alias(name='ProtocolError'), alias(name='ProxyError'), alias(name='ReadTimeoutError'), alias(name='SSLError'), alias(name='TimeoutError')], level=1), ImportFrom(module='packages', names=[alias(name='six')], level=1), ImportFrom(module='packages.six.moves', names=[alias(name='queue')], level=1), ImportFrom(module='request', names=[alias(name='RequestMethods')], level=1), ImportFrom(module='response', names=[alias(name='HTTPResponse')], level=1), ImportFrom(module='util.connection', names=[alias(name='is_connection_dropped')], level=1), ImportFrom(module='util.proxy', names=[alias(name='connection_requires_http_tunnel')], level=1), ImportFrom(module='util.queue', names=[alias(name='LifoQueue')], level=1), ImportFrom(module='util.request', names=[alias(name='set_file_position')], level=1), ImportFrom(module='util.response', names=[alias(name='assert_header_parsing')], level=1), ImportFrom(module='util.retry', names=[alias(name='Retry')], level=1), ImportFrom(module='util.ssl_match_hostname', names=[alias(name='CertificateError')], level=1), ImportFrom(module='util.timeout', names=[alias(name='Timeout')], level=1), ImportFrom(module='util.url', names=[alias(name='Url'), alias(name='_encode_target')], level=1), ImportFrom(module='util.url', names=[alias(name='_normalize_host', asname='normalize_host')], level=1), ImportFrom(module='util.url', names=[alias(name='get_host'), alias(name='parse_url')], level=1), Try(body=[Import(names=[alias(name='weakref')]), Assign(targets=[Name(id='weakref_finalize', ctx=Store())], value=Attribute(value=Name(id='weakref', ctx=Load()), attr='finalize', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[ImportFrom(module='packages.backports.weakref_finalize', names=[alias(name='weakref_finalize')], level=1)])], orelse=[], finalbody=[]), Assign(targets=[Name(id='xrange', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='six', ctx=Load()), attr='moves', ctx=Load()), attr='xrange', ctx=Load())), Assign(targets=[Name(id='log', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_Default', ctx=Store())], value=Call(func=Name(id='object', ctx=Load()), args=[], keywords=[])), ClassDef(name='ConnectionPool', bases=[Name(id='object', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded\n       target URIs.\n    ")), Assign(targets=[Name(id='scheme', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='QueueCls', ctx=Store())], value=Name(id='LifoQueue', ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='host'), arg(arg='port')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='host', ctx=Load())), body=[Raise(exc=Call(func=Name(id='LocationValueError', ctx=Load()), args=[Constant(value='No host specified.')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Store())], value=Call(func=Name(id='_normalize_host', ctx=Load()), args=[Name(id='host', ctx=Load())], keywords=[keyword(arg='scheme', value=Attribute(value=Name(id='self', ctx=Load()), attr='scheme', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_proxy_host', ctx=Store())], value=Call(func=Attribute(value=Name(id='host', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Store())], value=Name(id='port', ctx=Load()))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Constant(value='%s(host=%r, port=%r)'), op=Mod(), right=Tuple(elts=[Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load())], ctx=Load())))], decorator_list=[]), FunctionDef(name='__enter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='__exit__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exc_type'), arg(arg='exc_val'), arg(arg='exc_tb')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[])), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='close', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Close all pooled connections and disable the pool.\n        ')), Pass()], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='_blocking_errnos', ctx=Store())], value=Set(elts=[Attribute(value=Name(id='errno', ctx=Load()), attr='EAGAIN', ctx=Load()), Attribute(value=Name(id='errno', ctx=Load()), attr='EWOULDBLOCK', ctx=Load())])), ClassDef(name='HTTPConnectionPool', bases=[Name(id='ConnectionPool', ctx=Load()), Name(id='RequestMethods', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Thread-safe connection pool for one host.\n\n    :param host:\n        Host used for this HTTP Connection (e.g. "localhost"), passed into\n        :class:`http.client.HTTPConnection`.\n\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.\n\n    :param strict:\n        Causes BadStatusLine to be raised if the status line can\'t be parsed\n        as a valid HTTP/1.0 or 1.1 status line, passed into\n        :class:`http.client.HTTPConnection`.\n\n        .. note::\n           Only works in Python 2. This parameter is ignored in Python 3.\n\n    :param timeout:\n        Socket timeout in seconds for each individual connection. This can\n        be a float or integer, which sets the timeout for the HTTP request,\n        or an instance of :class:`urllib3.util.Timeout` which gives you more\n        fine-grained control over request timeouts. After the constructor has\n        been parsed, this is always a `urllib3.util.Timeout` object.\n\n    :param maxsize:\n        Number of connections to save that can be reused. More than 1 is useful\n        in multithreaded situations. If ``block`` is set to False, more\n        connections will be created but they will not be saved once they\'ve\n        been used.\n\n    :param block:\n        If set to True, no more than ``maxsize`` connections will be used at\n        a time. When no free connections are available, the call will block\n        until a connection has been released. This is a useful side effect for\n        particular multithreaded situations where one does not want to use more\n        than maxsize connections per host to prevent flooding.\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n\n    :param retries:\n        Retry configuration to use by default with requests in this pool.\n\n    :param _proxy:\n        Parsed proxy URL, should not be used directly, instead, see\n        :class:`urllib3.ProxyManager`\n\n    :param _proxy_headers:\n        A dictionary with proxy headers, should not be used directly,\n        instead, see :class:`urllib3.ProxyManager`\n\n    :param \\**conn_kw:\n        Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,\n        :class:`urllib3.connection.HTTPSConnection` instances.\n    ')), Assign(targets=[Name(id='scheme', ctx=Store())], value=Constant(value='http')), Assign(targets=[Name(id='ConnectionCls', ctx=Store())], value=Name(id='HTTPConnection', ctx=Load())), Assign(targets=[Name(id='ResponseCls', ctx=Store())], value=Name(id='HTTPResponse', ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='host'), arg(arg='port'), arg(arg='strict'), arg(arg='timeout'), arg(arg='maxsize'), arg(arg='block'), arg(arg='headers'), arg(arg='retries'), arg(arg='_proxy'), arg(arg='_proxy_headers'), arg(arg='_proxy_config')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='conn_kw'), defaults=[Constant(value=None), Constant(value=False), Attribute(value=Name(id='Timeout', ctx=Load()), attr='DEFAULT_TIMEOUT', ctx=Load()), Constant(value=1), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='ConnectionPool', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='host', ctx=Load()), Name(id='port', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='RequestMethods', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='headers', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='strict', ctx=Store())], value=Name(id='strict', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='timeout', ctx=Load()), Name(id='Timeout', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='timeout', ctx=Store())], value=Call(func=Attribute(value=Name(id='Timeout', ctx=Load()), attr='from_float', ctx=Load()), args=[Name(id='timeout', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='retries', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='retries', ctx=Store())], value=Attribute(value=Name(id='Retry', ctx=Load()), attr='DEFAULT', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='timeout', ctx=Store())], value=Name(id='timeout', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='retries', ctx=Store())], value=Name(id='retries', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='QueueCls', ctx=Load()), args=[Name(id='maxsize', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='block', ctx=Store())], value=Name(id='block', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Store())], value=Name(id='_proxy', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy_headers', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='_proxy_headers', ctx=Load()), Dict(keys=[], values=[])])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy_config', ctx=Store())], value=Name(id='_proxy_config', ctx=Load())), For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='xrange', ctx=Load()), args=[Name(id='maxsize', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Load()), attr='put', ctx=Load()), args=[Constant(value=None)], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='num_connections', ctx=Store())], value=Constant(value=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='num_requests', ctx=Store())], value=Constant(value=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='conn_kw', ctx=Store())], value=Name(id='conn_kw', ctx=Load())), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='conn_kw', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='socket_options'), List(elts=[], ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='conn_kw', ctx=Load()), slice=Constant(value='proxy'), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='conn_kw', ctx=Load()), slice=Constant(value='proxy_config'), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy_config', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='pool', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Load())), Expr(value=Call(func=Name(id='weakref_finalize', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='_close_pool_connections', ctx=Load()), Name(id='pool', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_new_conn', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a fresh :class:`HTTPConnection`.\n        ')), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='num_connections', ctx=Store()), op=Add(), value=Constant(value=1)), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Starting new HTTP connection (%d): %s:%s'), Attribute(value=Name(id='self', ctx=Load()), attr='num_connections', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Load()), BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load()), Constant(value='80')])], keywords=[])), Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='ConnectionCls', ctx=Load()), args=[], keywords=[keyword(arg='host', value=Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Load())), keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load())), keyword(arg='timeout', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='timeout', ctx=Load()), attr='connect_timeout', ctx=Load())), keyword(arg='strict', value=Attribute(value=Name(id='self', ctx=Load()), attr='strict', ctx=Load())), keyword(value=Attribute(value=Name(id='self', ctx=Load()), attr='conn_kw', ctx=Load()))])), Return(value=Name(id='conn', ctx=Load()))], decorator_list=[]), FunctionDef(name='_get_conn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Get a connection. Will return a pooled connection if one is available.\n\n        If no connections are available and :prop:`.block` is ``False``, then a\n        fresh connection is returned.\n\n        :param timeout:\n            Seconds to wait before giving up and raising\n            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and\n            :prop:`.block` is ``True``.\n        ')), Assign(targets=[Name(id='conn', ctx=Store())], value=Constant(value=None)), Try(body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Load()), attr='get', ctx=Load()), args=[], keywords=[keyword(arg='block', value=Attribute(value=Name(id='self', ctx=Load()), attr='block', ctx=Load())), keyword(arg='timeout', value=Name(id='timeout', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ClosedPoolError', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='Pool is closed.')], keywords=[]))]), ExceptHandler(type=Attribute(value=Name(id='queue', ctx=Load()), attr='Empty', ctx=Load()), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='block', ctx=Load()), body=[Raise(exc=Call(func=Name(id='EmptyPoolError', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='Pool reached maximum size and no more connections are allowed.')], keywords=[]))], orelse=[]), Pass()])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[Name(id='conn', ctx=Load()), Call(func=Name(id='is_connection_dropped', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Resetting dropped connection: %s'), Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='conn', ctx=Load()), Constant(value='auto_open'), Constant(value=1)], keywords=[]), ops=[Eq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Constant(value=None))], orelse=[])], orelse=[]), Return(value=BoolOp(op=Or(), values=[Name(id='conn', ctx=Load()), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_new_conn', ctx=Load()), args=[], keywords=[])]))], decorator_list=[]), FunctionDef(name='_put_conn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='conn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Put a connection back into the pool.\n\n        :param conn:\n            Connection object for the current host and port as returned by\n            :meth:`._new_conn` or :meth:`._get_conn`.\n\n        If the pool is already full, the connection is closed and discarded\n        because we exceeded maxsize. If connections are discarded frequently,\n        then maxsize should be increased.\n\n        If the pool is closed, then the connection will be closed and discarded.\n        ')), Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Load()), attr='put', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[keyword(arg='block', value=Constant(value=False))])), Return()], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Pass()]), ExceptHandler(type=Attribute(value=Name(id='queue', ctx=Load()), attr='Full', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Connection pool is full, discarding connection: %s. Connection pool size: %s'), Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Load()), attr='qsize', ctx=Load()), args=[], keywords=[])], keywords=[]))])], orelse=[], finalbody=[]), If(test=Name(id='conn', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_validate_conn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='conn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Called right before a request is made, after the socket is created.\n        ')), Pass()], decorator_list=[]), FunctionDef(name='_prepare_proxy', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='conn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[]), FunctionDef(name='_get_timeout', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='timeout')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper that always returns a :class:`urllib3.util.Timeout`')), If(test=Compare(left=Name(id='timeout', ctx=Load()), ops=[Is()], comparators=[Name(id='_Default', ctx=Load())]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='timeout', ctx=Load()), attr='clone', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='timeout', ctx=Load()), Name(id='Timeout', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='timeout', ctx=Load()), attr='clone', ctx=Load()), args=[], keywords=[]))], orelse=[Return(value=Call(func=Attribute(value=Name(id='Timeout', ctx=Load()), attr='from_float', ctx=Load()), args=[Name(id='timeout', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='_raise_timeout', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='err'), arg(arg='url'), arg(arg='timeout_value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Is the error actually a timeout? Will raise a ReadTimeout or pass')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='err', ctx=Load()), Name(id='SocketTimeout', ctx=Load())], keywords=[]), body=[Raise(exc=Call(func=Name(id='ReadTimeoutError', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='url', ctx=Load()), BinOp(left=Constant(value='Read timed out. (read timeout=%s)'), op=Mod(), right=Name(id='timeout_value', ctx=Load()))], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='err', ctx=Load()), Constant(value='errno')], keywords=[]), Compare(left=Attribute(value=Name(id='err', ctx=Load()), attr='errno', ctx=Load()), ops=[In()], comparators=[Name(id='_blocking_errnos', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='ReadTimeoutError', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='url', ctx=Load()), BinOp(left=Constant(value='Read timed out. (read timeout=%s)'), op=Mod(), right=Name(id='timeout_value', ctx=Load()))], keywords=[]))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Constant(value='timed out'), ops=[In()], comparators=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='err', ctx=Load())], keywords=[])]), Compare(left=Constant(value='did not complete (read)'), ops=[In()], comparators=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='err', ctx=Load())], keywords=[])])]), body=[Raise(exc=Call(func=Name(id='ReadTimeoutError', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='url', ctx=Load()), BinOp(left=Constant(value='Read timed out. (read timeout=%s)'), op=Mod(), right=Name(id='timeout_value', ctx=Load()))], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_make_request', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='conn'), arg(arg='method'), arg(arg='url'), arg(arg='timeout'), arg(arg='chunked')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='httplib_request_kw'), defaults=[Name(id='_Default', ctx=Load()), Constant(value=False)]), body=[Expr(value=Constant(value='\n        Perform a request on a given urllib connection object taken from our\n        pool.\n\n        :param conn:\n            a connection from one of our connection pools\n\n        :param timeout:\n            Socket timeout in seconds for the request. This can be a\n            float or integer, which will set the same timeout value for\n            the socket connect and the socket read, or an instance of\n            :class:`urllib3.util.Timeout`, which gives you more fine-grained\n            control over your timeouts.\n        ')), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='num_requests', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Name(id='timeout_obj', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_timeout', ctx=Load()), args=[Name(id='timeout', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='timeout_obj', ctx=Load()), attr='start_connect', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='conn', ctx=Load()), attr='timeout', ctx=Store())], value=Call(func=Attribute(value=Name(id='Timeout', ctx=Load()), attr='resolve_default_timeout', ctx=Load()), args=[Attribute(value=Name(id='timeout_obj', ctx=Load()), attr='connect_timeout', ctx=Load())], keywords=[])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_conn', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='SocketTimeout', ctx=Load()), Name(id='BaseSSLError', ctx=Load())], ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_timeout', ctx=Load()), args=[], keywords=[keyword(arg='err', value=Name(id='e', ctx=Load())), keyword(arg='url', value=Name(id='url', ctx=Load())), keyword(arg='timeout_value', value=Attribute(value=Name(id='conn', ctx=Load()), attr='timeout', ctx=Load()))])), Raise()])], orelse=[], finalbody=[]), Try(body=[If(test=Name(id='chunked', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='request_chunked', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='url', ctx=Load())], keywords=[keyword(value=Name(id='httplib_request_kw', ctx=Load()))]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='request', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='url', ctx=Load())], keywords=[keyword(value=Name(id='httplib_request_kw', ctx=Load()))]))])], handlers=[ExceptHandler(type=Name(id='BrokenPipeError', ctx=Load()), body=[Pass()]), ExceptHandler(type=Name(id='IOError', ctx=Load()), name='e', body=[If(test=Compare(left=Attribute(value=Name(id='e', ctx=Load()), attr='errno', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Attribute(value=Name(id='errno', ctx=Load()), attr='EPIPE', ctx=Load()), Attribute(value=Name(id='errno', ctx=Load()), attr='ESHUTDOWN', ctx=Load()), Attribute(value=Name(id='errno', ctx=Load()), attr='EPROTOTYPE', ctx=Load())])]), body=[Raise()], orelse=[])])], orelse=[], finalbody=[]), Assign(targets=[Name(id='read_timeout', ctx=Store())], value=Attribute(value=Name(id='timeout_obj', ctx=Load()), attr='read_timeout', ctx=Load())), If(test=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='conn', ctx=Load()), Constant(value='sock'), Constant(value=None)], keywords=[]), body=[If(test=Compare(left=Name(id='read_timeout', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ReadTimeoutError', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='url', ctx=Load()), BinOp(left=Constant(value='Read timed out. (read timeout=%s)'), op=Mod(), right=Name(id='read_timeout', ctx=Load()))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='read_timeout', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='Timeout', ctx=Load()), attr='DEFAULT_TIMEOUT', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='conn', ctx=Load()), attr='sock', ctx=Load()), attr='settimeout', ctx=Load()), args=[Call(func=Attribute(value=Name(id='socket', ctx=Load()), attr='getdefaulttimeout', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='conn', ctx=Load()), attr='sock', ctx=Load()), attr='settimeout', ctx=Load()), args=[Name(id='read_timeout', ctx=Load())], keywords=[]))])], orelse=[]), Try(body=[Try(body=[Assign(targets=[Name(id='httplib_response', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='getresponse', ctx=Load()), args=[], keywords=[keyword(arg='buffering', value=Constant(value=True))]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='httplib_response', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='getresponse', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='BaseException', ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='six', ctx=Load()), attr='raise_from', ctx=Load()), args=[Name(id='e', ctx=Load()), Constant(value=None)], keywords=[]))])], orelse=[], finalbody=[])])], orelse=[], finalbody=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='SocketTimeout', ctx=Load()), Name(id='BaseSSLError', ctx=Load()), Name(id='SocketError', ctx=Load())], ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_raise_timeout', ctx=Load()), args=[], keywords=[keyword(arg='err', value=Name(id='e', ctx=Load())), keyword(arg='url', value=Name(id='url', ctx=Load())), keyword(arg='timeout_value', value=Name(id='read_timeout', ctx=Load()))])), Raise()])], orelse=[], finalbody=[]), Assign(targets=[Name(id='http_version', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='conn', ctx=Load()), Constant(value='_http_vsn_str'), Constant(value='HTTP/?')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='%s://%s:%s "%s %s %s" %s %s'), Attribute(value=Name(id='self', ctx=Load()), attr='scheme', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load()), Name(id='method', ctx=Load()), Name(id='url', ctx=Load()), Name(id='http_version', ctx=Load()), Attribute(value=Name(id='httplib_response', ctx=Load()), attr='status', ctx=Load()), Attribute(value=Name(id='httplib_response', ctx=Load()), attr='length', ctx=Load())], keywords=[])), Try(body=[Expr(value=Call(func=Name(id='assert_header_parsing', ctx=Load()), args=[Attribute(value=Name(id='httplib_response', ctx=Load()), attr='msg', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='HeaderParsingError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), name='hpe', body=[Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Failed to parse headers (url=%s): %s'), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_absolute_url', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[]), Name(id='hpe', ctx=Load())], keywords=[keyword(arg='exc_info', value=Constant(value=True))]))])], orelse=[], finalbody=[]), Return(value=Name(id='httplib_response', ctx=Load()))], decorator_list=[]), FunctionDef(name='_absolute_url', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Call(func=Name(id='Url', ctx=Load()), args=[], keywords=[keyword(arg='scheme', value=Attribute(value=Name(id='self', ctx=Load()), attr='scheme', ctx=Load())), keyword(arg='host', value=Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Load())), keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load())), keyword(arg='path', value=Name(id='path', ctx=Load()))]), attr='url', ctx=Load()))], decorator_list=[]), FunctionDef(name='close', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Close all pooled connections and disable the pool.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return()], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='old_pool', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Store())], ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Load()), Constant(value=None)], ctx=Load())), Expr(value=Call(func=Name(id='_close_pool_connections', ctx=Load()), args=[Name(id='old_pool', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='is_same_host', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Check if the given ``url`` is a member of the same host as this\n        connection pool.\n        ')), If(test=Call(func=Attribute(value=Name(id='url', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='/')], keywords=[]), body=[Return(value=Constant(value=True))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='scheme', ctx=Store()), Name(id='host', ctx=Store()), Name(id='port', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_host', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='host', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='host', ctx=Store())], value=Call(func=Name(id='_normalize_host', ctx=Load()), args=[Name(id='host', ctx=Load())], keywords=[keyword(arg='scheme', value=Name(id='scheme', ctx=Load()))]))], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='port', ctx=Load()))]), body=[Assign(targets=[Name(id='port', ctx=Store())], value=Call(func=Attribute(value=Name(id='port_by_scheme', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='scheme', ctx=Load())], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load())), Compare(left=Name(id='port', ctx=Load()), ops=[Eq()], comparators=[Call(func=Attribute(value=Name(id='port_by_scheme', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='scheme', ctx=Load())], keywords=[])])]), body=[Assign(targets=[Name(id='port', ctx=Store())], value=Constant(value=None))], orelse=[])]), Return(value=Compare(left=Tuple(elts=[Name(id='scheme', ctx=Load()), Name(id='host', ctx=Load()), Name(id='port', ctx=Load())], ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='scheme', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load())], ctx=Load())]))], decorator_list=[]), FunctionDef(name='urlopen', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='method'), arg(arg='url'), arg(arg='body'), arg(arg='headers'), arg(arg='retries'), arg(arg='redirect'), arg(arg='assert_same_host'), arg(arg='timeout'), arg(arg='pool_timeout'), arg(arg='release_conn'), arg(arg='chunked'), arg(arg='body_pos')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='response_kw'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=True), Name(id='_Default', ctx=Load()), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value="\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n\n        .. note::\n\n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n\n        .. note::\n\n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n\n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n\n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n\n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n\n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n\n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n\n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n\n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n\n        :param \\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        ")), Assign(targets=[Name(id='parsed_url', ctx=Store())], value=Call(func=Name(id='parse_url', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='destination_scheme', ctx=Store())], value=Attribute(value=Name(id='parsed_url', ctx=Load()), attr='scheme', ctx=Load())), If(test=Compare(left=Name(id='headers', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='headers', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='headers', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='retries', ctx=Load()), Name(id='Retry', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='retries', ctx=Store())], value=Call(func=Attribute(value=Name(id='Retry', ctx=Load()), attr='from_int', ctx=Load()), args=[Name(id='retries', ctx=Load())], keywords=[keyword(arg='redirect', value=Name(id='redirect', ctx=Load())), keyword(arg='default', value=Attribute(value=Name(id='self', ctx=Load()), attr='retries', ctx=Load()))]))], orelse=[]), If(test=Compare(left=Name(id='release_conn', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='release_conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='response_kw', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='preload_content'), Constant(value=True)], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Name(id='assert_same_host', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_same_host', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='HostChangedError', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='url', ctx=Load()), Name(id='retries', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='url', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='/')], keywords=[]), body=[Assign(targets=[Name(id='url', ctx=Store())], value=Call(func=Attribute(value=Name(id='six', ctx=Load()), attr='ensure_str', ctx=Load()), args=[Call(func=Name(id='_encode_target', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='url', ctx=Store())], value=Call(func=Attribute(value=Name(id='six', ctx=Load()), attr='ensure_str', ctx=Load()), args=[Attribute(value=Name(id='parsed_url', ctx=Load()), attr='url', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='conn', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='release_this_conn', ctx=Store())], value=Name(id='release_conn', ctx=Load())), Assign(targets=[Name(id='http_tunnel_required', ctx=Store())], value=Call(func=Name(id='connection_requires_http_tunnel', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='proxy_config', ctx=Load()), Name(id='destination_scheme', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='http_tunnel_required', ctx=Load())), body=[Assign(targets=[Name(id='headers', ctx=Store())], value=Call(func=Attribute(value=Name(id='headers', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='headers', ctx=Load()), attr='update', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='proxy_headers', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='err', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='clean_exit', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='body_pos', ctx=Store())], value=Call(func=Name(id='set_file_position', ctx=Load()), args=[Name(id='body', ctx=Load()), Name(id='body_pos', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='timeout_obj', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_timeout', ctx=Load()), args=[Name(id='timeout', ctx=Load())], keywords=[])), Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_conn', ctx=Load()), args=[], keywords=[keyword(arg='timeout', value=Name(id='pool_timeout', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='conn', ctx=Load()), attr='timeout', ctx=Store())], value=Attribute(value=Name(id='timeout_obj', ctx=Load()), attr='connect_timeout', ctx=Load())), Assign(targets=[Name(id='is_new_proxy_conn', ctx=Store())], value=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='conn', ctx=Load()), Constant(value='sock'), Constant(value=None)], keywords=[]))])), If(test=BoolOp(op=And(), values=[Name(id='is_new_proxy_conn', ctx=Load()), Name(id='http_tunnel_required', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_prepare_proxy', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='httplib_response', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_request', ctx=Load()), args=[Name(id='conn', ctx=Load()), Name(id='method', ctx=Load()), Name(id='url', ctx=Load())], keywords=[keyword(arg='timeout', value=Name(id='timeout_obj', ctx=Load())), keyword(arg='body', value=Name(id='body', ctx=Load())), keyword(arg='headers', value=Name(id='headers', ctx=Load())), keyword(arg='chunked', value=Name(id='chunked', ctx=Load()))])), Assign(targets=[Name(id='response_conn', ctx=Store())], value=IfExp(test=UnaryOp(op=Not(), operand=Name(id='release_conn', ctx=Load())), body=Name(id='conn', ctx=Load()), orelse=Constant(value=None))), Assign(targets=[Subscript(value=Name(id='response_kw', ctx=Load()), slice=Constant(value='request_method'), ctx=Store())], value=Name(id='method', ctx=Load())), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ResponseCls', ctx=Load()), attr='from_httplib', ctx=Load()), args=[Name(id='httplib_response', ctx=Load())], keywords=[keyword(arg='pool', value=Name(id='self', ctx=Load())), keyword(arg='connection', value=Name(id='response_conn', ctx=Load())), keyword(arg='retries', value=Name(id='retries', ctx=Load())), keyword(value=Name(id='response_kw', ctx=Load()))])), Assign(targets=[Name(id='clean_exit', ctx=Store())], value=Constant(value=True))], handlers=[ExceptHandler(type=Name(id='EmptyPoolError', ctx=Load()), body=[Assign(targets=[Name(id='clean_exit', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='release_this_conn', ctx=Store())], value=Constant(value=False)), Raise()]), ExceptHandler(type=Tuple(elts=[Name(id='TimeoutError', ctx=Load()), Name(id='HTTPException', ctx=Load()), Name(id='SocketError', ctx=Load()), Name(id='ProtocolError', ctx=Load()), Name(id='BaseSSLError', ctx=Load()), Name(id='SSLError', ctx=Load()), Name(id='CertificateError', ctx=Load())], ctx=Load()), name='e', body=[Assign(targets=[Name(id='clean_exit', ctx=Store())], value=Constant(value=False)), FunctionDef(name='_is_ssl_error_message_from_http_proxy', args=arguments(posonlyargs=[], args=[arg(arg='ssl_error')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='message', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='[^a-z]'), Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='ssl_error', ctx=Load())], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Return(value=BoolOp(op=Or(), values=[Compare(left=Constant(value='wrong version number'), ops=[In()], comparators=[Name(id='message', ctx=Load())]), Compare(left=Constant(value='unknown protocol'), ops=[In()], comparators=[Name(id='message', ctx=Load())])]))], decorator_list=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='BaseSSLError', ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), Call(func=Name(id='_is_ssl_error_message_from_http_proxy', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), Attribute(value=Name(id='conn', ctx=Load()), attr='proxy', ctx=Load()), Compare(left=Attribute(value=Attribute(value=Name(id='conn', ctx=Load()), attr='proxy', ctx=Load()), attr='scheme', ctx=Load()), ops=[Eq()], comparators=[Constant(value='https')])]), body=[Assign(targets=[Name(id='e', ctx=Store())], value=Call(func=Name(id='ProxyError', ctx=Load()), args=[Constant(value='Your proxy appears to only use HTTP and not HTTPS, try changing your proxy URL to be HTTP. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html#https-proxy-error-http-proxy'), Call(func=Name(id='SSLError', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Tuple(elts=[Name(id='BaseSSLError', ctx=Load()), Name(id='CertificateError', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='e', ctx=Store())], value=Call(func=Name(id='SSLError', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Tuple(elts=[Name(id='SocketError', ctx=Load()), Name(id='NewConnectionError', ctx=Load())], ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load())]), body=[Assign(targets=[Name(id='e', ctx=Store())], value=Call(func=Name(id='ProxyError', ctx=Load()), args=[Constant(value='Cannot connect to proxy.'), Name(id='e', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Tuple(elts=[Name(id='SocketError', ctx=Load()), Name(id='HTTPException', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='e', ctx=Store())], value=Call(func=Name(id='ProtocolError', ctx=Load()), args=[Constant(value='Connection aborted.'), Name(id='e', ctx=Load())], keywords=[]))], orelse=[])])])]), Assign(targets=[Name(id='retries', ctx=Store())], value=Call(func=Attribute(value=Name(id='retries', ctx=Load()), attr='increment', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='url', ctx=Load())], keywords=[keyword(arg='error', value=Name(id='e', ctx=Load())), keyword(arg='_pool', value=Name(id='self', ctx=Load())), keyword(arg='_stacktrace', value=Subscript(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='exc_info', ctx=Load()), args=[], keywords=[]), slice=Constant(value=2), ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='retries', ctx=Load()), attr='sleep', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='err', ctx=Store())], value=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[If(test=UnaryOp(op=Not(), operand=Name(id='clean_exit', ctx=Load())), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='conn', ctx=Load()), Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[])])), Assign(targets=[Name(id='release_this_conn', ctx=Store())], value=Constant(value=True))], orelse=[]), If(test=Name(id='release_this_conn', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_put_conn', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[]))], orelse=[])]), If(test=UnaryOp(op=Not(), operand=Name(id='conn', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value="Retrying (%r) after connection broken by '%r': %s"), Name(id='retries', ctx=Load()), Name(id='err', ctx=Load()), Name(id='url', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='urlopen', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='url', ctx=Load()), Name(id='body', ctx=Load()), Name(id='headers', ctx=Load()), Name(id='retries', ctx=Load()), Name(id='redirect', ctx=Load()), Name(id='assert_same_host', ctx=Load())], keywords=[keyword(arg='timeout', value=Name(id='timeout', ctx=Load())), keyword(arg='pool_timeout', value=Name(id='pool_timeout', ctx=Load())), keyword(arg='release_conn', value=Name(id='release_conn', ctx=Load())), keyword(arg='chunked', value=Name(id='chunked', ctx=Load())), keyword(arg='body_pos', value=Name(id='body_pos', ctx=Load())), keyword(value=Name(id='response_kw', ctx=Load()))]))], orelse=[]), Assign(targets=[Name(id='redirect_location', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='redirect', ctx=Load()), Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='get_redirect_location', ctx=Load()), args=[], keywords=[])])), If(test=Name(id='redirect_location', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='response', ctx=Load()), attr='status', ctx=Load()), ops=[Eq()], comparators=[Constant(value=303)]), body=[Assign(targets=[Name(id='method', ctx=Store())], value=Constant(value='GET'))], orelse=[]), Try(body=[Assign(targets=[Name(id='retries', ctx=Store())], value=Call(func=Attribute(value=Name(id='retries', ctx=Load()), attr='increment', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='url', ctx=Load())], keywords=[keyword(arg='response', value=Name(id='response', ctx=Load())), keyword(arg='_pool', value=Name(id='self', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='MaxRetryError', ctx=Load()), body=[If(test=Attribute(value=Name(id='retries', ctx=Load()), attr='raise_on_redirect', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='drain_conn', ctx=Load()), args=[], keywords=[])), Raise()], orelse=[]), Return(value=Name(id='response', ctx=Load()))])], orelse=[], finalbody=[]), Expr(value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='drain_conn', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='retries', ctx=Load()), attr='sleep_for_retry', ctx=Load()), args=[Name(id='response', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Redirecting %s -> %s'), Name(id='url', ctx=Load()), Name(id='redirect_location', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='urlopen', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='redirect_location', ctx=Load()), Name(id='body', ctx=Load()), Name(id='headers', ctx=Load())], keywords=[keyword(arg='retries', value=Name(id='retries', ctx=Load())), keyword(arg='redirect', value=Name(id='redirect', ctx=Load())), keyword(arg='assert_same_host', value=Name(id='assert_same_host', ctx=Load())), keyword(arg='timeout', value=Name(id='timeout', ctx=Load())), keyword(arg='pool_timeout', value=Name(id='pool_timeout', ctx=Load())), keyword(arg='release_conn', value=Name(id='release_conn', ctx=Load())), keyword(arg='chunked', value=Name(id='chunked', ctx=Load())), keyword(arg='body_pos', value=Name(id='body_pos', ctx=Load())), keyword(value=Name(id='response_kw', ctx=Load()))]))], orelse=[]), Assign(targets=[Name(id='has_retry_after', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='response', ctx=Load()), attr='headers', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='Retry-After')], keywords=[])], keywords=[])), If(test=Call(func=Attribute(value=Name(id='retries', ctx=Load()), attr='is_retry', ctx=Load()), args=[Name(id='method', ctx=Load()), Attribute(value=Name(id='response', ctx=Load()), attr='status', ctx=Load()), Name(id='has_retry_after', ctx=Load())], keywords=[]), body=[Try(body=[Assign(targets=[Name(id='retries', ctx=Store())], value=Call(func=Attribute(value=Name(id='retries', ctx=Load()), attr='increment', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='url', ctx=Load())], keywords=[keyword(arg='response', value=Name(id='response', ctx=Load())), keyword(arg='_pool', value=Name(id='self', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='MaxRetryError', ctx=Load()), body=[If(test=Attribute(value=Name(id='retries', ctx=Load()), attr='raise_on_status', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='drain_conn', ctx=Load()), args=[], keywords=[])), Raise()], orelse=[]), Return(value=Name(id='response', ctx=Load()))])], orelse=[], finalbody=[]), Expr(value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='drain_conn', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='retries', ctx=Load()), attr='sleep', ctx=Load()), args=[Name(id='response', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Retry: %s'), Name(id='url', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='urlopen', ctx=Load()), args=[Name(id='method', ctx=Load()), Name(id='url', ctx=Load()), Name(id='body', ctx=Load()), Name(id='headers', ctx=Load())], keywords=[keyword(arg='retries', value=Name(id='retries', ctx=Load())), keyword(arg='redirect', value=Name(id='redirect', ctx=Load())), keyword(arg='assert_same_host', value=Name(id='assert_same_host', ctx=Load())), keyword(arg='timeout', value=Name(id='timeout', ctx=Load())), keyword(arg='pool_timeout', value=Name(id='pool_timeout', ctx=Load())), keyword(arg='release_conn', value=Name(id='release_conn', ctx=Load())), keyword(arg='chunked', value=Name(id='chunked', ctx=Load())), keyword(arg='body_pos', value=Name(id='body_pos', ctx=Load())), keyword(value=Name(id='response_kw', ctx=Load()))]))], orelse=[]), Return(value=Name(id='response', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='HTTPSConnectionPool', bases=[Name(id='HTTPConnectionPool', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Same as :class:`.HTTPConnectionPool`, but HTTPS.\n\n    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``,\n    ``assert_hostname`` and ``host`` in this order to verify connections.\n    If ``assert_hostname`` is False, no verification is done.\n\n    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,\n    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`\n    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade\n    the connection socket into an SSL socket.\n    ')), Assign(targets=[Name(id='scheme', ctx=Store())], value=Constant(value='https')), Assign(targets=[Name(id='ConnectionCls', ctx=Store())], value=Name(id='HTTPSConnection', ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='host'), arg(arg='port'), arg(arg='strict'), arg(arg='timeout'), arg(arg='maxsize'), arg(arg='block'), arg(arg='headers'), arg(arg='retries'), arg(arg='_proxy'), arg(arg='_proxy_headers'), arg(arg='key_file'), arg(arg='cert_file'), arg(arg='cert_reqs'), arg(arg='key_password'), arg(arg='ca_certs'), arg(arg='ssl_version'), arg(arg='assert_hostname'), arg(arg='assert_fingerprint'), arg(arg='ca_cert_dir')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='conn_kw'), defaults=[Constant(value=None), Constant(value=False), Attribute(value=Name(id='Timeout', ctx=Load()), attr='DEFAULT_TIMEOUT', ctx=Load()), Constant(value=1), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='HTTPConnectionPool', ctx=Load()), attr='__init__', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='host', ctx=Load()), Name(id='port', ctx=Load()), Name(id='strict', ctx=Load()), Name(id='timeout', ctx=Load()), Name(id='maxsize', ctx=Load()), Name(id='block', ctx=Load()), Name(id='headers', ctx=Load()), Name(id='retries', ctx=Load()), Name(id='_proxy', ctx=Load()), Name(id='_proxy_headers', ctx=Load())], keywords=[keyword(value=Name(id='conn_kw', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='key_file', ctx=Store())], value=Name(id='key_file', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='cert_file', ctx=Store())], value=Name(id='cert_file', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='cert_reqs', ctx=Store())], value=Name(id='cert_reqs', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='key_password', ctx=Store())], value=Name(id='key_password', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ca_certs', ctx=Store())], value=Name(id='ca_certs', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ca_cert_dir', ctx=Store())], value=Name(id='ca_cert_dir', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ssl_version', ctx=Store())], value=Name(id='ssl_version', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='assert_hostname', ctx=Store())], value=Name(id='assert_hostname', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='assert_fingerprint', ctx=Store())], value=Name(id='assert_fingerprint', ctx=Load()))], decorator_list=[]), FunctionDef(name='_prepare_conn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='conn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Prepare the ``connection`` for :meth:`urllib3.util.ssl_wrap_socket`\n        and establish the tunnel if proxy is used.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='conn', ctx=Load()), Name(id='VerifiedHTTPSConnection', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='set_cert', ctx=Load()), args=[], keywords=[keyword(arg='key_file', value=Attribute(value=Name(id='self', ctx=Load()), attr='key_file', ctx=Load())), keyword(arg='key_password', value=Attribute(value=Name(id='self', ctx=Load()), attr='key_password', ctx=Load())), keyword(arg='cert_file', value=Attribute(value=Name(id='self', ctx=Load()), attr='cert_file', ctx=Load())), keyword(arg='cert_reqs', value=Attribute(value=Name(id='self', ctx=Load()), attr='cert_reqs', ctx=Load())), keyword(arg='ca_certs', value=Attribute(value=Name(id='self', ctx=Load()), attr='ca_certs', ctx=Load())), keyword(arg='ca_cert_dir', value=Attribute(value=Name(id='self', ctx=Load()), attr='ca_cert_dir', ctx=Load())), keyword(arg='assert_hostname', value=Attribute(value=Name(id='self', ctx=Load()), attr='assert_hostname', ctx=Load())), keyword(arg='assert_fingerprint', value=Attribute(value=Name(id='self', ctx=Load()), attr='assert_fingerprint', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='conn', ctx=Load()), attr='ssl_version', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='ssl_version', ctx=Load()))], orelse=[]), Return(value=Name(id='conn', ctx=Load()))], decorator_list=[]), FunctionDef(name='_prepare_proxy', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='conn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Establishes a tunnel connection through HTTP CONNECT.\n\n        Tunnel connection is established early because otherwise httplib would\n        improperly set Host: header to proxy's IP:port.\n        ")), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='set_tunnel', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_proxy_host', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='proxy_headers', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), attr='scheme', ctx=Load()), ops=[Eq()], comparators=[Constant(value='https')]), body=[Assign(targets=[Attribute(value=Name(id='conn', ctx=Load()), attr='tls_in_tls_required', ctx=Store())], value=Constant(value=True))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='connect', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_new_conn', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a fresh :class:`http.client.HTTPSConnection`.\n        ')), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='num_connections', ctx=Store()), op=Add(), value=Constant(value=1)), Expr(value=Call(func=Attribute(value=Name(id='log', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Starting new HTTPS connection (%d): %s:%s'), Attribute(value=Name(id='self', ctx=Load()), attr='num_connections', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Load()), BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load()), Constant(value='443')])], keywords=[])), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='ConnectionCls', ctx=Load())), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ConnectionCls', ctx=Load()), ops=[Is()], comparators=[Name(id='DummyConnection', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='SSLError', ctx=Load()), args=[Constant(value="Can't connect to HTTPS URL because the SSL module is not available.")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='actual_host', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='host', ctx=Load())), Assign(targets=[Name(id='actual_port', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='port', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='actual_host', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), attr='host', ctx=Load())), Assign(targets=[Name(id='actual_port', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='proxy', ctx=Load()), attr='port', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='ConnectionCls', ctx=Load()), args=[], keywords=[keyword(arg='host', value=Name(id='actual_host', ctx=Load())), keyword(arg='port', value=Name(id='actual_port', ctx=Load())), keyword(arg='timeout', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='timeout', ctx=Load()), attr='connect_timeout', ctx=Load())), keyword(arg='strict', value=Attribute(value=Name(id='self', ctx=Load()), attr='strict', ctx=Load())), keyword(arg='cert_file', value=Attribute(value=Name(id='self', ctx=Load()), attr='cert_file', ctx=Load())), keyword(arg='key_file', value=Attribute(value=Name(id='self', ctx=Load()), attr='key_file', ctx=Load())), keyword(arg='key_password', value=Attribute(value=Name(id='self', ctx=Load()), attr='key_password', ctx=Load())), keyword(value=Attribute(value=Name(id='self', ctx=Load()), attr='conn_kw', ctx=Load()))])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_prepare_conn', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_validate_conn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='conn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Called right before a request is made, after the socket is created.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='HTTPSConnectionPool', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='_validate_conn', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='conn', ctx=Load()), Constant(value='sock'), Constant(value=None)], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='connect', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='conn', ctx=Load()), attr='is_verified', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[BinOp(left=Constant(value="Unverified HTTPS request is being made to host '%s'. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html#ssl-warnings"), op=Mod(), right=Attribute(value=Name(id='conn', ctx=Load()), attr='host', ctx=Load())), Name(id='InsecureRequestWarning', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='conn', ctx=Load()), Constant(value='proxy_is_verified'), Constant(value=None)], keywords=[]), ops=[Is()], comparators=[Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='Unverified HTTPS connection done to an HTTPS proxy. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html#ssl-warnings'), Name(id='InsecureRequestWarning', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])], decorator_list=[]), FunctionDef(name='connection_from_url', args=arguments(posonlyargs=[], args=[arg(arg='url')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kw'), defaults=[]), body=[Expr(value=Constant(value="\n    Given a url, return an :class:`.ConnectionPool` instance of its host.\n\n    This is a shortcut for not having to parse out the scheme, host, and port\n    of the url before creating an :class:`.ConnectionPool` instance.\n\n    :param url:\n        Absolute URL string that must include the scheme. Port is optional.\n\n    :param \\**kw:\n        Passes additional parameters to the constructor of the appropriate\n        :class:`.ConnectionPool`. Useful for specifying things like\n        timeout, maxsize, headers, etc.\n\n    Example::\n\n        >>> conn = connection_from_url('http://google.com/')\n        >>> r = conn.request('GET', '/')\n    ")), Assign(targets=[Tuple(elts=[Name(id='scheme', ctx=Store()), Name(id='host', ctx=Store()), Name(id='port', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_host', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='port', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='port', ctx=Load()), Call(func=Attribute(value=Name(id='port_by_scheme', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='scheme', ctx=Load()), Constant(value=80)], keywords=[])])), If(test=Compare(left=Name(id='scheme', ctx=Load()), ops=[Eq()], comparators=[Constant(value='https')]), body=[Return(value=Call(func=Name(id='HTTPSConnectionPool', ctx=Load()), args=[Name(id='host', ctx=Load())], keywords=[keyword(arg='port', value=Name(id='port', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))]))], orelse=[Return(value=Call(func=Name(id='HTTPConnectionPool', ctx=Load()), args=[Name(id='host', ctx=Load())], keywords=[keyword(arg='port', value=Name(id='port', ctx=Load())), keyword(value=Name(id='kw', ctx=Load()))]))])], decorator_list=[]), FunctionDef(name='_normalize_host', args=arguments(posonlyargs=[], args=[arg(arg='host'), arg(arg='scheme')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Normalize hosts for comparisons and use with sockets.\n    ')), Assign(targets=[Name(id='host', ctx=Store())], value=Call(func=Name(id='normalize_host', ctx=Load()), args=[Name(id='host', ctx=Load()), Name(id='scheme', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='host', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='[')], keywords=[]), Call(func=Attribute(value=Name(id='host', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value=']')], keywords=[])]), body=[Assign(targets=[Name(id='host', ctx=Store())], value=Subscript(value=Name(id='host', ctx=Load()), slice=Slice(lower=Constant(value=1), upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], orelse=[]), Return(value=Name(id='host', ctx=Load()))], decorator_list=[]), FunctionDef(name='_close_pool_connections', args=arguments(posonlyargs=[], args=[arg(arg='pool')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Drains a queue of connections and closes each one.')), Try(body=[While(test=Constant(value=True), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='pool', ctx=Load()), attr='get', ctx=Load()), args=[], keywords=[keyword(arg='block', value=Constant(value=False))])), If(test=Name(id='conn', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[])], handlers=[ExceptHandler(type=Attribute(value=Name(id='queue', ctx=Load()), attr='Empty', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], decorator_list=[])], type_ignores=[])