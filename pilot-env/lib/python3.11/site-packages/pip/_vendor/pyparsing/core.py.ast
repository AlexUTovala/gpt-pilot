Module(body=[ImportFrom(module='collections', names=[alias(name='deque')], level=0), Import(names=[alias(name='os')]), Import(names=[alias(name='typing')]), ImportFrom(module='typing', names=[alias(name='Any'), alias(name='Callable'), alias(name='Generator'), alias(name='List'), alias(name='NamedTuple'), alias(name='Sequence'), alias(name='Set'), alias(name='TextIO'), alias(name='Tuple'), alias(name='Union'), alias(name='cast')], level=0), ImportFrom(module='abc', names=[alias(name='ABC'), alias(name='abstractmethod')], level=0), ImportFrom(module='enum', names=[alias(name='Enum')], level=0), Import(names=[alias(name='string')]), Import(names=[alias(name='copy')]), Import(names=[alias(name='warnings')]), Import(names=[alias(name='re')]), Import(names=[alias(name='sys')]), ImportFrom(module='collections.abc', names=[alias(name='Iterable')], level=0), Import(names=[alias(name='traceback')]), Import(names=[alias(name='types')]), ImportFrom(module='operator', names=[alias(name='itemgetter')], level=0), ImportFrom(module='functools', names=[alias(name='wraps')], level=0), ImportFrom(module='threading', names=[alias(name='RLock')], level=0), ImportFrom(module='pathlib', names=[alias(name='Path')], level=0), ImportFrom(module='util', names=[alias(name='_FifoCache'), alias(name='_UnboundedCache'), alias(name='__config_flags'), alias(name='_collapse_string_to_ranges'), alias(name='_escape_regex_range_chars'), alias(name='_bslash'), alias(name='_flatten'), alias(name='LRUMemo', asname='_LRUMemo'), alias(name='UnboundedMemo', asname='_UnboundedMemo'), alias(name='replaced_by_pep8')], level=1), ImportFrom(module='exceptions', names=[alias(name='*')], level=1), ImportFrom(module='actions', names=[alias(name='*')], level=1), ImportFrom(module='results', names=[alias(name='ParseResults'), alias(name='_ParseResultsWithOffset')], level=1), ImportFrom(module='unicode', names=[alias(name='pyparsing_unicode')], level=1), Assign(targets=[Name(id='_MAX_INT', ctx=Store())], value=Attribute(value=Name(id='sys', ctx=Load()), attr='maxsize', ctx=Load())), AnnAssign(target=Name(id='str_type', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='type', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bytes', ctx=Load())], ctx=Load()), simple=1), If(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Constant(value=3), Constant(value=8)], ctx=Load())]), body=[ImportFrom(module='functools', names=[alias(name='cached_property')], level=0)], orelse=[ClassDef(name='cached_property', bases=[], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_func', ctx=Store())], value=Name(id='func', ctx=Load()))], decorator_list=[]), FunctionDef(name='__get__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instance'), arg(arg='owner')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='ret', ctx=Store()), Subscript(value=Attribute(value=Name(id='instance', ctx=Load()), attr='__dict__', ctx=Load()), slice=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_func', ctx=Load()), attr='__name__', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_func', ctx=Load()), args=[Name(id='instance', ctx=Load())], keywords=[])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[])], decorator_list=[])]), ClassDef(name='__compat__', bases=[Name(id='__config_flags', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A cross-version compatibility configuration for pyparsing features that will be\n    released in a future version. By setting values in this configuration to True,\n    those features can be enabled in prior versions for compatibility development\n    and testing.\n\n    - ``collect_all_And_tokens`` - flag to enable fix for Issue #63 that fixes erroneous grouping\n      of results names when an :class:`And` expression is nested within an :class:`Or` or :class:`MatchFirst`;\n      maintained for compatibility, but setting to ``False`` no longer restores pre-2.3.1\n      behavior\n    ')), Assign(targets=[Name(id='_type_desc', ctx=Store())], value=Constant(value='compatibility')), Assign(targets=[Name(id='collect_all_And_tokens', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='_all_names', ctx=Store())], value=ListComp(elt=Name(id='__', ctx=Load()), generators=[comprehension(target=Name(id='__', ctx=Store()), iter=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]), ifs=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='__', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_')], keywords=[]))], is_async=0)])), Assign(targets=[Name(id='_fixed_names', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n        collect_all_And_tokens\n        '), attr='split', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), ClassDef(name='__diag__', bases=[Name(id='__config_flags', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='_type_desc', ctx=Store())], value=Constant(value='diagnostic')), Assign(targets=[Name(id='warn_multiple_tokens_in_named_alternation', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='warn_ungrouped_named_tokens_in_collection', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='warn_name_set_on_empty_Forward', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='warn_on_parse_using_empty_Forward', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='warn_on_assignment_to_Forward', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='warn_on_multiple_string_args_to_oneof', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='warn_on_match_first_with_lshift_operator', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='enable_debug_on_named_expressions', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='_all_names', ctx=Store())], value=ListComp(elt=Name(id='__', ctx=Load()), generators=[comprehension(target=Name(id='__', ctx=Store()), iter=Call(func=Name(id='locals', ctx=Load()), args=[], keywords=[]), ifs=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='__', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='_')], keywords=[]))], is_async=0)])), Assign(targets=[Name(id='_warning_names', ctx=Store())], value=ListComp(elt=Name(id='name', ctx=Load()), generators=[comprehension(target=Name(id='name', ctx=Store()), iter=Name(id='_all_names', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='warn')], keywords=[])], is_async=0)])), Assign(targets=[Name(id='_debug_names', ctx=Store())], value=ListComp(elt=Name(id='name', ctx=Load()), generators=[comprehension(target=Name(id='name', ctx=Store()), iter=Name(id='_all_names', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='enable_debug')], keywords=[])], is_async=0)])), FunctionDef(name='enable_all_warnings', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='name', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='_warning_names', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='enable', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='Diagnostics', bases=[Name(id='Enum', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Diagnostic configuration (all default to disabled)\n\n    - ``warn_multiple_tokens_in_named_alternation`` - flag to enable warnings when a results\n      name is defined on a :class:`MatchFirst` or :class:`Or` expression with one or more :class:`And` subexpressions\n    - ``warn_ungrouped_named_tokens_in_collection`` - flag to enable warnings when a results\n      name is defined on a containing expression with ungrouped subexpressions that also\n      have results names\n    - ``warn_name_set_on_empty_Forward`` - flag to enable warnings when a :class:`Forward` is defined\n      with a results name, but has no contents defined\n    - ``warn_on_parse_using_empty_Forward`` - flag to enable warnings when a :class:`Forward` is\n      defined in a grammar but has never had an expression attached to it\n    - ``warn_on_assignment_to_Forward`` - flag to enable warnings when a :class:`Forward` is defined\n      but is overwritten by assigning using ``'='`` instead of ``'<<='`` or ``'<<'``\n    - ``warn_on_multiple_string_args_to_oneof`` - flag to enable warnings when :class:`one_of` is\n      incorrectly called with multiple str arguments\n    - ``enable_debug_on_named_expressions`` - flag to auto-enable debug on all subsequent\n      calls to :class:`ParserElement.set_name`\n\n    Diagnostics are enabled/disabled by calling :class:`enable_diag` and :class:`disable_diag`.\n    All warnings can be enabled by calling :class:`enable_all_warnings`.\n    ")), Assign(targets=[Name(id='warn_multiple_tokens_in_named_alternation', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='warn_ungrouped_named_tokens_in_collection', ctx=Store())], value=Constant(value=1)), Assign(targets=[Name(id='warn_name_set_on_empty_Forward', ctx=Store())], value=Constant(value=2)), Assign(targets=[Name(id='warn_on_parse_using_empty_Forward', ctx=Store())], value=Constant(value=3)), Assign(targets=[Name(id='warn_on_assignment_to_Forward', ctx=Store())], value=Constant(value=4)), Assign(targets=[Name(id='warn_on_multiple_string_args_to_oneof', ctx=Store())], value=Constant(value=5)), Assign(targets=[Name(id='warn_on_match_first_with_lshift_operator', ctx=Store())], value=Constant(value=6)), Assign(targets=[Name(id='enable_debug_on_named_expressions', ctx=Store())], value=Constant(value=7))], decorator_list=[]), FunctionDef(name='enable_diag', args=arguments(posonlyargs=[], args=[arg(arg='diag_enum', annotation=Name(id='Diagnostics', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Enable a global pyparsing diagnostic flag (see :class:`Diagnostics`).\n    ')), Expr(value=Call(func=Attribute(value=Name(id='__diag__', ctx=Load()), attr='enable', ctx=Load()), args=[Attribute(value=Name(id='diag_enum', ctx=Load()), attr='name', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='disable_diag', args=arguments(posonlyargs=[], args=[arg(arg='diag_enum', annotation=Name(id='Diagnostics', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Disable a global pyparsing diagnostic flag (see :class:`Diagnostics`).\n    ')), Expr(value=Call(func=Attribute(value=Name(id='__diag__', ctx=Load()), attr='disable', ctx=Load()), args=[Attribute(value=Name(id='diag_enum', ctx=Load()), attr='name', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='enable_all_warnings', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Enable all global pyparsing diagnostic warnings (see :class:`Diagnostics`).\n    ')), Expr(value=Call(func=Attribute(value=Name(id='__diag__', ctx=Load()), attr='enable_all_warnings', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), Delete(targets=[Name(id='__config_flags', ctx=Del())]), FunctionDef(name='_should_enable_warnings', args=arguments(posonlyargs=[], args=[arg(arg='cmd_line_warn_options', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='warn_env_var', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='enable', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='warn_env_var', ctx=Load())], keywords=[])), For(target=Name(id='warn_opt', ctx=Store()), iter=Name(id='cmd_line_warn_options', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='w_action', ctx=Store()), Name(id='w_message', ctx=Store()), Name(id='w_category', ctx=Store()), Name(id='w_module', ctx=Store()), Name(id='w_line', ctx=Store())], ctx=Store())], value=Subscript(value=Call(func=Attribute(value=BinOp(left=Name(id='warn_opt', ctx=Load()), op=Add(), right=Constant(value='::::')), attr='split', ctx=Load()), args=[Constant(value=':')], keywords=[]), slice=Slice(upper=Constant(value=5)), ctx=Load())), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='w_action', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Constant(value='i')], keywords=[])), BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Name(id='w_message', ctx=Load()), Name(id='w_category', ctx=Load()), Name(id='w_module', ctx=Load())])), Compare(left=Name(id='w_module', ctx=Load()), ops=[Eq()], comparators=[Constant(value='pyparsing')])])]), body=[Assign(targets=[Name(id='enable', ctx=Store())], value=Constant(value=True))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='w_action', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Constant(value='i')], keywords=[]), Compare(left=Name(id='w_module', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='pyparsing'), Constant(value='')], ctx=Load())])]), body=[Assign(targets=[Name(id='enable', ctx=Store())], value=Constant(value=False))], orelse=[])])], orelse=[]), Return(value=Name(id='enable', ctx=Load()))], decorator_list=[], returns=Name(id='bool', ctx=Load())), If(test=Call(func=Name(id='_should_enable_warnings', ctx=Load()), args=[Attribute(value=Name(id='sys', ctx=Load()), attr='warnoptions', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='PYPARSINGENABLEALLWARNINGS')], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Name(id='enable_all_warnings', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='_single_arg_builtins', ctx=Store())], value=Set(elts=[Name(id='sum', ctx=Load()), Name(id='len', ctx=Load()), Name(id='sorted', ctx=Load()), Name(id='reversed', ctx=Load()), Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load()), Name(id='set', ctx=Load()), Name(id='any', ctx=Load()), Name(id='all', ctx=Load()), Name(id='min', ctx=Load()), Name(id='max', ctx=Load())])), Assign(targets=[Name(id='_generatorType', ctx=Store())], value=Attribute(value=Name(id='types', ctx=Load()), attr='GeneratorType', ctx=Load())), Assign(targets=[Name(id='ParseImplReturnType', ctx=Store())], value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='PostParseReturnType', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParseResults', ctx=Load()), Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='ParseResults', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='ParseAction', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='ParseResults', ctx=Load())], ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Name(id='ParseResults', ctx=Load())], ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load()), Name(id='ParseResults', ctx=Load())], ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='ParseCondition', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='ParseResults', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Name(id='ParseResults', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load()), Name(id='ParseResults', ctx=Load())], ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='ParseFailAction', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load()), Constant(value='ParserElement'), Name(id='Exception', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='DebugStartAction', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load()), Constant(value='ParserElement'), Name(id='bool', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='DebugSuccessAction', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Constant(value='ParserElement'), Name(id='ParseResults', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='DebugExceptionAction', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load()), Constant(value='ParserElement'), Name(id='Exception', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='alphas', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='string', ctx=Load()), attr='ascii_uppercase', ctx=Load()), op=Add(), right=Attribute(value=Name(id='string', ctx=Load()), attr='ascii_lowercase', ctx=Load()))), Assign(targets=[Name(id='identchars', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='pyparsing_unicode', ctx=Load()), attr='Latin1', ctx=Load()), attr='identchars', ctx=Load())), Assign(targets=[Name(id='identbodychars', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='pyparsing_unicode', ctx=Load()), attr='Latin1', ctx=Load()), attr='identbodychars', ctx=Load())), Assign(targets=[Name(id='nums', ctx=Store())], value=Constant(value='0123456789')), Assign(targets=[Name(id='hexnums', ctx=Store())], value=BinOp(left=Name(id='nums', ctx=Load()), op=Add(), right=Constant(value='ABCDEFabcdef'))), Assign(targets=[Name(id='alphanums', ctx=Store())], value=BinOp(left=Name(id='alphas', ctx=Load()), op=Add(), right=Name(id='nums', ctx=Load()))), Assign(targets=[Name(id='printables', ctx=Store())], value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[ListComp(elt=Name(id='c', ctx=Load()), generators=[comprehension(target=Name(id='c', ctx=Store()), iter=Attribute(value=Name(id='string', ctx=Load()), attr='printable', ctx=Load()), ifs=[Compare(left=Name(id='c', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='string', ctx=Load()), attr='whitespace', ctx=Load())])], is_async=0)])], keywords=[])), AnnAssign(target=Name(id='_trim_arity_call_line', ctx=Store()), annotation=Attribute(value=Name(id='traceback', ctx=Load()), attr='StackSummary', ctx=Load()), value=Constant(value=None), simple=1), FunctionDef(name='_trim_arity', args=arguments(posonlyargs=[], args=[arg(arg='func'), arg(arg='max_limit')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=3)]), body=[Expr(value=Constant(value='decorator to trim function calls to match the arity of the target')), Global(names=['_trim_arity_call_line']), If(test=Compare(left=Name(id='func', ctx=Load()), ops=[In()], comparators=[Name(id='_single_arg_builtins', ctx=Load())]), body=[Return(value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='func', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[])))], orelse=[]), Assign(targets=[Name(id='limit', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='found_arity', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='LINE_DIFF', ctx=Store())], value=Constant(value=7)), Assign(targets=[Name(id='_trim_arity_call_line', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='_trim_arity_call_line', ctx=Load()), Subscript(value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='extract_stack', ctx=Load()), args=[], keywords=[keyword(arg='limit', value=Constant(value=2))]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())])), Assign(targets=[Name(id='pa_call_line_synth', ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='_trim_arity_call_line', ctx=Load()), slice=Constant(value=0), ctx=Load()), BinOp(left=Subscript(value=Name(id='_trim_arity_call_line', ctx=Load()), slice=Constant(value=1), ctx=Load()), op=Add(), right=Name(id='LINE_DIFF', ctx=Load()))], ctx=Load())), FunctionDef(name='wrapper', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Nonlocal(names=['found_arity', 'limit']), While(test=Constant(value=1), body=[Try(body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='func', ctx=Load()), args=[Starred(value=Subscript(value=Name(id='args', ctx=Load()), slice=Slice(lower=Name(id='limit', ctx=Load())), ctx=Load()), ctx=Load())], keywords=[])), Assign(targets=[Name(id='found_arity', ctx=Store())], value=Constant(value=True)), Return(value=Name(id='ret', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), name='te', body=[If(test=Name(id='found_arity', ctx=Load()), body=[Raise()], orelse=[Assign(targets=[Name(id='tb', ctx=Store())], value=Attribute(value=Name(id='te', ctx=Load()), attr='__traceback__', ctx=Load())), Assign(targets=[Name(id='frames', ctx=Store())], value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='extract_tb', ctx=Load()), args=[Name(id='tb', ctx=Load())], keywords=[keyword(arg='limit', value=Constant(value=2))])), Assign(targets=[Name(id='frame_summary', ctx=Store())], value=Subscript(value=Name(id='frames', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), Assign(targets=[Name(id='trim_arity_type_error', ctx=Store())], value=Compare(left=Subscript(value=Subscript(value=List(elts=[Subscript(value=Name(id='frame_summary', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load())], ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[Eq()], comparators=[Name(id='pa_call_line_synth', ctx=Load())])), Delete(targets=[Name(id='tb', ctx=Del())]), If(test=Name(id='trim_arity_type_error', ctx=Load()), body=[If(test=Compare(left=Name(id='limit', ctx=Load()), ops=[Lt()], comparators=[Name(id='max_limit', ctx=Load())]), body=[AugAssign(target=Name(id='limit', ctx=Store()), op=Add(), value=Constant(value=1)), Continue()], orelse=[])], orelse=[]), Raise()])])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='func_name', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__name__'), Attribute(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__class__')], keywords=[]), attr='__name__', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='wrapper', ctx=Load()), attr='__name__', ctx=Store())], value=Name(id='func_name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='wrapper', ctx=Load()), attr='__doc__', ctx=Store())], value=Attribute(value=Name(id='func', ctx=Load()), attr='__doc__', ctx=Load())), Return(value=Name(id='wrapper', ctx=Load()))], decorator_list=[]), FunctionDef(name='condition_as_parse_action', args=arguments(posonlyargs=[], args=[arg(arg='fn', annotation=Name(id='ParseCondition', ctx=Load())), arg(arg='message', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='fatal', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Function to convert a simple predicate function that returns ``True`` or ``False``\n    into a parse action. Can be used in places when a parse action is required\n    and :class:`ParserElement.add_condition` cannot be used (such as when adding a condition\n    to an operator level in :class:`infix_notation`).\n\n    Optional keyword arguments:\n\n    - ``message`` - define a custom message to be used in the raised exception\n    - ``fatal`` - if True, will raise :class:`ParseFatalException` to stop parsing immediately;\n      otherwise will raise :class:`ParseException`\n\n    ')), Assign(targets=[Name(id='msg', ctx=Store())], value=IfExp(test=Compare(left=Name(id='message', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='message', ctx=Load()), orelse=Constant(value='failed user-defined condition'))), Assign(targets=[Name(id='exc_type', ctx=Store())], value=IfExp(test=Name(id='fatal', ctx=Load()), body=Name(id='ParseFatalException', ctx=Load()), orelse=Name(id='ParseException', ctx=Load()))), Assign(targets=[Name(id='fn', ctx=Store())], value=Call(func=Name(id='_trim_arity', ctx=Load()), args=[Name(id='fn', ctx=Load())], keywords=[])), FunctionDef(name='pa', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='bool', ctx=Load()), args=[Call(func=Name(id='fn', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), Name(id='t', ctx=Load())], keywords=[])], keywords=[])), body=[Raise(exc=Call(func=Name(id='exc_type', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), Name(id='msg', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[Call(func=Name(id='wraps', ctx=Load()), args=[Name(id='fn', ctx=Load())], keywords=[])]), Return(value=Name(id='pa', ctx=Load()))], decorator_list=[], returns=Name(id='ParseAction', ctx=Load())), FunctionDef(name='_default_start_debug_action', args=arguments(posonlyargs=[], args=[arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='loc', annotation=Name(id='int', ctx=Load())), arg(arg='expr', annotation=Constant(value='ParserElement')), arg(arg='cache_hit', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Assign(targets=[Name(id='cache_hit_str', ctx=Store())], value=IfExp(test=Name(id='cache_hit', ctx=Load()), body=Constant(value='*'), orelse=Constant(value=''))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='cache_hit_str', ctx=Load()), conversion=-1), Constant(value='Match '), FormattedValue(value=Name(id='expr', ctx=Load()), conversion=-1), Constant(value=' at loc '), FormattedValue(value=Name(id='loc', ctx=Load()), conversion=-1), Constant(value='('), FormattedValue(value=Call(func=Name(id='lineno', ctx=Load()), args=[Name(id='loc', ctx=Load()), Name(id='instring', ctx=Load())], keywords=[]), conversion=-1), Constant(value=','), FormattedValue(value=Call(func=Name(id='col', ctx=Load()), args=[Name(id='loc', ctx=Load()), Name(id='instring', ctx=Load())], keywords=[]), conversion=-1), Constant(value=')\n  '), FormattedValue(value=Call(func=Name(id='line', ctx=Load()), args=[Name(id='loc', ctx=Load()), Name(id='instring', ctx=Load())], keywords=[]), conversion=-1), Constant(value='\n  '), FormattedValue(value=BinOp(left=Constant(value=' '), op=Mult(), right=BinOp(left=Call(func=Name(id='col', ctx=Load()), args=[Name(id='loc', ctx=Load()), Name(id='instring', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))), conversion=-1), Constant(value='^')])], keywords=[]))], decorator_list=[]), FunctionDef(name='_default_success_debug_action', args=arguments(posonlyargs=[], args=[arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='startloc', annotation=Name(id='int', ctx=Load())), arg(arg='endloc', annotation=Name(id='int', ctx=Load())), arg(arg='expr', annotation=Constant(value='ParserElement')), arg(arg='toks', annotation=Name(id='ParseResults', ctx=Load())), arg(arg='cache_hit', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Assign(targets=[Name(id='cache_hit_str', ctx=Store())], value=IfExp(test=Name(id='cache_hit', ctx=Load()), body=Constant(value='*'), orelse=Constant(value=''))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='cache_hit_str', ctx=Load()), conversion=-1), Constant(value='Matched '), FormattedValue(value=Name(id='expr', ctx=Load()), conversion=-1), Constant(value=' -> '), FormattedValue(value=Call(func=Attribute(value=Name(id='toks', ctx=Load()), attr='as_list', ctx=Load()), args=[], keywords=[]), conversion=-1)])], keywords=[]))], decorator_list=[]), FunctionDef(name='_default_exception_debug_action', args=arguments(posonlyargs=[], args=[arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='loc', annotation=Name(id='int', ctx=Load())), arg(arg='expr', annotation=Constant(value='ParserElement')), arg(arg='exc', annotation=Name(id='Exception', ctx=Load())), arg(arg='cache_hit', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Assign(targets=[Name(id='cache_hit_str', ctx=Store())], value=IfExp(test=Name(id='cache_hit', ctx=Load()), body=Constant(value='*'), orelse=Constant(value=''))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='cache_hit_str', ctx=Load()), conversion=-1), Constant(value='Match '), FormattedValue(value=Name(id='expr', ctx=Load()), conversion=-1), Constant(value=' failed, '), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='exc', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value=' raised: '), FormattedValue(value=Name(id='exc', ctx=Load()), conversion=-1)])], keywords=[]))], decorator_list=[]), FunctionDef(name='null_debug_action', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="'Do-nothing' debug action, to suppress debugging output during parsing."))], decorator_list=[]), ClassDef(name='ParserElement', bases=[Name(id='ABC', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Abstract base level parser element class.')), AnnAssign(target=Name(id='DEFAULT_WHITE_CHARS', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Constant(value=' \n\t\r'), simple=1), AnnAssign(target=Name(id='verbose_stacktrace', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=Constant(value=False), simple=1), AnnAssign(target=Name(id='_literalStringClass', ctx=Store()), annotation=Name(id='type', ctx=Load()), value=Constant(value=None), simple=1), FunctionDef(name='set_default_whitespace_chars', args=arguments(posonlyargs=[], args=[arg(arg='chars', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Overrides the default whitespace chars\n\n        Example::\n\n            # default whitespace chars are space, <TAB> and newline\n            Word(alphas)[1, ...].parse_string("abc def\\nghi jkl")  # -> [\'abc\', \'def\', \'ghi\', \'jkl\']\n\n            # change to just treat newline as significant\n            ParserElement.set_default_whitespace_chars(" \\t")\n            Word(alphas)[1, ...].parse_string("abc def\\nghi jkl")  # -> [\'abc\', \'def\']\n        ')), Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='DEFAULT_WHITE_CHARS', ctx=Store())], value=Name(id='chars', ctx=Load())), For(target=Name(id='expr', ctx=Store()), iter=Name(id='_builtin_exprs', ctx=Load()), body=[If(test=Attribute(value=Name(id='expr', ctx=Load()), attr='copyDefaultWhiteChars', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='expr', ctx=Load()), attr='whiteChars', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='chars', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='inline_literals_using', args=arguments(posonlyargs=[], args=[arg(arg='cls', annotation=Name(id='type', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Set class to be used for inclusion of string literals into a parser.\n\n        Example::\n\n            # default literal class used is Literal\n            integer = Word(nums)\n            date_str = integer("year") + \'/\' + integer("month") + \'/\' + integer("day")\n\n            date_str.parse_string("1999/12/31")  # -> [\'1999\', \'/\', \'12\', \'/\', \'31\']\n\n\n            # change to Suppress\n            ParserElement.inline_literals_using(Suppress)\n            date_str = integer("year") + \'/\' + integer("month") + \'/\' + integer("day")\n\n            date_str.parse_string("1999/12/31")  # -> [\'1999\', \'12\', \'31\']\n        ')), Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_literalStringClass', ctx=Store())], value=Name(id='cls', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='using_each', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='seq')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='class_kwargs'), defaults=[]), body=[Expr(value=Constant(value='\n        Yields a sequence of class(obj, **class_kwargs) for obj in seq.\n\n        Example::\n\n            LPAR, RPAR, LBRACE, RBRACE, SEMI = Suppress.using_each("(){};")\n\n        ')), Expr(value=YieldFrom(value=GeneratorExp(elt=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='obj', ctx=Load())], keywords=[keyword(value=Name(id='class_kwargs', ctx=Load()))]), generators=[comprehension(target=Name(id='obj', ctx=Store()), iter=Name(id='seq', ctx=Load()), ifs=[], is_async=0)])))], decorator_list=[Name(id='classmethod', ctx=Load())]), ClassDef(name='DebugActions', bases=[Name(id='NamedTuple', ctx=Load())], keywords=[], body=[AnnAssign(target=Name(id='debug_try', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='DebugStartAction', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='debug_match', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='DebugSuccessAction', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='debug_fail', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='DebugExceptionAction', ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='savelist', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='parseAction', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='ParseAction', ctx=Load()), ctx=Load()), value=Call(func=Name(id='list', ctx=Load()), args=[], keywords=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='failAction', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='ParseFailAction', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='customName', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Constant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_defaultName', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='resultsName', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Constant(value=None), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Name(id='savelist', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='whiteChars', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='DEFAULT_WHITE_CHARS', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='copyDefaultWhiteChars', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='keepTabs', ctx=Store())], value=Constant(value=False)), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='ParserElement'), ctx=Load()), value=Call(func=Name(id='list', ctx=Load()), args=[], keywords=[]), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='debug', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='streamlined', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=Constant(value='')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='modalResults', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='DebugActions', ctx=Load()), args=[Constant(value=None), Constant(value=None), Constant(value=None)], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callPreparse', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callDuringTry', ctx=Store())], value=Constant(value=False)), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='suppress_warnings_', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Diagnostics', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0)], decorator_list=[]), FunctionDef(name='suppress_warning', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='warning_type', annotation=Name(id='Diagnostics', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Suppress warnings emitted for a particular diagnostic on this expression.\n\n        Example::\n\n            base = pp.Forward()\n            base.suppress_warning(Diagnostics.warn_on_parse_using_empty_Forward)\n\n            # statement would normally raise a warning, but is now suppressed\n            print(base.parse_string("x"))\n\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='suppress_warnings_', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='warning_type', ctx=Load())], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='visit_all', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='General-purpose method to yield all expressions and sub-expressions\n        in a grammar. Typically just for internal use.\n        ')), Assign(targets=[Name(id='to_visit', ctx=Store())], value=Call(func=Name(id='deque', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='seen', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), While(test=Name(id='to_visit', ctx=Load()), body=[Assign(targets=[Name(id='cur', ctx=Store())], value=Call(func=Attribute(value=Name(id='to_visit', ctx=Load()), attr='popleft', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='cur', ctx=Load()), ops=[In()], comparators=[Name(id='seen', ctx=Load())]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='cur', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='to_visit', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='cur', ctx=Load()), attr='recurse', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Yield(value=Name(id='cur', ctx=Load())))], orelse=[])], decorator_list=[]), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Make a copy of this :class:`ParserElement`.  Useful for defining\n        different parse actions for the same parsing pattern, using copies of\n        the original parse element.\n\n        Example::\n\n            integer = Word(nums).set_parse_action(lambda toks: int(toks[0]))\n            integerK = integer.copy().add_parse_action(lambda toks: toks[0] * 1024) + Suppress("K")\n            integerM = integer.copy().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress("M")\n\n            print((integerK | integerM | integer)[1, ...].parse_string("5K 100 640K 256M"))\n\n        prints::\n\n            [5120, 100, 655360, 268435456]\n\n        Equivalent form of ``expr.copy()`` is just ``expr()``::\n\n            integerM = integer().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress("M")\n        ')), Assign(targets=[Name(id='cpy', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='copy', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='cpy', ctx=Load()), attr='parseAction', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='parseAction', ctx=Load()), slice=Slice(), ctx=Load())), Assign(targets=[Attribute(value=Name(id='cpy', ctx=Load()), attr='ignoreExprs', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), slice=Slice(), ctx=Load())), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='copyDefaultWhiteChars', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='cpy', ctx=Load()), attr='whiteChars', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='DEFAULT_WHITE_CHARS', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='cpy', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='set_results_name', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='list_all_matches', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='listAllMatches', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n        Define name for referencing matching tokens as a nested attribute\n        of the returned parse results.\n\n        Normally, results names are assigned as you would assign keys in a dict:\n        any existing value is overwritten by later values. If it is necessary to\n        keep all values captured for a particular results name, call ``set_results_name``\n        with ``list_all_matches`` = True.\n\n        NOTE: ``set_results_name`` returns a *copy* of the original :class:`ParserElement` object;\n        this is so that the client can define a basic element, such as an\n        integer, and reference it in multiple places with different names.\n\n        You can also set results names using the abbreviated syntax,\n        ``expr("name")`` in place of ``expr.set_results_name("name")``\n        - see :class:`__call__`. If ``list_all_matches`` is required, use\n        ``expr("name*")``.\n\n        Example::\n\n            date_str = (integer.set_results_name("year") + \'/\'\n                        + integer.set_results_name("month") + \'/\'\n                        + integer.set_results_name("day"))\n\n            # equivalent form:\n            date_str = integer("year") + \'/\' + integer("month") + \'/\' + integer("day")\n        ')), Assign(targets=[Name(id='listAllMatches', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='listAllMatches', ctx=Load()), Name(id='list_all_matches', ctx=Load())])), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_setResultsName', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='listAllMatches', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='_setResultsName', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='listAllMatches')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='newself', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='*')], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Subscript(value=Name(id='name', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())), Assign(targets=[Name(id='listAllMatches', ctx=Store())], value=Constant(value=True))], orelse=[]), Assign(targets=[Attribute(value=Name(id='newself', ctx=Load()), attr='resultsName', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='newself', ctx=Load()), attr='modalResults', ctx=Store())], value=UnaryOp(op=Not(), operand=Name(id='listAllMatches', ctx=Load()))), Return(value=Name(id='newself', ctx=Load()))], decorator_list=[]), FunctionDef(name='set_break', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='break_flag', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n        Method to invoke the Python pdb debugger when this element is\n        about to be parsed. Set ``break_flag`` to ``True`` to enable, ``False`` to\n        disable.\n        ')), If(test=Name(id='break_flag', ctx=Load()), body=[Assign(targets=[Name(id='_parseMethod', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_parse', ctx=Load())), FunctionDef(name='breaker', args=arguments(posonlyargs=[], args=[arg(arg='instring'), arg(arg='loc'), arg(arg='doActions'), arg(arg='callPreParse')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=True)]), body=[Import(names=[alias(name='pdb')]), Expr(value=Call(func=Attribute(value=Name(id='pdb', ctx=Load()), attr='set_trace', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='_parseMethod', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load()), Name(id='callPreParse', ctx=Load())], keywords=[]))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='breaker', ctx=Load()), attr='_originalParseMethod', ctx=Store())], value=Name(id='_parseMethod', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_parse', ctx=Store())], value=Name(id='breaker', ctx=Load()))], orelse=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_parse', ctx=Load()), Constant(value='_originalParseMethod')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_parse', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_parse', ctx=Load()), attr='_originalParseMethod', ctx=Load()))], orelse=[])]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='set_parse_action', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='fns', annotation=Name(id='ParseAction', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='\n        Define one or more actions to perform when successfully matching parse element definition.\n\n        Parse actions can be called to perform data conversions, do extra validation,\n        update external data structures, or enhance or replace the parsed tokens.\n        Each parse action ``fn`` is a callable method with 0-3 arguments, called as\n        ``fn(s, loc, toks)`` , ``fn(loc, toks)`` , ``fn(toks)`` , or just ``fn()`` , where:\n\n        - ``s``    = the original string being parsed (see note below)\n        - ``loc``  = the location of the matching substring\n        - ``toks`` = a list of the matched tokens, packaged as a :class:`ParseResults` object\n\n        The parsed tokens are passed to the parse action as ParseResults. They can be\n        modified in place using list-style append, extend, and pop operations to update\n        the parsed list elements; and with dictionary-style item set and del operations\n        to add, update, or remove any named results. If the tokens are modified in place,\n        it is not necessary to return them with a return statement.\n\n        Parse actions can also completely replace the given tokens, with another ``ParseResults``\n        object, or with some entirely different object (common for parse actions that perform data\n        conversions). A convenient way to build a new parse result is to define the values\n        using a dict, and then create the return value using :class:`ParseResults.from_dict`.\n\n        If None is passed as the ``fn`` parse action, all previously added parse actions for this\n        expression are cleared.\n\n        Optional keyword arguments:\n\n        - ``call_during_try`` = (default= ``False``) indicate if parse action should be run during\n          lookaheads and alternate testing. For parse actions that have side effects, it is\n          important to only call the parse action once it is determined that it is being\n          called as part of a successful parse. For parse actions that perform additional\n          validation, then call_during_try should be passed as True, so that the validation\n          code is included in the preliminary "try" parses.\n\n        Note: the default parsing behavior is to expand tabs in the input string\n        before starting the parsing process.  See :class:`parse_string` for more\n        information on parsing strings containing ``<TAB>`` s, and suggested\n        methods to maintain a consistent view of the parsed string, the parse\n        location, and line and column positions within the parsed string.\n\n        Example::\n\n            # parse dates in the form YYYY/MM/DD\n\n            # use parse action to convert toks from str to int at parse time\n            def convert_to_int(toks):\n                return int(toks[0])\n\n            # use a parse action to verify that the date is a valid date\n            def is_valid_date(instring, loc, toks):\n                from datetime import date\n                year, month, day = toks[::2]\n                try:\n                    date(year, month, day)\n                except ValueError:\n                    raise ParseException(instring, loc, "invalid date given")\n\n            integer = Word(nums)\n            date_str = integer + \'/\' + integer + \'/\' + integer\n\n            # add parse actions\n            integer.set_parse_action(convert_to_int)\n            date_str.set_parse_action(is_valid_date)\n\n            # note that integer fields are now ints, not strings\n            date_str.run_tests(\'\'\'\n                # successful parse - note that integer fields were converted to ints\n                1999/12/31\n\n                # fail - invalid date\n                1999/13/31\n                \'\'\')\n        ')), If(test=Compare(left=Call(func=Name(id='list', ctx=Load()), args=[Name(id='fns', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[List(elts=[Constant(value=None)], ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parseAction', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='fn', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='fn', ctx=Store()), iter=Name(id='fns', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='parse actions must be callable')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parseAction', ctx=Store())], value=ListComp(elt=Call(func=Name(id='_trim_arity', ctx=Load()), args=[Name(id='fn', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='fn', ctx=Store()), iter=Name(id='fns', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callDuringTry', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='call_during_try'), Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='callDuringTry'), Constant(value=False)], keywords=[])], keywords=[]))]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='add_parse_action', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='fns', annotation=Name(id='ParseAction', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value="\n        Add one or more parse actions to expression's list of parse actions. See :class:`set_parse_action`.\n\n        See examples in :class:`copy`.\n        ")), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='parseAction', ctx=Store()), op=Add(), value=ListComp(elt=Call(func=Name(id='_trim_arity', ctx=Load()), args=[Name(id='fn', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='fn', ctx=Store()), iter=Name(id='fns', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callDuringTry', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='callDuringTry', ctx=Load()), Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='call_during_try'), Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='callDuringTry'), Constant(value=False)], keywords=[])], keywords=[])])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='add_condition', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='fns', annotation=Name(id='ParseCondition', ctx=Load())), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Add a boolean predicate function to expression\'s list of parse actions. See\n        :class:`set_parse_action` for function call signatures. Unlike ``set_parse_action``,\n        functions passed to ``add_condition`` need to return boolean success/fail of the condition.\n\n        Optional keyword arguments:\n\n        - ``message`` = define a custom message to be used in the raised exception\n        - ``fatal`` = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise\n          ParseException\n        - ``call_during_try`` = boolean to indicate if this method should be called during internal tryParse calls,\n          default=False\n\n        Example::\n\n            integer = Word(nums).set_parse_action(lambda toks: int(toks[0]))\n            year_int = integer.copy()\n            year_int.add_condition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")\n            date_str = year_int + \'/\' + integer + \'/\' + integer\n\n            result = date_str.parse_string("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0),\n                                                                         (line:1, col:1)\n        ')), For(target=Name(id='fn', ctx=Store()), iter=Name(id='fns', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parseAction', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='condition_as_parse_action', ctx=Load()), args=[Name(id='fn', ctx=Load())], keywords=[keyword(arg='message', value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='message')], keywords=[])], keywords=[])), keyword(arg='fatal', value=Call(func=Name(id='bool', ctx=Load()), args=[Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='fatal'), Constant(value=False)], keywords=[])], keywords=[]))])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callDuringTry', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='callDuringTry', ctx=Load()), Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='call_during_try'), Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='callDuringTry'), Constant(value=False)], keywords=[])], keywords=[])])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='set_fail_action', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fn', annotation=Name(id='ParseFailAction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Define action to perform if parsing fails at this expression.\n        Fail acton fn is a callable function that takes the arguments\n        ``fn(s, loc, expr, err)`` where:\n\n        - ``s`` = string being parsed\n        - ``loc`` = location where expression match was attempted and failed\n        - ``expr`` = the parse expression that failed\n        - ``err`` = the exception thrown\n\n        The function returns no value.  It may throw :class:`ParseFatalException`\n        if it is desired to stop parsing immediately.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='failAction', ctx=Store())], value=Name(id='fn', ctx=Load())), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='_skipIgnorables', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='loc', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load())), body=[Return(value=Name(id='loc', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='exprsFound', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='ignore_expr_fns', ctx=Store())], value=ListComp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='_parse', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), ifs=[], is_async=0)])), While(test=Name(id='exprsFound', ctx=Load()), body=[Assign(targets=[Name(id='exprsFound', ctx=Store())], value=Constant(value=False)), For(target=Name(id='ignore_fn', ctx=Store()), iter=Name(id='ignore_expr_fns', ctx=Load()), body=[Try(body=[While(test=Constant(value=1), body=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='dummy', ctx=Store())], ctx=Store())], value=Call(func=Name(id='ignore_fn', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='exprsFound', ctx=Store())], value=Constant(value=True))], orelse=[])], handlers=[ExceptHandler(type=Name(id='ParseException', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[])], orelse=[]), Return(value=Name(id='loc', ctx=Load()))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='preParse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='loc', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), body=[Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_skipIgnorables', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Load()), body=[Assign(targets=[Name(id='instrlen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])), Assign(targets=[Name(id='white_chars', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='whiteChars', ctx=Load())), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Name(id='instrlen', ctx=Load())]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[In()], comparators=[Name(id='white_chars', ctx=Load())])]), body=[AugAssign(target=Name(id='loc', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[]), Return(value=Name(id='loc', ctx=Load()))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), List(elts=[], ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='postParse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='tokenlist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='tokenlist', ctx=Load()))], decorator_list=[]), FunctionDef(name='_parseNoCache', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions'), arg(arg='callPreParse')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=True)]), body=[Assign(targets=[Tuple(elts=[Name(id='TRY', ctx=Store()), Name(id='MATCH', ctx=Store()), Name(id='FAIL', ctx=Store())], ctx=Store())], value=Tuple(elts=[Constant(value=0), Constant(value=1), Constant(value=2)], ctx=Load())), Assign(targets=[Name(id='debugging', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='debug', ctx=Load())), Assign(targets=[Name(id='len_instring', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Name(id='debugging', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='failAction', ctx=Load())]), body=[Try(body=[If(test=BoolOp(op=And(), values=[Name(id='callPreParse', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='callPreparse', ctx=Load())]), body=[Assign(targets=[Name(id='pre_loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='preParse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='pre_loc', ctx=Store())], value=Name(id='loc', ctx=Load()))]), Assign(targets=[Name(id='tokens_start', ctx=Store())], value=Name(id='pre_loc', ctx=Load())), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_try', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_try', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tokens_start', ctx=Load()), Name(id='self', ctx=Load()), Constant(value=False)], keywords=[]))], orelse=[]), If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Load()), Compare(left=Name(id='pre_loc', ctx=Load()), ops=[GtE()], comparators=[Name(id='len_instring', ctx=Load())])]), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='tokens', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='pre_loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='len_instring', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], orelse=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='tokens', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='pre_loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='err', body=[If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_fail', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_fail', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tokens_start', ctx=Load()), Name(id='self', ctx=Load()), Name(id='err', ctx=Load()), Constant(value=False)], keywords=[]))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='failAction', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='failAction', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tokens_start', ctx=Load()), Name(id='self', ctx=Load()), Name(id='err', ctx=Load())], keywords=[]))], orelse=[]), Raise()])], orelse=[], finalbody=[])], orelse=[If(test=BoolOp(op=And(), values=[Name(id='callPreParse', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='callPreparse', ctx=Load())]), body=[Assign(targets=[Name(id='pre_loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='preParse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='pre_loc', ctx=Store())], value=Name(id='loc', ctx=Load()))]), Assign(targets=[Name(id='tokens_start', ctx=Store())], value=Name(id='pre_loc', ctx=Load())), If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Load()), Compare(left=Name(id='pre_loc', ctx=Load()), ops=[GtE()], comparators=[Name(id='len_instring', ctx=Load())])]), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='tokens', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='pre_loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='len_instring', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], orelse=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='tokens', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='pre_loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))])]), Assign(targets=[Name(id='tokens', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='postParse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='tokens', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ret_tokens', ctx=Store())], value=Call(func=Name(id='ParseResults', ctx=Load()), args=[Name(id='tokens', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='resultsName', ctx=Load())], keywords=[keyword(arg='asList', value=Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Load())), keyword(arg='modal', value=Attribute(value=Name(id='self', ctx=Load()), attr='modalResults', ctx=Load()))])), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='parseAction', ctx=Load()), BoolOp(op=Or(), values=[Name(id='doActions', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='callDuringTry', ctx=Load())])]), body=[If(test=Name(id='debugging', ctx=Load()), body=[Try(body=[For(target=Name(id='fn', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='parseAction', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='tokens', ctx=Store())], value=Call(func=Name(id='fn', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tokens_start', ctx=Load()), Name(id='ret_tokens', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), name='parse_action_exc', body=[Assign(targets=[Name(id='exc', ctx=Store())], value=Call(func=Name(id='ParseException', ctx=Load()), args=[Constant(value='exception raised in parse action')], keywords=[])), Raise(exc=Name(id='exc', ctx=Load()), cause=Name(id='parse_action_exc', ctx=Load()))])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='tokens', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='tokens', ctx=Load()), ops=[IsNot()], comparators=[Name(id='ret_tokens', ctx=Load())])]), body=[Assign(targets=[Name(id='ret_tokens', ctx=Store())], value=Call(func=Name(id='ParseResults', ctx=Load()), args=[Name(id='tokens', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='resultsName', ctx=Load())], keywords=[keyword(arg='asList', value=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Load()), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tokens', ctx=Load()), Tuple(elts=[Name(id='ParseResults', ctx=Load()), Name(id='list', ctx=Load())], ctx=Load())], keywords=[])])), keyword(arg='modal', value=Attribute(value=Name(id='self', ctx=Load()), attr='modalResults', ctx=Load()))]))], orelse=[])], orelse=[])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='err', body=[If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_fail', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_fail', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tokens_start', ctx=Load()), Name(id='self', ctx=Load()), Name(id='err', ctx=Load()), Constant(value=False)], keywords=[]))], orelse=[]), Raise()])], orelse=[], finalbody=[])], orelse=[For(target=Name(id='fn', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='parseAction', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='tokens', ctx=Store())], value=Call(func=Name(id='fn', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tokens_start', ctx=Load()), Name(id='ret_tokens', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), name='parse_action_exc', body=[Assign(targets=[Name(id='exc', ctx=Store())], value=Call(func=Name(id='ParseException', ctx=Load()), args=[Constant(value='exception raised in parse action')], keywords=[])), Raise(exc=Name(id='exc', ctx=Load()), cause=Name(id='parse_action_exc', ctx=Load()))])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='tokens', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='tokens', ctx=Load()), ops=[IsNot()], comparators=[Name(id='ret_tokens', ctx=Load())])]), body=[Assign(targets=[Name(id='ret_tokens', ctx=Store())], value=Call(func=Name(id='ParseResults', ctx=Load()), args=[Name(id='tokens', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='resultsName', ctx=Load())], keywords=[keyword(arg='asList', value=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Load()), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tokens', ctx=Load()), Tuple(elts=[Name(id='ParseResults', ctx=Load()), Name(id='list', ctx=Load())], ctx=Load())], keywords=[])])), keyword(arg='modal', value=Attribute(value=Name(id='self', ctx=Load()), attr='modalResults', ctx=Load()))]))], orelse=[])], orelse=[])])], orelse=[]), If(test=Name(id='debugging', ctx=Load()), body=[If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_match', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_match', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tokens_start', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='self', ctx=Load()), Name(id='ret_tokens', ctx=Load()), Constant(value=False)], keywords=[]))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='ret_tokens', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='ParseResults', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='try_parse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='loc', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[arg(arg='raise_fatal', annotation=Name(id='bool', ctx=Load())), arg(arg='do_actions', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False), Constant(value=False)], defaults=[]), body=[Try(body=[Return(value=Subscript(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[keyword(arg='doActions', value=Name(id='do_actions', ctx=Load()))]), slice=Constant(value=0), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ParseFatalException', ctx=Load()), body=[If(test=Name(id='raise_fatal', ctx=Load()), body=[Raise()], orelse=[]), Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='can_parse_next', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='loc', annotation=Name(id='int', ctx=Load())), arg(arg='do_actions', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='try_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[keyword(arg='do_actions', value=Name(id='do_actions', ctx=Load()))]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ParseException', ctx=Load()), Name(id='IndexError', ctx=Load())], ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[Return(value=Constant(value=True))], finalbody=[])], decorator_list=[], returns=Name(id='bool', ctx=Load())), Assign(targets=[Name(id='recursion_lock', ctx=Store())], value=Call(func=Name(id='RLock', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Name(id='recursion_memos', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Dict', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value='Forward'), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParseResults', ctx=Load()), Name(id='Exception', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), ClassDef(name='_CacheType', bases=[Name(id='dict', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n        class to help type checking\n        ')), AnnAssign(target=Name(id='not_in_cache', ctx=Store()), annotation=Name(id='bool', ctx=Load()), simple=1), FunctionDef(name='get', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[]), FunctionDef(name='set', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='packrat_cache', ctx=Store())], value=Call(func=Name(id='_CacheType', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='packrat_cache_lock', ctx=Store())], value=Call(func=Name(id='RLock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='packrat_cache_stats', ctx=Store())], value=List(elts=[Constant(value=0), Constant(value=0)], ctx=Load())), FunctionDef(name='_parseCache', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions'), arg(arg='callPreParse')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=True)]), body=[Assign(targets=[Tuple(elts=[Name(id='HIT', ctx=Store()), Name(id='MISS', ctx=Store())], ctx=Store())], value=Tuple(elts=[Constant(value=0), Constant(value=1)], ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='TRY', ctx=Store()), Name(id='MATCH', ctx=Store()), Name(id='FAIL', ctx=Store())], ctx=Store())], value=Tuple(elts=[Constant(value=0), Constant(value=1), Constant(value=2)], ctx=Load())), Assign(targets=[Name(id='lookup', ctx=Store())], value=Tuple(elts=[Name(id='self', ctx=Load()), Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='callPreParse', ctx=Load()), Name(id='doActions', ctx=Load())], ctx=Load())), With(items=[withitem(context_expr=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='packrat_cache_lock', ctx=Load()))], body=[Assign(targets=[Name(id='cache', ctx=Store())], value=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='packrat_cache', ctx=Load())), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='cache', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='lookup', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='cache', ctx=Load()), attr='not_in_cache', ctx=Load())]), body=[AugAssign(target=Subscript(value=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='packrat_cache_stats', ctx=Load()), slice=Name(id='MISS', ctx=Load()), ctx=Store()), op=Add(), value=Constant(value=1)), Try(body=[Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parseNoCache', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load()), Name(id='callPreParse', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), name='pe', body=[Expr(value=Call(func=Attribute(value=Name(id='cache', ctx=Load()), attr='set', ctx=Load()), args=[Name(id='lookup', ctx=Load()), Call(func=Attribute(value=Name(id='pe', ctx=Load()), attr='__class__', ctx=Load()), args=[Starred(value=Attribute(value=Name(id='pe', ctx=Load()), attr='args', ctx=Load()), ctx=Load())], keywords=[])], keywords=[])), Raise()])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='cache', ctx=Load()), attr='set', ctx=Load()), args=[Name(id='lookup', ctx=Load()), Tuple(elts=[Subscript(value=Name(id='value', ctx=Load()), slice=Constant(value=0), ctx=Load()), Call(func=Attribute(value=Subscript(value=Name(id='value', ctx=Load()), slice=Constant(value=1), ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), Name(id='loc', ctx=Load())], ctx=Load())], keywords=[])), Return(value=Name(id='value', ctx=Load()))], finalbody=[])], orelse=[AugAssign(target=Subscript(value=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='packrat_cache_stats', ctx=Load()), slice=Name(id='HIT', ctx=Load()), ctx=Store()), op=Add(), value=Constant(value=1)), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='debug', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_try', ctx=Load())]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_try', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='self', ctx=Load())], keywords=[keyword(arg='cache_hit', value=Constant(value=True))]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='Exception', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='debug', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_fail', ctx=Load())]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_fail', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='self', ctx=Load()), Name(id='value', ctx=Load())], keywords=[keyword(arg='cache_hit', value=Constant(value=True))]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Raise(exc=Name(id='value', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='value', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='ParseResults', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), Name(id='value', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='loc_', ctx=Store()), Name(id='result', ctx=Store()), Name(id='endloc', ctx=Store())], ctx=Store())], value=Tuple(elts=[Subscript(value=Name(id='value', ctx=Load()), slice=Constant(value=0), ctx=Load()), Call(func=Attribute(value=Subscript(value=Name(id='value', ctx=Load()), slice=Constant(value=1), ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), Subscript(value=Name(id='value', ctx=Load()), slice=Constant(value=2), ctx=Load())], ctx=Load())), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='debug', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_match', ctx=Load())]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Load()), attr='debug_match', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc_', ctx=Load()), Name(id='endloc', ctx=Load()), Name(id='self', ctx=Load()), Name(id='result', ctx=Load())], keywords=[keyword(arg='cache_hit', value=Constant(value=True))]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='loc_', ctx=Load()), Name(id='result', ctx=Load())], ctx=Load()))])])], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='ParseResults', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='_parse', ctx=Store())], value=Name(id='_parseNoCache', ctx=Load())), FunctionDef(name='reset_cache', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='packrat_cache', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='packrat_cache_stats', ctx=Load()), slice=Slice(), ctx=Store())], value=BinOp(left=List(elts=[Constant(value=0)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='packrat_cache_stats', ctx=Load())], keywords=[]))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='recursion_memos', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Constant(value=None)), Assign(targets=[Name(id='_packratEnabled', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='_left_recursion_enabled', ctx=Store())], value=Constant(value=False)), FunctionDef(name='disable_memoization', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Disables active Packrat or Left Recursion parsing and their memoization\n\n        This method also works if neither Packrat nor Left Recursion are enabled.\n        This makes it safe to call before activating Packrat nor Left Recursion\n        to clear any previous settings.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='reset_cache', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_left_recursion_enabled', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_packratEnabled', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_parse', ctx=Store())], value=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_parseNoCache', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='enable_left_recursion', args=arguments(posonlyargs=[], args=[arg(arg='cache_size_limit', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='force')], kw_defaults=[Constant(value=False)], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Enables "bounded recursion" parsing, which allows for both direct and indirect\n        left-recursion. During parsing, left-recursive :class:`Forward` elements are\n        repeatedly matched with a fixed recursion depth that is gradually increased\n        until finding the longest match.\n\n        Example::\n\n            from pip._vendor import pyparsing as pp\n            pp.ParserElement.enable_left_recursion()\n\n            E = pp.Forward("E")\n            num = pp.Word(pp.nums)\n            # match `num`, or `num \'+\' num`, or `num \'+\' num \'+\' num`, ...\n            E <<= E + \'+\' - num | num\n\n            print(E.parse_string("1+2+3"))\n\n        Recursion search naturally memoizes matches of ``Forward`` elements and may\n        thus skip reevaluation of parse actions during backtracking. This may break\n        programs with parse actions which rely on strict ordering of side-effects.\n\n        Parameters:\n\n        - ``cache_size_limit`` - (default=``None``) - memoize at most this many\n          ``Forward`` elements during matching; if ``None`` (the default),\n          memoize all ``Forward`` elements.\n\n        Bounded Recursion parsing works similar but not identical to Packrat parsing,\n        thus the two cannot be used together. Use ``force=True`` to disable any\n        previous, conflicting settings.\n        ')), If(test=Name(id='force', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='disable_memoization', ctx=Load()), args=[], keywords=[]))], orelse=[If(test=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_packratEnabled', ctx=Load()), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='Packrat and Bounded Recursion are not compatible')], keywords=[]))], orelse=[])]), If(test=Compare(left=Name(id='cache_size_limit', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='recursion_memos', ctx=Store())], value=Call(func=Name(id='_UnboundedMemo', ctx=Load()), args=[], keywords=[]))], orelse=[If(test=Compare(left=Name(id='cache_size_limit', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='recursion_memos', ctx=Store())], value=Call(func=Name(id='_LRUMemo', ctx=Load()), args=[], keywords=[keyword(arg='capacity', value=Name(id='cache_size_limit', ctx=Load()))]))], orelse=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[BinOp(left=Constant(value='Memo size of %s'), op=Mod(), right=Name(id='cache_size_limit', ctx=Load()))], keywords=[]))])]), Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_left_recursion_enabled', ctx=Store())], value=Constant(value=True))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='enable_packrat', args=arguments(posonlyargs=[], args=[arg(arg='cache_size_limit', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[arg(arg='force', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value=128)]), body=[Expr(value=Constant(value='\n        Enables "packrat" parsing, which adds memoizing to the parsing logic.\n        Repeated parse attempts at the same string location (which happens\n        often in many complex grammars) can immediately return a cached value,\n        instead of re-executing parsing/validating code.  Memoizing is done of\n        both valid results and parsing exceptions.\n\n        Parameters:\n\n        - ``cache_size_limit`` - (default= ``128``) - if an integer value is provided\n          will limit the size of the packrat cache; if None is passed, then\n          the cache size will be unbounded; if 0 is passed, the cache will\n          be effectively disabled.\n\n        This speedup may break existing programs that use parse actions that\n        have side-effects.  For this reason, packrat parsing is disabled when\n        you first import pyparsing.  To activate the packrat feature, your\n        program must call the class method :class:`ParserElement.enable_packrat`.\n        For best results, call ``enable_packrat()`` immediately after\n        importing pyparsing.\n\n        Example::\n\n            from pip._vendor import pyparsing\n            pyparsing.ParserElement.enable_packrat()\n\n        Packrat parsing works similar but not identical to Bounded Recursion parsing,\n        thus the two cannot be used together. Use ``force=True`` to disable any\n        previous, conflicting settings.\n        ')), If(test=Name(id='force', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='disable_memoization', ctx=Load()), args=[], keywords=[]))], orelse=[If(test=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_left_recursion_enabled', ctx=Load()), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='Packrat and Bounded Recursion are not compatible')], keywords=[]))], orelse=[])]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_packratEnabled', ctx=Load())), body=[Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_packratEnabled', ctx=Store())], value=Constant(value=True)), If(test=Compare(left=Name(id='cache_size_limit', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='packrat_cache', ctx=Store())], value=Call(func=Name(id='_UnboundedCache', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='packrat_cache', ctx=Store())], value=Call(func=Name(id='_FifoCache', ctx=Load()), args=[Name(id='cache_size_limit', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_parse', ctx=Store())], value=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_parseCache', ctx=Load()))], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='parse_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='parse_all', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='parseAll', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value="\n        Parse a string with respect to the parser definition. This function is intended as the primary interface to the\n        client code.\n\n        :param instring: The input string to be parsed.\n        :param parse_all: If set, the entire input string must match the grammar.\n        :param parseAll: retained for pre-PEP8 compatibility, will be removed in a future release.\n        :raises ParseException: Raised if ``parse_all`` is set and the input string does not match the whole grammar.\n        :returns: the parsed data as a :class:`ParseResults` object, which may be accessed as a `list`, a `dict`, or\n          an object with attributes if the given parser includes results names.\n\n        If the input string is required to match the entire grammar, ``parse_all`` flag must be set to ``True``. This\n        is also equivalent to ending the grammar with :class:`StringEnd`\\ ().\n\n        To report proper column numbers, ``parse_string`` operates on a copy of the input string where all tabs are\n        converted to spaces (8 spaces per tab, as per the default in ``string.expandtabs``). If the input string\n        contains tabs and the grammar uses parse actions that use the ``loc`` argument to index into the string\n        being parsed, one can ensure a consistent view of the input string by doing one of the following:\n\n        - calling ``parse_with_tabs`` on your grammar before calling ``parse_string`` (see :class:`parse_with_tabs`),\n        - define your parse action using the full ``(s,loc,toks)`` signature, and reference the input string using the\n          parse action's ``s`` argument, or\n        - explicitly expand the tabs in your input string before calling ``parse_string``.\n\n        Examples:\n\n        By default, partial matches are OK.\n\n        >>> res = Word('a').parse_string('aaaaabaaa')\n        >>> print(res)\n        ['aaaaa']\n\n        The parsing behavior varies by the inheriting class of this abstract class. Please refer to the children\n        directly to see more examples.\n\n        It raises an exception if parse_all flag is set and instring does not match the whole grammar.\n\n        >>> res = Word('a').parse_string('aaaaabaaa', parse_all=True)\n        Traceback (most recent call last):\n        ...\n        pyparsing.ParseException: Expected end of text, found 'b'  (at char 5), (line:1, col:6)\n        ")), Assign(targets=[Name(id='parseAll', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='parse_all', ctx=Load()), Name(id='parseAll', ctx=Load())])), Expr(value=Call(func=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='reset_cache', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='streamlined', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='streamline', ctx=Load()), args=[], keywords=[]))], orelse=[]), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='streamline', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='keepTabs', ctx=Load())), body=[Assign(targets=[Name(id='instring', ctx=Store())], value=Call(func=Attribute(value=Name(id='instring', ctx=Load()), attr='expandtabs', ctx=Load()), args=[], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='tokens', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Constant(value=0)], keywords=[])), If(test=Name(id='parseAll', ctx=Load()), body=[Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='preParse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='se', ctx=Store())], value=BinOp(left=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id='StringEnd', ctx=Load()), args=[], keywords=[]))), Expr(value=Call(func=Attribute(value=Name(id='se', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), name='exc', body=[If(test=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='verbose_stacktrace', ctx=Load()), body=[Raise()], orelse=[Raise(exc=Call(func=Attribute(value=Name(id='exc', ctx=Load()), attr='with_traceback', ctx=Load()), args=[Constant(value=None)], keywords=[]))])])], orelse=[Return(value=Name(id='tokens', ctx=Load()))], finalbody=[])], decorator_list=[], returns=Name(id='ParseResults', ctx=Load())), FunctionDef(name='scan_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='max_matches', annotation=Name(id='int', ctx=Load())), arg(arg='overlap', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='debug', annotation=Name(id='bool', ctx=Load())), arg(arg='maxMatches', annotation=Name(id='int', ctx=Load()))], kw_defaults=[Constant(value=False), Name(id='_MAX_INT', ctx=Load())], defaults=[Name(id='_MAX_INT', ctx=Load()), Constant(value=False)]), body=[Expr(value=Constant(value='\n        Scan the input string for expression matches.  Each match will return the\n        matching tokens, start location, and end location.  May be called with optional\n        ``max_matches`` argument, to clip scanning after \'n\' matches are found.  If\n        ``overlap`` is specified, then overlapping matches will be reported.\n\n        Note that the start and end locations are reported relative to the string\n        being parsed.  See :class:`parse_string` for more information on parsing\n        strings with embedded tabs.\n\n        Example::\n\n            source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"\n            print(source)\n            for tokens, start, end in Word(alphas).scan_string(source):\n                print(\' \'*start + \'^\'*(end-start))\n                print(\' \'*start + tokens[0])\n\n        prints::\n\n            sldjf123lsdjjkf345sldkjf879lkjsfd987\n            ^^^^^\n            sldjf\n                    ^^^^^^^\n                    lsdjjkf\n                              ^^^^^^\n                              sldkjf\n                                       ^^^^^^\n                                       lkjsfd\n        ')), Assign(targets=[Name(id='maxMatches', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='maxMatches', ctx=Load()), Name(id='max_matches', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='streamlined', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='streamline', ctx=Load()), args=[], keywords=[]))], orelse=[]), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='streamline', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='keepTabs', ctx=Load())), body=[Assign(targets=[Name(id='instring', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[]), attr='expandtabs', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='instrlen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])), Assign(targets=[Name(id='loc', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='preparseFn', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='preParse', ctx=Load())), Assign(targets=[Name(id='parseFn', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_parse', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='resetCache', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='matches', ctx=Store())], value=Constant(value=0)), Try(body=[While(test=BoolOp(op=And(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[LtE()], comparators=[Name(id='instrlen', ctx=Load())]), Compare(left=Name(id='matches', ctx=Load()), ops=[Lt()], comparators=[Name(id='maxMatches', ctx=Load())])]), body=[Try(body=[AnnAssign(target=Name(id='preloc', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Call(func=Name(id='preparseFn', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]), simple=1), AnnAssign(target=Name(id='nextLoc', ctx=Store()), annotation=Name(id='int', ctx=Load()), simple=1), AnnAssign(target=Name(id='tokens', ctx=Store()), annotation=Name(id='ParseResults', ctx=Load()), simple=1), Assign(targets=[Tuple(elts=[Name(id='nextLoc', ctx=Store()), Name(id='tokens', ctx=Store())], ctx=Store())], value=Call(func=Name(id='parseFn', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='preloc', ctx=Load())], keywords=[keyword(arg='callPreParse', value=Constant(value=False))]))], handlers=[ExceptHandler(type=Name(id='ParseException', ctx=Load()), body=[Assign(targets=[Name(id='loc', ctx=Store())], value=BinOp(left=Name(id='preloc', ctx=Load()), op=Add(), right=Constant(value=1)))])], orelse=[If(test=Compare(left=Name(id='nextLoc', ctx=Load()), ops=[Gt()], comparators=[Name(id='loc', ctx=Load())]), body=[AugAssign(target=Name(id='matches', ctx=Store()), op=Add(), value=Constant(value=1)), If(test=Name(id='debug', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Dict(keys=[Constant(value='tokens'), Constant(value='start'), Constant(value='end')], values=[Call(func=Attribute(value=Name(id='tokens', ctx=Load()), attr='asList', ctx=Load()), args=[], keywords=[]), Name(id='preloc', ctx=Load()), Name(id='nextLoc', ctx=Load())])], keywords=[]))], orelse=[]), Expr(value=Yield(value=Tuple(elts=[Name(id='tokens', ctx=Load()), Name(id='preloc', ctx=Load()), Name(id='nextLoc', ctx=Load())], ctx=Load()))), If(test=Name(id='overlap', ctx=Load()), body=[Assign(targets=[Name(id='nextloc', ctx=Store())], value=Call(func=Name(id='preparseFn', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='nextloc', ctx=Load()), ops=[Gt()], comparators=[Name(id='loc', ctx=Load())]), body=[Assign(targets=[Name(id='loc', ctx=Store())], value=Name(id='nextLoc', ctx=Load()))], orelse=[AugAssign(target=Name(id='loc', ctx=Store()), op=Add(), value=Constant(value=1))])], orelse=[Assign(targets=[Name(id='loc', ctx=Store())], value=Name(id='nextLoc', ctx=Load()))])], orelse=[Assign(targets=[Name(id='loc', ctx=Store())], value=BinOp(left=Name(id='preloc', ctx=Load()), op=Add(), right=Constant(value=1)))])], finalbody=[])], orelse=[])], handlers=[ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), name='exc', body=[If(test=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='verbose_stacktrace', ctx=Load()), body=[Raise()], orelse=[Raise(exc=Call(func=Attribute(value=Name(id='exc', ctx=Load()), attr='with_traceback', ctx=Load()), args=[Constant(value=None)], keywords=[]))])])], orelse=[], finalbody=[])], decorator_list=[], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='ParseResults', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), FunctionDef(name='transform_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='debug', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[]), body=[Expr(value=Constant(value='\n        Extension to :class:`scan_string`, to modify matching text with modified tokens that may\n        be returned from a parse action.  To use ``transform_string``, define a grammar and\n        attach a parse action to it that modifies the returned token list.\n        Invoking ``transform_string()`` on a target string will then scan for matches,\n        and replace the matched text patterns according to the logic in the parse\n        action.  ``transform_string()`` returns the resulting transformed string.\n\n        Example::\n\n            wd = Word(alphas)\n            wd.set_parse_action(lambda toks: toks[0].title())\n\n            print(wd.transform_string("now is the winter of our discontent made glorious summer by this sun of york."))\n\n        prints::\n\n            Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.\n        ')), AnnAssign(target=Name(id='out', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='lastE', ctx=Store())], value=Constant(value=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='keepTabs', ctx=Store())], value=Constant(value=True)), Try(body=[For(target=Tuple(elts=[Name(id='t', ctx=Store()), Name(id='s', ctx=Store()), Name(id='e', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='scan_string', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[keyword(arg='debug', value=Name(id='debug', ctx=Load()))]), body=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='lastE', ctx=Load()), upper=Name(id='s', ctx=Load())), ctx=Load())], keywords=[])), If(test=Name(id='t', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Name(id='ParseResults', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='out', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='as_list', ctx=Load()), args=[], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Name(id='Iterable', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='t', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]))]), body=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]))])])], orelse=[]), Assign(targets=[Name(id='lastE', ctx=Store())], value=Name(id='e', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='lastE', ctx=Load())), ctx=Load())], keywords=[])), Assign(targets=[Name(id='out', ctx=Store())], value=ListComp(elt=Name(id='o', ctx=Load()), generators=[comprehension(target=Name(id='o', ctx=Store()), iter=Name(id='out', ctx=Load()), ifs=[Name(id='o', ctx=Load())], is_async=0)])), Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='s', ctx=Store()), iter=Call(func=Name(id='_flatten', ctx=Load()), args=[Name(id='out', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), name='exc', body=[If(test=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='verbose_stacktrace', ctx=Load()), body=[Raise()], orelse=[Raise(exc=Call(func=Attribute(value=Name(id='exc', ctx=Load()), attr='with_traceback', ctx=Load()), args=[Constant(value=None)], keywords=[]))])])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='search_string', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='max_matches', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[arg(arg='debug', annotation=Name(id='bool', ctx=Load())), arg(arg='maxMatches', annotation=Name(id='int', ctx=Load()))], kw_defaults=[Constant(value=False), Name(id='_MAX_INT', ctx=Load())], defaults=[Name(id='_MAX_INT', ctx=Load())]), body=[Expr(value=Constant(value='\n        Another extension to :class:`scan_string`, simplifying the access to the tokens found\n        to match the given parse expression.  May be called with optional\n        ``max_matches`` argument, to clip searching after \'n\' matches are found.\n\n        Example::\n\n            # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters\n            cap_word = Word(alphas.upper(), alphas.lower())\n\n            print(cap_word.search_string("More than Iron, more than Lead, more than Gold I need Electricity"))\n\n            # the sum() builtin can be used to merge results into a single ParseResults object\n            print(sum(cap_word.search_string("More than Iron, more than Lead, more than Gold I need Electricity")))\n\n        prints::\n\n            [[\'More\'], [\'Iron\'], [\'Lead\'], [\'Gold\'], [\'I\'], [\'Electricity\']]\n            [\'More\', \'Iron\', \'Lead\', \'Gold\', \'I\', \'Electricity\']\n        ')), Assign(targets=[Name(id='maxMatches', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='maxMatches', ctx=Load()), Name(id='max_matches', ctx=Load())], keywords=[])), Try(body=[Return(value=Call(func=Name(id='ParseResults', ctx=Load()), args=[ListComp(elt=Name(id='t', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='t', ctx=Store()), Name(id='s', ctx=Store()), Name(id='e', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='scan_string', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='maxMatches', ctx=Load())], keywords=[keyword(arg='debug', value=Name(id='debug', ctx=Load()))]), ifs=[], is_async=0)])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), name='exc', body=[If(test=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='verbose_stacktrace', ctx=Load()), body=[Raise()], orelse=[Raise(exc=Call(func=Attribute(value=Name(id='exc', ctx=Load()), attr='with_traceback', ctx=Load()), args=[Constant(value=None)], keywords=[]))])])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='ParseResults', ctx=Load())), FunctionDef(name='split', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='maxsplit', annotation=Name(id='int', ctx=Load())), arg(arg='include_separators', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='includeSeparators')], kw_defaults=[Constant(value=False)], defaults=[Name(id='_MAX_INT', ctx=Load()), Constant(value=False)]), body=[Expr(value=Constant(value='\n        Generator method to split a string using the given expression as a separator.\n        May be called with optional ``maxsplit`` argument, to limit the number of splits;\n        and the optional ``include_separators`` argument (default= ``False``), if the separating\n        matching text should be included in the split results.\n\n        Example::\n\n            punc = one_of(list(".,;:/-!?"))\n            print(list(punc.split("This, this?, this sentence, is badly punctuated!")))\n\n        prints::\n\n            [\'This\', \' this\', \'\', \' this sentence\', \' is badly punctuated\', \'\']\n        ')), Assign(targets=[Name(id='includeSeparators', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='includeSeparators', ctx=Load()), Name(id='include_separators', ctx=Load())])), Assign(targets=[Name(id='last', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='t', ctx=Store()), Name(id='s', ctx=Store()), Name(id='e', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='scan_string', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[keyword(arg='max_matches', value=Name(id='maxsplit', ctx=Load()))]), body=[Expr(value=Yield(value=Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='last', ctx=Load()), upper=Name(id='s', ctx=Load())), ctx=Load()))), If(test=Name(id='includeSeparators', ctx=Load()), body=[Expr(value=Yield(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load())))], orelse=[]), Assign(targets=[Name(id='last', ctx=Store())], value=Name(id='e', ctx=Load()))], orelse=[]), Expr(value=Yield(value=Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='last', ctx=Load())), ctx=Load())))], decorator_list=[], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), FunctionDef(name='__add__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``+`` operator - returns :class:`And`. Adding strings to a :class:`ParserElement`\n        converts them to :class:`Literal`\\ s by default.\n\n        Example::\n\n            greet = Word(alphas) + "," + Word(alphas) + "!"\n            hello = "Hello, World!"\n            print(hello, "->", greet.parse_string(hello))\n\n        prints::\n\n            Hello, World! -> [\'Hello\', \',\', \'World\', \'!\']\n\n        ``...`` may be used as a parse expression as a short form of :class:`SkipTo`::\n\n            Literal(\'start\') + ... + Literal(\'end\')\n\n        is equivalent to::\n\n            Literal(\'start\') + SkipTo(\'end\')("_skipped*") + Literal(\'end\')\n\n        Note that the skipped text is returned with \'_skipped\' as a results name,\n        and to support having multiple skips in the same parser, the value returned is\n        a list of all skipped text.\n        ')), If(test=Compare(left=Name(id='other', ctx=Load()), ops=[Is()], comparators=[Name(id='Ellipsis', ctx=Load())]), body=[Return(value=Call(func=Name(id='_PendingSkip', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='And', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__radd__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``+`` operator when left operand is not a :class:`ParserElement`\n        ')), If(test=Compare(left=Name(id='other', ctx=Load()), ops=[Is()], comparators=[Name(id='Ellipsis', ctx=Load())]), body=[Return(value=BinOp(left=Call(func=Call(func=Name(id='SkipTo', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), args=[Constant(value='_skipped*')], keywords=[]), op=Add(), right=Name(id='self', ctx=Load())))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=BinOp(left=Name(id='other', ctx=Load()), op=Add(), right=Name(id='self', ctx=Load())))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__sub__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``-`` operator, returns :class:`And` with error stop\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=BinOp(left=BinOp(left=Name(id='self', ctx=Load()), op=Add(), right=Call(func=Attribute(value=Name(id='And', ctx=Load()), attr='_ErrorStop', ctx=Load()), args=[], keywords=[])), op=Add(), right=Name(id='other', ctx=Load())))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__rsub__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``-`` operator when left operand is not a :class:`ParserElement`\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=BinOp(left=Name(id='other', ctx=Load()), op=Sub(), right=Name(id='self', ctx=Load())))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__mul__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``*`` operator, allows use of ``expr * 3`` in place of\n        ``expr + expr + expr``.  Expressions may also be multiplied by a 2-integer\n        tuple, similar to ``{min, max}`` multipliers in regular expressions.  Tuples\n        may also include ``None`` as in:\n\n        - ``expr*(n, None)`` or ``expr*(n, )`` is equivalent\n          to ``expr*n + ZeroOrMore(expr)``\n          (read as "at least n instances of ``expr``")\n        - ``expr*(None, n)`` is equivalent to ``expr*(0, n)``\n          (read as "0 to n instances of ``expr``")\n        - ``expr*(None, None)`` is equivalent to ``ZeroOrMore(expr)``\n        - ``expr*(1, None)`` is equivalent to ``OneOrMore(expr)``\n\n        Note that ``expr*(None, n)`` does not raise an exception if\n        more than n exprs exist in the input stream; that is,\n        ``expr*(None, n)`` does not enforce a maximum number of expr\n        occurrences.  If this behavior is desired, then write\n        ``expr*(None, n) + ~expr``\n        ')), If(test=Compare(left=Name(id='other', ctx=Load()), ops=[Is()], comparators=[Name(id='Ellipsis', ctx=Load())]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Tuple(elts=[Constant(value=0), Constant(value=None)], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), Compare(left=Subscript(value=Name(id='other', ctx=Load()), slice=Slice(upper=Constant(value=1)), ctx=Load()), ops=[Eq()], comparators=[Tuple(elts=[Name(id='Ellipsis', ctx=Load())], ctx=Load())])]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Subscript(value=BinOp(left=BinOp(left=Tuple(elts=[Constant(value=0)], ctx=Load()), op=Add(), right=Subscript(value=Name(id='other', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())), op=Add(), right=Tuple(elts=[Constant(value=None)], ctx=Load())), slice=Slice(upper=Constant(value=2)), ctx=Load()))], orelse=[])]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='minElements', ctx=Store()), Name(id='optElements', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='other', ctx=Load()), Constant(value=0)], ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=IfExp(test=Compare(left=Name(id='o', ctx=Load()), ops=[IsNot()], comparators=[Name(id='Ellipsis', ctx=Load())]), body=Name(id='o', ctx=Load()), orelse=Constant(value=None)), generators=[comprehension(target=Name(id='o', ctx=Store()), iter=Name(id='other', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='other', ctx=Store())], value=Subscript(value=BinOp(left=Name(id='other', ctx=Load()), op=Add(), right=Tuple(elts=[Constant(value=None), Constant(value=None)], ctx=Load())), slice=Slice(upper=Constant(value=2)), ctx=Load())), If(test=Compare(left=Subscript(value=Name(id='other', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Tuple(elts=[Constant(value=0), Subscript(value=Name(id='other', ctx=Load()), slice=Constant(value=1), ctx=Load())], ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='other', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Subscript(value=Name(id='other', ctx=Load()), slice=Constant(value=1), ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[If(test=Compare(left=Subscript(value=Name(id='other', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Call(func=Name(id='ZeroOrMore', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Name(id='other', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Call(func=Name(id='OneOrMore', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[Return(value=BinOp(left=BinOp(left=Name(id='self', ctx=Load()), op=Mult(), right=Subscript(value=Name(id='other', ctx=Load()), slice=Constant(value=0), ctx=Load())), op=Add(), right=Call(func=Name(id='ZeroOrMore', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[])))])], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='other', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='other', ctx=Load()), slice=Constant(value=1), ctx=Load()), Name(id='int', ctx=Load())], keywords=[])]), body=[Assign(targets=[Tuple(elts=[Name(id='minElements', ctx=Store()), Name(id='optElements', ctx=Store())], ctx=Store())], value=Name(id='other', ctx=Load())), AugAssign(target=Name(id='optElements', ctx=Store()), op=Sub(), value=Name(id='minElements', ctx=Load()))], orelse=[Return(value=Name(id='NotImplemented', ctx=Load()))])])], orelse=[Return(value=Name(id='NotImplemented', ctx=Load()))])]), If(test=Compare(left=Name(id='minElements', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot multiply ParserElement by negative value')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='optElements', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='second tuple value must be greater or equal to first tuple value')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='minElements', ctx=Load()), ops=[Eq(), Eq()], comparators=[Name(id='optElements', ctx=Load()), Constant(value=0)]), body=[Return(value=Call(func=Name(id='And', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='optElements', ctx=Load()), body=[FunctionDef(name='makeOptionalList', args=arguments(posonlyargs=[], args=[arg(arg='n')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='n', ctx=Load()), ops=[Gt()], comparators=[Constant(value=1)]), body=[Return(value=Call(func=Name(id='Opt', ctx=Load()), args=[BinOp(left=Name(id='self', ctx=Load()), op=Add(), right=Call(func=Name(id='makeOptionalList', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Sub(), right=Constant(value=1))], keywords=[]))], keywords=[]))], orelse=[Return(value=Call(func=Name(id='Opt', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))])], decorator_list=[]), If(test=Name(id='minElements', ctx=Load()), body=[If(test=Compare(left=Name(id='minElements', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=BinOp(left=Name(id='self', ctx=Load()), op=Add(), right=Call(func=Name(id='makeOptionalList', ctx=Load()), args=[Name(id='optElements', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='ret', ctx=Store())], value=BinOp(left=Call(func=Name(id='And', ctx=Load()), args=[BinOp(left=List(elts=[Name(id='self', ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='minElements', ctx=Load()))], keywords=[]), op=Add(), right=Call(func=Name(id='makeOptionalList', ctx=Load()), args=[Name(id='optElements', ctx=Load())], keywords=[])))])], orelse=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='makeOptionalList', ctx=Load()), args=[Name(id='optElements', ctx=Load())], keywords=[]))])], orelse=[If(test=Compare(left=Name(id='minElements', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Name(id='self', ctx=Load()))], orelse=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='And', ctx=Load()), args=[BinOp(left=List(elts=[Name(id='self', ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='minElements', ctx=Load()))], keywords=[]))])]), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__rmul__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__mul__', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__or__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``|`` operator - returns :class:`MatchFirst`\n        ')), If(test=Compare(left=Name(id='other', ctx=Load()), ops=[Is()], comparators=[Name(id='Ellipsis', ctx=Load())]), body=[Return(value=Call(func=Name(id='_PendingSkip', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(arg='must_skip', value=Constant(value=True))]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='other', ctx=Load()), ops=[Eq()], comparators=[Constant(value='')]), body=[Return(value=Call(func=Name(id='Opt', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='MatchFirst', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__ror__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``|`` operator when left operand is not a :class:`ParserElement`\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=BinOp(left=Name(id='other', ctx=Load()), op=BitOr(), right=Name(id='self', ctx=Load())))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__xor__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``^`` operator - returns :class:`Or`\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='Or', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__rxor__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``^`` operator when left operand is not a :class:`ParserElement`\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=BinOp(left=Name(id='other', ctx=Load()), op=BitXor(), right=Name(id='self', ctx=Load())))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__and__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``&`` operator - returns :class:`Each`\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Call(func=Name(id='Each', ctx=Load()), args=[List(elts=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__rand__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``&`` operator when left operand is not a :class:`ParserElement`\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=BinOp(left=Name(id='other', ctx=Load()), op=BitAnd(), right=Name(id='self', ctx=Load())))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__invert__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Implementation of ``~`` operator - returns :class:`NotAny`\n        ')), Return(value=Call(func=Name(id='NotAny', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='ParserElement')), Assign(targets=[Name(id='__iter__', ctx=Store())], value=Constant(value=None)), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='key')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        use ``[]`` indexing notation as a short form for expression repetition:\n\n        - ``expr[n]`` is equivalent to ``expr*n``\n        - ``expr[m, n]`` is equivalent to ``expr*(m, n)``\n        - ``expr[n, ...]`` or ``expr[n,]`` is equivalent\n             to ``expr*n + ZeroOrMore(expr)``\n             (read as "at least n instances of ``expr``")\n        - ``expr[..., n]`` is equivalent to ``expr*(0, n)``\n             (read as "0 to n instances of ``expr``")\n        - ``expr[...]`` and ``expr[0, ...]`` are equivalent to ``ZeroOrMore(expr)``\n        - ``expr[1, ...]`` is equivalent to ``OneOrMore(expr)``\n\n        ``None`` may be used in place of ``...``.\n\n        Note that ``expr[..., n]`` and ``expr[m, n]`` do not raise an exception\n        if more than ``n`` ``expr``\\ s exist in the input stream.  If this behavior is\n        desired, then write ``expr[..., n] + ~expr``.\n\n        For repetition with a stop_on expression, use slice notation:\n\n        - ``expr[...: end_expr]`` and ``expr[0, ...: end_expr]`` are equivalent to ``ZeroOrMore(expr, stop_on=end_expr)``\n        - ``expr[1, ...: end_expr]`` is equivalent to ``OneOrMore(expr, stop_on=end_expr)``\n\n        ')), Assign(targets=[Name(id='stop_on_defined', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='stop_on', ctx=Store())], value=Call(func=Name(id='NoMatch', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='slice', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='stop_on', ctx=Store())], ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='key', ctx=Load()), attr='start', ctx=Load()), Attribute(value=Name(id='key', ctx=Load()), attr='stop', ctx=Load())], ctx=Load())), If(test=Compare(left=Name(id='key', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='key', ctx=Store())], value=Constant(value=Ellipsis))], orelse=[]), Assign(targets=[Name(id='stop_on_defined', ctx=Store())], value=Constant(value=True))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='tuple', ctx=Load())], keywords=[]), Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='slice', ctx=Load())], keywords=[])]), body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='stop_on', ctx=Store())], ctx=Store())], value=Tuple(elts=[Tuple(elts=[Subscript(value=Name(id='key', ctx=Load()), slice=Constant(value=0), ctx=Load()), Attribute(value=Subscript(value=Name(id='key', ctx=Load()), slice=Constant(value=1), ctx=Load()), attr='start', ctx=Load())], ctx=Load()), Attribute(value=Subscript(value=Name(id='key', ctx=Load()), slice=Constant(value=1), ctx=Load()), attr='stop', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='stop_on_defined', ctx=Store())], value=Constant(value=True))], orelse=[])]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='key', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key', ctx=Store())], value=Tuple(elts=[Name(id='key', ctx=Load())], ctx=Load()))], orelse=[]), Try(body=[Expr(value=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Assign(targets=[Name(id='key', ctx=Store())], value=Tuple(elts=[Name(id='key', ctx=Load()), Name(id='key', ctx=Load())], ctx=Load()))])], orelse=[], finalbody=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=2)]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='only 1 or 2 index arguments supported ('), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(upper=Constant(value=5)), ctx=Load()), conversion=-1), FormattedValue(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=5)]), body=JoinedStr(values=[Constant(value='... ['), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]), conversion=-1), Constant(value=']')]), orelse=Constant(value='')), conversion=-1), Constant(value=')')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='ret', ctx=Store())], value=BinOp(left=Name(id='self', ctx=Load()), op=Mult(), right=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load())], keywords=[]))), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='_MultipleMatch', ctx=Load()), Name(id='ret', ctx=Load())], keywords=[])), If(test=Name(id='stop_on_defined', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='stopOn', ctx=Load()), args=[Name(id='stop_on', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Shortcut for :class:`set_results_name`, with ``list_all_matches=False``.\n\n        If ``name`` is given with a trailing ``\'*\'`` character, then ``list_all_matches`` will be\n        passed as ``True``.\n\n        If ``name`` is omitted, same as calling :class:`copy`.\n\n        Example::\n\n            # these are equivalent\n            userdata = Word(alphas).set_results_name("name") + Word(nums + "-").set_results_name("socsecno")\n            userdata = Word(alphas)("name") + Word(nums + "-")("socsecno")\n        ')), If(test=Compare(left=Name(id='name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_setResultsName', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))])], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='suppress', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Suppresses the output of this :class:`ParserElement`; useful to keep punctuation from\n        cluttering up returned output.\n        ')), Return(value=Call(func=Name(id='Suppress', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='ignore_whitespace', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='recursive', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value="\n        Enables the skipping of whitespace before matching the characters in the\n        :class:`ParserElement`'s defined pattern.\n\n        :param recursive: If ``True`` (the default), also enable whitespace skipping in child elements (if any)\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=True)), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='leave_whitespace', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='recursive', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value="\n        Disables the skipping of whitespace before matching the characters in the\n        :class:`ParserElement`'s defined pattern.  This is normally only used internally by\n        the pyparsing module, but may be needed in some whitespace-sensitive grammars.\n\n        :param recursive: If true (the default), also disable whitespace skipping in child elements (if any)\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=False)), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='set_whitespace_chars', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='chars', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='copy_defaults', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n        Overrides the default whitespace chars\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='whiteChars', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='chars', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='copyDefaultWhiteChars', ctx=Store())], value=Name(id='copy_defaults', ctx=Load())), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='parse_with_tabs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Overrides default behavior to expand ``<TAB>`` s to spaces before parsing the input string.\n        Must be called before ``parse_string`` when the input grammar contains elements that\n        match ``<TAB>`` characters.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='keepTabs', ctx=Store())], value=Constant(value=True)), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='ignore', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Constant(value='ParserElement'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Define expression to be ignored (e.g., comments) while doing pattern\n        matching; may be called repeatedly, to define multiple comment or other\n        ignorable patterns.\n\n        Example::\n\n            patt = Word(alphas)[1, ...]\n            patt.parse_string('ablaj /* comment */ lskjd')\n            # -> ['ablaj']\n\n            patt.ignore(c_style_comment)\n            patt.parse_string('ablaj /* comment */ lskjd')\n            # -> ['ablaj', 'lskjd']\n        ")), Import(names=[alias(name='typing')]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Name(id='Suppress', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Suppress', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='other', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='Suppress', ctx=Load()), args=[Call(func=Attribute(value=Name(id='other', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='set_debug_actions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='start_action', annotation=Name(id='DebugStartAction', ctx=Load())), arg(arg='success_action', annotation=Name(id='DebugSuccessAction', ctx=Load())), arg(arg='exception_action', annotation=Name(id='DebugExceptionAction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Customize display of debugging messages while doing pattern matching:\n\n        - ``start_action`` - method to be called when an expression is about to be parsed;\n          should have the signature ``fn(input_string: str, location: int, expression: ParserElement, cache_hit: bool)``\n\n        - ``success_action`` - method to be called when an expression has successfully parsed;\n          should have the signature ``fn(input_string: str, start_location: int, end_location: int, expression: ParserELement, parsed_tokens: ParseResults, cache_hit: bool)``\n\n        - ``exception_action`` - method to be called when expression fails to parse;\n          should have the signature ``fn(input_string: str, location: int, expression: ParserElement, exception: Exception, cache_hit: bool)``\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='debugActions', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='DebugActions', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='start_action', ctx=Load()), Name(id='_default_start_debug_action', ctx=Load())]), BoolOp(op=Or(), values=[Name(id='success_action', ctx=Load()), Name(id='_default_success_debug_action', ctx=Load())]), BoolOp(op=Or(), values=[Name(id='exception_action', ctx=Load()), Name(id='_default_exception_debug_action', ctx=Load())])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='debug', ctx=Store())], value=Constant(value=True)), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='set_debug', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='flag', annotation=Name(id='bool', ctx=Load())), arg(arg='recurse', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=False)]), body=[Expr(value=Constant(value='\n        Enable display of debugging messages while doing pattern matching.\n        Set ``flag`` to ``True`` to enable, ``False`` to disable.\n        Set ``recurse`` to ``True`` to set the debug flag on this expression and all sub-expressions.\n\n        Example::\n\n            wd = Word(alphas).set_name("alphaword")\n            integer = Word(nums).set_name("numword")\n            term = wd | integer\n\n            # turn on debugging for wd\n            wd.set_debug()\n\n            term[1, ...].parse_string("abc 123 xyz 890")\n\n        prints::\n\n            Match alphaword at loc 0(1,1)\n            Matched alphaword -> [\'abc\']\n            Match alphaword at loc 3(1,4)\n            Exception raised:Expected alphaword (at char 4), (line:1, col:5)\n            Match alphaword at loc 7(1,8)\n            Matched alphaword -> [\'xyz\']\n            Match alphaword at loc 11(1,12)\n            Exception raised:Expected alphaword (at char 12), (line:1, col:13)\n            Match alphaword at loc 15(1,16)\n            Exception raised:Expected alphaword (at char 15), (line:1, col:16)\n\n        The output shown is that produced by the default debug actions - custom debug actions can be\n        specified using :class:`set_debug_actions`. Prior to attempting\n        to match the ``wd`` expression, the debugging message ``"Match <exprname> at loc <n>(<line>,<col>)"``\n        is shown. Then if the parse succeeds, a ``"Matched"`` message is shown, or an ``"Exception raised"``\n        message is shown. Also note the use of :class:`set_name` to assign a human-readable name to the expression,\n        which makes debugging and exception messages easier to understand - for instance, the default\n        name created for the :class:`Word` expression without calling ``set_name`` is ``"W:(A-Za-z)"``.\n        ')), If(test=Name(id='recurse', ctx=Load()), body=[For(target=Name(id='expr', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='visit_all', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='expr', ctx=Load()), attr='set_debug', ctx=Load()), args=[Name(id='flag', ctx=Load())], keywords=[keyword(arg='recurse', value=Constant(value=False))]))], orelse=[]), Return(value=Name(id='self', ctx=Load()))], orelse=[]), If(test=Name(id='flag', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_debug_actions', ctx=Load()), args=[Name(id='_default_start_debug_action', ctx=Load()), Name(id='_default_success_debug_action', ctx=Load()), Name(id='_default_exception_debug_action', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='debug', ctx=Store())], value=Constant(value=False))]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='default_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_defaultName', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_defaultName', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_generateDefaultName', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_defaultName', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Child classes must define this method, which defines how the ``default_name`` is set.\n        '))], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='set_name', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Define name for this expression, makes debugging and exception messages clearer.\n\n        Example::\n\n            Word(nums).parse_string("ABC")  # -> Exception: Expected W:(0-9) (at char 0), (line:1, col:1)\n            Word(nums).set_name("integer").parse_string("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='customName', ctx=Store())], value=Name(id='name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='Expected '), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))), If(test=Attribute(value=Name(id='__diag__', ctx=Load()), attr='enable_debug_on_named_expressions', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_debug', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='customName', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='customName', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='default_name', ctx=Load())))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='streamline', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='streamlined', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_defaultName', ctx=Store())], value=Constant(value=None)), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='recurse', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=List(elts=[], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='ParserElement'), ctx=Load())), FunctionDef(name='_checkRecursion', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parseElementList')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='subRecCheckList', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='parseElementList', ctx=Load()), slice=Slice(), ctx=Load()), op=Add(), right=List(elts=[Name(id='self', ctx=Load())], ctx=Load()))), For(target=Name(id='e', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='recurse', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='_checkRecursion', ctx=Load()), args=[Name(id='subRecCheckList', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='validate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='validateTrace')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Check defined expressions for valid structure, check for infinite recursive definitions.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='ParserElement.validate() is deprecated, and should not be used to check for left recursion'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_checkRecursion', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='parse_file', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='file_or_filename', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Path', ctx=Load()), Name(id='TextIO', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='encoding', annotation=Name(id='str', ctx=Load())), arg(arg='parse_all', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='parseAll', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value='utf-8'), Constant(value=False)]), body=[Expr(value=Constant(value='\n        Execute the parse expression on the given file or filename.\n        If a filename is specified (instead of a file object),\n        the entire file is opened, read, and closed before parsing.\n        ')), Assign(targets=[Name(id='parseAll', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='parseAll', ctx=Load()), Name(id='parse_all', ctx=Load())])), Try(body=[Assign(targets=[Name(id='file_or_filename', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='TextIO', ctx=Load()), Name(id='file_or_filename', ctx=Load())], keywords=[])), Assign(targets=[Name(id='file_contents', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_or_filename', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[Assign(targets=[Name(id='file_or_filename', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='file_or_filename', ctx=Load())], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_or_filename', ctx=Load()), Constant(value='r')], keywords=[keyword(arg='encoding', value=Name(id='encoding', ctx=Load()))]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='file_contents', ctx=Store())], value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])])], orelse=[], finalbody=[]), Try(body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parse_string', ctx=Load()), args=[Name(id='file_contents', ctx=Load()), Name(id='parseAll', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), name='exc', body=[If(test=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='verbose_stacktrace', ctx=Load()), body=[Raise()], orelse=[Raise(exc=Call(func=Attribute(value=Name(id='exc', ctx=Load()), attr='with_traceback', ctx=Load()), args=[Constant(value=None)], keywords=[]))])])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='ParseResults', ctx=Load())), FunctionDef(name='__eq__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='self', ctx=Load()), ops=[Is()], comparators=[Name(id='other', ctx=Load())]), body=[Return(value=Constant(value=True))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='matches', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[keyword(arg='parse_all', value=Constant(value=True))]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[]), body=[Return(value=Compare(left=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='vars', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])]))], orelse=[])])]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='__hash__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='id', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='matches', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='test_string', annotation=Name(id='str', ctx=Load())), arg(arg='parse_all', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='parseAll', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=True)], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n        Method for quick testing of a parser against a test string. Good for simple\n        inline microtests of sub expressions while building up larger parser.\n\n        Parameters:\n\n        - ``test_string`` - to test against this expression for a match\n        - ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests\n\n        Example::\n\n            expr = Word(nums)\n            assert expr.matches("100")\n        ')), Assign(targets=[Name(id='parseAll', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='parseAll', ctx=Load()), Name(id='parse_all', ctx=Load())])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parse_string', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='test_string', ctx=Load())], keywords=[])], keywords=[keyword(arg='parse_all', value=Name(id='parseAll', ctx=Load()))])), Return(value=Constant(value=True))], handlers=[ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='run_tests', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tests', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='parse_all', annotation=Name(id='bool', ctx=Load())), arg(arg='comment', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Constant(value='ParserElement'), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='full_dump', annotation=Name(id='bool', ctx=Load())), arg(arg='print_results', annotation=Name(id='bool', ctx=Load())), arg(arg='failure_tests', annotation=Name(id='bool', ctx=Load())), arg(arg='post_parse', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='ParseResults', ctx=Load())], ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='file', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='TextIO', ctx=Load()), ctx=Load())), arg(arg='with_line_numbers', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='parseAll', annotation=Name(id='bool', ctx=Load())), arg(arg='fullDump', annotation=Name(id='bool', ctx=Load())), arg(arg='printResults', annotation=Name(id='bool', ctx=Load())), arg(arg='failureTests', annotation=Name(id='bool', ctx=Load())), arg(arg='postParse', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Name(id='str', ctx=Load()), Name(id='ParseResults', ctx=Load())], ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=True), Constant(value=True), Constant(value=True), Constant(value=False), Constant(value=None)], defaults=[Constant(value=True), Constant(value='#'), Constant(value=True), Constant(value=True), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='\n        Execute the parse expression on a series of test strings, showing each\n        test, the parsed results or where the parse failed. Quick and easy way to\n        run a parse expression against a list of sample strings.\n\n        Parameters:\n\n        - ``tests`` - a list of separate test strings, or a multiline string of test strings\n        - ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests\n        - ``comment`` - (default= ``\'#\'``) - expression for indicating embedded comments in the test\n          string; pass None to disable comment filtering\n        - ``full_dump`` - (default= ``True``) - dump results as list followed by results names in nested outline;\n          if False, only dump nested list\n        - ``print_results`` - (default= ``True``) prints test output to stdout\n        - ``failure_tests`` - (default= ``False``) indicates if these tests are expected to fail parsing\n        - ``post_parse`` - (default= ``None``) optional callback for successful parse results; called as\n          `fn(test_string, parse_results)` and returns a string to be added to the test output\n        - ``file`` - (default= ``None``) optional file-like object to which test output will be written;\n          if None, will default to ``sys.stdout``\n        - ``with_line_numbers`` - default= ``False``) show test strings with line and column numbers\n\n        Returns: a (success, results) tuple, where success indicates that all tests succeeded\n        (or failed if ``failure_tests`` is True), and the results contain a list of lines of each\n        test\'s output\n\n        Example::\n\n            number_expr = pyparsing_common.number.copy()\n\n            result = number_expr.run_tests(\'\'\'\n                # unsigned integer\n                100\n                # negative integer\n                -100\n                # float with scientific notation\n                6.02e23\n                # integer with scientific notation\n                1e-12\n                \'\'\')\n            print("Success" if result[0] else "Failed!")\n\n            result = number_expr.run_tests(\'\'\'\n                # stray character\n                100Z\n                # missing leading digit before \'.\'\n                -.100\n                # too many \'.\'\n                3.14.159\n                \'\'\', failure_tests=True)\n            print("Success" if result[0] else "Failed!")\n\n        prints::\n\n            # unsigned integer\n            100\n            [100]\n\n            # negative integer\n            -100\n            [-100]\n\n            # float with scientific notation\n            6.02e23\n            [6.02e+23]\n\n            # integer with scientific notation\n            1e-12\n            [1e-12]\n\n            Success\n\n            # stray character\n            100Z\n               ^\n            FAIL: Expected end of text (at char 3), (line:1, col:4)\n\n            # missing leading digit before \'.\'\n            -.100\n            ^\n            FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)\n\n            # too many \'.\'\n            3.14.159\n                ^\n            FAIL: Expected end of text (at char 4), (line:1, col:5)\n\n            Success\n\n        Each test string must be on a single line. If you want to test a string that spans multiple\n        lines, create a test like this::\n\n            expr.run_tests(r"this is a test\\n of strings that spans \\n 3 lines")\n\n        (Note that this is a raw string literal, you must include the leading ``\'r\'``.)\n        ')), ImportFrom(module='testing', names=[alias(name='pyparsing_test')], level=1), Assign(targets=[Name(id='parseAll', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='parseAll', ctx=Load()), Name(id='parse_all', ctx=Load())])), Assign(targets=[Name(id='fullDump', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='fullDump', ctx=Load()), Name(id='full_dump', ctx=Load())])), Assign(targets=[Name(id='printResults', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='printResults', ctx=Load()), Name(id='print_results', ctx=Load())])), Assign(targets=[Name(id='failureTests', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='failureTests', ctx=Load()), Name(id='failure_tests', ctx=Load())])), Assign(targets=[Name(id='postParse', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='postParse', ctx=Load()), Name(id='post_parse', ctx=Load())])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tests', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='tests', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='tests', ctx=Load())], keywords=[])), Assign(targets=[Name(id='line_strip', ctx=Store())], value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='tests', ctx=Load())], keywords=[]), attr='strip', ctx=Load())), Assign(targets=[Name(id='tests', ctx=Store())], value=ListComp(elt=Call(func=Name(id='line_strip', ctx=Load()), args=[Name(id='test_line', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='test_line', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='tests', ctx=Load()), attr='rstrip', ctx=Load()), args=[], keywords=[]), attr='splitlines', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], orelse=[]), Assign(targets=[Name(id='comment_specified', ctx=Store())], value=Compare(left=Name(id='comment', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), If(test=Name(id='comment_specified', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='comment', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='comment', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='comment', ctx=Load())], keywords=[])), Assign(targets=[Name(id='comment', ctx=Store())], value=Call(func=Name(id='Literal', ctx=Load()), args=[Name(id='comment', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='comment', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='ParserElement', ctx=Load()), Name(id='comment', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='file', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='file', ctx=Store())], value=Attribute(value=Name(id='sys', ctx=Load()), attr='stdout', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='print_', ctx=Store())], value=Attribute(value=Name(id='file', ctx=Load()), attr='write', ctx=Load())), AnnAssign(target=Name(id='result', ctx=Store()), annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParseResults', ctx=Load()), Name(id='Exception', ctx=Load())], ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='allResults', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParseResults', ctx=Load()), Name(id='Exception', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='comments', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='success', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='NL', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Literal', ctx=Load()), args=[Constant(value='\\n')], keywords=[]), attr='add_parse_action', ctx=Load()), args=[Call(func=Name(id='replace_with', ctx=Load()), args=[Constant(value='\n')], keywords=[])], keywords=[]), attr='ignore', ctx=Load()), args=[Name(id='quoted_string', ctx=Load())], keywords=[])), Assign(targets=[Name(id='BOM', ctx=Store())], value=Constant(value='\ufeff')), For(target=Name(id='t', ctx=Store()), iter=Name(id='tests', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Name(id='comment_specified', ctx=Load()), Call(func=Attribute(value=Name(id='comment', ctx=Load()), attr='matches', ctx=Load()), args=[Name(id='t', ctx=Load()), Constant(value=False)], keywords=[])]), BoolOp(op=And(), values=[Name(id='comments', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='t', ctx=Load()))])]), body=[Expr(value=Call(func=Attribute(value=Name(id='comments', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Name(id='with_line_numbers', ctx=Load()), body=Call(func=Attribute(value=Name(id='pyparsing_test', ctx=Load()), attr='with_line_numbers', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), orelse=Name(id='t', ctx=Load()))], keywords=[])), Continue()], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='t', ctx=Load())), body=[Continue()], orelse=[]), Assign(targets=[Name(id='out', ctx=Store())], value=List(elts=[IfExp(test=Name(id='comments', ctx=Load()), body=BinOp(left=Constant(value='\n'), op=Add(), right=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='comments', ctx=Load())], keywords=[])), orelse=Constant(value='')), IfExp(test=Name(id='with_line_numbers', ctx=Load()), body=Call(func=Attribute(value=Name(id='pyparsing_test', ctx=Load()), attr='with_line_numbers', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), orelse=Name(id='t', ctx=Load()))], ctx=Load())), Assign(targets=[Name(id='comments', ctx=Store())], value=List(elts=[], ctx=Load())), Try(body=[Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Attribute(value=Name(id='NL', ctx=Load()), attr='transform_string', ctx=Load()), args=[Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='lstrip', ctx=Load()), args=[Name(id='BOM', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='parse_string', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[keyword(arg='parse_all', value=Name(id='parseAll', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), name='pe', body=[Assign(targets=[Name(id='fatal', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pe', ctx=Load()), Name(id='ParseFatalException', ctx=Load())], keywords=[]), body=Constant(value='(FATAL)'), orelse=Constant(value=''))), Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pe', ctx=Load()), attr='explain', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Constant(value='FAIL: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='pe', ctx=Load())], keywords=[]))], keywords=[])), If(test=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='verbose_stacktrace', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='format_tb', ctx=Load()), args=[Attribute(value=Name(id='pe', ctx=Load()), attr='__traceback__', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='success', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='success', ctx=Load()), Name(id='failureTests', ctx=Load())])), Assign(targets=[Name(id='result', ctx=Store())], value=Name(id='pe', ctx=Load()))]), ExceptHandler(type=Name(id='Exception', ctx=Load()), name='exc', body=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[Constant(value='FAIL-EXCEPTION: '), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='exc', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='exc', ctx=Load()), conversion=-1)])], keywords=[])), If(test=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='verbose_stacktrace', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='format_tb', ctx=Load()), args=[Attribute(value=Name(id='exc', ctx=Load()), attr='__traceback__', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='success', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='success', ctx=Load()), Name(id='failureTests', ctx=Load())])), Assign(targets=[Name(id='result', ctx=Store())], value=Name(id='exc', ctx=Load()))])], orelse=[Assign(targets=[Name(id='success', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='success', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='failureTests', ctx=Load()))])), If(test=Compare(left=Name(id='postParse', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Try(body=[Assign(targets=[Name(id='pp_value', ctx=Store())], value=Call(func=Name(id='postParse', ctx=Load()), args=[Name(id='t', ctx=Load()), Name(id='result', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='pp_value', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pp_value', ctx=Load()), Name(id='ParseResults', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pp_value', ctx=Load()), attr='dump', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='pp_value', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='dump', ctx=Load()), args=[], keywords=[])], keywords=[]))])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='dump', ctx=Load()), args=[], keywords=[keyword(arg='full', value=Name(id='fullDump', ctx=Load()))])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='postParse', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value=' failed: '), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='dump', ctx=Load()), args=[], keywords=[keyword(arg='full', value=Name(id='fullDump', ctx=Load()))])], keywords=[]))])], finalbody=[]), Expr(value=Call(func=Attribute(value=Name(id='out', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='')], keywords=[])), If(test=Name(id='printResults', ctx=Load()), body=[Expr(value=Call(func=Name(id='print_', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='out', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='allResults', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='t', ctx=Load()), Name(id='result', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='success', ctx=Load()), Name(id='allResults', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParseResults', ctx=Load()), Name(id='Exception', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='create_diagram', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='output_html', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='TextIO', ctx=Load()), Name(id='Path', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='vertical', annotation=Name(id='int', ctx=Load())), arg(arg='show_results_names', annotation=Name(id='bool', ctx=Load())), arg(arg='show_groups', annotation=Name(id='bool', ctx=Load())), arg(arg='embed', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=3), Constant(value=False), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value='\n        Create a railroad diagram for the parser.\n\n        Parameters:\n\n        - ``output_html`` (str or file-like object) - output target for generated\n          diagram HTML\n        - ``vertical`` (int) - threshold for formatting multiple alternatives vertically\n          instead of horizontally (default=3)\n        - ``show_results_names`` - bool flag whether diagram should show annotations for\n          defined results names\n        - ``show_groups`` - bool flag whether groups should be highlighted with an unlabeled surrounding box\n        - ``embed`` - bool flag whether generated HTML should omit <HEAD>, <BODY>, and <DOCTYPE> tags to embed\n          the resulting HTML in an enclosing HTML source\n        - ``head`` - str containing additional HTML to insert into the <HEAD> section of the generated code;\n          can be used to insert custom CSS styling\n        - ``body`` - str containing additional HTML to insert at the beginning of the <BODY> section of the\n          generated code\n\n        Additional diagram-formatting keyword arguments can also be included;\n        see railroad.Diagram class.\n        ')), Try(body=[ImportFrom(module='diagram', names=[alias(name='to_railroad'), alias(name='railroad_to_html')], level=1)], handlers=[ExceptHandler(type=Name(id='ImportError', ctx=Load()), name='ie', body=[Raise(exc=Call(func=Name(id='Exception', ctx=Load()), args=[Constant(value='must ``pip install pyparsing[diagrams]`` to generate parser railroad diagrams')], keywords=[]), cause=Name(id='ie', ctx=Load()))])], orelse=[], finalbody=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='streamline', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='railroad', ctx=Store())], value=Call(func=Name(id='to_railroad', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[keyword(arg='vertical', value=Name(id='vertical', ctx=Load())), keyword(arg='show_results_names', value=Name(id='show_results_names', ctx=Load())), keyword(arg='show_groups', value=Name(id='show_groups', ctx=Load())), keyword(arg='diagram_kwargs', value=Name(id='kwargs', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='output_html', ctx=Load()), Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Path', ctx=Load())], ctx=Load())], keywords=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='output_html', ctx=Load()), Constant(value='w')], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='diag_file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='diag_file', ctx=Load()), attr='write', ctx=Load()), args=[Call(func=Name(id='railroad_to_html', ctx=Load()), args=[Name(id='railroad', ctx=Load())], keywords=[keyword(arg='embed', value=Name(id='embed', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[]))])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='output_html', ctx=Load()), attr='write', ctx=Load()), args=[Call(func=Name(id='railroad_to_html', ctx=Load()), args=[Name(id='railroad', ctx=Load())], keywords=[keyword(arg='embed', value=Name(id='embed', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[]))])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='inlineLiteralsUsing', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='staticmethod', ctx=Load()), Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='inline_literals_using', ctx=Load())], keywords=[])]), FunctionDef(name='setDefaultWhitespaceChars', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='staticmethod', ctx=Load()), Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='set_default_whitespace_chars', ctx=Load())], keywords=[])]), FunctionDef(name='setResultsName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='set_results_name', ctx=Load())], keywords=[])]), FunctionDef(name='setBreak', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='set_break', ctx=Load())], keywords=[])]), FunctionDef(name='setParseAction', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='set_parse_action', ctx=Load())], keywords=[])]), FunctionDef(name='addParseAction', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='add_parse_action', ctx=Load())], keywords=[])]), FunctionDef(name='addCondition', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='add_condition', ctx=Load())], keywords=[])]), FunctionDef(name='setFailAction', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='set_fail_action', ctx=Load())], keywords=[])]), FunctionDef(name='tryParse', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='try_parse', ctx=Load())], keywords=[])]), FunctionDef(name='enableLeftRecursion', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='staticmethod', ctx=Load()), Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='enable_left_recursion', ctx=Load())], keywords=[])]), FunctionDef(name='enablePackrat', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Name(id='staticmethod', ctx=Load()), Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='enable_packrat', ctx=Load())], keywords=[])]), FunctionDef(name='parseString', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='parse_string', ctx=Load())], keywords=[])]), FunctionDef(name='scanString', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='scan_string', ctx=Load())], keywords=[])]), FunctionDef(name='transformString', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='transform_string', ctx=Load())], keywords=[])]), FunctionDef(name='searchString', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='search_string', ctx=Load())], keywords=[])]), FunctionDef(name='ignoreWhitespace', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='ignore_whitespace', ctx=Load())], keywords=[])]), FunctionDef(name='leaveWhitespace', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='leave_whitespace', ctx=Load())], keywords=[])]), FunctionDef(name='setWhitespaceChars', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='set_whitespace_chars', ctx=Load())], keywords=[])]), FunctionDef(name='parseWithTabs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='parse_with_tabs', ctx=Load())], keywords=[])]), FunctionDef(name='setDebugActions', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='set_debug_actions', ctx=Load())], keywords=[])]), FunctionDef(name='setDebug', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='set_debug', ctx=Load())], keywords=[])]), FunctionDef(name='setName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='set_name', ctx=Load())], keywords=[])]), FunctionDef(name='parseFile', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='parse_file', ctx=Load())], keywords=[])]), FunctionDef(name='runTests', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='run_tests', ctx=Load())], keywords=[])]), Assign(targets=[Name(id='canParseNext', ctx=Store())], value=Name(id='can_parse_next', ctx=Load())), Assign(targets=[Name(id='resetCache', ctx=Store())], value=Name(id='reset_cache', ctx=Load())), Assign(targets=[Name(id='defaultName', ctx=Store())], value=Name(id='default_name', ctx=Load()))], decorator_list=[]), ClassDef(name='_PendingSkip', bases=[Name(id='ParserElement', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load())), arg(arg='must_skip', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='anchor', ctx=Store())], value=Name(id='expr', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='must_skip', ctx=Store())], value=Name(id='must_skip', ctx=Load()))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='anchor', ctx=Load()), op=Add(), right=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]))], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='Empty'), Constant(value='...')], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__add__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='skipper', ctx=Store())], value=Call(func=Call(func=Attribute(value=Call(func=Name(id='SkipTo', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='...')], keywords=[]), args=[Constant(value='_skipped*')], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='must_skip', ctx=Load()), body=[FunctionDef(name='must_skip', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='t', ctx=Load()), attr='_skipped', ctx=Load())), Compare(left=Call(func=Attribute(value=Attribute(value=Name(id='t', ctx=Load()), attr='_skipped', ctx=Load()), attr='as_list', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[List(elts=[Constant(value='')], ctx=Load())])]), body=[Delete(targets=[Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Del())]), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='_skipped'), Constant(value=None)], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='show_skip', args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='t', ctx=Load()), attr='_skipped', ctx=Load()), attr='as_list', ctx=Load()), args=[], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), ops=[Eq()], comparators=[List(elts=[Constant(value='')], ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='_skipped')], keywords=[])), Assign(targets=[Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value='_skipped'), ctx=Store())], value=BinOp(left=BinOp(left=Constant(value='missing <'), op=Add(), right=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='anchor', ctx=Load())], keywords=[])), op=Add(), right=Constant(value='>')))], orelse=[])], decorator_list=[]), Return(value=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='anchor', ctx=Load()), op=Add(), right=Call(func=Attribute(value=Call(func=Name(id='skipper', ctx=Load()), args=[], keywords=[]), attr='add_parse_action', ctx=Load()), args=[Name(id='must_skip', ctx=Load())], keywords=[])), op=BitOr(), right=Call(func=Attribute(value=Call(func=Name(id='skipper', ctx=Load()), args=[], keywords=[]), attr='add_parse_action', ctx=Load()), args=[Name(id='show_skip', ctx=Load())], keywords=[])), op=Add(), right=Name(id='other', ctx=Load())))], orelse=[]), Return(value=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='anchor', ctx=Load()), op=Add(), right=Name(id='skipper', ctx=Load())), op=Add(), right=Name(id='other', ctx=Load())))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='defaultName', ctx=Load()))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='Exception', ctx=Load()), args=[Constant(value='use of `...` expression without following SkipTo target expression')], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Token', bases=[Name(id='ParserElement', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Abstract :class:`ParserElement` subclass, for defining atomic\n    matching patterns.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='savelist', value=Constant(value=False))]))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='NoMatch', bases=[Name(id='Token', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    A token that will never match.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=Constant(value='Unmatchable token'))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Literal', bases=[Name(id='Token', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Token to exactly match a specified string.\n\n    Example::\n\n        Literal(\'blah\').parse_string(\'blah\')  # -> [\'blah\']\n        Literal(\'blah\').parse_string(\'blahfooblah\')  # -> [\'blah\']\n        Literal(\'blah\').parse_string(\'bla\')  # -> Exception: Expected "blah"\n\n    For case-insensitive matching, use :class:`CaselessLiteral`.\n\n    For keyword matching (force word break before and after the matched string),\n    use :class:`Keyword` or :class:`CaselessKeyword`.\n    ')), FunctionDef(name='__new__', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='match_string', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='matchString', annotation=Name(id='str', ctx=Load()))], kw_defaults=[Constant(value='')], defaults=[Constant(value='')]), body=[If(test=Compare(left=Name(id='cls', ctx=Load()), ops=[Is()], comparators=[Name(id='Literal', ctx=Load())]), body=[Assign(targets=[Name(id='match_string', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='matchString', ctx=Load()), Name(id='match_string', ctx=Load())])), If(test=UnaryOp(op=Not(), operand=Name(id='match_string', ctx=Load())), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='Empty', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='match_string', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='_SingleCharLiteral', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__new__', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__getnewargs__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='match_string', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='matchString', annotation=Name(id='str', ctx=Load()))], kw_defaults=[Constant(value='')], defaults=[Constant(value='')]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='match_string', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='matchString', ctx=Load()), Name(id='match_string', ctx=Load())])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Store())], value=Name(id='match_string', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='match_string', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='firstMatchChar', ctx=Store())], value=Subscript(value=Name(id='match_string', ctx=Load()), slice=Slice(upper=Constant(value=1)), ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='Expected '), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='firstMatchChar', ctx=Load())]), Call(func=Attribute(value=Name(id='instring', ctx=Load()), attr='startswith', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])]), body=[Return(value=Tuple(elts=[BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load())), Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Load())], ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Empty', bases=[Name(id='Literal', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    An empty token, will always match.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='match_string')], kwonlyargs=[arg(arg='matchString')], kw_defaults=[Constant(value='')], defaults=[Constant(value='')]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Constant(value='')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='Empty'))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), List(elts=[], ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='_SingleCharLiteral', bases=[Name(id='Literal', ctx=Load())], keywords=[], body=[FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='firstMatchChar', ctx=Load())]), body=[Return(value=Tuple(elts=[BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Constant(value=1)), Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Load())], ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_literalStringClass', ctx=Store())], value=Name(id='Literal', ctx=Load())), ClassDef(name='Keyword', bases=[Name(id='Token', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Token to exactly match a specified string as a keyword, that is,\n    it must be immediately preceded and followed by whitespace or\n    non-keyword characters. Compare with :class:`Literal`:\n\n    - ``Literal("if")`` will match the leading ``\'if\'`` in\n      ``\'ifAndOnlyIf\'``.\n    - ``Keyword("if")`` will not; it will only match the leading\n      ``\'if\'`` in ``\'if x=1\'``, or ``\'if(y==2)\'``\n\n    Accepts two optional constructor arguments in addition to the\n    keyword string:\n\n    - ``ident_chars`` is a string of characters that would be valid\n      identifier characters, defaulting to all alphanumerics + "_" and\n      "$"\n    - ``caseless`` allows case-insensitive matching, default is ``False``.\n\n    Example::\n\n        Keyword("start").parse_string("start")  # -> [\'start\']\n        Keyword("start").parse_string("starting")  # -> Exception\n\n    For case-insensitive matching, use :class:`CaselessKeyword`.\n    ')), Assign(targets=[Name(id='DEFAULT_KEYWORD_CHARS', ctx=Store())], value=BinOp(left=Name(id='alphanums', ctx=Load()), op=Add(), right=Constant(value='_$'))), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='match_string', annotation=Name(id='str', ctx=Load())), arg(arg='ident_chars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='caseless', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='matchString', annotation=Name(id='str', ctx=Load())), arg(arg='identChars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=''), Constant(value=None)], defaults=[Constant(value=''), Constant(value=None), Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='identChars', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='identChars', ctx=Load()), Name(id='ident_chars', ctx=Load())])), If(test=Compare(left=Name(id='identChars', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='identChars', ctx=Store())], value=Attribute(value=Name(id='Keyword', ctx=Load()), attr='DEFAULT_KEYWORD_CHARS', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='match_string', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='matchString', ctx=Load()), Name(id='match_string', ctx=Load())])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Store())], value=Name(id='match_string', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='match_string', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='firstMatchChar', ctx=Store())], value=Subscript(value=Name(id='match_string', ctx=Load()), slice=Constant(value=0), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='null string passed to Keyword; use Empty() instead')], keywords=[]))])], orelse=[], finalbody=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=JoinedStr(values=[Constant(value='Expected '), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='caseless', ctx=Store())], value=Name(id='caseless', ctx=Load())), If(test=Name(id='caseless', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='caselessmatch', ctx=Store())], value=Call(func=Attribute(value=Name(id='match_string', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='identChars', ctx=Store())], value=Call(func=Attribute(value=Name(id='identChars', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='identChars', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='identChars', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='errmsg', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load())), Assign(targets=[Name(id='errloc', ctx=Store())], value=Name(id='loc', ctx=Load())), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='caseless', ctx=Load()), body=[If(test=Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='loc', ctx=Load()), upper=BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load()))), ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='caselessmatch', ctx=Load())]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='instring', ctx=Load()), slice=BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='identChars', ctx=Load())])]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[]), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load()))]), Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='instring', ctx=Load()), slice=BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load())), ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='identChars', ctx=Load())])]), body=[Return(value=Tuple(elts=[BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load())), Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Load())], ctx=Load()))], orelse=[AugAssign(target=Name(id='errmsg', ctx=Store()), op=Add(), value=Constant(value=', was immediately followed by keyword character')), Assign(targets=[Name(id='errloc', ctx=Store())], value=BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load())))])], orelse=[AugAssign(target=Name(id='errmsg', ctx=Store()), op=Add(), value=Constant(value=', keyword was immediately preceded by keyword character')), Assign(targets=[Name(id='errloc', ctx=Store())], value=BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Constant(value=1)))])], orelse=[])], orelse=[If(test=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='firstMatchChar', ctx=Load())]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)])]), Call(func=Attribute(value=Name(id='instring', ctx=Load()), attr='startswith', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='identChars', ctx=Load())])]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[]), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load()))]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load())), ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='identChars', ctx=Load())])]), body=[Return(value=Tuple(elts=[BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load())), Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Load())], ctx=Load()))], orelse=[AugAssign(target=Name(id='errmsg', ctx=Store()), op=Add(), value=Constant(value=', keyword was immediately followed by keyword character')), Assign(targets=[Name(id='errloc', ctx=Store())], value=BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load())))])], orelse=[AugAssign(target=Name(id='errmsg', ctx=Store()), op=Add(), value=Constant(value=', keyword was immediately preceded by keyword character')), Assign(targets=[Name(id='errloc', ctx=Store())], value=BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Constant(value=1)))])], orelse=[])]), Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='errloc', ctx=Load()), Name(id='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='set_default_keyword_chars', args=arguments(posonlyargs=[], args=[arg(arg='chars')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Overrides the default characters used by :class:`Keyword` expressions.\n        ')), Assign(targets=[Attribute(value=Name(id='Keyword', ctx=Load()), attr='DEFAULT_KEYWORD_CHARS', ctx=Store())], value=Name(id='chars', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Constant(value=None)), Assign(targets=[Name(id='setDefaultKeywordChars', ctx=Store())], value=Name(id='set_default_keyword_chars', ctx=Load()))], decorator_list=[]), ClassDef(name='CaselessLiteral', bases=[Name(id='Literal', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Token to match a specified string, ignoring case of letters.\n    Note: the matched results will always be in the case of the given\n    match string, NOT the case of the input text.\n\n    Example::\n\n        CaselessLiteral("CMD")[1, ...].parse_string("cmd CMD Cmd10")\n        # -> [\'CMD\', \'CMD\', \'CMD\']\n\n    (Contrast with example for :class:`CaselessKeyword`.)\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='match_string', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='matchString', annotation=Name(id='str', ctx=Load()))], kw_defaults=[Constant(value='')], defaults=[Constant(value='')]), body=[Assign(targets=[Name(id='match_string', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='matchString', ctx=Load()), Name(id='match_string', ctx=Load())])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Call(func=Attribute(value=Name(id='match_string', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='returnString', ctx=Store())], value=Name(id='match_string', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='Expected '), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='loc', ctx=Load()), upper=BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load()))), ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='match', ctx=Load())]), body=[Return(value=Tuple(elts=[BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='matchLen', ctx=Load())), Attribute(value=Name(id='self', ctx=Load()), attr='returnString', ctx=Load())], ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='CaselessKeyword', bases=[Name(id='Keyword', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Caseless version of :class:`Keyword`.\n\n    Example::\n\n        CaselessKeyword("CMD")[1, ...].parse_string("cmd CMD Cmd10")\n        # -> [\'CMD\', \'CMD\']\n\n    (Contrast with example for :class:`CaselessLiteral`.)\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='match_string', annotation=Name(id='str', ctx=Load())), arg(arg='ident_chars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='matchString', annotation=Name(id='str', ctx=Load())), arg(arg='identChars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=''), Constant(value=None)], defaults=[Constant(value=''), Constant(value=None)]), body=[Assign(targets=[Name(id='identChars', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='identChars', ctx=Load()), Name(id='ident_chars', ctx=Load())])), Assign(targets=[Name(id='match_string', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='matchString', ctx=Load()), Name(id='match_string', ctx=Load())])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='match_string', ctx=Load()), Name(id='identChars', ctx=Load())], keywords=[keyword(arg='caseless', value=Constant(value=True))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='CloseMatch', bases=[Name(id='Token', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A variation on :class:`Literal` which matches "close" matches,\n    that is, strings with at most \'n\' mismatching characters.\n    :class:`CloseMatch` takes parameters:\n\n    - ``match_string`` - string to be matched\n    - ``caseless`` - a boolean indicating whether to ignore casing when comparing characters\n    - ``max_mismatches`` - (``default=1``) maximum number of\n      mismatches allowed to count as a match\n\n    The results from a successful parse will contain the matched text\n    from the input string and the following named results:\n\n    - ``mismatches`` - a list of the positions within the\n      match_string where mismatches were found\n    - ``original`` - the original match_string used to compare\n      against the input string\n\n    If ``mismatches`` is an empty list, then the match was an exact\n    match.\n\n    Example::\n\n        patt = CloseMatch("ATCATCGAATGGA")\n        patt.parse_string("ATCATCGAAXGGA") # -> ([\'ATCATCGAAXGGA\'], {\'mismatches\': [[9]], \'original\': [\'ATCATCGAATGGA\']})\n        patt.parse_string("ATCAXCGAAXGGA") # -> Exception: Expected \'ATCATCGAATGGA\' (with up to 1 mismatches) (at char 0), (line:1, col:1)\n\n        # exact match\n        patt.parse_string("ATCATCGAATGGA") # -> ([\'ATCATCGAATGGA\'], {\'mismatches\': [[]], \'original\': [\'ATCATCGAATGGA\']})\n\n        # close match allowing up to 2 mismatches\n        patt = CloseMatch("ATCATCGAATGGA", max_mismatches=2)\n        patt.parse_string("ATCAXCGAAXGGA") # -> ([\'ATCAXCGAAXGGA\'], {\'mismatches\': [[4, 9]], \'original\': [\'ATCATCGAATGGA\']})\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='match_string', annotation=Name(id='str', ctx=Load())), arg(arg='max_mismatches', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='maxMismatches', annotation=Name(id='int', ctx=Load())), arg(arg='caseless')], kw_defaults=[Constant(value=1), Constant(value=False)], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='maxMismatches', ctx=Store())], value=IfExp(test=Compare(left=Name(id='max_mismatches', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='max_mismatches', ctx=Load()), orelse=Name(id='maxMismatches', ctx=Load()))), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='match_string', ctx=Store())], value=Name(id='match_string', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxMismatches', ctx=Store())], value=Name(id='maxMismatches', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=JoinedStr(values=[Constant(value='Expected '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='match_string', ctx=Load()), conversion=114), Constant(value=' (with up to '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='maxMismatches', ctx=Load()), conversion=-1), Constant(value=' mismatches)')])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='caseless', ctx=Store())], value=Name(id='caseless', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value=':'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='match_string', ctx=Load()), conversion=114)]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=Name(id='loc', ctx=Load())), Assign(targets=[Name(id='instrlen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])), Assign(targets=[Name(id='maxloc', ctx=Store())], value=BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='match_string', ctx=Load())], keywords=[]))), If(test=Compare(left=Name(id='maxloc', ctx=Load()), ops=[LtE()], comparators=[Name(id='instrlen', ctx=Load())]), body=[Assign(targets=[Name(id='match_string', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='match_string', ctx=Load())), Assign(targets=[Name(id='match_stringloc', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='mismatches', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='maxMismatches', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='maxMismatches', ctx=Load())), For(target=Tuple(elts=[Name(id='match_stringloc', ctx=Store()), Name(id='s_m', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='loc', ctx=Load()), upper=Name(id='maxloc', ctx=Load())), ctx=Load()), Name(id='match_string', ctx=Load())], keywords=[])], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='src', ctx=Store()), Name(id='mat', ctx=Store())], ctx=Store())], value=Name(id='s_m', ctx=Load())), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='caseless', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='src', ctx=Store()), Name(id='mat', ctx=Store())], ctx=Store())], value=Tuple(elts=[Call(func=Attribute(value=Name(id='src', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='mat', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])], ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='src', ctx=Load()), ops=[NotEq()], comparators=[Name(id='mat', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='mismatches', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='match_stringloc', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mismatches', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='maxMismatches', ctx=Load())]), body=[Break()], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='loc', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Name(id='match_stringloc', ctx=Load())), op=Add(), right=Constant(value=1))), Assign(targets=[Name(id='results', ctx=Store())], value=Call(func=Name(id='ParseResults', ctx=Load()), args=[List(elts=[Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='loc', ctx=Load())), ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='results', ctx=Load()), slice=Constant(value='original'), ctx=Store())], value=Name(id='match_string', ctx=Load())), Assign(targets=[Subscript(value=Name(id='results', ctx=Load()), slice=Constant(value='mismatches'), ctx=Store())], value=Name(id='mismatches', ctx=Load())), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='results', ctx=Load())], ctx=Load()))])], orelse=[]), Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Word', bases=[Name(id='Token', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Token for matching words composed of allowed character sets.\n\n    Parameters:\n\n    - ``init_chars`` - string of all characters that should be used to\n      match as a word; "ABC" will match "AAA", "ABAB", "CBAC", etc.;\n      if ``body_chars`` is also specified, then this is the string of\n      initial characters\n    - ``body_chars`` - string of characters that\n      can be used for matching after a matched initial character as\n      given in ``init_chars``; if omitted, same as the initial characters\n      (default=``None``)\n    - ``min`` - minimum number of characters to match (default=1)\n    - ``max`` - maximum number of characters to match (default=0)\n    - ``exact`` - exact number of characters to match (default=0)\n    - ``as_keyword`` - match as a keyword (default=``False``)\n    - ``exclude_chars`` - characters that might be\n      found in the input ``body_chars`` string but which should not be\n      accepted for matching ;useful to define a word of all\n      printables except for one or two characters, for instance\n      (default=``None``)\n\n    :class:`srange` is useful for defining custom character set strings\n    for defining :class:`Word` expressions, using range notation from\n    regular expression character sets.\n\n    A common mistake is to use :class:`Word` to match a specific literal\n    string, as in ``Word("Address")``. Remember that :class:`Word`\n    uses the string argument to define *sets* of matchable characters.\n    This expression would match "Add", "AAA", "dAred", or any other word\n    made up of the characters \'A\', \'d\', \'r\', \'e\', and \'s\'. To match an\n    exact literal string, use :class:`Literal` or :class:`Keyword`.\n\n    pyparsing includes helper strings for building Words:\n\n    - :class:`alphas`\n    - :class:`nums`\n    - :class:`alphanums`\n    - :class:`hexnums`\n    - :class:`alphas8bit` (alphabetic characters in ASCII range 128-255\n      - accented, tilded, umlauted, etc.)\n    - :class:`punc8bit` (non-alphabetic characters in ASCII range\n      128-255 - currency, symbols, superscripts, diacriticals, etc.)\n    - :class:`printables` (any non-whitespace character)\n\n    ``alphas``, ``nums``, and ``printables`` are also defined in several\n    Unicode sets - see :class:`pyparsing_unicode``.\n\n    Example::\n\n        # a word composed of digits\n        integer = Word(nums) # equivalent to Word("0123456789") or Word(srange("0-9"))\n\n        # a word with a leading capital, and zero or more lowercase\n        capital_word = Word(alphas.upper(), alphas.lower())\n\n        # hostnames are alphanumeric, with leading alpha, and \'-\'\n        hostname = Word(alphas, alphanums + \'-\')\n\n        # roman numeral (not a strict parser, accepts invalid mix of characters)\n        roman = Word("IVXLCDM")\n\n        # any string of non-whitespace characters, except for \',\'\n        csv_value = Word(printables, exclude_chars=",")\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='init_chars', annotation=Name(id='str', ctx=Load())), arg(arg='body_chars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='min', annotation=Name(id='int', ctx=Load())), arg(arg='max', annotation=Name(id='int', ctx=Load())), arg(arg='exact', annotation=Name(id='int', ctx=Load())), arg(arg='as_keyword', annotation=Name(id='bool', ctx=Load())), arg(arg='exclude_chars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='initChars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='bodyChars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='asKeyword', annotation=Name(id='bool', ctx=Load())), arg(arg='excludeChars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None)], defaults=[Constant(value=''), Constant(value=None), Constant(value=1), Constant(value=0), Constant(value=0), Constant(value=False), Constant(value=None)]), body=[Assign(targets=[Name(id='initChars', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='initChars', ctx=Load()), Name(id='init_chars', ctx=Load())])), Assign(targets=[Name(id='bodyChars', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='bodyChars', ctx=Load()), Name(id='body_chars', ctx=Load())])), Assign(targets=[Name(id='asKeyword', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='asKeyword', ctx=Load()), Name(id='as_keyword', ctx=Load())])), Assign(targets=[Name(id='excludeChars', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='excludeChars', ctx=Load()), Name(id='exclude_chars', ctx=Load())])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='initChars', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='invalid '), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value=', initChars cannot be empty string')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='initChars_set', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='initChars', ctx=Load())], keywords=[])), If(test=Name(id='excludeChars', ctx=Load()), body=[Assign(targets=[Name(id='excludeChars_set', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='excludeChars', ctx=Load())], keywords=[])), AugAssign(target=Name(id='initChars_set', ctx=Store()), op=Sub(), value=Name(id='excludeChars_set', ctx=Load())), If(test=Name(id='bodyChars', ctx=Load()), body=[Assign(targets=[Name(id='bodyChars', ctx=Store())], value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[BinOp(left=Call(func=Name(id='set', ctx=Load()), args=[Name(id='bodyChars', ctx=Load())], keywords=[]), op=Sub(), right=Name(id='excludeChars_set', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initChars', ctx=Store())], value=Name(id='initChars_set', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initCharsOrig', ctx=Store())], value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='initChars_set', ctx=Load())], keywords=[])], keywords=[])), If(test=Name(id='bodyChars', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='bodyChars', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='bodyChars', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='bodyCharsOrig', ctx=Store())], value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='bodyChars', ctx=Load())], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='bodyChars', ctx=Store())], value=Name(id='initChars_set', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='bodyCharsOrig', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='initCharsOrig', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxSpecified', ctx=Store())], value=Compare(left=Name(id='max', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)])), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot specify a minimum length < 1; use Opt(Word()) if zero-length word is permitted')], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='maxSpecified', ctx=Load()), Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Name(id='max', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='invalid args, if min and max both specified min must be <= max (min='), FormattedValue(value=Name(id='min', ctx=Load()), conversion=-1), Constant(value=', max='), FormattedValue(value=Name(id='max', ctx=Load()), conversion=-1), Constant(value=')')])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Store())], value=Name(id='min', ctx=Load())), If(test=Compare(left=Name(id='max', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Store())], value=Name(id='max', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Store())], value=Name(id='_MAX_INT', ctx=Load()))]), If(test=Compare(left=Name(id='exact', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='min', ctx=Store()), Name(id='max', ctx=Store())], value=Name(id='exact', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Store())], value=Name(id='exact', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Store())], value=Name(id='exact', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='Expected '), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='asKeyword', ctx=Store())], value=Name(id='asKeyword', ctx=Load())), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='asKeyword', ctx=Load()), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store()), op=Add(), value=Constant(value=' as a keyword'))], orelse=[]), If(test=Compare(left=Constant(value=' '), ops=[NotIn()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='initChars', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='self', ctx=Load()), attr='bodyChars', ctx=Load()))]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initChars', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='re_leading_fragment', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initCharsOrig', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='re_leading_fragment', ctx=Store())], value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Call(func=Name(id='_collapse_string_to_ranges', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initChars', ctx=Load())], keywords=[]), conversion=-1), Constant(value=']')]))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='bodyChars', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='initChars', ctx=Load())]), body=[If(test=Compare(left=Name(id='max', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='repeat', ctx=Store())], value=Constant(value='+'))], orelse=[If(test=Compare(left=Name(id='max', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='repeat', ctx=Store())], value=Constant(value=''))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Load())]), body=[Assign(targets=[Name(id='repeat', ctx=Store())], value=JoinedStr(values=[Constant(value='{'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load()), conversion=-1), Constant(value=','), FormattedValue(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Load()), ops=[Eq()], comparators=[Name(id='_MAX_INT', ctx=Load())]), body=Constant(value=''), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Load())), conversion=-1), Constant(value='}')]))], orelse=[Assign(targets=[Name(id='repeat', ctx=Store())], value=JoinedStr(values=[Constant(value='{'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load()), conversion=-1), Constant(value='}')]))])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='reString', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='re_leading_fragment', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='repeat', ctx=Load()), conversion=-1)]))], orelse=[If(test=Compare(left=Name(id='max', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='re_body_fragment', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='repeat', ctx=Store())], value=Constant(value=''))], orelse=[Assign(targets=[Name(id='re_body_fragment', ctx=Store())], value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Call(func=Name(id='_collapse_string_to_ranges', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='bodyChars', ctx=Load())], keywords=[]), conversion=-1), Constant(value=']')])), If(test=Compare(left=Name(id='max', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='repeat', ctx=Store())], value=Constant(value='*'))], orelse=[If(test=Compare(left=Name(id='max', ctx=Load()), ops=[Eq()], comparators=[Constant(value=2)]), body=[Assign(targets=[Name(id='repeat', ctx=Store())], value=IfExp(test=Compare(left=Name(id='min', ctx=Load()), ops=[LtE()], comparators=[Constant(value=1)]), body=Constant(value='?'), orelse=Constant(value='')))], orelse=[If(test=Compare(left=Name(id='min', ctx=Load()), ops=[NotEq()], comparators=[Name(id='max', ctx=Load())]), body=[Assign(targets=[Name(id='repeat', ctx=Store())], value=JoinedStr(values=[Constant(value='{'), FormattedValue(value=IfExp(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=BinOp(left=Name(id='min', ctx=Load()), op=Sub(), right=Constant(value=1)), orelse=Constant(value=0)), conversion=-1), Constant(value=','), FormattedValue(value=BinOp(left=Name(id='max', ctx=Load()), op=Sub(), right=Constant(value=1)), conversion=-1), Constant(value='}')]))], orelse=[Assign(targets=[Name(id='repeat', ctx=Store())], value=JoinedStr(values=[Constant(value='{'), FormattedValue(value=IfExp(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=BinOp(left=Name(id='min', ctx=Load()), op=Sub(), right=Constant(value=1)), orelse=Constant(value=0)), conversion=-1), Constant(value='}')]))])])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='reString', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='re_leading_fragment', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='re_body_fragment', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='repeat', ctx=Load()), conversion=-1)]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='asKeyword', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='reString', ctx=Store())], value=JoinedStr(values=[Constant(value='\\b'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='reString', ctx=Load()), conversion=-1), Constant(value='\\b')]))], orelse=[]), Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='reString', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='re', ctx=Load()), attr='error', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='re', ctx=Store())], value=Constant(value=None))])], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='re_match', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='re', ctx=Load()), attr='match', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parseImpl', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='parseImpl_regex', ctx=Load()))], finalbody=[])], orelse=[])], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='charsAsStr', args=arguments(posonlyargs=[], args=[arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='max_repr_len', ctx=Store())], value=Constant(value=16)), Assign(targets=[Name(id='s', ctx=Store())], value=Call(func=Name(id='_collapse_string_to_ranges', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[keyword(arg='re_escape', value=Constant(value=False))])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='max_repr_len', ctx=Load())]), body=[Return(value=BinOp(left=Subscript(value=Name(id='s', ctx=Load()), slice=Slice(upper=BinOp(left=Name(id='max_repr_len', ctx=Load()), op=Sub(), right=Constant(value=3))), ctx=Load()), op=Add(), right=Constant(value='...')))], orelse=[Return(value=Name(id='s', ctx=Load()))])], decorator_list=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='initChars', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='bodyChars', ctx=Load())]), body=[Assign(targets=[Name(id='base', ctx=Store())], value=JoinedStr(values=[Constant(value='W:('), FormattedValue(value=Call(func=Name(id='charsAsStr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initChars', ctx=Load())], keywords=[]), conversion=-1), Constant(value=', '), FormattedValue(value=Call(func=Name(id='charsAsStr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='bodyChars', ctx=Load())], keywords=[]), conversion=-1), Constant(value=')')]))], orelse=[Assign(targets=[Name(id='base', ctx=Store())], value=JoinedStr(values=[Constant(value='W:('), FormattedValue(value=Call(func=Name(id='charsAsStr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initChars', ctx=Load())], keywords=[]), conversion=-1), Constant(value=')')]))]), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load()), ops=[Gt()], comparators=[Constant(value=1)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Load()), ops=[NotEq()], comparators=[Name(id='_MAX_INT', ctx=Load())])]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Subscript(value=Name(id='base', ctx=Load()), slice=Slice(lower=Constant(value=2)), ctx=Load()))], orelse=[Return(value=BinOp(left=Name(id='base', ctx=Load()), op=Add(), right=JoinedStr(values=[Constant(value='{'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load()), conversion=-1), Constant(value='}')])))])], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Load()), ops=[Eq()], comparators=[Name(id='_MAX_INT', ctx=Load())]), body=[Return(value=BinOp(left=Name(id='base', ctx=Load()), op=Add(), right=JoinedStr(values=[Constant(value='{'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load()), conversion=-1), Constant(value=',...}')])))], orelse=[Return(value=BinOp(left=Name(id='base', ctx=Load()), op=Add(), right=JoinedStr(values=[Constant(value='{'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load()), conversion=-1), Constant(value=','), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Load()), conversion=-1), Constant(value='}')])))])])], orelse=[]), Return(value=Name(id='base', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='initChars', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='start', ctx=Store())], value=Name(id='loc', ctx=Load())), AugAssign(target=Name(id='loc', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Name(id='instrlen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bodychars', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='bodyChars', ctx=Load())), Assign(targets=[Name(id='maxloc', ctx=Store())], value=BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Load()))), Assign(targets=[Name(id='maxloc', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='maxloc', ctx=Load()), Name(id='instrlen', ctx=Load())], keywords=[])), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Name(id='maxloc', ctx=Load())]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[In()], comparators=[Name(id='bodychars', ctx=Load())])]), body=[AugAssign(target=Name(id='loc', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Assign(targets=[Name(id='throwException', ctx=Store())], value=Constant(value=False)), If(test=Compare(left=BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Name(id='start', ctx=Load())), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load())]), body=[Assign(targets=[Name(id='throwException', ctx=Store())], value=Constant(value=True))], orelse=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='maxSpecified', ctx=Load()), Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Name(id='instrlen', ctx=Load())]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[In()], comparators=[Name(id='bodychars', ctx=Load())])]), body=[Assign(targets=[Name(id='throwException', ctx=Store())], value=Constant(value=True))], orelse=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='asKeyword', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Compare(left=Name(id='start', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=BinOp(left=Name(id='start', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load()), ops=[In()], comparators=[Name(id='bodychars', ctx=Load())])]), BoolOp(op=And(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Name(id='instrlen', ctx=Load())]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[In()], comparators=[Name(id='bodychars', ctx=Load())])])]), body=[Assign(targets=[Name(id='throwException', ctx=Store())], value=Constant(value=True))], orelse=[])], orelse=[])])]), If(test=Name(id='throwException', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='loc', ctx=Load())), ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='parseImpl_regex', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='re_match', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='result', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[])), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='group', ctx=Load()), args=[], keywords=[])], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='Char', bases=[Name(id='Word', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A short-cut class for defining :class:`Word` ``(characters, exact=1)``,\n    when defining a match of any single character in a string of\n    characters.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='charset', annotation=Name(id='str', ctx=Load())), arg(arg='as_keyword', annotation=Name(id='bool', ctx=Load())), arg(arg='exclude_chars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='asKeyword', annotation=Name(id='bool', ctx=Load())), arg(arg='excludeChars', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=False), Constant(value=None)], defaults=[Constant(value=False), Constant(value=None)]), body=[Assign(targets=[Name(id='asKeyword', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='asKeyword', ctx=Load()), Name(id='as_keyword', ctx=Load())])), Assign(targets=[Name(id='excludeChars', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='excludeChars', ctx=Load()), Name(id='exclude_chars', ctx=Load())])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='charset', ctx=Load())], keywords=[keyword(arg='exact', value=Constant(value=1)), keyword(arg='as_keyword', value=Name(id='asKeyword', ctx=Load())), keyword(arg='exclude_chars', value=Name(id='excludeChars', ctx=Load()))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Regex', bases=[Name(id='Token', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Token for matching strings that match a given regular\n    expression. Defined with string specifying the regular expression in\n    a form recognized by the stdlib Python  `re module <https://docs.python.org/3/library/re.html>`_.\n    If the given regex contains named groups (defined using ``(?P<name>...)``),\n    these will be preserved as named :class:`ParseResults`.\n\n    If instead of the Python stdlib ``re`` module you wish to use a different RE module\n    (such as the ``regex`` module), you can do so by building your ``Regex`` object with\n    a compiled RE that was compiled using ``regex``.\n\n    Example::\n\n        realnum = Regex(r"[+-]?\\d+\\.\\d*")\n        # ref: https://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression\n        roman = Regex(r"M{0,4}(CM|CD|D?{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")\n\n        # named fields in a regex will be returned as named results\n        date = Regex(r\'(?P<year>\\d{4})-(?P<month>\\d\\d?)-(?P<day>\\d\\d?)\')\n\n        # the Regex class will accept re\'s compiled using the regex module\n        import regex\n        parser = pp.Regex(regex.compile(r\'[0-9]\'))\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pattern', annotation=Name(id='Any', ctx=Load())), arg(arg='flags', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='re', ctx=Load()), attr='RegexFlag', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='as_group_list', annotation=Name(id='bool', ctx=Load())), arg(arg='as_match', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='asGroupList', annotation=Name(id='bool', ctx=Load())), arg(arg='asMatch', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False), Constant(value=False)], defaults=[Constant(value=0), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value='The parameters ``pattern`` and ``flags`` are passed\n        to the ``re.compile()`` function as-is. See the Python\n        `re module <https://docs.python.org/3/library/re.html>`_ module for an\n        explanation of the acceptable patterns and flags.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='asGroupList', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='asGroupList', ctx=Load()), Name(id='as_group_list', ctx=Load())])), Assign(targets=[Name(id='asMatch', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='asMatch', ctx=Load()), Name(id='as_match', ctx=Load())])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='pattern', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='null string passed to Regex; use Empty() instead')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_re', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='reString', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Store())], value=Name(id='pattern', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='flags', ctx=Store())], value=Name(id='flags', ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Constant(value='pattern')], keywords=[]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Constant(value='match')], keywords=[])]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_re', ctx=Store())], value=Name(id='pattern', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Store()), Attribute(value=Name(id='self', ctx=Load()), attr='reString', ctx=Store())], value=Attribute(value=Name(id='pattern', ctx=Load()), attr='pattern', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='flags', ctx=Store())], value=Name(id='flags', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Regex may only be constructed with a string or a compiled RE object')], keywords=[]))])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='Expected '), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='asGroupList', ctx=Store())], value=Name(id='asGroupList', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='asMatch', ctx=Store())], value=Name(id='asMatch', ctx=Load())), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='asGroupList', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parseImpl', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='parseImplAsGroupList', ctx=Load()))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='asMatch', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parseImpl', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='parseImplAsMatch', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='re', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_re', ctx=Load()), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_re', ctx=Load()))], orelse=[Try(body=[Return(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='flags', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='re', ctx=Load()), attr='error', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='invalid pattern ('), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()), conversion=114), Constant(value=') passed to Regex')])], keywords=[]))])], orelse=[], finalbody=[])])], decorator_list=[Name(id='cached_property', ctx=Load())]), FunctionDef(name='re_match', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='re', ctx=Load()), attr='match', ctx=Load()))], decorator_list=[Name(id='cached_property', ctx=Load())]), FunctionDef(name='mayReturnEmpty', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='re_match', ctx=Load()), args=[Constant(value='')], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)]))], decorator_list=[Name(id='cached_property', ctx=Load())]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='Re:({})'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load())], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='\\\\'), Constant(value='\\')], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='re_match', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='result', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='ParseResults', ctx=Load()), args=[Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='group', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='d', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='groupdict', ctx=Load()), args=[], keywords=[])), If(test=Name(id='d', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='d', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='ret', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Store())], value=Name(id='v', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='ret', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='parseImplAsGroupList', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='re_match', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='result', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[])), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='ret', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='parseImplAsMatch', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='re_match', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='result', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ret', ctx=Store())], value=Name(id='result', ctx=Load())), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='ret', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='sub', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='repl', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return :class:`Regex` with an attached parse action to transform the parsed\n        result as if called using `re.sub(expr, repl, string) <https://docs.python.org/3/library/re.html#re.sub>`_.\n\n        Example::\n\n            make_html = Regex(r"(\\w+):(.*?):").sub(r"<\\1>\\2</\\1>")\n            print(make_html.transform_string("h1:main title:"))\n            # prints "<h1>main title</h1>"\n        ')), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='asGroupList', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='cannot use sub() with Regex(as_group_list=True)')], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='asMatch', ctx=Load()), Call(func=Name(id='callable', ctx=Load()), args=[Name(id='repl', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='cannot use sub() with a callable with Regex(as_match=True)')], keywords=[]))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='asMatch', ctx=Load()), body=[FunctionDef(name='pa', args=arguments(posonlyargs=[], args=[arg(arg='tokens')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Subscript(value=Name(id='tokens', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='expand', ctx=Load()), args=[Name(id='repl', ctx=Load())], keywords=[]))], decorator_list=[])], orelse=[FunctionDef(name='pa', args=arguments(posonlyargs=[], args=[arg(arg='tokens')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='re', ctx=Load()), attr='sub', ctx=Load()), args=[Name(id='repl', ctx=Load()), Subscript(value=Name(id='tokens', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], decorator_list=[])]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add_parse_action', ctx=Load()), args=[Name(id='pa', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load()))], decorator_list=[]), ClassDef(name='QuotedString', bases=[Name(id='Token', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Token for matching strings that are delimited by quoting characters.\n\n    Defined with the following parameters:\n\n    - ``quote_char`` - string of one or more characters defining the\n      quote delimiting string\n    - ``esc_char`` - character to re_escape quotes, typically backslash\n      (default= ``None``)\n    - ``esc_quote`` - special quote sequence to re_escape an embedded quote\n      string (such as SQL\'s ``""`` to re_escape an embedded ``"``)\n      (default= ``None``)\n    - ``multiline`` - boolean indicating whether quotes can span\n      multiple lines (default= ``False``)\n    - ``unquote_results`` - boolean indicating whether the matched text\n      should be unquoted (default= ``True``)\n    - ``end_quote_char`` - string of one or more characters defining the\n      end of the quote delimited string (default= ``None``  => same as\n      quote_char)\n    - ``convert_whitespace_escapes`` - convert escaped whitespace\n      (``\'\\t\'``, ``\'\\n\'``, etc.) to actual whitespace\n      (default= ``True``)\n\n    Example::\n\n        qs = QuotedString(\'"\')\n        print(qs.search_string(\'lsjdf "This is the quote" sldjf\'))\n        complex_qs = QuotedString(\'{{\', end_quote_char=\'}}\')\n        print(complex_qs.search_string(\'lsjdf {{This is the "quote"}} sldjf\'))\n        sql_qs = QuotedString(\'"\', esc_quote=\'""\')\n        print(sql_qs.search_string(\'lsjdf "This is the quote with ""embedded"" quotes" sldjf\'))\n\n    prints::\n\n        [[\'This is the quote\']]\n        [[\'This is the "quote"\']]\n        [[\'This is the quote with "embedded" quotes\']]\n    ')), Assign(targets=[Name(id='ws_map', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Tuple(elts=[Tuple(elts=[Constant(value='\\t'), Constant(value='\t')], ctx=Load()), Tuple(elts=[Constant(value='\\n'), Constant(value='\n')], ctx=Load()), Tuple(elts=[Constant(value='\\f'), Constant(value='\x0c')], ctx=Load()), Tuple(elts=[Constant(value='\\r'), Constant(value='\r')], ctx=Load())], ctx=Load())], keywords=[])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='quote_char', annotation=Name(id='str', ctx=Load())), arg(arg='esc_char', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='esc_quote', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='multiline', annotation=Name(id='bool', ctx=Load())), arg(arg='unquote_results', annotation=Name(id='bool', ctx=Load())), arg(arg='end_quote_char', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='convert_whitespace_escapes', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='quoteChar', annotation=Name(id='str', ctx=Load())), arg(arg='escChar', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='escQuote', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='unquoteResults', annotation=Name(id='bool', ctx=Load())), arg(arg='endQuoteChar', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='convertWhitespaceEscapes', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=''), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=None), Constant(value=True)], defaults=[Constant(value=''), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=True), Constant(value=None), Constant(value=True)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='escChar', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='escChar', ctx=Load()), Name(id='esc_char', ctx=Load())])), Assign(targets=[Name(id='escQuote', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='escQuote', ctx=Load()), Name(id='esc_quote', ctx=Load())])), Assign(targets=[Name(id='unquoteResults', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='unquoteResults', ctx=Load()), Name(id='unquote_results', ctx=Load())])), Assign(targets=[Name(id='endQuoteChar', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='endQuoteChar', ctx=Load()), Name(id='end_quote_char', ctx=Load())])), Assign(targets=[Name(id='convertWhitespaceEscapes', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='convertWhitespaceEscapes', ctx=Load()), Name(id='convert_whitespace_escapes', ctx=Load())])), Assign(targets=[Name(id='quote_char', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='quoteChar', ctx=Load()), Name(id='quote_char', ctx=Load())])), Assign(targets=[Name(id='quote_char', ctx=Store())], value=Call(func=Attribute(value=Name(id='quote_char', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='quote_char', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='quote_char cannot be the empty string')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='endQuoteChar', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='endQuoteChar', ctx=Store())], value=Name(id='quote_char', ctx=Load()))], orelse=[Assign(targets=[Name(id='endQuoteChar', ctx=Store())], value=Call(func=Attribute(value=Name(id='endQuoteChar', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='endQuoteChar', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='end_quote_char cannot be the empty string')], keywords=[]))], orelse=[])]), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='quoteChar', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Name(id='quote_char', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='quoteCharLen', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='quote_char', ctx=Load())], keywords=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='firstQuoteChar', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Subscript(value=Name(id='quote_char', ctx=Load()), slice=Constant(value=0), ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Name(id='endQuoteChar', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteCharLen', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='endQuoteChar', ctx=Load())], keywords=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='escChar', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=BoolOp(op=Or(), values=[Name(id='escChar', ctx=Load()), Constant(value='')]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='escQuote', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=BoolOp(op=Or(), values=[Name(id='escQuote', ctx=Load()), Constant(value='')]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='unquoteResults', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=Name(id='unquoteResults', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='convertWhitespaceEscapes', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=Name(id='convertWhitespaceEscapes', ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='multiline', ctx=Store())], value=Name(id='multiline', ctx=Load())), Assign(targets=[Name(id='sep', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='inner_pattern', ctx=Store())], value=Constant(value='')), If(test=Name(id='escQuote', ctx=Load()), body=[AugAssign(target=Name(id='inner_pattern', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='sep', ctx=Load()), conversion=-1), Constant(value='(?:'), FormattedValue(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='escQuote', ctx=Load())], keywords=[]), conversion=-1), Constant(value=')')])), Assign(targets=[Name(id='sep', ctx=Store())], value=Constant(value='|'))], orelse=[]), If(test=Name(id='escChar', ctx=Load()), body=[AugAssign(target=Name(id='inner_pattern', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='sep', ctx=Load()), conversion=-1), Constant(value='(?:'), FormattedValue(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='escChar', ctx=Load())], keywords=[]), conversion=-1), Constant(value='.)')])), Assign(targets=[Name(id='sep', ctx=Store())], value=Constant(value='|')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='escCharReplacePattern', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='escChar', ctx=Load())], keywords=[]), op=Add(), right=Constant(value='(.)')))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=[AugAssign(target=Name(id='inner_pattern', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=JoinedStr(values=[FormattedValue(value=Name(id='sep', ctx=Load()), conversion=-1), Constant(value='(?:')]), op=Add(), right=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[GeneratorExp(elt=JoinedStr(values=[Constant(value='(?:'), FormattedValue(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Load()), slice=Slice(upper=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]), conversion=-1), Constant(value='(?!'), FormattedValue(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]), conversion=-1), Constant(value='))')]), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1)), Constant(value=0), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), ifs=[], is_async=0)])], keywords=[])), op=Add(), right=Constant(value=')'))), Assign(targets=[Name(id='sep', ctx=Store())], value=Constant(value='|'))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='flags', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='RegexFlag', ctx=Load()), args=[Constant(value=0)], keywords=[])), If(test=Name(id='multiline', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='flags', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='re', ctx=Load()), attr='DOTALL', ctx=Load()))), AugAssign(target=Name(id='inner_pattern', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='sep', ctx=Load()), conversion=-1), Constant(value='(?:[^'), FormattedValue(value=Call(func=Name(id='_escape_regex_range_chars', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), conversion=-1), FormattedValue(value=IfExp(test=Compare(left=Name(id='escChar', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Call(func=Name(id='_escape_regex_range_chars', ctx=Load()), args=[Name(id='escChar', ctx=Load())], keywords=[]), orelse=Constant(value='')), conversion=-1), Constant(value='])')]))], orelse=[AugAssign(target=Name(id='inner_pattern', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='sep', ctx=Load()), conversion=-1), Constant(value='(?:[^'), FormattedValue(value=Call(func=Name(id='_escape_regex_range_chars', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), conversion=-1), Constant(value='\\n\\r'), FormattedValue(value=IfExp(test=Compare(left=Name(id='escChar', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Call(func=Name(id='_escape_regex_range_chars', ctx=Load()), args=[Name(id='escChar', ctx=Load())], keywords=[]), orelse=Constant(value='')), conversion=-1), Constant(value='])')]))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Store())], value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[List(elts=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quoteChar', ctx=Load())], keywords=[]), Constant(value='(?:'), Name(id='inner_pattern', ctx=Load()), Constant(value=')*'), Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Load())], keywords=[])], ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='unquoteResults', ctx=Load()), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='convertWhitespaceEscapes', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='unquote_scan_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[JoinedStr(values=[Constant(value='('), FormattedValue(value=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='ws_map', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), conversion=-1), Constant(value=')|('), FormattedValue(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='escChar', ctx=Load())], keywords=[]), conversion=-1), Constant(value='.)|(\\n|.)')])], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='self', ctx=Load()), attr='flags', ctx=Load()))]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='unquote_scan_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[JoinedStr(values=[Constant(value='('), FormattedValue(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='escChar', ctx=Load())], keywords=[]), conversion=-1), Constant(value='.)|(\\n|.)')])], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='self', ctx=Load()), attr='flags', ctx=Load()))]))])], orelse=[]), Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='flags', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='reString', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='re_match', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='re', ctx=Load()), attr='match', ctx=Load()))], handlers=[ExceptHandler(type=Attribute(value=Name(id='re', ctx=Load()), attr='error', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='invalid pattern '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()), conversion=114), Constant(value=' passed to Regex')])], keywords=[]))])], orelse=[], finalbody=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='Expected '), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quoteChar', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Load())]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quoteChar', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[])]), body=[Return(value=JoinedStr(values=[Constant(value='string enclosed in '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='quoteChar', ctx=Load()), conversion=114)]))], orelse=[]), Return(value=JoinedStr(values=[Constant(value='quoted string, starting with '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='quoteChar', ctx=Load()), conversion=-1), Constant(value=' ending with '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Load()), conversion=-1)]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='firstQuoteChar', ctx=Load())]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='re_match', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])]), Constant(value=None)])), If(test=UnaryOp(op=Not(), operand=Name(id='result', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='group', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='unquoteResults', ctx=Load()), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Subscript(value=Name(id='ret', ctx=Load()), slice=Slice(lower=Attribute(value=Name(id='self', ctx=Load()), attr='quoteCharLen', ctx=Load()), upper=UnaryOp(op=USub(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteCharLen', ctx=Load()))), ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='ret', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='convertWhitespaceEscapes', ctx=Load()), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=IfExp(test=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), body=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='ws_map', ctx=Load()), slice=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), ctx=Load()), orelse=IfExp(test=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=2)], keywords=[]), body=Subscript(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=2)], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), orelse=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=3)], keywords=[]))), generators=[comprehension(target=Name(id='match', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='unquote_scan_re', ctx=Load()), attr='finditer', ctx=Load()), args=[Name(id='ret', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=IfExp(test=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), body=Subscript(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), orelse=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=2)], keywords=[])), generators=[comprehension(target=Name(id='match', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='unquote_scan_re', ctx=Load()), attr='finditer', ctx=Load()), args=[Name(id='ret', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='escQuote', ctx=Load()), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='replace', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='escQuote', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='endQuoteChar', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='ret', ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='CharsNotIn', bases=[Name(id='Token', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Token for matching words composed of characters *not* in a given\n    set (will include whitespace in matched characters if not listed in\n    the provided exclusion set - see example). Defined with string\n    containing all disallowed characters, and an optional minimum,\n    maximum, and/or exact length.  The default value for ``min`` is\n    1 (a minimum value < 1 is not valid); the default values for\n    ``max`` and ``exact`` are 0, meaning no maximum or exact\n    length restriction.\n\n    Example::\n\n        # define a comma-separated-value as anything that is not a \',\'\n        csv_value = CharsNotIn(\',\')\n        print(DelimitedList(csv_value).parse_string("dkls,lsdkjf,s12 34,@!#,213"))\n\n    prints::\n\n        [\'dkls\', \'lsdkjf\', \'s12 34\', \'@!#\', \'213\']\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='not_chars', annotation=Name(id='str', ctx=Load())), arg(arg='min', annotation=Name(id='int', ctx=Load())), arg(arg='max', annotation=Name(id='int', ctx=Load())), arg(arg='exact', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[arg(arg='notChars', annotation=Name(id='str', ctx=Load()))], kw_defaults=[Constant(value='')], defaults=[Constant(value=''), Constant(value=1), Constant(value=0), Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='notChars', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='not_chars', ctx=Load()), Name(id='notChars', ctx=Load())])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='notCharsSet', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='notChars', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='cannot specify a minimum length < 1; use Opt(CharsNotIn()) if zero-length char group is permitted')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Store())], value=Name(id='min', ctx=Load())), If(test=Compare(left=Name(id='max', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Store())], value=Name(id='max', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Store())], value=Name(id='_MAX_INT', ctx=Load()))]), If(test=Compare(left=Name(id='exact', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Store())], value=Name(id='exact', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Store())], value=Name(id='exact', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='Expected '), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='not_chars_str', ctx=Store())], value=Call(func=Name(id='_collapse_string_to_ranges', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='notChars', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='not_chars_str', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=16)]), body=[Return(value=JoinedStr(values=[Constant(value='!W:('), FormattedValue(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='notChars', ctx=Load()), slice=Slice(upper=BinOp(left=Constant(value=16), op=Sub(), right=Constant(value=3))), ctx=Load()), conversion=-1), Constant(value='...)')]))], orelse=[Return(value=JoinedStr(values=[Constant(value='!W:('), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='notChars', ctx=Load()), conversion=-1), Constant(value=')')]))])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='notchars', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='notCharsSet', ctx=Load())), If(test=Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[In()], comparators=[Name(id='notchars', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='start', ctx=Store())], value=Name(id='loc', ctx=Load())), AugAssign(target=Name(id='loc', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Name(id='maxlen', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Load())), Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])], keywords=[])), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Name(id='maxlen', ctx=Load())]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[NotIn()], comparators=[Name(id='notchars', ctx=Load())])]), body=[AugAssign(target=Name(id='loc', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), If(test=Compare(left=BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Name(id='start', ctx=Load())), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='loc', ctx=Load())), ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='White', bases=[Name(id='Token', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Special matching class for matching whitespace.  Normally,\n    whitespace is ignored by pyparsing grammars.  This class is included\n    when some whitespace structures are significant.  Define with\n    a string containing the whitespace characters to be matched; default\n    is ``" \\t\\r\\n"``.  Also takes optional ``min``,\n    ``max``, and ``exact`` arguments, as defined for the\n    :class:`Word` class.\n    ')), Assign(targets=[Name(id='whiteStrs', ctx=Store())], value=Dict(keys=[Constant(value=' '), Constant(value='\t'), Constant(value='\n'), Constant(value='\r'), Constant(value='\x0c'), Constant(value='\xa0'), Constant(value='\u1680'), Constant(value='\u180e'), Constant(value='\u2000'), Constant(value='\u2001'), Constant(value='\u2002'), Constant(value='\u2003'), Constant(value='\u2004'), Constant(value='\u2005'), Constant(value='\u2006'), Constant(value='\u2007'), Constant(value='\u2008'), Constant(value='\u2009'), Constant(value='\u200a'), Constant(value='\u200b'), Constant(value='\u202f'), Constant(value='\u205f'), Constant(value='\u3000')], values=[Constant(value='<SP>'), Constant(value='<TAB>'), Constant(value='<LF>'), Constant(value='<CR>'), Constant(value='<FF>'), Constant(value='<NBSP>'), Constant(value='<OGHAM_SPACE_MARK>'), Constant(value='<MONGOLIAN_VOWEL_SEPARATOR>'), Constant(value='<EN_QUAD>'), Constant(value='<EM_QUAD>'), Constant(value='<EN_SPACE>'), Constant(value='<EM_SPACE>'), Constant(value='<THREE-PER-EM_SPACE>'), Constant(value='<FOUR-PER-EM_SPACE>'), Constant(value='<SIX-PER-EM_SPACE>'), Constant(value='<FIGURE_SPACE>'), Constant(value='<PUNCTUATION_SPACE>'), Constant(value='<THIN_SPACE>'), Constant(value='<HAIR_SPACE>'), Constant(value='<ZERO_WIDTH_SPACE>'), Constant(value='<NNBSP>'), Constant(value='<MMSP>'), Constant(value='<IDEOGRAPHIC_SPACE>')])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ws', annotation=Name(id='str', ctx=Load())), arg(arg='min', annotation=Name(id='int', ctx=Load())), arg(arg='max', annotation=Name(id='int', ctx=Load())), arg(arg='exact', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=' \t\r\n'), Constant(value=1), Constant(value=0), Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='matchWhite', ctx=Store())], value=Name(id='ws', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_whitespace_chars', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=Name(id='c', ctx=Load()), generators=[comprehension(target=Name(id='c', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='whiteStrs', ctx=Load()), ifs=[Compare(left=Name(id='c', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='matchWhite', ctx=Load())])], is_async=0)])], keywords=[])], keywords=[keyword(arg='copy_defaults', value=Constant(value=True))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='Expected '), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Store())], value=Name(id='min', ctx=Load())), If(test=Compare(left=Name(id='max', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Store())], value=Name(id='max', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Store())], value=Name(id='_MAX_INT', ctx=Load()))]), If(test=Compare(left=Name(id='exact', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Store())], value=Name(id='exact', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Store())], value=Name(id='exact', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Attribute(value=Name(id='White', ctx=Load()), attr='whiteStrs', ctx=Load()), slice=Name(id='c', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='c', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='matchWhite', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='matchWhite', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='start', ctx=Store())], value=Name(id='loc', ctx=Load())), AugAssign(target=Name(id='loc', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Name(id='maxloc', ctx=Store())], value=BinOp(left=Name(id='start', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='maxLen', ctx=Load()))), Assign(targets=[Name(id='maxloc', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='maxloc', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])], keywords=[])), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Name(id='maxloc', ctx=Load())]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='matchWhite', ctx=Load())])]), body=[AugAssign(target=Name(id='loc', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), If(test=Compare(left=BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Name(id='start', ctx=Load())), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='minLen', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='loc', ctx=Load())), ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='PositionToken', bases=[Name(id='Token', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False))], decorator_list=[])], decorator_list=[]), ClassDef(name='GoToColumn', bases=[Name(id='PositionToken', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Token to advance to a specific column of input text; useful for\n    tabular report scraping.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='colno', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='col', ctx=Store())], value=Name(id='colno', ctx=Load()))], decorator_list=[]), FunctionDef(name='preParse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='loc', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Call(func=Name(id='col', ctx=Load()), args=[Name(id='loc', ctx=Load()), Name(id='instring', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='col', ctx=Load())]), body=[Assign(targets=[Name(id='instrlen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), body=[Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_skipIgnorables', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]))], orelse=[]), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Name(id='instrlen', ctx=Load())]), Call(func=Attribute(value=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), attr='isspace', ctx=Load()), args=[], keywords=[]), Compare(left=Call(func=Name(id='col', ctx=Load()), args=[Name(id='loc', ctx=Load()), Name(id='instring', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='col', ctx=Load())])]), body=[AugAssign(target=Name(id='loc', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[]), Return(value=Name(id='loc', ctx=Load()))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='thiscol', ctx=Store())], value=Call(func=Name(id='col', ctx=Load()), args=[Name(id='loc', ctx=Load()), Name(id='instring', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='thiscol', ctx=Load()), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='col', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Constant(value='Text not in expected column'), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='newloc', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='col', ctx=Load())), op=Sub(), right=Name(id='thiscol', ctx=Load()))), Assign(targets=[Name(id='ret', ctx=Store())], value=Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='loc', ctx=Load()), upper=Name(id='newloc', ctx=Load())), ctx=Load())), Return(value=Tuple(elts=[Name(id='newloc', ctx=Load()), Name(id='ret', ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='LineStart', bases=[Name(id='PositionToken', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Matches if current position is at the beginning of a line within\n    the parse string\n\n    Example::\n\n        test = '''\\\n        AAA this line\n        AAA and this line\n          AAA but not this one\n        B AAA and definitely not this one\n        '''\n\n        for t in (LineStart() + 'AAA' + rest_of_line).search_string(test):\n            print(t)\n\n    prints::\n\n        ['AAA', ' this line']\n        ['AAA', ' and this line']\n\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='leave_whitespace', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='orig_whiteChars', ctx=Store())], value=BinOp(left=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Attribute(value=Name(id='self', ctx=Load()), attr='whiteChars', ctx=Load()))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='whiteChars', ctx=Load()), attr='discard', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipper', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), attr='set_whitespace_chars', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='whiteChars', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=Constant(value='Expected start of line'))], decorator_list=[]), FunctionDef(name='preParse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring', annotation=Name(id='str', ctx=Load())), arg(arg='loc', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Name(id='loc', ctx=Load()))], orelse=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='skipper', ctx=Load()), attr='preParse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), If(test=Compare(left=Constant(value='\n'), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='orig_whiteChars', ctx=Load())]), body=[While(test=Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='ret', ctx=Load()), upper=BinOp(left=Name(id='ret', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load()), ops=[Eq()], comparators=[Constant(value='\n')]), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='skipper', ctx=Load()), attr='preParse', ctx=Load()), args=[Name(id='instring', ctx=Load()), BinOp(left=Name(id='ret', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='ret', ctx=Load()))])], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Call(func=Name(id='col', ctx=Load()), args=[Name(id='loc', ctx=Load()), Name(id='instring', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), List(elts=[], ctx=Load())], ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='LineEnd', bases=[Name(id='PositionToken', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Matches if current position is at the end of a line within the\n    parse string\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='whiteChars', ctx=Load()), attr='discard', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_whitespace_chars', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='whiteChars', ctx=Load())], keywords=[keyword(arg='copy_defaults', value=Constant(value=False))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=Constant(value='Expected end of line'))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])]), body=[If(test=Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[Eq()], comparators=[Constant(value='\n')]), body=[Return(value=Tuple(elts=[BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Constant(value=1)), Constant(value='\n')], ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))])], orelse=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])]), body=[Return(value=Tuple(elts=[BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Constant(value=1)), List(elts=[], ctx=Load())], ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))])])], decorator_list=[])], decorator_list=[]), ClassDef(name='StringStart', bases=[Name(id='PositionToken', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Matches if current position is at the beginning of the parse\n    string\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=Constant(value='Expected start of text'))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[NotEq()], comparators=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='preParse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Constant(value=0)], keywords=[])]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), List(elts=[], ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='StringEnd', bases=[Name(id='PositionToken', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Matches if current position is at the end of the parse string\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=Constant(value='Expected end of text'))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])]), body=[Return(value=Tuple(elts=[BinOp(left=Name(id='loc', ctx=Load()), op=Add(), right=Constant(value=1)), List(elts=[], ctx=Load())], ctx=Load()))], orelse=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[Gt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])]), body=[Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), List(elts=[], ctx=Load())], ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))])])])], decorator_list=[])], decorator_list=[]), ClassDef(name='WordStart', bases=[Name(id='PositionToken', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Matches if the current position is at the beginning of a\n    :class:`Word`, and is not preceded by any character in a given\n    set of ``word_chars`` (default= ``printables``). To emulate the\n    ``\x08`` behavior of regular expressions, use\n    ``WordStart(alphanums)``. ``WordStart`` will also match at\n    the beginning of the string being parsed, or at the beginning of\n    a line.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='word_chars', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='wordChars', annotation=Name(id='str', ctx=Load()))], kw_defaults=[Name(id='printables', ctx=Load())], defaults=[Name(id='printables', ctx=Load())]), body=[Assign(targets=[Name(id='wordChars', ctx=Store())], value=IfExp(test=Compare(left=Name(id='wordChars', ctx=Load()), ops=[Eq()], comparators=[Name(id='printables', ctx=Load())]), body=Name(id='word_chars', ctx=Load()), orelse=Name(id='wordChars', ctx=Load()))), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='wordChars', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='wordChars', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=Constant(value='Not at the start of a word'))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='wordChars', ctx=Load())]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='wordChars', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), List(elts=[], ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='WordEnd', bases=[Name(id='PositionToken', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Matches if the current position is at the end of a :class:`Word`,\n    and is not followed by any character in a given set of ``word_chars``\n    (default= ``printables``). To emulate the ``\x08`` behavior of\n    regular expressions, use ``WordEnd(alphanums)``. ``WordEnd``\n    will also match at the end of the string being parsed, or at the end\n    of a line.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='word_chars', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[arg(arg='wordChars', annotation=Name(id='str', ctx=Load()))], kw_defaults=[Name(id='printables', ctx=Load())], defaults=[Name(id='printables', ctx=Load())]), body=[Assign(targets=[Name(id='wordChars', ctx=Store())], value=IfExp(test=Compare(left=Name(id='wordChars', ctx=Load()), ops=[Eq()], comparators=[Name(id='printables', ctx=Load())]), body=Name(id='word_chars', ctx=Load()), orelse=Name(id='wordChars', ctx=Load()))), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='wordChars', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='wordChars', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=Constant(value='Not at the end of a word'))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='instrlen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='instrlen', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Name(id='instrlen', ctx=Load())])]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=Name(id='loc', ctx=Load()), ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='wordChars', ctx=Load())]), Compare(left=Subscript(value=Name(id='instring', ctx=Load()), slice=BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='wordChars', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), List(elts=[], ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='ParseExpression', bases=[Name(id='ParserElement', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Abstract subclass of ParserElement, for combining and\n    post-processing parsed tokens.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exprs', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load())), arg(arg='savelist', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='savelist', ctx=Load())], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load()), simple=0), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='exprs', ctx=Load()), Name(id='_generatorType', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='exprs', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='exprs', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='exprs', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store())], value=List(elts=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='exprs', ctx=Load())], keywords=[])], ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='exprs', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store())], value=List(elts=[Name(id='exprs', ctx=Load())], ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='exprs', ctx=Load()), Name(id='Iterable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='exprs', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='exprs', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='expr', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='expr', ctx=Store()), iter=Name(id='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='exprs', ctx=Store())], value=GeneratorExp(elt=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), orelse=Name(id='e', ctx=Load())), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Name(id='exprs', ctx=Load()), ifs=[], is_async=0)]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='exprs', ctx=Load())], keywords=[]))], orelse=[Try(body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='exprs', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store())], value=List(elts=[Name(id='exprs', ctx=Load())], ctx=Load()))])], orelse=[], finalbody=[])])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callPreparse', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='recurse', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Slice(), ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load())), FunctionDef(name='append', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_defaultName', ctx=Store())], value=Constant(value=None)), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='leave_whitespace', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='recursive', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n        Extends ``leave_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on\n           all contained expressions.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='leave_whitespace', ctx=Load()), args=[Name(id='recursive', ctx=Load())], keywords=[])), If(test=Name(id='recursive', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='leave_whitespace', ctx=Load()), args=[Name(id='recursive', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='ignore_whitespace', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='recursive', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n        Extends ``ignore_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on\n           all contained expressions.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='ignore_whitespace', ctx=Load()), args=[Name(id='recursive', ctx=Load())], keywords=[])), If(test=Name(id='recursive', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='ignore_whitespace', ctx=Load()), args=[Name(id='recursive', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='ignore', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Suppress', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='other', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='ignore', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='ignore', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='ignore', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='ignore', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], keywords=[]))], orelse=[])]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value=':('), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load())], keywords=[]), conversion=-1), Constant(value=')')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='streamline', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='streamlined', ctx=Load()), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='streamline', ctx=Load()), args=[], keywords=[])), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='streamline', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Constant(value=0), ctx=Load())), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='other', ctx=Load()), attr='parseAction', ctx=Load())), Compare(left=Attribute(value=Name(id='other', ctx=Load()), attr='resultsName', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='other', ctx=Load()), attr='debug', ctx=Load()))]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store())], value=BinOp(left=Subscript(value=Attribute(value=Name(id='other', ctx=Load()), attr='exprs', ctx=Load()), slice=Slice(), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Constant(value=1), ctx=Load())], ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_defaultName', ctx=Store())], value=Constant(value=None)), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store()), op=BitOr(), value=Attribute(value=Name(id='other', ctx=Load()), attr='mayReturnEmpty', ctx=Load())), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store()), op=BitOr(), value=Attribute(value=Name(id='other', ctx=Load()), attr='mayIndexError', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='other', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='other', ctx=Load()), attr='parseAction', ctx=Load())), Compare(left=Attribute(value=Name(id='other', ctx=Load()), attr='resultsName', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='other', ctx=Load()), attr='debug', ctx=Load()))]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store())], value=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), op=Add(), right=Subscript(value=Attribute(value=Name(id='other', ctx=Load()), attr='exprs', ctx=Load()), slice=Slice(), ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_defaultName', ctx=Store())], value=Constant(value=None)), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store()), op=BitOr(), value=Attribute(value=Name(id='other', ctx=Load()), attr='mayReturnEmpty', ctx=Load())), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store()), op=BitOr(), value=Attribute(value=Name(id='other', ctx=Load()), attr='mayIndexError', ctx=Load()))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='Expected '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='validate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='validateTrace')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='ParserElement.validate() is deprecated, and should not be used to check for left recursion'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Assign(targets=[Name(id='tmp', ctx=Store())], value=BinOp(left=Subscript(value=IfExp(test=Compare(left=Name(id='validateTrace', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='validateTrace', ctx=Load()), orelse=List(elts=[], ctx=Load())), slice=Slice(), ctx=Load()), op=Add(), right=List(elts=[Name(id='self', ctx=Load())], ctx=Load()))), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='validate', ctx=Load()), args=[Name(id='tmp', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_checkRecursion', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='ParseExpression', ctx=Load()), Name(id='ret', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='ret', ctx=Load()), attr='exprs', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='_setResultsName', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='listAllMatches')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='__diag__', ctx=Load()), attr='warn_ungrouped_named_tokens_in_collection', ctx=Load()), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_ungrouped_named_tokens_in_collection', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), body=[For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[]), Attribute(value=Name(id='e', ctx=Load()), attr='resultsName', ctx=Load()), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_ungrouped_named_tokens_in_collection', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='e', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{}: setting results name {!r} on {} expression collides with {!r} on contained expression'), attr='format', ctx=Load()), args=[Constant(value='warn_ungrouped_named_tokens_in_collection'), Name(id='name', ctx=Load()), Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), Attribute(value=Name(id='e', ctx=Load()), attr='resultsName', ctx=Load())], keywords=[])], keywords=[keyword(arg='stacklevel', value=Constant(value=3))]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='_setResultsName', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='listAllMatches', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='leaveWhitespace', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='leave_whitespace', ctx=Load())], keywords=[])]), FunctionDef(name='ignoreWhitespace', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='ignore_whitespace', ctx=Load())], keywords=[])])], decorator_list=[]), ClassDef(name='And', bases=[Name(id='ParseExpression', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Requires all given :class:`ParseExpression` s to be found in the given order.\n    Expressions may be separated by whitespace.\n    May be constructed using the ``\'+\'`` operator.\n    May also be constructed using the ``\'-\'`` operator, which will\n    suppress backtracking.\n\n    Example::\n\n        integer = Word(nums)\n        name_expr = Word(alphas)[1, ...]\n\n        expr = And([integer("id"), name_expr("name"), integer("age")])\n        # more easily written as:\n        expr = integer("id") + name_expr("name") + integer("age")\n    ')), ClassDef(name='_ErrorStop', bases=[Name(id='Empty', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='leave_whitespace', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='-'))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exprs_arg', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load())), arg(arg='savelist', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[AnnAssign(target=Name(id='exprs', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load()), value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='exprs_arg', ctx=Load())], keywords=[]), simple=1), If(test=BoolOp(op=And(), values=[Name(id='exprs', ctx=Load()), Compare(left=Name(id='Ellipsis', ctx=Load()), ops=[In()], comparators=[Name(id='exprs', ctx=Load())])]), body=[Assign(targets=[Name(id='tmp', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='expr', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='exprs', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='expr', ctx=Load()), ops=[Is()], comparators=[Name(id='Ellipsis', ctx=Load())]), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='exprs', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))]), body=[AnnAssign(target=Name(id='skipto_arg', ctx=Store()), annotation=Name(id='ParserElement', ctx=Load()), value=Subscript(value=Attribute(value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='ParseExpression', ctx=Load()), BinOp(left=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), op=Add(), right=Subscript(value=Name(id='exprs', ctx=Load()), slice=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Load()))], keywords=[]), attr='exprs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), simple=1), Expr(value=Call(func=Attribute(value=Name(id='tmp', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Call(func=Name(id='SkipTo', ctx=Load()), args=[Name(id='skipto_arg', ctx=Load())], keywords=[]), args=[Constant(value='_skipped*')], keywords=[])], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='Exception', ctx=Load()), args=[Constant(value='cannot construct And with sequence ending in ...')], keywords=[]))])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='tmp', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Subscript(value=Name(id='exprs', ctx=Load()), slice=Slice(), ctx=Store())], value=Name(id='tmp', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='exprs', ctx=Load()), Name(id='savelist', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='mayReturnEmpty', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='White', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_whitespace_chars', ctx=Load()), args=[Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='whiteChars', ctx=Load())], keywords=[keyword(arg='copy_defaults', value=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='copyDefaultWhiteChars', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='skipWhitespace', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=False))])], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callPreparse', ctx=Store())], value=Constant(value=True))], decorator_list=[]), FunctionDef(name='streamline', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='ParseExpression', ctx=Load())], keywords=[]), Attribute(value=Name(id='e', ctx=Load()), attr='exprs', ctx=Load()), Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='e', ctx=Load()), attr='exprs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='_PendingSkip', ctx=Load())], keywords=[])]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='deleted_expr_marker', ctx=Store())], value=Call(func=Name(id='NoMatch', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='e', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='e', ctx=Load()), ops=[Is()], comparators=[Name(id='deleted_expr_marker', ctx=Load())]), body=[Continue()], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='ParseExpression', ctx=Load())], keywords=[]), Attribute(value=Name(id='e', ctx=Load()), attr='exprs', ctx=Load()), Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='e', ctx=Load()), attr='exprs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='_PendingSkip', ctx=Load())], keywords=[])]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='e', ctx=Load()), attr='exprs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Store())], value=BinOp(left=Subscript(value=Attribute(value=Name(id='e', ctx=Load()), attr='exprs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), op=Add(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Load()))), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Store())], value=Name(id='deleted_expr_marker', ctx=Load()))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Store())], value=ListComp(elt=Name(id='e', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[Compare(left=Name(id='e', ctx=Load()), ops=[IsNot()], comparators=[Name(id='deleted_expr_marker', ctx=Load())])], is_async=0)]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='streamline', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Name(id='prev', ctx=Store()), annotation=Name(id='ParserElement', ctx=Load()), simple=1), AnnAssign(target=Name(id='cur', ctx=Store()), annotation=Name(id='ParserElement', ctx=Load()), simple=1), For(target=Tuple(elts=[Name(id='prev', ctx=Store()), Name(id='cur', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='seen', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), While(test=Constant(value=True), body=[If(test=Compare(left=Call(func=Name(id='id', ctx=Load()), args=[Name(id='cur', ctx=Load())], keywords=[]), ops=[In()], comparators=[Name(id='seen', ctx=Load())]), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Call(func=Name(id='id', ctx=Load()), args=[Name(id='cur', ctx=Load())], keywords=[])], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='cur', ctx=Load()), Name(id='IndentedBlock', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='prev', ctx=Load()), attr='add_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t'), arg(arg='cur_')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='cur', ctx=Load())]), body=Call(func=Name(id='setattr', ctx=Load()), args=[Name(id='cur_', ctx=Load()), Constant(value='parent_anchor'), Call(func=Name(id='col', ctx=Load()), args=[Name(id='l', ctx=Load()), Name(id='s', ctx=Load())], keywords=[])], keywords=[]))], keywords=[])), Break()], orelse=[]), Assign(targets=[Name(id='subs', ctx=Store())], value=Call(func=Attribute(value=Name(id='cur', ctx=Load()), attr='recurse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='next_first', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Name(id='subs', ctx=Load())], keywords=[]), Constant(value=None)], keywords=[])), If(test=Compare(left=Name(id='next_first', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Break()], orelse=[]), Assign(targets=[Name(id='cur', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='ParserElement', ctx=Load()), Name(id='next_first', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='mayReturnEmpty', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='resultlist', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[keyword(arg='callPreParse', value=Constant(value=False))])), Assign(targets=[Name(id='errorStop', ctx=Store())], value=Constant(value=False)), For(target=Name(id='e', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='type', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), ops=[Is()], comparators=[Attribute(value=Name(id='And', ctx=Load()), attr='_ErrorStop', ctx=Load())]), body=[Assign(targets=[Name(id='errorStop', ctx=Store())], value=Constant(value=True)), Continue()], orelse=[]), If(test=Name(id='errorStop', ctx=Load()), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='exprtokens', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseSyntaxException', ctx=Load()), body=[Raise()]), ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), name='pe', body=[Assign(targets=[Attribute(value=Name(id='pe', ctx=Load()), attr='__traceback__', ctx=Store())], value=Constant(value=None)), Raise(exc=Call(func=Attribute(value=Name(id='ParseSyntaxException', ctx=Load()), attr='_from_exception', ctx=Load()), args=[Name(id='pe', ctx=Load())], keywords=[]))]), ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ParseSyntaxException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], orelse=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='exprtokens', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))]), AugAssign(target=Name(id='resultlist', ctx=Store()), op=Add(), value=Name(id='exprtokens', ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='resultlist', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='__iadd__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_checkRecursion', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parseElementList')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='subRecCheckList', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='parseElementList', ctx=Load()), slice=Slice(), ctx=Load()), op=Add(), right=List(elts=[Name(id='self', ctx=Load())], ctx=Load()))), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='_checkRecursion', ctx=Load()), args=[Name(id='subRecCheckList', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='e', ctx=Load()), attr='mayReturnEmpty', ctx=Load())), body=[Break()], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='inner', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), While(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='inner', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), Compare(left=Subscript(value=Name(id='inner', ctx=Load()), slice=Slice(lower=Constant(value=0), step=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='inner', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))), ctx=Load()), ops=[Eq()], comparators=[Constant(value='{}')])]), body=[Assign(targets=[Name(id='inner', ctx=Store())], value=Subscript(value=Name(id='inner', ctx=Load()), slice=Slice(lower=Constant(value=1), upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], orelse=[]), Return(value=BinOp(left=BinOp(left=Constant(value='{'), op=Add(), right=Name(id='inner', ctx=Load())), op=Add(), right=Constant(value='}')))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='Or', bases=[Name(id='ParseExpression', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Requires that at least one :class:`ParseExpression` is found. If\n    two expressions match, the expression that matches the longest\n    string will be used. May be constructed using the ``\'^\'``\n    operator.\n\n    Example::\n\n        # construct Or using \'^\' operator\n\n        number = Word(nums) ^ Combine(Word(nums) + \'.\' + Word(nums))\n        print(number.search_string("123 3.1416 789"))\n\n    prints::\n\n        [[\'123\'], [\'3.1416\'], [\'789\']]\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exprs', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load())), arg(arg='savelist', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='exprs', ctx=Load()), Name(id='savelist', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='mayReturnEmpty', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='skipWhitespace', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True))])], decorator_list=[]), FunctionDef(name='streamline', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='streamline', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='mayReturnEmpty', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='saveAsList', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Attribute(value=Name(id='e', ctx=Load()), attr='skipWhitespace', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='White', ctx=Load())], keywords=[]))]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Constant(value=False))]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='maxExcLoc', ctx=Store())], value=UnaryOp(op=USub(), operand=Constant(value=1))), Assign(targets=[Name(id='maxException', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='matches', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='fatals', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='callPreparse', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='loc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='preParse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='loc2', ctx=Store())], value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='try_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[keyword(arg='raise_fatal', value=Constant(value=True))]))], handlers=[ExceptHandler(type=Name(id='ParseFatalException', ctx=Load()), name='pfe', body=[Assign(targets=[Attribute(value=Name(id='pfe', ctx=Load()), attr='__traceback__', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='pfe', ctx=Load()), attr='parser_element', ctx=Store())], value=Name(id='e', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='fatals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='pfe', ctx=Load())], keywords=[])), Assign(targets=[Name(id='maxException', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='maxExcLoc', ctx=Store())], value=UnaryOp(op=USub(), operand=Constant(value=1)))]), ExceptHandler(type=Name(id='ParseException', ctx=Load()), name='err', body=[If(test=UnaryOp(op=Not(), operand=Name(id='fatals', ctx=Load())), body=[Assign(targets=[Attribute(value=Name(id='err', ctx=Load()), attr='__traceback__', ctx=Store())], value=Constant(value=None)), If(test=Compare(left=Attribute(value=Name(id='err', ctx=Load()), attr='loc', ctx=Load()), ops=[Gt()], comparators=[Name(id='maxExcLoc', ctx=Load())]), body=[Assign(targets=[Name(id='maxException', ctx=Store())], value=Name(id='err', ctx=Load())), Assign(targets=[Name(id='maxExcLoc', ctx=Store())], value=Attribute(value=Name(id='err', ctx=Load()), attr='loc', ctx=Load()))], orelse=[])], orelse=[])]), ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='maxExcLoc', ctx=Load())]), body=[Assign(targets=[Name(id='maxException', ctx=Store())], value=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[]), Attribute(value=Name(id='e', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Name(id='maxExcLoc', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[]))], orelse=[])])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='matches', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='loc2', ctx=Load()), Name(id='e', ctx=Load())], ctx=Load())], keywords=[]))], finalbody=[])], orelse=[]), If(test=Name(id='matches', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='matches', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Call(func=Name(id='itemgetter', ctx=Load()), args=[Constant(value=0)], keywords=[])), keyword(arg='reverse', value=Constant(value=True))])), If(test=UnaryOp(op=Not(), operand=Name(id='doActions', ctx=Load())), body=[Assign(targets=[Name(id='best_expr', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='matches', ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value=1), ctx=Load())), Return(value=Call(func=Attribute(value=Name(id='best_expr', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='longest', ctx=Store())], value=Tuple(elts=[UnaryOp(op=USub(), operand=Constant(value=1)), Constant(value=None)], ctx=Load())), For(target=Tuple(elts=[Name(id='loc1', ctx=Store()), Name(id='expr1', ctx=Store())], ctx=Store()), iter=Name(id='matches', ctx=Load()), body=[If(test=Compare(left=Name(id='loc1', ctx=Load()), ops=[LtE()], comparators=[Subscript(value=Name(id='longest', ctx=Load()), slice=Constant(value=0), ctx=Load())]), body=[Return(value=Name(id='longest', ctx=Load()))], orelse=[]), Try(body=[Assign(targets=[Tuple(elts=[Name(id='loc2', ctx=Store()), Name(id='toks', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='expr1', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseException', ctx=Load()), name='err', body=[Assign(targets=[Attribute(value=Name(id='err', ctx=Load()), attr='__traceback__', ctx=Store())], value=Constant(value=None)), If(test=Compare(left=Attribute(value=Name(id='err', ctx=Load()), attr='loc', ctx=Load()), ops=[Gt()], comparators=[Name(id='maxExcLoc', ctx=Load())]), body=[Assign(targets=[Name(id='maxException', ctx=Store())], value=Name(id='err', ctx=Load())), Assign(targets=[Name(id='maxExcLoc', ctx=Store())], value=Attribute(value=Name(id='err', ctx=Load()), attr='loc', ctx=Load()))], orelse=[])])], orelse=[If(test=Compare(left=Name(id='loc2', ctx=Load()), ops=[GtE()], comparators=[Name(id='loc1', ctx=Load())]), body=[Return(value=Tuple(elts=[Name(id='loc2', ctx=Load()), Name(id='toks', ctx=Load())], ctx=Load()))], orelse=[If(test=Compare(left=Name(id='loc2', ctx=Load()), ops=[Gt()], comparators=[Subscript(value=Name(id='longest', ctx=Load()), slice=Constant(value=0), ctx=Load())]), body=[Assign(targets=[Name(id='longest', ctx=Store())], value=Tuple(elts=[Name(id='loc2', ctx=Load()), Name(id='toks', ctx=Load())], ctx=Load()))], orelse=[])])], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='longest', ctx=Load()), ops=[NotEq()], comparators=[Tuple(elts=[UnaryOp(op=USub(), operand=Constant(value=1)), Constant(value=None)], ctx=Load())]), body=[Return(value=Name(id='longest', ctx=Load()))], orelse=[])], orelse=[]), If(test=Name(id='fatals', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='fatals', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='fatals', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='e')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=UnaryOp(op=USub(), operand=Attribute(value=Name(id='e', ctx=Load()), attr='loc', ctx=Load()))))])), If(test=Compare(left=Attribute(value=Subscript(value=Name(id='fatals', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='loc', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Subscript(value=Name(id='fatals', ctx=Load()), slice=Constant(value=1), ctx=Load()), attr='loc', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='fatals', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='e')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[UnaryOp(op=USub(), operand=Attribute(value=Name(id='e', ctx=Load()), attr='loc', ctx=Load())), UnaryOp(op=USub(), operand=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='e', ctx=Load()), attr='parser_element', ctx=Load())], keywords=[])], keywords=[]))], ctx=Load())))]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='max_fatal', ctx=Store())], value=Subscript(value=Name(id='fatals', ctx=Load()), slice=Constant(value=0), ctx=Load())), Raise(exc=Name(id='max_fatal', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='maxException', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='maxExcLoc', ctx=Load()), ops=[Eq()], comparators=[Name(id='loc', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='maxException', ctx=Load()), attr='msg', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()))], orelse=[]), Raise(exc=Name(id='maxException', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Constant(value='no defined alternatives to match'), Name(id='self', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='__ixor__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=BinOp(left=Constant(value='{'), op=Add(), right=Call(func=Attribute(value=Constant(value=' ^ '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), op=Add(), right=Constant(value='}')))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_setResultsName', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='listAllMatches')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='__diag__', ctx=Load()), attr='warn_multiple_tokens_in_named_alternation', ctx=Load()), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_multiple_tokens_in_named_alternation', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), body=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='And', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_multiple_tokens_in_named_alternation', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='e', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{}: setting results name {!r} on {} expression will return a list of all parsed tokens in an And alternative, in prior versions only the first token was returned; enclose contained argument in Group'), attr='format', ctx=Load()), args=[Constant(value='warn_multiple_tokens_in_named_alternation'), Name(id='name', ctx=Load()), Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load())], keywords=[])], keywords=[keyword(arg='stacklevel', value=Constant(value=3))]))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='_setResultsName', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='listAllMatches', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='MatchFirst', bases=[Name(id='ParseExpression', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Requires that at least one :class:`ParseExpression` is found. If\n    more than one expression matches, the first one listed is the one that will\n    match. May be constructed using the ``\'|\'`` operator.\n\n    Example::\n\n        # construct MatchFirst using \'|\' operator\n\n        # watch the order of expressions to match\n        number = Word(nums) | Combine(Word(nums) + \'.\' + Word(nums))\n        print(number.search_string("123 3.1416 789")) #  Fail! -> [[\'123\'], [\'3\'], [\'1416\'], [\'789\']]\n\n        # put more selective expression first\n        number = Combine(Word(nums) + \'.\' + Word(nums)) | Word(nums)\n        print(number.search_string("123 3.1416 789")) #  Better -> [[\'123\'], [\'3.1416\'], [\'789\']]\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exprs', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load())), arg(arg='savelist', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='exprs', ctx=Load()), Name(id='savelist', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='mayReturnEmpty', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='skipWhitespace', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True))])], decorator_list=[]), FunctionDef(name='streamline', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='streamlined', ctx=Load()), body=[Return(value=Name(id='self', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='streamline', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='saveAsList', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='mayReturnEmpty', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Attribute(value=Name(id='e', ctx=Load()), attr='skipWhitespace', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='White', ctx=Load())], keywords=[]))]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True))]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='maxExcLoc', ctx=Store())], value=UnaryOp(op=USub(), operand=Constant(value=1))), Assign(targets=[Name(id='maxException', ctx=Store())], value=Constant(value=None)), For(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Try(body=[Return(value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseFatalException', ctx=Load()), name='pfe', body=[Assign(targets=[Attribute(value=Name(id='pfe', ctx=Load()), attr='__traceback__', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='pfe', ctx=Load()), attr='parser_element', ctx=Store())], value=Name(id='e', ctx=Load())), Raise()]), ExceptHandler(type=Name(id='ParseException', ctx=Load()), name='err', body=[If(test=Compare(left=Attribute(value=Name(id='err', ctx=Load()), attr='loc', ctx=Load()), ops=[Gt()], comparators=[Name(id='maxExcLoc', ctx=Load())]), body=[Assign(targets=[Name(id='maxException', ctx=Store())], value=Name(id='err', ctx=Load())), Assign(targets=[Name(id='maxExcLoc', ctx=Store())], value=Attribute(value=Name(id='err', ctx=Load()), attr='loc', ctx=Load()))], orelse=[])]), ExceptHandler(type=Name(id='IndexError', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='maxExcLoc', ctx=Load())]), body=[Assign(targets=[Name(id='maxException', ctx=Store())], value=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[]), Attribute(value=Name(id='e', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[])), Assign(targets=[Name(id='maxExcLoc', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[]))], orelse=[])])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='maxException', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='maxExcLoc', ctx=Load()), ops=[Eq()], comparators=[Name(id='loc', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='maxException', ctx=Load()), attr='msg', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()))], orelse=[]), Raise(exc=Name(id='maxException', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Constant(value='no defined alternatives to match'), Name(id='self', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='__ior__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=BinOp(left=Constant(value='{'), op=Add(), right=Call(func=Attribute(value=Constant(value=' | '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), op=Add(), right=Constant(value='}')))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_setResultsName', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='listAllMatches')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='__diag__', ctx=Load()), attr='warn_multiple_tokens_in_named_alternation', ctx=Load()), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_multiple_tokens_in_named_alternation', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), body=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='And', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_multiple_tokens_in_named_alternation', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='e', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{}: setting results name {!r} on {} expression will return a list of all parsed tokens in an And alternative, in prior versions only the first token was returned; enclose contained argument in Group'), attr='format', ctx=Load()), args=[Constant(value='warn_multiple_tokens_in_named_alternation'), Name(id='name', ctx=Load()), Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load())], keywords=[])], keywords=[keyword(arg='stacklevel', value=Constant(value=3))]))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='_setResultsName', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='listAllMatches', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='Each', bases=[Name(id='ParseExpression', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Requires all given :class:`ParseExpression` s to be found, but in\n    any order. Expressions may be separated by whitespace.\n\n    May be constructed using the ``\'&\'`` operator.\n\n    Example::\n\n        color = one_of("RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN")\n        shape_type = one_of("SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON")\n        integer = Word(nums)\n        shape_attr = "shape:" + shape_type("shape")\n        posn_attr = "posn:" + Group(integer("x") + \',\' + integer("y"))("posn")\n        color_attr = "color:" + color("color")\n        size_attr = "size:" + integer("size")\n\n        # use Each (using operator \'&\') to accept attributes in any order\n        # (shape and posn are required, color and size are optional)\n        shape_spec = shape_attr & posn_attr & Opt(color_attr) & Opt(size_attr)\n\n        shape_spec.run_tests(\'\'\'\n            shape: SQUARE color: BLACK posn: 100, 120\n            shape: CIRCLE size: 50 color: BLUE posn: 50,80\n            color:GREEN size:20 shape:TRIANGLE posn:20,40\n            \'\'\'\n            )\n\n    prints::\n\n        shape: SQUARE color: BLACK posn: 100, 120\n        [\'shape:\', \'SQUARE\', \'color:\', \'BLACK\', \'posn:\', [\'100\', \',\', \'120\']]\n        - color: BLACK\n        - posn: [\'100\', \',\', \'120\']\n          - x: 100\n          - y: 120\n        - shape: SQUARE\n\n\n        shape: CIRCLE size: 50 color: BLUE posn: 50,80\n        [\'shape:\', \'CIRCLE\', \'size:\', \'50\', \'color:\', \'BLUE\', \'posn:\', [\'50\', \',\', \'80\']]\n        - color: BLUE\n        - posn: [\'50\', \',\', \'80\']\n          - x: 50\n          - y: 80\n        - shape: CIRCLE\n        - size: 50\n\n\n        color: GREEN size: 20 shape: TRIANGLE posn: 20,40\n        [\'color:\', \'GREEN\', \'size:\', \'20\', \'shape:\', \'TRIANGLE\', \'posn:\', [\'20\', \',\', \'40\']]\n        - color: GREEN\n        - posn: [\'20\', \',\', \'40\']\n          - x: 20\n          - y: 40\n        - shape: TRIANGLE\n        - size: 20\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exprs', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load())), arg(arg='savelist', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='exprs', ctx=Load()), Name(id='savelist', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='mayReturnEmpty', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initExprGroups', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Constant(value=True))], decorator_list=[]), FunctionDef(name='__iand__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='streamline', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='streamline', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='mayReturnEmpty', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True))]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='initExprGroups', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='opt1map', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[GeneratorExp(elt=Tuple(elts=[Call(func=Name(id='id', ctx=Load()), args=[Attribute(value=Name(id='e', ctx=Load()), attr='expr', ctx=Load())], keywords=[]), Name(id='e', ctx=Load())], ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='Opt', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])), Assign(targets=[Name(id='opt1', ctx=Store())], value=ListComp(elt=Attribute(value=Name(id='e', ctx=Load()), attr='expr', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='Opt', ctx=Load())], keywords=[])], is_async=0)])), Assign(targets=[Name(id='opt2', ctx=Store())], value=ListComp(elt=Name(id='e', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[BoolOp(op=And(), values=[Attribute(value=Name(id='e', ctx=Load()), attr='mayReturnEmpty', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Tuple(elts=[Name(id='Opt', ctx=Load()), Name(id='Regex', ctx=Load()), Name(id='ZeroOrMore', ctx=Load())], ctx=Load())], keywords=[]))])], is_async=0)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optionals', ctx=Store())], value=BinOp(left=Name(id='opt1', ctx=Load()), op=Add(), right=Name(id='opt2', ctx=Load()))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='multioptionals', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Attribute(value=Name(id='e', ctx=Load()), attr='expr', ctx=Load()), attr='set_results_name', ctx=Load()), args=[Attribute(value=Name(id='e', ctx=Load()), attr='resultsName', ctx=Load())], keywords=[keyword(arg='list_all_matches', value=Constant(value=True))]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='_MultipleMatch', ctx=Load())], keywords=[])], is_async=0)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='multirequired', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Attribute(value=Name(id='e', ctx=Load()), attr='expr', ctx=Load()), attr='set_results_name', ctx=Load()), args=[Attribute(value=Name(id='e', ctx=Load()), attr='resultsName', ctx=Load())], keywords=[keyword(arg='list_all_matches', value=Constant(value=True))]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='OneOrMore', ctx=Load())], keywords=[])], is_async=0)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='required', ctx=Store())], value=ListComp(elt=Name(id='e', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Tuple(elts=[Name(id='Opt', ctx=Load()), Name(id='ZeroOrMore', ctx=Load()), Name(id='OneOrMore', ctx=Load())], ctx=Load())], keywords=[]))], is_async=0)])), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='required', ctx=Store()), op=Add(), value=Attribute(value=Name(id='self', ctx=Load()), attr='multirequired', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initExprGroups', ctx=Store())], value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='tmpLoc', ctx=Store())], value=Name(id='loc', ctx=Load())), Assign(targets=[Name(id='tmpReqd', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='required', ctx=Load()), slice=Slice(), ctx=Load())), Assign(targets=[Name(id='tmpOpt', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='optionals', ctx=Load()), slice=Slice(), ctx=Load())), Assign(targets=[Name(id='multis', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='multioptionals', ctx=Load()), slice=Slice(), ctx=Load())), Assign(targets=[Name(id='matchOrder', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='keepMatching', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='failed', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='fatals', ctx=Store())], value=List(elts=[], ctx=Load())), While(test=Name(id='keepMatching', ctx=Load()), body=[Assign(targets=[Name(id='tmpExprs', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='tmpReqd', ctx=Load()), op=Add(), right=Name(id='tmpOpt', ctx=Load())), op=Add(), right=Name(id='multis', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='failed', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='fatals', ctx=Load()), attr='clear', ctx=Load()), args=[], keywords=[])), For(target=Name(id='e', ctx=Store()), iter=Name(id='tmpExprs', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='tmpLoc', ctx=Store())], value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='try_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tmpLoc', ctx=Load())], keywords=[keyword(arg='raise_fatal', value=Constant(value=True))]))], handlers=[ExceptHandler(type=Name(id='ParseFatalException', ctx=Load()), name='pfe', body=[Assign(targets=[Attribute(value=Name(id='pfe', ctx=Load()), attr='__traceback__', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='pfe', ctx=Load()), attr='parser_element', ctx=Store())], value=Name(id='e', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='fatals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='pfe', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='failed', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))]), ExceptHandler(type=Name(id='ParseException', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='failed', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='matchOrder', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='opt1map', ctx=Load()), attr='get', ctx=Load()), args=[Call(func=Name(id='id', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), Name(id='e', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='e', ctx=Load()), ops=[In()], comparators=[Name(id='tmpReqd', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='tmpReqd', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='e', ctx=Load()), ops=[In()], comparators=[Name(id='tmpOpt', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='tmpOpt', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))], orelse=[])])], finalbody=[])], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='failed', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='tmpExprs', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='keepMatching', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[]), If(test=Name(id='fatals', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='fatals', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='fatals', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='e')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=UnaryOp(op=USub(), operand=Attribute(value=Name(id='e', ctx=Load()), attr='loc', ctx=Load()))))])), If(test=Compare(left=Attribute(value=Subscript(value=Name(id='fatals', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='loc', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Subscript(value=Name(id='fatals', ctx=Load()), slice=Constant(value=1), ctx=Load()), attr='loc', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='fatals', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='e')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[UnaryOp(op=USub(), operand=Attribute(value=Name(id='e', ctx=Load()), attr='loc', ctx=Load())), UnaryOp(op=USub(), operand=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='e', ctx=Load()), attr='parser_element', ctx=Load())], keywords=[])], keywords=[]))], ctx=Load())))]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='max_fatal', ctx=Store())], value=Subscript(value=Name(id='fatals', ctx=Load()), slice=Constant(value=0), ctx=Load())), Raise(exc=Name(id='max_fatal', ctx=Load()))], orelse=[]), If(test=Name(id='tmpReqd', ctx=Load()), body=[Assign(targets=[Name(id='missing', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Name(id='tmpReqd', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), JoinedStr(values=[Constant(value='Missing one or more required elements ('), FormattedValue(value=Name(id='missing', ctx=Load()), conversion=-1), Constant(value=')')])], keywords=[]))], orelse=[]), AugAssign(target=Name(id='matchOrder', ctx=Store()), op=Add(), value=ListComp(elt=Name(id='e', ctx=Load()), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='Opt', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='e', ctx=Load()), attr='expr', ctx=Load()), ops=[In()], comparators=[Name(id='tmpOpt', ctx=Load())])])], is_async=0)])), Assign(targets=[Name(id='total_results', ctx=Store())], value=Call(func=Name(id='ParseResults', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[])), For(target=Name(id='e', ctx=Store()), iter=Name(id='matchOrder', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[])), AugAssign(target=Name(id='total_results', ctx=Store()), op=Add(), value=Name(id='results', ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='total_results', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=BinOp(left=Constant(value='{'), op=Add(), right=Call(func=Attribute(value=Constant(value=' & '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='exprs', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), op=Add(), right=Constant(value='}')))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='ParseElementEnhance', bases=[Name(id='ParserElement', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Abstract subclass of :class:`ParserElement`, for combining and\n    post-processing parsed tokens.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='savelist', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='savelist', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='expr', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='expr_str', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='expr', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), Name(id='Token', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='expr_str', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='issubclass', ctx=Load()), args=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Name(id='Literal', ctx=Load()), args=[Name(id='expr_str', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Call(func=Name(id='Literal', ctx=Load()), args=[Name(id='expr_str', ctx=Load())], keywords=[])], keywords=[]))])])], orelse=[]), Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='ParserElement', ctx=Load()), Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Store())], value=Name(id='expr', ctx=Load())), If(test=Compare(left=Name(id='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Attribute(value=Name(id='expr', ctx=Load()), attr='mayIndexError', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Attribute(value=Name(id='expr', ctx=Load()), attr='mayReturnEmpty', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_whitespace_chars', ctx=Load()), args=[Attribute(value=Name(id='expr', ctx=Load()), attr='whiteChars', ctx=Load())], keywords=[keyword(arg='copy_defaults', value=Attribute(value=Name(id='expr', ctx=Load()), attr='copyDefaultWhiteChars', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Attribute(value=Name(id='expr', ctx=Load()), attr='skipWhitespace', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Attribute(value=Name(id='expr', ctx=Load()), attr='saveAsList', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callPreparse', ctx=Store())], value=Attribute(value=Name(id='expr', ctx=Load()), attr='callPreparse', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='expr', ctx=Load()), attr='ignoreExprs', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='recurse', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=List(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], ctx=Load()), orelse=List(elts=[], ctx=Load())))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Try(body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[keyword(arg='callPreParse', value=Constant(value=False))]))], handlers=[ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), name='pbe', body=[Assign(targets=[Attribute(value=Name(id='pbe', ctx=Load()), attr='msg', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load())), Raise()])], orelse=[], finalbody=[])], orelse=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Constant(value='No expression defined'), Name(id='self', ctx=Load())], keywords=[]))])], decorator_list=[]), FunctionDef(name='leave_whitespace', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='recursive', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='leave_whitespace', ctx=Load()), args=[Name(id='recursive', ctx=Load())], keywords=[])), If(test=Name(id='recursive', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='leave_whitespace', ctx=Load()), args=[Name(id='recursive', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='ignore_whitespace', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='recursive', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='ignore_whitespace', ctx=Load()), args=[Name(id='recursive', ctx=Load())], keywords=[])), If(test=Name(id='recursive', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='ignore_whitespace', ctx=Load()), args=[Name(id='recursive', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='ignore', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='Suppress', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='other', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='ignore', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='ignore', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='ignore', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='ignore', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())], keywords=[]))], orelse=[])]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='streamline', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='streamline', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='streamline', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='_checkRecursion', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parseElementList')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='self', ctx=Load()), ops=[In()], comparators=[Name(id='parseElementList', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='RecursiveGrammarException', ctx=Load()), args=[BinOp(left=Name(id='parseElementList', ctx=Load()), op=Add(), right=List(elts=[Name(id='self', ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='subRecCheckList', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='parseElementList', ctx=Load()), slice=Slice(), ctx=Load()), op=Add(), right=List(elts=[Name(id='self', ctx=Load())], ctx=Load()))), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='_checkRecursion', ctx=Load()), args=[Name(id='subRecCheckList', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='validate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='validateTrace')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='ParserElement.validate() is deprecated, and should not be used to check for left recursion'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), If(test=Compare(left=Name(id='validateTrace', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='validateTrace', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='tmp', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='validateTrace', ctx=Load()), slice=Slice(), ctx=Load()), op=Add(), right=List(elts=[Name(id='self', ctx=Load())], ctx=Load()))), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='validate', ctx=Load()), args=[Name(id='tmp', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_checkRecursion', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value=':('), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], keywords=[]), conversion=-1), Constant(value=')')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='leaveWhitespace', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='leave_whitespace', ctx=Load())], keywords=[])]), FunctionDef(name='ignoreWhitespace', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='ignore_whitespace', ctx=Load())], keywords=[])])], decorator_list=[]), ClassDef(name='IndentedBlock', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Expression to match one or more expressions at a given indentation level.\n    Useful for parsing text where structure is implied by indentation (like Python source code).\n    ')), ClassDef(name='_Indent', bases=[Name(id='Empty', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ref_col', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=JoinedStr(values=[Constant(value='expected indent at column '), FormattedValue(value=Name(id='ref_col', ctx=Load()), conversion=-1)])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add_condition', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Call(func=Name(id='col', ctx=Load()), args=[Name(id='l', ctx=Load()), Name(id='s', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Name(id='ref_col', ctx=Load())]))], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='_IndentGreater', bases=[Name(id='Empty', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ref_col', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=JoinedStr(values=[Constant(value='expected indent at column greater than '), FormattedValue(value=Name(id='ref_col', ctx=Load()), conversion=-1)])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='add_condition', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Call(func=Name(id='col', ctx=Load()), args=[Name(id='l', ctx=Load()), Name(id='s', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='ref_col', ctx=Load())]))], keywords=[]))], decorator_list=[])], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load()))], kwonlyargs=[arg(arg='recursive', annotation=Name(id='bool', ctx=Load())), arg(arg='grouped', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False), Constant(value=True)], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[keyword(arg='savelist', value=Constant(value=True))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_recursive', ctx=Store())], value=Name(id='recursive', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_grouped', ctx=Store())], value=Name(id='grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parent_anchor', ctx=Store())], value=Constant(value=1))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='anchor_loc', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), attr='preParse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='try_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='anchor_loc', ctx=Load())], keywords=[keyword(arg='do_actions', value=Name(id='doActions', ctx=Load()))])), Assign(targets=[Name(id='indent_col', ctx=Store())], value=Call(func=Name(id='col', ctx=Load()), args=[Name(id='anchor_loc', ctx=Load()), Name(id='instring', ctx=Load())], keywords=[])), Assign(targets=[Name(id='peer_detect_expr', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_Indent', ctx=Load()), args=[Name(id='indent_col', ctx=Load())], keywords=[])), Assign(targets=[Name(id='inner_expr', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), op=Add(), right=Name(id='peer_detect_expr', ctx=Load())), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()))), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_recursive', ctx=Load()), body=[Assign(targets=[Name(id='sub_indent', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_IndentGreater', ctx=Load()), args=[Name(id='indent_col', ctx=Load())], keywords=[])), Assign(targets=[Name(id='nested_block', ctx=Store())], value=Call(func=Name(id='IndentedBlock', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], keywords=[keyword(arg='recursive', value=Attribute(value=Name(id='self', ctx=Load()), attr='_recursive', ctx=Load())), keyword(arg='grouped', value=Attribute(value=Name(id='self', ctx=Load()), attr='_grouped', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='nested_block', ctx=Load()), attr='set_debug', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='debug', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='nested_block', ctx=Load()), attr='parent_anchor', ctx=Store())], value=Name(id='indent_col', ctx=Load())), AugAssign(target=Name(id='inner_expr', ctx=Store()), op=Add(), value=Call(func=Name(id='Opt', ctx=Load()), args=[BinOp(left=Name(id='sub_indent', ctx=Load()), op=Add(), right=Name(id='nested_block', ctx=Load()))], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='inner_expr', ctx=Load()), attr='set_name', ctx=Load()), args=[JoinedStr(values=[Constant(value='inner '), FormattedValue(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='hex', ctx=Load()), args=[Call(func=Name(id='id', ctx=Load()), args=[Name(id='inner_expr', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Constant(value=4))), ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), conversion=-1), Constant(value='@'), FormattedValue(value=Name(id='indent_col', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='block', ctx=Store())], value=Call(func=Name(id='OneOrMore', ctx=Load()), args=[Name(id='inner_expr', ctx=Load())], keywords=[])), Assign(targets=[Name(id='trailing_undent', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_Indent', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='parent_anchor', ctx=Load())], keywords=[]), op=BitOr(), right=Call(func=Name(id='StringEnd', ctx=Load()), args=[], keywords=[]))), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_grouped', ctx=Load()), body=[Assign(targets=[Name(id='wrapper', ctx=Store())], value=Name(id='Group', ctx=Load()))], orelse=[Assign(targets=[Name(id='wrapper', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='expr')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='expr', ctx=Load())))]), Return(value=Call(func=Attribute(value=BinOp(left=Call(func=Name(id='wrapper', ctx=Load()), args=[Name(id='block', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='Optional', ctx=Load()), args=[Name(id='trailing_undent', ctx=Load())], keywords=[])), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='anchor_loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='AtStringStart', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Matches if expression matches at the beginning of the parse\n    string::\n\n        AtStringStart(Word(nums)).parse_string("123")\n        # prints ["123"]\n\n        AtStringStart(Word(nums)).parse_string("    123")\n        # raises ParseException\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callPreparse', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Constant(value='not found at string start')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='AtLineStart', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Matches if an expression matches at the beginning of a line within\n    the parse string\n\n    Example::\n\n        test = '''\\\n        AAA this line\n        AAA and this line\n          AAA but not this one\n        B AAA and definitely not this one\n        '''\n\n        for t in (AtLineStart('AAA') + rest_of_line).search_string(test):\n            print(t)\n\n    prints::\n\n        ['AAA', ' this line']\n        ['AAA', ' and this line']\n\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callPreparse', ctx=Store())], value=Constant(value=False))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Compare(left=Call(func=Name(id='col', ctx=Load()), args=[Name(id='loc', ctx=Load()), Name(id='instring', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Constant(value='not found at line start')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='FollowedBy', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Lookahead matching of the given parse expression.\n    ``FollowedBy`` does *not* advance the parsing position within\n    the input string, it only verifies that the specified parse\n    expression matches at the current position.  ``FollowedBy``\n    always returns a null token list. If any results names are defined\n    in the lookahead expression, those *will* be returned for access by\n    name.\n\n    Example::\n\n        # use FollowedBy to match a label only if it is followed by a \':\'\n        data_word = Word(alphas)\n        label = data_word + FollowedBy(\':\')\n        attr_expr = Group(label + Suppress(\':\') + OneOrMore(data_word, stop_on=label).set_parse_action(\' \'.join))\n\n        attr_expr[1, ...].parse_string("shape: SQUARE color: BLACK posn: upper left").pprint()\n\n    prints::\n\n        [[\'shape\', \'SQUARE\'], [\'color\', \'BLACK\'], [\'posn\', \'upper left\']]\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='ret', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[keyword(arg='doActions', value=Name(id='doActions', ctx=Load()))])), Delete(targets=[Subscript(value=Name(id='ret', ctx=Load()), slice=Slice(), ctx=Del())]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='ret', ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='PrecededBy', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Lookbehind matching of the given parse expression.\n    ``PrecededBy`` does not advance the parsing position within the\n    input string, it only verifies that the specified parse expression\n    matches prior to the current position.  ``PrecededBy`` always\n    returns a null token list, but if a results name is defined on the\n    given expression, it is returned.\n\n    Parameters:\n\n    - ``expr`` - expression that must match prior to the current parse\n      location\n    - ``retreat`` - (default= ``None``) - (int) maximum number of characters\n      to lookbehind prior to the current parse location\n\n    If the lookbehind expression is a string, :class:`Literal`,\n    :class:`Keyword`, or a :class:`Word` or :class:`CharsNotIn`\n    with a specified exact or maximum length, then the retreat\n    parameter is not required. Otherwise, retreat must be specified to\n    give a maximum number of characters to look back from\n    the current parse position for a lookbehind match.\n\n    Example::\n\n        # VB-style variable names with type prefixes\n        int_var = PrecededBy("#") + pyparsing_common.identifier\n        str_var = PrecededBy("$") + pyparsing_common.identifier\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='retreat', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), args=[], keywords=[]), attr='leave_whitespace', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exact', ctx=Store())], value=Constant(value=False)), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='expr', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Name(id='retreat', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exact', ctx=Store())], value=Constant(value=True))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='expr', ctx=Load()), Tuple(elts=[Name(id='Literal', ctx=Load()), Name(id='Keyword', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='retreat', ctx=Store())], value=Attribute(value=Name(id='expr', ctx=Load()), attr='matchLen', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exact', ctx=Store())], value=Constant(value=True))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='expr', ctx=Load()), Tuple(elts=[Name(id='Word', ctx=Load()), Name(id='CharsNotIn', ctx=Load())], ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='expr', ctx=Load()), attr='maxLen', ctx=Load()), ops=[NotEq()], comparators=[Name(id='_MAX_INT', ctx=Load())])]), body=[Assign(targets=[Name(id='retreat', ctx=Store())], value=Attribute(value=Name(id='expr', ctx=Load()), attr='maxLen', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exact', ctx=Store())], value=Constant(value=True))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='expr', ctx=Load()), Name(id='PositionToken', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='retreat', ctx=Store())], value=Constant(value=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exact', ctx=Store())], value=Constant(value=True))], orelse=[])])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='retreat', ctx=Store())], value=Name(id='retreat', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='not preceded by '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[]))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=False)), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='parseAction', ctx=Load()), attr='append', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='__delitem__', ctx=Load()), args=[Call(func=Name(id='slice', ctx=Load()), args=[Constant(value=None), Constant(value=None)], keywords=[])], keywords=[]))], keywords=[]))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=True)]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='exact', ctx=Load()), body=[If(test=Compare(left=Name(id='loc', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='retreat', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='start', ctx=Store())], value=BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='retreat', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='ret', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='start', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='test_expr', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), op=Add(), right=Call(func=Name(id='StringEnd', ctx=Load()), args=[], keywords=[]))), Assign(targets=[Name(id='instring_slice', ctx=Store())], value=Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='retreat', ctx=Load()))], keywords=[]), upper=Name(id='loc', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='last_expr', ctx=Store())], value=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load())], keywords=[])), For(target=Name(id='offset', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=1), BinOp(left=Call(func=Name(id='min', ctx=Load()), args=[Name(id='loc', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='retreat', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), op=Add(), right=Constant(value=1))], keywords=[]), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='ret', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='test_expr', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring_slice', ctx=Load()), BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring_slice', ctx=Load())], keywords=[]), op=Sub(), right=Name(id='offset', ctx=Load()))], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseBaseException', ctx=Load()), name='pbe', body=[Assign(targets=[Name(id='last_expr', ctx=Store())], value=Name(id='pbe', ctx=Load()))])], orelse=[Break()], finalbody=[])], orelse=[Raise(exc=Name(id='last_expr', ctx=Load()))])]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='ret', ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='Located', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Decorates a returned token with its starting and ending\n    locations in the input string.\n\n    This helper adds the following results names:\n\n    - ``locn_start`` - location where matched expression begins\n    - ``locn_end`` - location where matched expression ends\n    - ``value`` - the actual parsed results\n\n    Be careful if the input text contains ``<TAB>`` characters, you\n    may want to call :class:`ParserElement.parse_with_tabs`\n\n    Example::\n\n        wd = Word(alphas)\n        for match in Located(wd).search_string("ljsdf123lksdjjf123lkkjj1222"):\n            print(match)\n\n    prints::\n\n        [0, [\'ljsdf\'], 5]\n        [8, [\'lksdjjf\'], 15]\n        [18, [\'lkkjj\'], 23]\n\n    ')), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='start', ctx=Store())], value=Name(id='loc', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='tokens', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='start', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[keyword(arg='callPreParse', value=Constant(value=False))])), Assign(targets=[Name(id='ret_tokens', ctx=Store())], value=Call(func=Name(id='ParseResults', ctx=Load()), args=[List(elts=[Name(id='start', ctx=Load()), Name(id='tokens', ctx=Load()), Name(id='loc', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='ret_tokens', ctx=Load()), slice=Constant(value='locn_start'), ctx=Store())], value=Name(id='start', ctx=Load())), Assign(targets=[Subscript(value=Name(id='ret_tokens', ctx=Load()), slice=Constant(value='value'), ctx=Store())], value=Name(id='tokens', ctx=Load())), Assign(targets=[Subscript(value=Name(id='ret_tokens', ctx=Load()), slice=Constant(value='locn_end'), ctx=Store())], value=Name(id='loc', ctx=Load())), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='resultsName', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), List(elts=[Name(id='ret_tokens', ctx=Load())], ctx=Load())], ctx=Load()))], orelse=[Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='ret_tokens', ctx=Load())], ctx=Load()))])], decorator_list=[])], decorator_list=[]), ClassDef(name='NotAny', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Lookahead to disallow matching with the given parse expression.\n    ``NotAny`` does *not* advance the parsing position within the\n    input string, it only verifies that the specified parse expression\n    does *not* match at the current position.  Also, ``NotAny`` does\n    *not* skip over leading whitespace. ``NotAny`` always returns\n    a null token list.  May be constructed using the ``\'~\'`` operator.\n\n    Example::\n\n        AND, OR, NOT = map(CaselessKeyword, "AND OR NOT".split())\n\n        # take care not to mistake keywords for identifiers\n        ident = ~(AND | OR | NOT) + Word(alphas)\n        boolean_term = Opt(NOT) + ident\n\n        # very crude boolean expression - to support parenthesis groups and\n        # operation hierarchy, use infix_notation\n        boolean_expr = boolean_term + ((AND | OR) + boolean_term)[...]\n\n        # integers that are followed by "." are actually floats\n        integer = Word(nums) + ~Char(".")\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='Found unwanted token, '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], keywords=[])))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='can_parse_next', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[keyword(arg='do_actions', value=Name(id='doActions', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), List(elts=[], ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=BinOp(left=Constant(value='~{'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], keywords=[])), op=Add(), right=Constant(value='}')))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='_MultipleMatch', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='stop_on', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='stopOn', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Name(id='stopOn', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='stopOn', ctx=Load()), Name(id='stop_on', ctx=Load())])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='ender', ctx=Store())], value=Name(id='stopOn', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='ender', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='ender', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='ender', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='stopOn', ctx=Load()), args=[Name(id='ender', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='stopOn', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ender')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='ender', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='ender', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='ender', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='not_ender', ctx=Store())], value=IfExp(test=Compare(left=Name(id='ender', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=UnaryOp(op=Invert(), operand=Name(id='ender', ctx=Load())), orelse=Constant(value=None))), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='self_expr_parse', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='_parse', ctx=Load())), Assign(targets=[Name(id='self_skip_ignorables', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_skipIgnorables', ctx=Load())), Assign(targets=[Name(id='check_ender', ctx=Store())], value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='not_ender', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), If(test=Name(id='check_ender', ctx=Load()), body=[Assign(targets=[Name(id='try_not_ender', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='not_ender', ctx=Load()), attr='try_parse', ctx=Load()))], orelse=[]), If(test=Name(id='check_ender', ctx=Load()), body=[Expr(value=Call(func=Name(id='try_not_ender', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='tokens', ctx=Store())], ctx=Store())], value=Call(func=Name(id='self_expr_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='hasIgnoreExprs', ctx=Store())], value=UnaryOp(op=Not(), operand=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load())))), While(test=Constant(value=1), body=[If(test=Name(id='check_ender', ctx=Load()), body=[Expr(value=Call(func=Name(id='try_not_ender', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='hasIgnoreExprs', ctx=Load()), body=[Assign(targets=[Name(id='preloc', ctx=Store())], value=Call(func=Name(id='self_skip_ignorables', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='preloc', ctx=Store())], value=Name(id='loc', ctx=Load()))]), Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='tmptokens', ctx=Store())], ctx=Store())], value=Call(func=Name(id='self_expr_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='preloc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[])), AugAssign(target=Name(id='tokens', ctx=Store()), op=Add(), value=Name(id='tmptokens', ctx=Load()))], orelse=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ParseException', ctx=Load()), Name(id='IndexError', ctx=Load())], ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='tokens', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_setResultsName', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='listAllMatches')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='__diag__', ctx=Load()), attr='warn_ungrouped_named_tokens_in_collection', ctx=Load()), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_ungrouped_named_tokens_in_collection', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), body=[For(target=Name(id='e', ctx=Store()), iter=BinOp(left=List(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], ctx=Load()), op=Add(), right=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='recurse', ctx=Load()), args=[], keywords=[])), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='e', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[]), Attribute(value=Name(id='e', ctx=Load()), attr='resultsName', ctx=Load()), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_ungrouped_named_tokens_in_collection', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='e', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{}: setting results name {!r} on {} expression collides with {!r} on contained expression'), attr='format', ctx=Load()), args=[Constant(value='warn_ungrouped_named_tokens_in_collection'), Name(id='name', ctx=Load()), Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), Attribute(value=Name(id='e', ctx=Load()), attr='resultsName', ctx=Load())], keywords=[])], keywords=[keyword(arg='stacklevel', value=Constant(value=3))]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='_setResultsName', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='listAllMatches', ctx=Load())], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='OneOrMore', bases=[Name(id='_MultipleMatch', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Repetition of one or more of the given expression.\n\n    Parameters:\n\n    - ``expr`` - expression that must match one or more times\n    - ``stop_on`` - (default= ``None``) - expression for a terminating sentinel\n      (only required if the sentinel would ordinarily match the repetition\n      expression)\n\n    Example::\n\n        data_word = Word(alphas)\n        label = data_word + FollowedBy(\':\')\n        attr_expr = Group(label + Suppress(\':\') + OneOrMore(data_word).set_parse_action(\' \'.join))\n\n        text = "shape: SQUARE posn: upper left color: BLACK"\n        attr_expr[1, ...].parse_string(text).pprint()  # Fail! read \'color\' as data instead of next label -> [[\'shape\', \'SQUARE color\']]\n\n        # use stop_on attribute for OneOrMore to avoid reading label string as part of the data\n        attr_expr = Group(label + Suppress(\':\') + OneOrMore(data_word, stop_on=label).set_parse_action(\' \'.join))\n        OneOrMore(attr_expr).parse_string(text).pprint() # Better -> [[\'shape\', \'SQUARE\'], [\'posn\', \'upper left\'], [\'color\', \'BLACK\']]\n\n        # could also be written as\n        (attr_expr * (1,)).parse_string(text).pprint()\n    ')), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=BinOp(left=Constant(value='{'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], keywords=[])), op=Add(), right=Constant(value='}...')))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='ZeroOrMore', bases=[Name(id='_MultipleMatch', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Optional repetition of zero or more of the given expression.\n\n    Parameters:\n\n    - ``expr`` - expression that must match zero or more times\n    - ``stop_on`` - expression for a terminating sentinel\n      (only required if the sentinel would ordinarily match the repetition\n      expression) - (default= ``None``)\n\n    Example: similar to :class:`OneOrMore`\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='stop_on', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='stopOn', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[keyword(arg='stopOn', value=BoolOp(op=Or(), values=[Name(id='stopOn', ctx=Load()), Name(id='stop_on', ctx=Load())]))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Try(body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ParseException', ctx=Load()), Name(id='IndexError', ctx=Load())], ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Call(func=Name(id='ParseResults', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[keyword(arg='name', value=Attribute(value=Name(id='self', ctx=Load()), attr='resultsName', ctx=Load()))])], ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=BinOp(left=Constant(value='['), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=']...')))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='DelimitedList', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='delim', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='combine', annotation=Name(id='bool', ctx=Load())), arg(arg='min', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='max', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='allow_trailing_delim', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value=','), Constant(value=False), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Helper to define a delimited list of expressions - the delimiter\n        defaults to \',\'. By default, the list elements and delimiters can\n        have intervening whitespace, and comments, but this can be\n        overridden by passing ``combine=True`` in the constructor. If\n        ``combine`` is set to ``True``, the matching tokens are\n        returned as a single token string, with the delimiters included;\n        otherwise, the matching tokens are returned as a list of tokens,\n        with the delimiters suppressed.\n\n        If ``allow_trailing_delim`` is set to True, then the list may end with\n        a delimiter.\n\n        Example::\n\n            DelimitedList(Word(alphas)).parse_string("aa,bb,cc") # -> [\'aa\', \'bb\', \'cc\']\n            DelimitedList(Word(hexnums), delim=\':\', combine=True).parse_string("AA:BB:CC:DD:EE") # -> [\'AA:BB:CC:DD:EE\']\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='expr', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='ParserElement', ctx=Load()), Name(id='expr', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='min must be greater than 0')], keywords=[]))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='max', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='min', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='max', ctx=Load()), ops=[Lt()], comparators=[Name(id='min', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='max must be greater than, or equal to min')], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='content', ctx=Store())], value=Name(id='expr', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='raw_delim', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='delim', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='delim', ctx=Store())], value=Name(id='delim', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='combine', ctx=Store())], value=Name(id='combine', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='combine', ctx=Load())), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='delim', ctx=Store())], value=Call(func=Name(id='Suppress', ctx=Load()), args=[Name(id='delim', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='min', ctx=Load()), Constant(value=1)])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Store())], value=Name(id='max', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='allow_trailing_delim', ctx=Store())], value=Name(id='allow_trailing_delim', ctx=Load())), Assign(targets=[Name(id='delim_list_expr', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='content', ctx=Load()), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='delim', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='content', ctx=Load())), op=Mult(), right=Tuple(elts=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='min', ctx=Load()), op=Sub(), right=Constant(value=1)), IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Constant(value=None), orelse=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='max', ctx=Load()), op=Sub(), right=Constant(value=1)))], ctx=Load())))), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='allow_trailing_delim', ctx=Load()), body=[AugAssign(target=Name(id='delim_list_expr', ctx=Store()), op=Add(), value=Call(func=Name(id='Opt', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='delim', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='combine', ctx=Load()), body=[Assign(targets=[Name(id='delim_list_expr', ctx=Store())], value=Call(func=Name(id='Combine', ctx=Load()), args=[Name(id='delim_list_expr', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='delim_list_expr', ctx=Load())], keywords=[keyword(arg='savelist', value=Constant(value=True))]))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='{0} [{1} {0}]...'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='content', ctx=Load()), attr='streamline', ctx=Load()), args=[], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='raw_delim', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='_NullToken', bases=[], keywords=[], body=[FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value=''))], decorator_list=[])], decorator_list=[]), ClassDef(name='Opt', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Optional matching of the given expression.\n\n    Parameters:\n\n    - ``expr`` - expression that must match zero or more times\n    - ``default`` (optional) - value to be returned if the optional expression is not found.\n\n    Example::\n\n        # US postal code can be a 5-digit zip, plus optional 4-digit qualifier\n        zip = Combine(Word(nums, exact=5) + Opt('-' + Word(nums, exact=4)))\n        zip.run_tests('''\n            # traditional ZIP code\n            12345\n\n            # ZIP+4 form\n            12101-0001\n\n            # invalid ZIP\n            98765-\n            ''')\n\n    prints::\n\n        # traditional ZIP code\n        12345\n        ['12345']\n\n        # ZIP+4 form\n        12101-0001\n        ['12101-0001']\n\n        # invalid ZIP\n        98765-\n             ^\n        FAIL: Expected end of text (at char 5), (line:1, col:6)\n    ")), Assign(targets=[Name(id='__optionalNotMatched', ctx=Store())], value=Call(func=Name(id='_NullToken', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='default', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='__optionalNotMatched', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[keyword(arg='savelist', value=Constant(value=False))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='saveAsList', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='defaultValue', ctx=Store())], value=Name(id='default', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='self_expr', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())), Try(body=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='tokens', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self_expr', ctx=Load()), attr='_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[keyword(arg='callPreParse', value=Constant(value=False))]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ParseException', ctx=Load()), Name(id='IndexError', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='default_value', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='defaultValue', ctx=Load())), If(test=Compare(left=Name(id='default_value', ctx=Load()), ops=[IsNot()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='__optionalNotMatched', ctx=Load())]), body=[If(test=Attribute(value=Name(id='self_expr', ctx=Load()), attr='resultsName', ctx=Load()), body=[Assign(targets=[Name(id='tokens', ctx=Store())], value=Call(func=Name(id='ParseResults', ctx=Load()), args=[List(elts=[Name(id='default_value', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='tokens', ctx=Load()), slice=Attribute(value=Name(id='self_expr', ctx=Load()), attr='resultsName', ctx=Load()), ctx=Store())], value=Name(id='default_value', ctx=Load()))], orelse=[Assign(targets=[Name(id='tokens', ctx=Store())], value=List(elts=[Name(id='default_value', ctx=Load())], ctx=Load()))])], orelse=[Assign(targets=[Name(id='tokens', ctx=Store())], value=List(elts=[], ctx=Load()))])])], orelse=[], finalbody=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='tokens', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='inner', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], keywords=[])), While(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='inner', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), Compare(left=Subscript(value=Name(id='inner', ctx=Load()), slice=Slice(lower=Constant(value=0), step=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='inner', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))), ctx=Load()), ops=[Eq()], comparators=[Constant(value='{}')])]), body=[Assign(targets=[Name(id='inner', ctx=Store())], value=Subscript(value=Name(id='inner', ctx=Load()), slice=Slice(lower=Constant(value=1), upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], orelse=[]), Return(value=BinOp(left=BinOp(left=Constant(value='['), op=Add(), right=Name(id='inner', ctx=Load())), op=Add(), right=Constant(value=']')))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='Optional', ctx=Store())], value=Name(id='Opt', ctx=Load())), ClassDef(name='SkipTo', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Token for skipping over all undefined text until the matched\n    expression is found.\n\n    Parameters:\n\n    - ``expr`` - target expression marking the end of the data to be skipped\n    - ``include`` - if ``True``, the target expression is also parsed\n      (the skipped text and target expression are returned as a 2-element\n      list) (default= ``False``).\n    - ``ignore`` - (default= ``None``) used to define grammars (typically quoted strings and\n      comments) that might contain false matches to the target expression\n    - ``fail_on`` - (default= ``None``) define expressions that are not allowed to be\n      included in the skipped test; if found before the target expression is found,\n      the :class:`SkipTo` is not a match\n\n    Example::\n\n        report = \'\'\'\n            Outstanding Issues Report - 1 Jan 2000\n\n               # | Severity | Description                               |  Days Open\n            -----+----------+-------------------------------------------+-----------\n             101 | Critical | Intermittent system crash                 |          6\n              94 | Cosmetic | Spelling error on Login (\'log|n\')         |         14\n              79 | Minor    | System slow when running too many reports |         47\n            \'\'\'\n        integer = Word(nums)\n        SEP = Suppress(\'|\')\n        # use SkipTo to simply match everything up until the next SEP\n        # - ignore quoted strings, so that a \'|\' character inside a quoted string does not match\n        # - parse action will call token.strip() for each matched token, i.e., the description body\n        string_data = SkipTo(SEP, ignore=quoted_string)\n        string_data.set_parse_action(token_map(str.strip))\n        ticket_expr = (integer("issue_num") + SEP\n                      + string_data("sev") + SEP\n                      + string_data("desc") + SEP\n                      + integer("days_open"))\n\n        for tkt in ticket_expr.search_string(report):\n            print tkt.dump()\n\n    prints::\n\n        [\'101\', \'Critical\', \'Intermittent system crash\', \'6\']\n        - days_open: \'6\'\n        - desc: \'Intermittent system crash\'\n        - issue_num: \'101\'\n        - sev: \'Critical\'\n        [\'94\', \'Cosmetic\', "Spelling error on Login (\'log|n\')", \'14\']\n        - days_open: \'14\'\n        - desc: "Spelling error on Login (\'log|n\')"\n        - issue_num: \'94\'\n        - sev: \'Cosmetic\'\n        [\'79\', \'Minor\', \'System slow when running too many reports\', \'47\']\n        - days_open: \'47\'\n        - desc: \'System slow when running too many reports\'\n        - issue_num: \'79\'\n        - sev: \'Minor\'\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='include', annotation=Name(id='bool', ctx=Load())), arg(arg='ignore', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='fail_on', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='failOn', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], defaults=[Constant(value=False), Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), Assign(targets=[Name(id='failOn', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='failOn', ctx=Load()), Name(id='fail_on', ctx=Load())])), If(test=Compare(left=Name(id='ignore', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='ignore', ctx=Load()), args=[Name(id='ignore', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Constant(value=False)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='includeMatch', ctx=Store())], value=Name(id='include', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Constant(value=False)), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='failOn', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='failOn', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='failOn', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='failOn', ctx=Store())], value=Name(id='failOn', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Store())], value=BinOp(left=Constant(value='No match found for '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], keywords=[])))], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Name(id='startloc', ctx=Store())], value=Name(id='loc', ctx=Load())), Assign(targets=[Name(id='instrlen', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='instring', ctx=Load())], keywords=[])), Assign(targets=[Name(id='self_expr_parse', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='_parse', ctx=Load())), Assign(targets=[Name(id='self_failOn_canParseNext', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='failOn', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='failOn', ctx=Load()), attr='canParseNext', ctx=Load()), orelse=Constant(value=None))), Assign(targets=[Name(id='self_preParse', ctx=Store())], value=IfExp(test=Attribute(value=Name(id='self', ctx=Load()), attr='callPreparse', ctx=Load()), body=Attribute(value=Name(id='self', ctx=Load()), attr='preParse', ctx=Load()), orelse=Constant(value=None))), Assign(targets=[Name(id='tmploc', ctx=Store())], value=Name(id='loc', ctx=Load())), While(test=Compare(left=Name(id='tmploc', ctx=Load()), ops=[LtE()], comparators=[Name(id='instrlen', ctx=Load())]), body=[If(test=Compare(left=Name(id='self_failOn_canParseNext', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Call(func=Name(id='self_failOn_canParseNext', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tmploc', ctx=Load())], keywords=[]), body=[Break()], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='self_preParse', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='tmploc', ctx=Store())], value=Call(func=Name(id='self_preParse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tmploc', ctx=Load())], keywords=[]))], orelse=[]), Try(body=[Expr(value=Call(func=Name(id='self_expr_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='tmploc', ctx=Load())], keywords=[keyword(arg='doActions', value=Constant(value=False)), keyword(arg='callPreParse', value=Constant(value=False))]))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ParseException', ctx=Load()), Name(id='IndexError', ctx=Load())], ctx=Load()), body=[AugAssign(target=Name(id='tmploc', ctx=Store()), op=Add(), value=Constant(value=1))])], orelse=[Break()], finalbody=[])], orelse=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='errmsg', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='loc', ctx=Store())], value=Name(id='tmploc', ctx=Load())), Assign(targets=[Name(id='skiptext', ctx=Store())], value=Subscript(value=Name(id='instring', ctx=Load()), slice=Slice(lower=Name(id='startloc', ctx=Load()), upper=Name(id='loc', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='skipresult', ctx=Store())], value=Call(func=Name(id='ParseResults', ctx=Load()), args=[Name(id='skiptext', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='includeMatch', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='loc', ctx=Store()), Name(id='mat', ctx=Store())], ctx=Store())], value=Call(func=Name(id='self_expr_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[keyword(arg='callPreParse', value=Constant(value=False))])), AugAssign(target=Name(id='skipresult', ctx=Store()), op=Add(), value=Name(id='mat', ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='skipresult', ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='Forward', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Forward declaration of an expression to be defined later -\n    used for recursive grammars, such as algebraic infix notation.\n    When the expression is known, it is assigned to the ``Forward``\n    variable using the ``'<<'`` operator.\n\n    Note: take care when assigning to ``Forward`` not to overlook\n    precedence of operators.\n\n    Specifically, ``'|'`` has a lower precedence than ``'<<'``, so that::\n\n        fwd_expr << a | b | c\n\n    will actually be evaluated as::\n\n        (fwd_expr << a) | b | c\n\n    thereby leaving b and c out as parseable alternatives.  It is recommended that you\n    explicitly group the values inserted into the ``Forward``::\n\n        fwd_expr << (a | b | c)\n\n    Converting to use the ``'<<='`` operator instead will avoid this problem.\n\n    See :class:`ParseResults.pprint` for an example of a recursive\n    parser created using ``Forward``.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='caller_frame', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='extract_stack', ctx=Load()), args=[], keywords=[keyword(arg='limit', value=Constant(value=2))]), slice=Constant(value=0), ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[keyword(arg='savelist', value=Constant(value=False))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='lshift_line', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='__lshift__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='caller_frame')], keywords=[]), body=[Delete(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='caller_frame', ctx=Del())])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='other', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Store())], value=Name(id='other', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='streamlined', ctx=Store())], value=Attribute(value=Name(id='other', ctx=Load()), attr='streamlined', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayIndexError', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='mayIndexError', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mayReturnEmpty', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='mayReturnEmpty', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='set_whitespace_chars', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='whiteChars', ctx=Load())], keywords=[keyword(arg='copy_defaults', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='copyDefaultWhiteChars', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='skipWhitespace', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='saveAsList', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ignoreExprs', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='ignoreExprs', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='lshift_line', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='extract_stack', ctx=Load()), args=[], keywords=[keyword(arg='limit', value=Constant(value=2))]), slice=UnaryOp(op=USub(), operand=Constant(value=2)), ctx=Load())), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='Forward')), FunctionDef(name='__ilshift__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=BinOp(left=Name(id='self', ctx=Load()), op=LShift(), right=Name(id='other', ctx=Load())))], decorator_list=[], returns=Constant(value='Forward')), FunctionDef(name='__or__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='caller_line', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='extract_stack', ctx=Load()), args=[], keywords=[keyword(arg='limit', value=Constant(value=2))]), slice=UnaryOp(op=USub(), operand=Constant(value=2)), ctx=Load())), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='__diag__', ctx=Load()), attr='warn_on_match_first_with_lshift_operator', ctx=Load()), Compare(left=Name(id='caller_line', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='lshift_line', ctx=Load())]), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_on_match_first_with_lshift_operator', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value="using '<<' operator with '|' is probably an error, use '<<='")], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))], orelse=[]), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__or__', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__del__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Attribute(value=Name(id='__diag__', ctx=Load()), attr='warn_on_assignment_to_Forward', ctx=Load()), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_on_assignment_to_Forward', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn_explicit', ctx=Load()), args=[Constant(value="Forward defined here but no expression attached later using '<<=' or '<<'"), Name(id='UserWarning', ctx=Load())], keywords=[keyword(arg='filename', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='caller_frame', ctx=Load()), attr='filename', ctx=Load())), keyword(arg='lineno', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='caller_frame', ctx=Load()), attr='lineno', ctx=Load()))]))], orelse=[])], decorator_list=[]), FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Attribute(value=Name(id='__diag__', ctx=Load()), attr='warn_on_parse_using_empty_Forward', ctx=Load()), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_on_parse_using_empty_Forward', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), body=[Assign(targets=[Name(id='parse_fns', ctx=Store())], value=Tuple(elts=[Constant(value='parse_string'), Constant(value='scan_string'), Constant(value='search_string'), Constant(value='transform_string')], ctx=Load())), Assign(targets=[Name(id='tb', ctx=Store())], value=Call(func=Attribute(value=Name(id='traceback', ctx=Load()), attr='extract_stack', ctx=Load()), args=[], keywords=[keyword(arg='limit', value=Constant(value=200))])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='frm', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Call(func=Name(id='reversed', ctx=Load()), args=[Name(id='tb', ctx=Load())], keywords=[])], keywords=[keyword(arg='start', value=Constant(value=1))]), body=[If(test=Compare(left=Attribute(value=Name(id='frm', ctx=Load()), attr='name', ctx=Load()), ops=[In()], comparators=[Name(id='parse_fns', ctx=Load())]), body=[Assign(targets=[Name(id='stacklevel', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1))), Break()], orelse=[])], orelse=[Assign(targets=[Name(id='stacklevel', ctx=Store())], value=Constant(value=2))]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='Forward expression was never assigned a value, will not parse any input')], keywords=[keyword(arg='stacklevel', value=Name(id='stacklevel', ctx=Load()))]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_left_recursion_enabled', ctx=Load())), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='doActions', ctx=Load())], keywords=[]))], orelse=[]), With(items=[withitem(context_expr=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='recursion_lock', ctx=Load()))], body=[Assign(targets=[Name(id='memo', ctx=Store())], value=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='recursion_memos', ctx=Load())), Try(body=[Assign(targets=[Tuple(elts=[Name(id='prev_loc', ctx=Store()), Name(id='prev_result', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='memo', ctx=Load()), slice=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='self', ctx=Load()), Name(id='doActions', ctx=Load())], ctx=Load()), ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='prev_result', ctx=Load()), Name(id='Exception', ctx=Load())], keywords=[]), body=[Raise(exc=Name(id='prev_result', ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[Name(id='prev_loc', ctx=Load()), Call(func=Attribute(value=Name(id='prev_result', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])], ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Assign(targets=[Name(id='act_key', ctx=Store())], value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='self', ctx=Load()), Constant(value=True)], ctx=Load())), Assign(targets=[Name(id='peek_key', ctx=Store())], value=Tuple(elts=[Name(id='loc', ctx=Load()), Name(id='self', ctx=Load()), Constant(value=False)], ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='prev_loc', ctx=Store()), Name(id='prev_peek', ctx=Store())], ctx=Store()), Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='peek_key', ctx=Load()), ctx=Store())], value=Tuple(elts=[BinOp(left=Name(id='loc', ctx=Load()), op=Sub(), right=Constant(value=1)), Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Constant(value='Forward recursion without base case'), Name(id='self', ctx=Load())], keywords=[])], ctx=Load())), If(test=Name(id='doActions', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='act_key', ctx=Load()), ctx=Store())], value=Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='peek_key', ctx=Load()), ctx=Load()))], orelse=[]), While(test=Constant(value=True), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='new_loc', ctx=Store()), Name(id='new_peek', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Constant(value=False)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseException', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='prev_peek', ctx=Load()), Name(id='Exception', ctx=Load())], keywords=[]), body=[Raise()], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='new_loc', ctx=Store()), Name(id='new_peek', ctx=Store())], ctx=Store())], value=Tuple(elts=[Name(id='prev_loc', ctx=Load()), Name(id='prev_peek', ctx=Load())], ctx=Load()))])], orelse=[], finalbody=[]), If(test=Compare(left=Name(id='new_loc', ctx=Load()), ops=[LtE()], comparators=[Name(id='prev_loc', ctx=Load())]), body=[If(test=Name(id='doActions', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='prev_loc', ctx=Store()), Name(id='prev_result', ctx=Store())], ctx=Store()), Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='peek_key', ctx=Load()), ctx=Store())], value=Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='act_key', ctx=Load()), ctx=Load())), Delete(targets=[Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='peek_key', ctx=Load()), ctx=Del()), Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='act_key', ctx=Load()), ctx=Del())]), Return(value=Tuple(elts=[Name(id='prev_loc', ctx=Load()), Call(func=Attribute(value=Name(id='prev_result', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])], ctx=Load()))], orelse=[]), Delete(targets=[Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='peek_key', ctx=Load()), ctx=Del())]), Return(value=Tuple(elts=[Name(id='prev_loc', ctx=Load()), Call(func=Attribute(value=Name(id='prev_peek', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])], ctx=Load()))], orelse=[If(test=Name(id='doActions', ctx=Load()), body=[Try(body=[Assign(targets=[Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='act_key', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='parseImpl', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load()), Constant(value=True)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ParseException', ctx=Load()), name='e', body=[Assign(targets=[Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='peek_key', ctx=Load()), ctx=Store()), Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='act_key', ctx=Load()), ctx=Store())], value=Tuple(elts=[Name(id='new_loc', ctx=Load()), Name(id='e', ctx=Load())], ctx=Load())), Raise()])], orelse=[], finalbody=[])], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='prev_loc', ctx=Store()), Name(id='prev_peek', ctx=Store())], ctx=Store()), Subscript(value=Name(id='memo', ctx=Load()), slice=Name(id='peek_key', ctx=Load()), ctx=Store())], value=Tuple(elts=[Name(id='new_loc', ctx=Load()), Name(id='new_peek', ctx=Load())], ctx=Load()))])], orelse=[])])], orelse=[], finalbody=[])])], decorator_list=[]), FunctionDef(name='leave_whitespace', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='recursive', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=False)), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='ignore_whitespace', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='recursive', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=True)), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='streamline', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='streamlined', ctx=Load())), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='streamlined', ctx=Store())], value=Constant(value=True)), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='streamline', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='validate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='validateTrace')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='ParserElement.validate() is deprecated, and should not be used to check for left recursion'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), If(test=Compare(left=Name(id='validateTrace', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='validateTrace', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='self', ctx=Load()), ops=[NotIn()], comparators=[Name(id='validateTrace', ctx=Load())]), body=[Assign(targets=[Name(id='tmp', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='validateTrace', ctx=Load()), slice=Slice(), ctx=Load()), op=Add(), right=List(elts=[Name(id='self', ctx=Load())], ctx=Load()))), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='validate', ctx=Load()), args=[Name(id='tmp', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_checkRecursion', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_generateDefaultName', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_defaultName', ctx=Store())], value=Constant(value=': ...')), Assign(targets=[Name(id='retString', ctx=Store())], value=Constant(value='...')), Try(body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='retString', ctx=Store())], value=Subscript(value=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load())], keywords=[]), slice=Slice(upper=Constant(value=1000)), ctx=Load()))], orelse=[Assign(targets=[Name(id='retString', ctx=Store())], value=Constant(value='None'))])], handlers=[], orelse=[], finalbody=[Return(value=BinOp(left=BinOp(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), op=Add(), right=Constant(value=': ')), op=Add(), right=Name(id='retString', ctx=Load())))])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='copy', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='copy', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='Forward', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=LShift(), value=Name(id='self', ctx=Load())), Return(value=Name(id='ret', ctx=Load()))])], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='_setResultsName', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name'), arg(arg='list_all_matches')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='__diag__', ctx=Load()), attr='warn_name_set_on_empty_Forward', ctx=Load()), Compare(left=Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_name_set_on_empty_Forward', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='suppress_warnings_', ctx=Load())])]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{}: setting results name {!r} on {} expression that has no contained expression'), attr='format', ctx=Load()), args=[Constant(value='warn_name_set_on_empty_Forward'), Name(id='name', ctx=Load()), Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load())], keywords=[])], keywords=[keyword(arg='stacklevel', value=Constant(value=3))]))], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='_setResultsName', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='list_all_matches', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='leaveWhitespace', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='leave_whitespace', ctx=Load())], keywords=[])]), FunctionDef(name='ignoreWhitespace', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='ignore_whitespace', ctx=Load())], keywords=[])])], decorator_list=[]), ClassDef(name='TokenConverter', bases=[Name(id='ParseElementEnhance', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Abstract subclass of :class:`ParseExpression`, for converting parsed results.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='savelist')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Constant(value=False))], decorator_list=[])], decorator_list=[]), ClassDef(name='Combine', bases=[Name(id='TokenConverter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Converter to concatenate all matching tokens to a single string.\n    By default, the matching patterns must also be contiguous in the\n    input string; this can be disabled by specifying\n    ``'adjacent=False'`` in the constructor.\n\n    Example::\n\n        real = Word(nums) + '.' + Word(nums)\n        print(real.parse_string('3.1416')) # -> ['3', '.', '1416']\n        # will also erroneously match the following\n        print(real.parse_string('3. 1416')) # -> ['3', '.', '1416']\n\n        real = Combine(Word(nums) + '.' + Word(nums))\n        print(real.parse_string('3.1416')) # -> ['3.1416']\n        # no match when there are internal spaces\n        print(real.parse_string('3. 1416')) # -> Exception: Expected W:(0123...)\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load())), arg(arg='join_string', annotation=Name(id='str', ctx=Load())), arg(arg='adjacent', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='joinString', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], defaults=[Constant(value=''), Constant(value=True)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Name(id='joinString', ctx=Store())], value=IfExp(test=Compare(left=Name(id='joinString', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='joinString', ctx=Load()), orelse=Name(id='join_string', ctx=Load()))), If(test=Name(id='adjacent', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='leave_whitespace', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='adjacent', ctx=Store())], value=Name(id='adjacent', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='skipWhitespace', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='joinString', ctx=Store())], value=Name(id='joinString', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callPreparse', ctx=Store())], value=Constant(value=True))], decorator_list=[]), FunctionDef(name='ignore', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='adjacent', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='ignore', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='ignore', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='postParse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='tokenlist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='retToks', ctx=Store())], value=Call(func=Attribute(value=Name(id='tokenlist', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Delete(targets=[Subscript(value=Name(id='retToks', ctx=Load()), slice=Slice(), ctx=Del())]), AugAssign(target=Name(id='retToks', ctx=Store()), op=Add(), value=Call(func=Name(id='ParseResults', ctx=Load()), args=[List(elts=[Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='tokenlist', ctx=Load()), attr='_asStringList', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='joinString', ctx=Load())], keywords=[])], keywords=[])], ctx=Load())], keywords=[keyword(arg='modal', value=Attribute(value=Name(id='self', ctx=Load()), attr='modalResults', ctx=Load()))])), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='resultsName', ctx=Load()), Call(func=Attribute(value=Name(id='retToks', ctx=Load()), attr='haskeys', ctx=Load()), args=[], keywords=[])]), body=[Return(value=List(elts=[Name(id='retToks', ctx=Load())], ctx=Load()))], orelse=[Return(value=Name(id='retToks', ctx=Load()))])], decorator_list=[])], decorator_list=[]), ClassDef(name='Group', bases=[Name(id='TokenConverter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Converter to return the matched tokens as a list - useful for\n    returning tokens of :class:`ZeroOrMore` and :class:`OneOrMore` expressions.\n\n    The optional ``aslist`` argument when set to True will return the\n    parsed tokens as a Python list instead of a pyparsing ParseResults.\n\n    Example::\n\n        ident = Word(alphas)\n        num = Word(nums)\n        term = ident | num\n        func = ident + Opt(DelimitedList(term))\n        print(func.parse_string("fn a, b, 100"))\n        # -> [\'fn\', \'a\', \'b\', \'100\']\n\n        func = ident + Group(Opt(DelimitedList(term)))\n        print(func.parse_string("fn a, b, 100"))\n        # -> [\'fn\', [\'a\', \'b\', \'100\']]\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load())), arg(arg='aslist', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_asPythonList', ctx=Store())], value=Name(id='aslist', ctx=Load()))], decorator_list=[]), FunctionDef(name='postParse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='tokenlist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_asPythonList', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Name(id='ParseResults', ctx=Load()), attr='List', ctx=Load()), args=[IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tokenlist', ctx=Load()), Name(id='ParseResults', ctx=Load())], keywords=[]), body=Call(func=Attribute(value=Name(id='tokenlist', ctx=Load()), attr='asList', ctx=Load()), args=[], keywords=[]), orelse=Call(func=Name(id='list', ctx=Load()), args=[Name(id='tokenlist', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[Return(value=List(elts=[Name(id='tokenlist', ctx=Load())], ctx=Load()))])], decorator_list=[])], decorator_list=[]), ClassDef(name='Dict', bases=[Name(id='TokenConverter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Converter to return a repetitive expression as a list, but also\n    as a dictionary. Each element can also be referenced using the first\n    token in the expression as its key. Useful for tabular report\n    scraping when the first column can be used as a item key.\n\n    The optional ``asdict`` argument when set to True will return the\n    parsed tokens as a Python dict instead of a pyparsing ParseResults.\n\n    Example::\n\n        data_word = Word(alphas)\n        label = data_word + FollowedBy(\':\')\n\n        text = "shape: SQUARE posn: upper left color: light blue texture: burlap"\n        attr_expr = (label + Suppress(\':\') + OneOrMore(data_word, stop_on=label).set_parse_action(\' \'.join))\n\n        # print attributes as plain groups\n        print(attr_expr[1, ...].parse_string(text).dump())\n\n        # instead of OneOrMore(expr), parse using Dict(Group(expr)[1, ...]) - Dict will auto-assign names\n        result = Dict(Group(attr_expr)[1, ...]).parse_string(text)\n        print(result.dump())\n\n        # access named fields as dict entries, or output as dict\n        print(result[\'shape\'])\n        print(result.as_dict())\n\n    prints::\n\n        [\'shape\', \'SQUARE\', \'posn\', \'upper left\', \'color\', \'light blue\', \'texture\', \'burlap\']\n        [[\'shape\', \'SQUARE\'], [\'posn\', \'upper left\'], [\'color\', \'light blue\'], [\'texture\', \'burlap\']]\n        - color: \'light blue\'\n        - posn: \'upper left\'\n        - shape: \'SQUARE\'\n        - texture: \'burlap\'\n        SQUARE\n        {\'color\': \'light blue\', \'posn\': \'upper left\', \'texture\': \'burlap\', \'shape\': \'SQUARE\'}\n\n    See more examples at :class:`ParseResults` of accessing fields by results name.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load())), arg(arg='asdict', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='saveAsList', ctx=Store())], value=Constant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_asPythonDict', ctx=Store())], value=Name(id='asdict', ctx=Load()))], decorator_list=[]), FunctionDef(name='postParse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='tokenlist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='tok', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='tokenlist', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='tok', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=0)]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='ikey', ctx=Store())], value=Subscript(value=Name(id='tok', ctx=Load()), slice=Constant(value=0), ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='ikey', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='ikey', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='ikey', ctx=Load())], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='tok', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Subscript(value=Name(id='tokenlist', ctx=Load()), slice=Name(id='ikey', ctx=Load()), ctx=Store())], value=Call(func=Name(id='_ParseResultsWithOffset', ctx=Load()), args=[Constant(value=''), Name(id='i', ctx=Load())], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='tok', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='tok', ctx=Load()), slice=Constant(value=1), ctx=Load()), Name(id='ParseResults', ctx=Load())], keywords=[]))]), body=[Assign(targets=[Subscript(value=Name(id='tokenlist', ctx=Load()), slice=Name(id='ikey', ctx=Load()), ctx=Store())], value=Call(func=Name(id='_ParseResultsWithOffset', ctx=Load()), args=[Subscript(value=Name(id='tok', ctx=Load()), slice=Constant(value=1), ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[Try(body=[Assign(targets=[Name(id='dictvalue', ctx=Store())], value=Call(func=Attribute(value=Name(id='tok', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Assign(targets=[Name(id='exc', ctx=Store())], value=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='could not extract dict values from parsed results - Dict expression must contain Grouped expressions')], keywords=[])), Raise(exc=Name(id='exc', ctx=Load()), cause=Constant(value=None))])], orelse=[], finalbody=[]), Delete(targets=[Subscript(value=Name(id='dictvalue', ctx=Load()), slice=Constant(value=0), ctx=Del())]), If(test=BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='dictvalue', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=1)]), BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='dictvalue', ctx=Load()), Name(id='ParseResults', ctx=Load())], keywords=[]), Call(func=Attribute(value=Name(id='dictvalue', ctx=Load()), attr='haskeys', ctx=Load()), args=[], keywords=[])])]), body=[Assign(targets=[Subscript(value=Name(id='tokenlist', ctx=Load()), slice=Name(id='ikey', ctx=Load()), ctx=Store())], value=Call(func=Name(id='_ParseResultsWithOffset', ctx=Load()), args=[Name(id='dictvalue', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Subscript(value=Name(id='tokenlist', ctx=Load()), slice=Name(id='ikey', ctx=Load()), ctx=Store())], value=Call(func=Name(id='_ParseResultsWithOffset', ctx=Load()), args=[Subscript(value=Name(id='dictvalue', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))])])])], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_asPythonDict', ctx=Load()), body=[Return(value=IfExp(test=Attribute(value=Name(id='self', ctx=Load()), attr='resultsName', ctx=Load()), body=List(elts=[Call(func=Attribute(value=Name(id='tokenlist', ctx=Load()), attr='as_dict', ctx=Load()), args=[], keywords=[])], ctx=Load()), orelse=Call(func=Attribute(value=Name(id='tokenlist', ctx=Load()), attr='as_dict', ctx=Load()), args=[], keywords=[])))], orelse=[Return(value=IfExp(test=Attribute(value=Name(id='self', ctx=Load()), attr='resultsName', ctx=Load()), body=List(elts=[Name(id='tokenlist', ctx=Load())], ctx=Load()), orelse=Name(id='tokenlist', ctx=Load())))])], decorator_list=[])], decorator_list=[]), ClassDef(name='Suppress', bases=[Name(id='TokenConverter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Converter for ignoring the results of a parsed expression.\n\n    Example::\n\n        source = "a, b, c,d"\n        wd = Word(alphas)\n        wd_list1 = wd + (\',\' + wd)[...]\n        print(wd_list1.parse_string(source))\n\n        # often, delimiters that are useful during parsing are just in the\n        # way afterward - use Suppress to keep them out of the parsed output\n        wd_list2 = wd + (Suppress(\',\') + wd)[...]\n        print(wd_list2.parse_string(source))\n\n        # Skipped text (using \'...\') can be suppressed as well\n        source = "lead in START relevant text END trailing text"\n        start_marker = Keyword("START")\n        end_marker = Keyword("END")\n        find_body = Suppress(...) + start_marker + ... + end_marker\n        print(find_body.parse_string(source)\n\n    prints::\n\n        [\'a\', \',\', \'b\', \',\', \'c\', \',\', \'d\']\n        [\'a\', \'b\', \'c\', \'d\']\n        [\'START\', \'relevant text \', \'END\']\n\n    (See also :class:`DelimitedList`.)\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='savelist', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[If(test=Compare(left=Name(id='expr', ctx=Load()), ops=[Is()], comparators=[Constant(value=Ellipsis)]), body=[Assign(targets=[Name(id='expr', ctx=Store())], value=Call(func=Name(id='_PendingSkip', ctx=Load()), args=[Call(func=Name(id='NoMatch', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__add__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), Name(id='_PendingSkip', ctx=Load())], keywords=[]), body=[Return(value=BinOp(left=Call(func=Name(id='Suppress', ctx=Load()), args=[Call(func=Name(id='SkipTo', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])], keywords=[]), op=Add(), right=Name(id='other', ctx=Load())))], orelse=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__add__', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))])], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='__sub__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), Name(id='_PendingSkip', ctx=Load())], keywords=[]), body=[Return(value=BinOp(left=Call(func=Name(id='Suppress', ctx=Load()), args=[Call(func=Name(id='SkipTo', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])], keywords=[]), op=Sub(), right=Name(id='other', ctx=Load())))], orelse=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__sub__', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[]))])], decorator_list=[], returns=Constant(value='ParserElement')), FunctionDef(name='postParse', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='tokenlist')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=List(elts=[], ctx=Load()))], decorator_list=[]), FunctionDef(name='suppress', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load()))], decorator_list=[]), FunctionDef(name='trace_parse_action', args=arguments(posonlyargs=[], args=[arg(arg='f', annotation=Name(id='ParseAction', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Decorator for debugging parse actions.\n\n    When the parse action is called, this decorator will print\n    ``">> entering method-name(line:<current_source_line>, <parse_location>, <matched_tokens>)"``.\n    When the parse action completes, the decorator will print\n    ``"<<"`` followed by the returned value, or any exception that the parse action raised.\n\n    Example::\n\n        wd = Word(alphas)\n\n        @trace_parse_action\n        def remove_duplicate_chars(tokens):\n            return \'\'.join(sorted(set(\'\'.join(tokens))))\n\n        wds = wd[1, ...].set_parse_action(remove_duplicate_chars)\n        print(wds.parse_string("slkdjs sld sldd sdlf sdljf"))\n\n    prints::\n\n        >>entering remove_duplicate_chars(line: \'slkdjs sld sldd sdlf sdljf\', 0, ([\'slkdjs\', \'sld\', \'sldd\', \'sdlf\', \'sdljf\'], {}))\n        <<leaving remove_duplicate_chars (ret: \'dfjkls\')\n        [\'dfjkls\']\n    ')), Assign(targets=[Name(id='f', ctx=Store())], value=Call(func=Name(id='_trim_arity', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[])), FunctionDef(name='z', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='paArgs'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='thisFunc', ctx=Store())], value=Attribute(value=Name(id='f', ctx=Load()), attr='__name__', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='s', ctx=Store()), Name(id='l', ctx=Store()), Name(id='t', ctx=Store())], ctx=Store())], value=Subscript(value=Name(id='paArgs', ctx=Load()), slice=Slice(lower=UnaryOp(op=USub(), operand=Constant(value=3))), ctx=Load())), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='paArgs', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=3)]), body=[Assign(targets=[Name(id='thisFunc', ctx=Store())], value=BinOp(left=BinOp(left=Attribute(value=Attribute(value=Subscript(value=Name(id='paArgs', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), op=Add(), right=Constant(value='.')), op=Add(), right=Name(id='thisFunc', ctx=Load())))], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='>>entering '), FormattedValue(value=Name(id='thisFunc', ctx=Load()), conversion=-1), Constant(value='(line: '), FormattedValue(value=Call(func=Name(id='line', ctx=Load()), args=[Name(id='l', ctx=Load()), Name(id='s', ctx=Load())], keywords=[]), conversion=114), Constant(value=', '), FormattedValue(value=Name(id='l', ctx=Load()), conversion=-1), Constant(value=', '), FormattedValue(value=Name(id='t', ctx=Load()), conversion=114), Constant(value=')\n')])], keywords=[])), Try(body=[Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='f', ctx=Load()), args=[Starred(value=Name(id='paArgs', ctx=Load()), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='exc', body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='<<leaving '), FormattedValue(value=Name(id='thisFunc', ctx=Load()), conversion=-1), Constant(value=' (exception: '), FormattedValue(value=Name(id='exc', ctx=Load()), conversion=-1), Constant(value=')\n')])], keywords=[])), Raise()])], orelse=[], finalbody=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='<<leaving '), FormattedValue(value=Name(id='thisFunc', ctx=Load()), conversion=-1), Constant(value=' (ret: '), FormattedValue(value=Name(id='ret', ctx=Load()), conversion=114), Constant(value=')\n')])], keywords=[])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='z', ctx=Load()), attr='__name__', ctx=Store())], value=Attribute(value=Name(id='f', ctx=Load()), attr='__name__', ctx=Load())), Return(value=Name(id='z', ctx=Load()))], decorator_list=[], returns=Name(id='ParseAction', ctx=Load())), Assign(targets=[Name(id='empty', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='empty')], keywords=[])), Assign(targets=[Name(id='line_start', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='LineStart', ctx=Load()), args=[], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='line_start')], keywords=[])), Assign(targets=[Name(id='line_end', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='LineEnd', ctx=Load()), args=[], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='line_end')], keywords=[])), Assign(targets=[Name(id='string_start', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='StringStart', ctx=Load()), args=[], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='string_start')], keywords=[])), Assign(targets=[Name(id='string_end', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='StringEnd', ctx=Load()), args=[], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='string_end')], keywords=[])), Assign(targets=[Name(id='_escapedPunc', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='\\\\[\\\\[\\]\\/\\-\\*\\.\\$\\+\\^\\?()~ ]')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Subscript(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value=1), ctx=Load()))], keywords=[])), Assign(targets=[Name(id='_escapedHexChar', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='\\\\0?[xX][0-9a-fA-F]+')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='chr', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='lstrip', ctx=Load()), args=[Constant(value='\\0x')], keywords=[]), Constant(value=16)], keywords=[])], keywords=[]))], keywords=[])), Assign(targets=[Name(id='_escapedOctChar', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='\\\\0[0-7]+')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='chr', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), Constant(value=8)], keywords=[])], keywords=[]))], keywords=[])), Assign(targets=[Name(id='_singleChar', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Name(id='_escapedPunc', ctx=Load()), op=BitOr(), right=Name(id='_escapedHexChar', ctx=Load())), op=BitOr(), right=Name(id='_escapedOctChar', ctx=Load())), op=BitOr(), right=Call(func=Name(id='CharsNotIn', ctx=Load()), args=[Constant(value='\\]')], keywords=[keyword(arg='exact', value=Constant(value=1))]))), Assign(targets=[Name(id='_charRange', ctx=Store())], value=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='_singleChar', ctx=Load()), op=Add(), right=Call(func=Name(id='Suppress', ctx=Load()), args=[Constant(value='-')], keywords=[])), op=Add(), right=Name(id='_singleChar', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='_reBracketExpr', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id='Literal', ctx=Load()), args=[Constant(value='[')], keywords=[]), op=Add(), right=Call(func=Attribute(value=Call(func=Name(id='Opt', ctx=Load()), args=[Constant(value='^')], keywords=[]), attr='set_results_name', ctx=Load()), args=[Constant(value='negate')], keywords=[])), op=Add(), right=Call(func=Attribute(value=Call(func=Name(id='Group', ctx=Load()), args=[Call(func=Name(id='OneOrMore', ctx=Load()), args=[BinOp(left=Name(id='_charRange', ctx=Load()), op=BitOr(), right=Name(id='_singleChar', ctx=Load()))], keywords=[])], keywords=[]), attr='set_results_name', ctx=Load()), args=[Constant(value='body')], keywords=[])), op=Add(), right=Call(func=Name(id='Literal', ctx=Load()), args=[Constant(value=']')], keywords=[]))), FunctionDef(name='srange', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper to easily define string ranges for use in :class:`Word`\n    construction. Borrows syntax from regexp ``\'[]\'`` string range\n    definitions::\n\n        srange("[0-9]")   -> "0123456789"\n        srange("[a-z]")   -> "abcdefghijklmnopqrstuvwxyz"\n        srange("[a-z$_]") -> "abcdefghijklmnopqrstuvwxyz$_"\n\n    The input string must be enclosed in []\'s, and the returned string\n    is the expanded character set joined into a single string. The\n    values enclosed in the []\'s may be:\n\n    - a single character\n    - an escaped character with a leading backslash (such as ``\\-``\n      or ``\\]``)\n    - an escaped hex character with a leading ``\'\\x\'``\n      (``\\x21``, which is a ``\'!\'`` character) (``\\0x##``\n      is also supported for backwards compatibility)\n    - an escaped octal character with a leading ``\'\\0\'``\n      (``\\041``, which is a ``\'!\'`` character)\n    - a range of any of the above, separated by a dash (``\'a-z\'``,\n      etc.)\n    - any combination of the above (``\'aeiouy\'``,\n      ``\'a-zA-Z0-9_$\'``, etc.)\n    ')), Assign(targets=[Name(id='_expanded', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='p')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=IfExp(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='p', ctx=Load()), Name(id='ParseResults', ctx=Load())], keywords=[])), body=Name(id='p', ctx=Load()), orelse=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='chr', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='c', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='ord', ctx=Load()), args=[Subscript(value=Name(id='p', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), BinOp(left=Call(func=Name(id='ord', ctx=Load()), args=[Subscript(value=Name(id='p', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1))], keywords=[]), ifs=[], is_async=0)])], keywords=[])))), Try(body=[Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_expanded', ctx=Load()), args=[Name(id='part', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='part', ctx=Store()), iter=Attribute(value=Call(func=Attribute(value=Name(id='_reBracketExpr', ctx=Load()), attr='parse_string', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]), attr='body', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Return(value=Constant(value=''))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='token_map', args=arguments(posonlyargs=[], args=[arg(arg='func')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Helper to define a parse action by mapping a function to all\n    elements of a :class:`ParseResults` list. If any additional args are passed,\n    they are forwarded to the given function as additional arguments\n    after the token, as in\n    ``hex_integer = Word(hexnums).set_parse_action(token_map(int, 16))``,\n    which will convert the parsed data to an integer using base 16.\n\n    Example (compare the last to example in :class:`ParserElement.transform_string`::\n\n        hex_ints = Word(hexnums)[1, ...].set_parse_action(token_map(int, 16))\n        hex_ints.run_tests('''\n            00 11 22 aa FF 0a 0d 1a\n            ''')\n\n        upperword = Word(alphas).set_parse_action(token_map(str.upper))\n        upperword[1, ...].run_tests('''\n            my kingdom for a horse\n            ''')\n\n        wd = Word(alphas).set_parse_action(token_map(str.title))\n        wd[1, ...].set_parse_action(' '.join).run_tests('''\n            now is the winter of our discontent made glorious summer by this sun of york\n            ''')\n\n    prints::\n\n        00 11 22 aa FF 0a 0d 1a\n        [0, 17, 34, 170, 255, 10, 13, 26]\n\n        my kingdom for a horse\n        ['MY', 'KINGDOM', 'FOR', 'A', 'HORSE']\n\n        now is the winter of our discontent made glorious summer by this sun of york\n        ['Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York']\n    ")), FunctionDef(name='pa', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=ListComp(elt=Call(func=Name(id='func', ctx=Load()), args=[Name(id='tokn', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='tokn', ctx=Store()), iter=Name(id='t', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[]), Assign(targets=[Name(id='func_name', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__name__'), Attribute(value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='func', ctx=Load()), Constant(value='__class__')], keywords=[]), attr='__name__', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='pa', ctx=Load()), attr='__name__', ctx=Store())], value=Name(id='func_name', ctx=Load())), Return(value=Name(id='pa', ctx=Load()))], decorator_list=[], returns=Name(id='ParseAction', ctx=Load())), FunctionDef(name='autoname_elements', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Utility to simplify mass-naming of parser elements, for\n    generating railroad diagram with named subdiagrams.\n    ')), Assign(targets=[Name(id='calling_frame', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='_getframe', ctx=Load()), args=[], keywords=[]), attr='f_back', ctx=Load())), If(test=Compare(left=Name(id='calling_frame', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return()], orelse=[]), Assign(targets=[Name(id='calling_frame', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Attribute(value=Name(id='types', ctx=Load()), attr='FrameType', ctx=Load()), Name(id='calling_frame', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='name', ctx=Store()), Name(id='var', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='calling_frame', ctx=Load()), attr='f_locals', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='var', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='var', ctx=Load()), attr='customName', ctx=Load()))]), body=[Expr(value=Call(func=Attribute(value=Name(id='var', ctx=Load()), attr='set_name', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[], returns=Constant(value=None)), Assign(targets=[Name(id='dbl_quoted_string', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[BinOp(left=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='"(?:[^"\\n\\r\\\\]|(?:"")|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*')], keywords=[]), op=Add(), right=Constant(value='"'))], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='string enclosed in double quotes')], keywords=[])), Assign(targets=[Name(id='sgl_quoted_string', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[BinOp(left=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value="'(?:[^'\\n\\r\\\\]|(?:'')|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*")], keywords=[]), op=Add(), right=Constant(value="'"))], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='string enclosed in single quotes')], keywords=[])), Assign(targets=[Name(id='quoted_string', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=BinOp(left=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='"(?:[^"\\n\\r\\\\]|(?:"")|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*')], keywords=[]), op=Add(), right=Constant(value='"')), attr='set_name', ctx=Load()), args=[Constant(value='double quoted string')], keywords=[]), op=BitOr(), right=Call(func=Attribute(value=BinOp(left=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value="'(?:[^'\\n\\r\\\\]|(?:'')|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*")], keywords=[]), op=Add(), right=Constant(value="'")), attr='set_name', ctx=Load()), args=[Constant(value='single quoted string')], keywords=[]))], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='quoted string using single or double quotes')], keywords=[])), Assign(targets=[Name(id='python_quoted_string', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Call(func=Attribute(value=BinOp(left=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='"""(?:[^"\\\\]|""(?!")|"(?!"")|\\\\.)*')], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load()))]), op=Add(), right=Constant(value='"""')), attr='set_name', ctx=Load()), args=[Constant(value='multiline double quoted string')], keywords=[]), op=BitXor(), right=Call(func=Attribute(value=BinOp(left=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value="'''(?:[^'\\\\]|''(?!')|'(?!'')|\\\\.)*")], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load()))]), op=Add(), right=Constant(value="'''")), attr='set_name', ctx=Load()), args=[Constant(value='multiline single quoted string')], keywords=[])), op=BitXor(), right=Call(func=Attribute(value=BinOp(left=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='"(?:[^"\\n\\r\\\\]|(?:\\\\")|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*')], keywords=[]), op=Add(), right=Constant(value='"')), attr='set_name', ctx=Load()), args=[Constant(value='double quoted string')], keywords=[])), op=BitXor(), right=Call(func=Attribute(value=BinOp(left=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value="'(?:[^'\\n\\r\\\\]|(?:\\\\')|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*")], keywords=[]), op=Add(), right=Constant(value="'")), attr='set_name', ctx=Load()), args=[Constant(value='single quoted string')], keywords=[]))], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='Python quoted string')], keywords=[])), Assign(targets=[Name(id='unicode_string', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[BinOp(left=Constant(value='u'), op=Add(), right=Call(func=Attribute(value=Name(id='quoted_string', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='unicode string literal')], keywords=[])), Assign(targets=[Name(id='alphas8bit', ctx=Store())], value=Call(func=Name(id='srange', ctx=Load()), args=[Constant(value='[\\0xc0-\\0xd6\\0xd8-\\0xf6\\0xf8-\\0xff]')], keywords=[])), Assign(targets=[Name(id='punc8bit', ctx=Store())], value=Call(func=Name(id='srange', ctx=Load()), args=[Constant(value='[\\0xa1-\\0xbf\\0xd7\\0xf7]')], keywords=[])), AnnAssign(target=Name(id='_builtin_exprs', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load()), value=ListComp(elt=Name(id='v', ctx=Load()), generators=[comprehension(target=Name(id='v', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[], keywords=[]), attr='values', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='v', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])], is_async=0)]), simple=1), Assign(targets=[Name(id='sglQuotedString', ctx=Store())], value=Name(id='sgl_quoted_string', ctx=Load())), Assign(targets=[Name(id='dblQuotedString', ctx=Store())], value=Name(id='dbl_quoted_string', ctx=Load())), Assign(targets=[Name(id='quotedString', ctx=Store())], value=Name(id='quoted_string', ctx=Load())), Assign(targets=[Name(id='unicodeString', ctx=Store())], value=Name(id='unicode_string', ctx=Load())), Assign(targets=[Name(id='lineStart', ctx=Store())], value=Name(id='line_start', ctx=Load())), Assign(targets=[Name(id='lineEnd', ctx=Store())], value=Name(id='line_end', ctx=Load())), Assign(targets=[Name(id='stringStart', ctx=Store())], value=Name(id='string_start', ctx=Load())), Assign(targets=[Name(id='stringEnd', ctx=Store())], value=Name(id='string_end', ctx=Load())), FunctionDef(name='nullDebugAction', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='null_debug_action', ctx=Load())], keywords=[])]), FunctionDef(name='traceParseAction', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='trace_parse_action', ctx=Load())], keywords=[])]), FunctionDef(name='conditionAsParseAction', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='condition_as_parse_action', ctx=Load())], keywords=[])]), FunctionDef(name='tokenMap', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='token_map', ctx=Load())], keywords=[])])], type_ignores=[])