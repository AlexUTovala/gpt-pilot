Module(body=[Import(names=[alias(name='html.entities')]), Import(names=[alias(name='re')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='typing')]), ImportFrom(names=[alias(name='__diag__')], level=1), ImportFrom(module='core', names=[alias(name='*')], level=1), ImportFrom(module='util', names=[alias(name='_bslash'), alias(name='_flatten'), alias(name='_escape_regex_range_chars'), alias(name='replaced_by_pep8')], level=1), FunctionDef(name='counted_array', args=arguments(posonlyargs=[], args=[arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load())), arg(arg='int_expr', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='intExpr', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value=None)], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Helper to define a counted list of expressions.\n\n    This helper defines a pattern of the form::\n\n        integer expr expr expr...\n\n    where the leading integer tells how many expr expressions follow.\n    The matched tokens returns the array of expr tokens as a list - the\n    leading count token is suppressed.\n\n    If ``int_expr`` is specified, it should be a pyparsing expression\n    that produces an integer value.\n\n    Example::\n\n        counted_array(Word(alphas)).parse_string(\'2 ab cd ef\')  # -> [\'ab\', \'cd\']\n\n        # in this parser, the leading integer value is given in binary,\n        # \'10\' indicating that 2 values are in the array\n        binary_constant = Word(\'01\').set_parse_action(lambda t: int(t[0], 2))\n        counted_array(Word(alphas), int_expr=binary_constant).parse_string(\'10 ab cd ef\')  # -> [\'ab\', \'cd\']\n\n        # if other fields must be parsed after the count but before the\n        # list items, give the fields results names and they will\n        # be preserved in the returned ParseResults:\n        count_with_metadata = integer + Word(alphas)("type")\n        typed_array = counted_array(Word(alphanums), int_expr=count_with_metadata)("items")\n        result = typed_array.parse_string("3 bool True True False")\n        print(result.dump())\n\n        # prints\n        # [\'True\', \'True\', \'False\']\n        # - items: [\'True\', \'True\', \'False\']\n        # - type: \'bool\'\n    ')), Assign(targets=[Name(id='intExpr', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='intExpr', ctx=Load()), Name(id='int_expr', ctx=Load())])), Assign(targets=[Name(id='array_expr', ctx=Store())], value=Call(func=Name(id='Forward', ctx=Load()), args=[], keywords=[])), FunctionDef(name='count_field_parse_action', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Nonlocal(names=['array_expr']), Assign(targets=[Name(id='n', ctx=Store())], value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load())), AugAssign(target=Name(id='array_expr', ctx=Store()), op=LShift(), value=IfExp(test=Name(id='n', ctx=Load()), body=BinOp(left=Name(id='expr', ctx=Load()), op=Mult(), right=Name(id='n', ctx=Load())), orelse=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]))), Delete(targets=[Subscript(value=Name(id='t', ctx=Load()), slice=Slice(), ctx=Del())])], decorator_list=[]), If(test=Compare(left=Name(id='intExpr', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='intExpr', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Word', ctx=Load()), args=[Name(id='nums', ctx=Load())], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], keywords=[]))], orelse=[Assign(targets=[Name(id='intExpr', ctx=Store())], value=Call(func=Attribute(value=Name(id='intExpr', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='intExpr', ctx=Load()), attr='set_name', ctx=Load()), args=[Constant(value='arrayLen')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='intExpr', ctx=Load()), attr='add_parse_action', ctx=Load()), args=[Name(id='count_field_parse_action', ctx=Load())], keywords=[keyword(arg='call_during_try', value=Constant(value=True))])), Return(value=Call(func=Attribute(value=BinOp(left=Name(id='intExpr', ctx=Load()), op=Add(), right=Name(id='array_expr', ctx=Load())), attr='set_name', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value='(len) '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[])), op=Add(), right=Constant(value='...'))], keywords=[]))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='match_previous_literal', args=arguments(posonlyargs=[], args=[arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper to define an expression that is indirectly defined from\n    the tokens matched in a previous expression, that is, it looks for\n    a \'repeat\' of a previous expression.  For example::\n\n        first = Word(nums)\n        second = match_previous_literal(first)\n        match_expr = first + ":" + second\n\n    will match ``"1:1"``, but not ``"1:2"``.  Because this\n    matches a previous literal, will also match the leading\n    ``"1:1"`` in ``"1:10"``. If this is not desired, use\n    :class:`match_previous_expr`. Do *not* use with packrat parsing\n    enabled.\n    ')), Assign(targets=[Name(id='rep', ctx=Store())], value=Call(func=Name(id='Forward', ctx=Load()), args=[], keywords=[])), FunctionDef(name='copy_token_to_repeater', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Name(id='t', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='t', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Expr(value=BinOp(left=Name(id='rep', ctx=Load()), op=LShift(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load())))], orelse=[Assign(targets=[Name(id='tflat', ctx=Store())], value=Call(func=Name(id='_flatten', ctx=Load()), args=[Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='as_list', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=BinOp(left=Name(id='rep', ctx=Load()), op=LShift(), right=Call(func=Name(id='And', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='Literal', ctx=Load()), args=[Name(id='tt', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='tt', ctx=Store()), iter=Name(id='tflat', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))])], orelse=[Expr(value=BinOp(left=Name(id='rep', ctx=Load()), op=LShift(), right=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[])))])], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='expr', ctx=Load()), attr='add_parse_action', ctx=Load()), args=[Name(id='copy_token_to_repeater', ctx=Load())], keywords=[keyword(arg='callDuringTry', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Name(id='rep', ctx=Load()), attr='set_name', ctx=Load()), args=[BinOp(left=Constant(value='(prev) '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[]))], keywords=[])), Return(value=Name(id='rep', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='match_previous_expr', args=arguments(posonlyargs=[], args=[arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper to define an expression that is indirectly defined from\n    the tokens matched in a previous expression, that is, it looks for\n    a \'repeat\' of a previous expression.  For example::\n\n        first = Word(nums)\n        second = match_previous_expr(first)\n        match_expr = first + ":" + second\n\n    will match ``"1:1"``, but not ``"1:2"``.  Because this\n    matches by expressions, will *not* match the leading ``"1:1"``\n    in ``"1:10"``; the expressions are evaluated first, and then\n    compared, so ``"1"`` is compared with ``"10"``. Do *not* use\n    with packrat parsing enabled.\n    ')), Assign(targets=[Name(id='rep', ctx=Store())], value=Call(func=Name(id='Forward', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='e2', ctx=Store())], value=Call(func=Attribute(value=Name(id='expr', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='rep', ctx=Store()), op=LShift(), value=Name(id='e2', ctx=Load())), FunctionDef(name='copy_token_to_repeater', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='matchTokens', ctx=Store())], value=Call(func=Name(id='_flatten', ctx=Load()), args=[Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='as_list', ctx=Load()), args=[], keywords=[])], keywords=[])), FunctionDef(name='must_match_these_tokens', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='theseTokens', ctx=Store())], value=Call(func=Name(id='_flatten', ctx=Load()), args=[Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='as_list', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='theseTokens', ctx=Load()), ops=[NotEq()], comparators=[Name(id='matchTokens', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), JoinedStr(values=[Constant(value='Expected '), FormattedValue(value=Name(id='matchTokens', ctx=Load()), conversion=-1), Constant(value=', found'), FormattedValue(value=Name(id='theseTokens', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='rep', ctx=Load()), attr='set_parse_action', ctx=Load()), args=[Name(id='must_match_these_tokens', ctx=Load())], keywords=[keyword(arg='callDuringTry', value=Constant(value=True))]))], decorator_list=[]), Expr(value=Call(func=Attribute(value=Name(id='expr', ctx=Load()), attr='add_parse_action', ctx=Load()), args=[Name(id='copy_token_to_repeater', ctx=Load())], keywords=[keyword(arg='callDuringTry', value=Constant(value=True))])), Expr(value=Call(func=Attribute(value=Name(id='rep', ctx=Load()), attr='set_name', ctx=Load()), args=[BinOp(left=Constant(value='(prev) '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[]))], keywords=[])), Return(value=Name(id='rep', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='one_of', args=arguments(posonlyargs=[], args=[arg(arg='strs', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='caseless', annotation=Name(id='bool', ctx=Load())), arg(arg='use_regex', annotation=Name(id='bool', ctx=Load())), arg(arg='as_keyword', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='useRegex', annotation=Name(id='bool', ctx=Load())), arg(arg='asKeyword', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=True), Constant(value=False)], defaults=[Constant(value=False), Constant(value=True), Constant(value=False)]), body=[Expr(value=Constant(value='Helper to quickly define a set of alternative :class:`Literal` s,\n    and makes sure to do longest-first testing when there is a conflict,\n    regardless of the input order, but returns\n    a :class:`MatchFirst` for best performance.\n\n    Parameters:\n\n    - ``strs`` - a string of space-delimited literals, or a collection of\n      string literals\n    - ``caseless`` - treat all literals as caseless - (default= ``False``)\n    - ``use_regex`` - as an optimization, will\n      generate a :class:`Regex` object; otherwise, will generate\n      a :class:`MatchFirst` object (if ``caseless=True`` or ``as_keyword=True``, or if\n      creating a :class:`Regex` raises an exception) - (default= ``True``)\n    - ``as_keyword`` - enforce :class:`Keyword`-style matching on the\n      generated expressions - (default= ``False``)\n    - ``asKeyword`` and ``useRegex`` are retained for pre-PEP8 compatibility,\n      but will be removed in a future release\n\n    Example::\n\n        comp_oper = one_of("< = > <= >= !=")\n        var = Word(alphas)\n        number = Word(nums)\n        term = var | number\n        comparison_expr = term + comp_oper + term\n        print(comparison_expr.search_string("B = 12  AA=23 B<=AA AA>12"))\n\n    prints::\n\n        [[\'B\', \'=\', \'12\'], [\'AA\', \'=\', \'23\'], [\'B\', \'<=\', \'AA\'], [\'AA\', \'>\', \'12\']]\n    ')), Assign(targets=[Name(id='asKeyword', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='asKeyword', ctx=Load()), Name(id='as_keyword', ctx=Load())])), Assign(targets=[Name(id='useRegex', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='useRegex', ctx=Load()), Name(id='use_regex', ctx=Load())])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='caseless', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), Attribute(value=Name(id='__diag__', ctx=Load()), attr='warn_on_multiple_string_args_to_oneof', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='More than one string argument passed to one_of, pass choices as a list or space-delimited string')], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))], orelse=[]), If(test=Name(id='caseless', ctx=Load()), body=[Assign(targets=[Name(id='isequal', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Call(func=Attribute(value=Name(id='a', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[])]))), Assign(targets=[Name(id='masks', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Call(func=Attribute(value=Name(id='a', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[])], keywords=[]))), Assign(targets=[Name(id='parseElementClass', ctx=Store())], value=IfExp(test=Name(id='asKeyword', ctx=Load()), body=Name(id='CaselessKeyword', ctx=Load()), orelse=Name(id='CaselessLiteral', ctx=Load())))], orelse=[Assign(targets=[Name(id='isequal', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Name(id='b', ctx=Load())]))), Assign(targets=[Name(id='masks', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='parseElementClass', ctx=Store())], value=IfExp(test=Name(id='asKeyword', ctx=Load()), body=Name(id='Keyword', ctx=Load()), orelse=Name(id='Literal', ctx=Load())))]), AnnAssign(target=Name(id='symbols', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='strs', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='strs', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='strs', ctx=Load())], keywords=[])), Assign(targets=[Name(id='symbols', ctx=Store())], value=Call(func=Attribute(value=Name(id='strs', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='strs', ctx=Load()), Name(id='Iterable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='symbols', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='strs', ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Invalid argument to one_of, expected string or iterable')], keywords=[]))])]), If(test=UnaryOp(op=Not(), operand=Name(id='symbols', ctx=Load())), body=[Return(value=Call(func=Name(id='NoMatch', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sym', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), generators=[comprehension(target=Name(id='sym', ctx=Store()), iter=Name(id='symbols', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='i', ctx=Store())], value=Constant(value=0)), While(test=Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='symbols', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))]), body=[Assign(targets=[Name(id='cur', ctx=Store())], value=Subscript(value=Name(id='symbols', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())), For(target=Tuple(elts=[Name(id='j', ctx=Store()), Name(id='other', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Subscript(value=Name(id='symbols', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isequal', ctx=Load()), args=[Name(id='other', ctx=Load()), Name(id='cur', ctx=Load())], keywords=[]), body=[Delete(targets=[Subscript(value=Name(id='symbols', ctx=Load()), slice=BinOp(left=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Name(id='j', ctx=Load())), op=Add(), right=Constant(value=1)), ctx=Del())]), Break()], orelse=[If(test=Call(func=Name(id='masks', ctx=Load()), args=[Name(id='cur', ctx=Load()), Name(id='other', ctx=Load())], keywords=[]), body=[Delete(targets=[Subscript(value=Name(id='symbols', ctx=Load()), slice=BinOp(left=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Name(id='j', ctx=Load())), op=Add(), right=Constant(value=1)), ctx=Del())]), Expr(value=Call(func=Attribute(value=Name(id='symbols', ctx=Load()), attr='insert', ctx=Load()), args=[Name(id='i', ctx=Load()), Name(id='other', ctx=Load())], keywords=[])), Break()], orelse=[])])], orelse=[AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Constant(value=1))])], orelse=[])], orelse=[]), If(test=Name(id='useRegex', ctx=Load()), body=[AnnAssign(target=Name(id='re_flags', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=IfExp(test=Name(id='caseless', ctx=Load()), body=Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load()), orelse=Constant(value=0)), simple=1), Try(body=[If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='sym', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), generators=[comprehension(target=Name(id='sym', ctx=Store()), iter=Name(id='symbols', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='patt', ctx=Store())], value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='_escape_regex_range_chars', ctx=Load()), args=[Name(id='sym', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='sym', ctx=Store()), iter=Name(id='symbols', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), conversion=-1), Constant(value=']')]))], orelse=[Assign(targets=[Name(id='patt', ctx=Store())], value=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='sym', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='sym', ctx=Store()), iter=Name(id='symbols', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))]), If(test=Name(id='asKeyword', ctx=Load()), body=[Assign(targets=[Name(id='patt', ctx=Store())], value=JoinedStr(values=[Constant(value='\\b(?:'), FormattedValue(value=Name(id='patt', ctx=Load()), conversion=-1), Constant(value=')\\b')]))], orelse=[]), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Name(id='patt', ctx=Load())], keywords=[keyword(arg='flags', value=Name(id='re_flags', ctx=Load()))]), attr='set_name', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=' | '), attr='join', ctx=Load()), args=[Name(id='symbols', ctx=Load())], keywords=[])], keywords=[])), If(test=Name(id='caseless', ctx=Load()), body=[Assign(targets=[Name(id='symbol_map', ctx=Store())], value=DictComp(key=Call(func=Attribute(value=Name(id='sym', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), value=Name(id='sym', ctx=Load()), generators=[comprehension(target=Name(id='sym', ctx=Store()), iter=Name(id='symbols', ctx=Load()), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='add_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Subscript(value=Name(id='symbol_map', ctx=Load()), slice=Call(func=Attribute(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Name(id='ret', ctx=Load()))], handlers=[ExceptHandler(type=Attribute(value=Name(id='re', ctx=Load()), attr='error', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='Exception creating Regex for one_of, building MatchFirst')], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))])], orelse=[], finalbody=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Name(id='MatchFirst', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='parseElementClass', ctx=Load()), args=[Name(id='sym', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='sym', ctx=Store()), iter=Name(id='symbols', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), attr='set_name', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=' | '), attr='join', ctx=Load()), args=[Name(id='symbols', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='dict_of', args=arguments(posonlyargs=[], args=[arg(arg='key', annotation=Name(id='ParserElement', ctx=Load())), arg(arg='value', annotation=Name(id='ParserElement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper to easily and clearly define a dictionary by specifying\n    the respective patterns for the key and value.  Takes care of\n    defining the :class:`Dict`, :class:`ZeroOrMore`, and\n    :class:`Group` tokens in the proper order.  The key pattern\n    can include delimiting markers or punctuation, as long as they are\n    suppressed, thereby leaving the significant key text.  The value\n    pattern can include named results, so that the :class:`Dict` results\n    can include named token fields.\n\n    Example::\n\n        text = "shape: SQUARE posn: upper left color: light blue texture: burlap"\n        attr_expr = (label + Suppress(\':\') + OneOrMore(data_word, stop_on=label).set_parse_action(\' \'.join))\n        print(attr_expr[1, ...].parse_string(text).dump())\n\n        attr_label = label\n        attr_value = Suppress(\':\') + OneOrMore(data_word, stop_on=label).set_parse_action(\' \'.join)\n\n        # similar to Dict, but simpler call format\n        result = dict_of(attr_label, attr_value).parse_string(text)\n        print(result.dump())\n        print(result[\'shape\'])\n        print(result.shape)  # object attribute access works too\n        print(result.as_dict())\n\n    prints::\n\n        [[\'shape\', \'SQUARE\'], [\'posn\', \'upper left\'], [\'color\', \'light blue\'], [\'texture\', \'burlap\']]\n        - color: \'light blue\'\n        - posn: \'upper left\'\n        - shape: \'SQUARE\'\n        - texture: \'burlap\'\n        SQUARE\n        SQUARE\n        {\'color\': \'light blue\', \'shape\': \'SQUARE\', \'posn\': \'upper left\', \'texture\': \'burlap\'}\n    ')), Return(value=Call(func=Name(id='Dict', ctx=Load()), args=[Call(func=Name(id='OneOrMore', ctx=Load()), args=[Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=Name(id='key', ctx=Load()), op=Add(), right=Name(id='value', ctx=Load()))], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='original_text_for', args=arguments(posonlyargs=[], args=[arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load())), arg(arg='as_string', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[arg(arg='asString', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=True)], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Helper to return the original, untokenized text for a given\n    expression.  Useful to restore the parsed fields of an HTML start\n    tag into the raw tag text itself, or to revert separate tokens with\n    intervening whitespace back to the original matching input text. By\n    default, returns a string containing the original parsed text.\n\n    If the optional ``as_string`` argument is passed as\n    ``False``, then the return value is\n    a :class:`ParseResults` containing any results names that\n    were originally matched, and a single token containing the original\n    matched text from the input string.  So if the expression passed to\n    :class:`original_text_for` contains expressions with defined\n    results names, you must set ``as_string`` to ``False`` if you\n    want to preserve those results name values.\n\n    The ``asString`` pre-PEP8 argument is retained for compatibility,\n    but will be removed in a future release.\n\n    Example::\n\n        src = "this is test <b> bold <i>text</i> </b> normal text "\n        for tag in ("b", "i"):\n            opener, closer = make_html_tags(tag)\n            patt = original_text_for(opener + ... + closer)\n            print(patt.search_string(src)[0])\n\n    prints::\n\n        [\'<b> bold <i>text</i> </b>\']\n        [\'<i>text</i>\']\n    ')), Assign(targets=[Name(id='asString', ctx=Store())], value=BoolOp(op=And(), values=[Name(id='asString', ctx=Load()), Name(id='as_string', ctx=Load())])), Assign(targets=[Name(id='locMarker', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='loc'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='loc', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='endlocMarker', ctx=Store())], value=Call(func=Attribute(value=Name(id='locMarker', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='endlocMarker', ctx=Load()), attr='callPreparse', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='matchExpr', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='locMarker', ctx=Load()), args=[Constant(value='_original_start')], keywords=[]), op=Add(), right=Name(id='expr', ctx=Load())), op=Add(), right=Call(func=Name(id='endlocMarker', ctx=Load()), args=[Constant(value='_original_end')], keywords=[]))), If(test=Name(id='asString', ctx=Load()), body=[Assign(targets=[Name(id='extractText', ctx=Store())], value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Subscript(value=Name(id='s', ctx=Load()), slice=Slice(lower=Attribute(value=Name(id='t', ctx=Load()), attr='_original_start', ctx=Load()), upper=Attribute(value=Name(id='t', ctx=Load()), attr='_original_end', ctx=Load())), ctx=Load())))], orelse=[FunctionDef(name='extractText', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Subscript(value=Name(id='t', ctx=Load()), slice=Slice(), ctx=Store())], value=List(elts=[Subscript(value=Name(id='s', ctx=Load()), slice=Slice(lower=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='_original_start')], keywords=[]), upper=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='_original_end')], keywords=[])), ctx=Load())], ctx=Load()))], decorator_list=[])]), Expr(value=Call(func=Attribute(value=Name(id='matchExpr', ctx=Load()), attr='set_parse_action', ctx=Load()), args=[Name(id='extractText', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='matchExpr', ctx=Load()), attr='ignoreExprs', ctx=Store())], value=Attribute(value=Name(id='expr', ctx=Load()), attr='ignoreExprs', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='matchExpr', ctx=Load()), attr='suppress_warning', ctx=Load()), args=[Attribute(value=Name(id='Diagnostics', ctx=Load()), attr='warn_ungrouped_named_tokens_in_collection', ctx=Load())], keywords=[])), Return(value=Name(id='matchExpr', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='ungroup', args=arguments(posonlyargs=[], args=[arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Helper to undo pyparsing's default grouping of And expressions,\n    even if all but one are non-empty.\n    ")), Return(value=Call(func=Attribute(value=Call(func=Name(id='TokenConverter', ctx=Load()), args=[Name(id='expr', ctx=Load())], keywords=[]), attr='add_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()))], keywords=[]))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='locatedExpr', args=arguments(posonlyargs=[], args=[arg(arg='expr', annotation=Name(id='ParserElement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    (DEPRECATED - future code should use the :class:`Located` class)\n    Helper to decorate a returned token with its starting and ending\n    locations in the input string.\n\n    This helper adds the following results names:\n\n    - ``locn_start`` - location where matched expression begins\n    - ``locn_end`` - location where matched expression ends\n    - ``value`` - the actual parsed results\n\n    Be careful if the input text contains ``<TAB>`` characters, you\n    may want to call :class:`ParserElement.parse_with_tabs`\n\n    Example::\n\n        wd = Word(alphas)\n        for match in locatedExpr(wd).search_string("ljsdf123lksdjjf123lkkjj1222"):\n            print(match)\n\n    prints::\n\n        [[0, \'ljsdf\', 5]]\n        [[8, \'lksdjjf\', 15]]\n        [[18, \'lkkjj\', 23]]\n    ')), Assign(targets=[Name(id='locator', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='ss'), arg(arg='ll'), arg(arg='tt')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Name(id='ll', ctx=Load()))], keywords=[])), Return(value=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Name(id='locator', ctx=Load()), args=[Constant(value='locn_start')], keywords=[]), op=Add(), right=Call(func=Name(id='expr', ctx=Load()), args=[Constant(value='value')], keywords=[])), op=Add(), right=Call(func=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='locator', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), attr='leaveWhitespace', ctx=Load()), args=[], keywords=[]), args=[Constant(value='locn_end')], keywords=[]))], keywords=[]))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='nested_expr', args=arguments(posonlyargs=[], args=[arg(arg='opener', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='closer', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='content', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load())), arg(arg='ignore_expr', annotation=Name(id='ParserElement', ctx=Load()))], kwonlyargs=[arg(arg='ignoreExpr', annotation=Name(id='ParserElement', ctx=Load()))], kw_defaults=[Call(func=Name(id='quoted_string', ctx=Load()), args=[], keywords=[])], defaults=[Constant(value='('), Constant(value=')'), Constant(value=None), Call(func=Name(id='quoted_string', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Constant(value='Helper method for defining nested lists enclosed in opening and\n    closing delimiters (``"("`` and ``")"`` are the default).\n\n    Parameters:\n\n    - ``opener`` - opening character for a nested list\n      (default= ``"("``); can also be a pyparsing expression\n    - ``closer`` - closing character for a nested list\n      (default= ``")"``); can also be a pyparsing expression\n    - ``content`` - expression for items within the nested lists\n      (default= ``None``)\n    - ``ignore_expr`` - expression for ignoring opening and closing delimiters\n      (default= :class:`quoted_string`)\n    - ``ignoreExpr`` - this pre-PEP8 argument is retained for compatibility\n      but will be removed in a future release\n\n    If an expression is not provided for the content argument, the\n    nested expression will capture all whitespace-delimited content\n    between delimiters as a list of separate values.\n\n    Use the ``ignore_expr`` argument to define expressions that may\n    contain opening or closing characters that should not be treated as\n    opening or closing characters for nesting, such as quoted_string or\n    a comment expression.  Specify multiple expressions using an\n    :class:`Or` or :class:`MatchFirst`. The default is\n    :class:`quoted_string`, but if no expressions are to be ignored, then\n    pass ``None`` for this argument.\n\n    Example::\n\n        data_type = one_of("void int short long char float double")\n        decl_data_type = Combine(data_type + Opt(Word(\'*\')))\n        ident = Word(alphas+\'_\', alphanums+\'_\')\n        number = pyparsing_common.number\n        arg = Group(decl_data_type + ident)\n        LPAR, RPAR = map(Suppress, "()")\n\n        code_body = nested_expr(\'{\', \'}\', ignore_expr=(quoted_string | c_style_comment))\n\n        c_function = (decl_data_type("type")\n                      + ident("name")\n                      + LPAR + Opt(DelimitedList(arg), [])("args") + RPAR\n                      + code_body("body"))\n        c_function.ignore(c_style_comment)\n\n        source_code = \'\'\'\n            int is_odd(int x) {\n                return (x%2);\n            }\n\n            int dec_to_hex(char hchar) {\n                if (hchar >= \'0\' && hchar <= \'9\') {\n                    return (ord(hchar)-ord(\'0\'));\n                } else {\n                    return (10+ord(hchar)-ord(\'A\'));\n                }\n            }\n        \'\'\'\n        for func in c_function.search_string(source_code):\n            print("%(name)s (%(type)s) args: %(args)s" % func)\n\n\n    prints::\n\n        is_odd (int) args: [[\'int\', \'x\']]\n        dec_to_hex (int) args: [[\'char\', \'hchar\']]\n    ')), If(test=Compare(left=Name(id='ignoreExpr', ctx=Load()), ops=[NotEq()], comparators=[Name(id='ignore_expr', ctx=Load())]), body=[Assign(targets=[Name(id='ignoreExpr', ctx=Store())], value=IfExp(test=Compare(left=Name(id='ignoreExpr', ctx=Load()), ops=[Eq()], comparators=[Call(func=Name(id='quoted_string', ctx=Load()), args=[], keywords=[])]), body=Name(id='ignore_expr', ctx=Load()), orelse=Name(id='ignoreExpr', ctx=Load())))], orelse=[]), If(test=Compare(left=Name(id='opener', ctx=Load()), ops=[Eq()], comparators=[Name(id='closer', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='opening and closing strings cannot be the same')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='content', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='opener', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='closer', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='opener', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='opener', ctx=Load())], keywords=[])), Assign(targets=[Name(id='closer', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='closer', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='opener', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='closer', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)])]), body=[If(test=Compare(left=Name(id='ignoreExpr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[Call(func=Name(id='OneOrMore', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Name(id='ignoreExpr', ctx=Load())), op=Add(), right=Call(func=Name(id='CharsNotIn', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='opener', ctx=Load()), op=Add(), right=Name(id='closer', ctx=Load())), op=Add(), right=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='DEFAULT_WHITE_CHARS', ctx=Load()))], keywords=[keyword(arg='exact', value=Constant(value=1))]))], keywords=[])], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], keywords=[]))], orelse=[Assign(targets=[Name(id='content', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='empty', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Attribute(value=Call(func=Name(id='CharsNotIn', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='opener', ctx=Load()), op=Add(), right=Name(id='closer', ctx=Load())), op=Add(), right=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='DEFAULT_WHITE_CHARS', ctx=Load()))], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], keywords=[])))])], orelse=[If(test=Compare(left=Name(id='ignoreExpr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[Call(func=Name(id='OneOrMore', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=UnaryOp(op=Invert(), operand=Name(id='ignoreExpr', ctx=Load())), op=Add(), right=UnaryOp(op=Invert(), operand=Call(func=Name(id='Literal', ctx=Load()), args=[Name(id='opener', ctx=Load())], keywords=[]))), op=Add(), right=UnaryOp(op=Invert(), operand=Call(func=Name(id='Literal', ctx=Load()), args=[Name(id='closer', ctx=Load())], keywords=[]))), op=Add(), right=Call(func=Name(id='CharsNotIn', ctx=Load()), args=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='DEFAULT_WHITE_CHARS', ctx=Load())], keywords=[keyword(arg='exact', value=Constant(value=1))]))], keywords=[])], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], keywords=[]))], orelse=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[Call(func=Name(id='OneOrMore', ctx=Load()), args=[BinOp(left=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='Literal', ctx=Load()), args=[Name(id='opener', ctx=Load())], keywords=[])), op=Add(), right=UnaryOp(op=Invert(), operand=Call(func=Name(id='Literal', ctx=Load()), args=[Name(id='closer', ctx=Load())], keywords=[]))), op=Add(), right=Call(func=Name(id='CharsNotIn', ctx=Load()), args=[Attribute(value=Name(id='ParserElement', ctx=Load()), attr='DEFAULT_WHITE_CHARS', ctx=Load())], keywords=[keyword(arg='exact', value=Constant(value=1))]))], keywords=[])], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], keywords=[]))])])], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='opening and closing arguments must be strings if no content expression is given')], keywords=[]))])], orelse=[]), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='Forward', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='ignoreExpr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=LShift(), value=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Name(id='Suppress', ctx=Load()), args=[Name(id='opener', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='ZeroOrMore', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='ignoreExpr', ctx=Load()), op=BitOr(), right=Name(id='ret', ctx=Load())), op=BitOr(), right=Name(id='content', ctx=Load()))], keywords=[])), op=Add(), right=Call(func=Name(id='Suppress', ctx=Load()), args=[Name(id='closer', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=LShift(), value=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Name(id='Suppress', ctx=Load()), args=[Name(id='opener', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='ZeroOrMore', ctx=Load()), args=[BinOp(left=Name(id='ret', ctx=Load()), op=BitOr(), right=Name(id='content', ctx=Load()))], keywords=[])), op=Add(), right=Call(func=Name(id='Suppress', ctx=Load()), args=[Name(id='closer', ctx=Load())], keywords=[]))], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='set_name', ctx=Load()), args=[BinOp(left=Constant(value='nested %s%s expression'), op=Mod(), right=Tuple(elts=[Name(id='opener', ctx=Load()), Name(id='closer', ctx=Load())], ctx=Load()))], keywords=[])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='_makeTags', args=arguments(posonlyargs=[], args=[arg(arg='tagStr'), arg(arg='xml'), arg(arg='suppress_LT'), arg(arg='suppress_GT')], kwonlyargs=[], kw_defaults=[], defaults=[Call(func=Name(id='Suppress', ctx=Load()), args=[Constant(value='<')], keywords=[]), Call(func=Name(id='Suppress', ctx=Load()), args=[Constant(value='>')], keywords=[])]), body=[Expr(value=Constant(value='Internal helper to construct opening and closing tag expressions, given a tag name')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='tagStr', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='resname', ctx=Store())], value=Name(id='tagStr', ctx=Load())), Assign(targets=[Name(id='tagStr', ctx=Store())], value=Call(func=Name(id='Keyword', ctx=Load()), args=[Name(id='tagStr', ctx=Load())], keywords=[keyword(arg='caseless', value=UnaryOp(op=Not(), operand=Name(id='xml', ctx=Load())))]))], orelse=[Assign(targets=[Name(id='resname', ctx=Store())], value=Attribute(value=Name(id='tagStr', ctx=Load()), attr='name', ctx=Load()))]), Assign(targets=[Name(id='tagAttrName', ctx=Store())], value=Call(func=Name(id='Word', ctx=Load()), args=[Name(id='alphas', ctx=Load()), BinOp(left=Name(id='alphanums', ctx=Load()), op=Add(), right=Constant(value='_-:'))], keywords=[])), If(test=Name(id='xml', ctx=Load()), body=[Assign(targets=[Name(id='tagAttrValue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='dbl_quoted_string', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='remove_quotes', ctx=Load())], keywords=[])), Assign(targets=[Name(id='openTag', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Name(id='suppress_LT', ctx=Load()), op=Add(), right=Call(func=Name(id='tagStr', ctx=Load()), args=[Constant(value='tag')], keywords=[])), op=Add(), right=Call(func=Name(id='Dict', ctx=Load()), args=[Call(func=Name(id='ZeroOrMore', ctx=Load()), args=[Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='tagAttrName', ctx=Load()), op=Add(), right=Call(func=Name(id='Suppress', ctx=Load()), args=[Constant(value='=')], keywords=[])), op=Add(), right=Name(id='tagAttrValue', ctx=Load()))], keywords=[])], keywords=[])], keywords=[])), op=Add(), right=Call(func=Attribute(value=Call(func=Call(func=Name(id='Opt', ctx=Load()), args=[Constant(value='/')], keywords=[keyword(arg='default', value=List(elts=[Constant(value=False)], ctx=Load()))]), args=[Constant(value='empty')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Constant(value='/')]))], keywords=[])), op=Add(), right=Name(id='suppress_GT', ctx=Load())))], orelse=[Assign(targets=[Name(id='tagAttrValue', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='quoted_string', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='remove_quotes', ctx=Load())], keywords=[]), op=BitOr(), right=Call(func=Name(id='Word', ctx=Load()), args=[Name(id='printables', ctx=Load())], keywords=[keyword(arg='exclude_chars', value=Constant(value='>'))]))), Assign(targets=[Name(id='openTag', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Name(id='suppress_LT', ctx=Load()), op=Add(), right=Call(func=Name(id='tagStr', ctx=Load()), args=[Constant(value='tag')], keywords=[])), op=Add(), right=Call(func=Name(id='Dict', ctx=Load()), args=[Call(func=Name(id='ZeroOrMore', ctx=Load()), args=[Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='tagAttrName', ctx=Load()), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]))], keywords=[]), op=Add(), right=Call(func=Name(id='Opt', ctx=Load()), args=[BinOp(left=Call(func=Name(id='Suppress', ctx=Load()), args=[Constant(value='=')], keywords=[]), op=Add(), right=Name(id='tagAttrValue', ctx=Load()))], keywords=[]))], keywords=[])], keywords=[])], keywords=[])), op=Add(), right=Call(func=Attribute(value=Call(func=Call(func=Name(id='Opt', ctx=Load()), args=[Constant(value='/')], keywords=[keyword(arg='default', value=List(elts=[Constant(value=False)], ctx=Load()))]), args=[Constant(value='empty')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Constant(value='/')]))], keywords=[])), op=Add(), right=Name(id='suppress_GT', ctx=Load())))]), Assign(targets=[Name(id='closeTag', ctx=Store())], value=Call(func=Name(id='Combine', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Name(id='Literal', ctx=Load()), args=[Constant(value='</')], keywords=[]), op=Add(), right=Name(id='tagStr', ctx=Load())), op=Add(), right=Constant(value='>'))], keywords=[keyword(arg='adjacent', value=Constant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='openTag', ctx=Load()), attr='set_name', ctx=Load()), args=[BinOp(left=Constant(value='<%s>'), op=Mod(), right=Name(id='resname', ctx=Load()))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='openTag', ctx=Load()), attr='add_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='__setitem__', ctx=Load()), args=[BinOp(left=Constant(value='start'), op=Add(), right=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='resname', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=':'), Constant(value=' ')], keywords=[]), attr='title', ctx=Load()), args=[], keywords=[]), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[])), Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])], keywords=[]))], keywords=[])), Assign(targets=[Name(id='closeTag', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='closeTag', ctx=Load()), args=[BinOp(left=Constant(value='end'), op=Add(), right=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='resname', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=':'), Constant(value=' ')], keywords=[]), attr='title', ctx=Load()), args=[], keywords=[]), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[]))], keywords=[]), attr='set_name', ctx=Load()), args=[BinOp(left=Constant(value='</%s>'), op=Mod(), right=Name(id='resname', ctx=Load()))], keywords=[])), Assign(targets=[Attribute(value=Name(id='openTag', ctx=Load()), attr='tag', ctx=Store())], value=Name(id='resname', ctx=Load())), Assign(targets=[Attribute(value=Name(id='closeTag', ctx=Load()), attr='tag', ctx=Store())], value=Name(id='resname', ctx=Load())), Assign(targets=[Attribute(value=Name(id='openTag', ctx=Load()), attr='tag_body', ctx=Store())], value=Call(func=Name(id='SkipTo', ctx=Load()), args=[Call(func=Name(id='closeTag', ctx=Load()), args=[], keywords=[])], keywords=[])), Return(value=Tuple(elts=[Name(id='openTag', ctx=Load()), Name(id='closeTag', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='make_html_tags', args=arguments(posonlyargs=[], args=[arg(arg='tag_str', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper to construct opening and closing tag expressions for HTML,\n    given a tag name. Matches tags in either upper or lower case,\n    attributes with namespaces and with quoted or unquoted values.\n\n    Example::\n\n        text = \'<td>More info at the <a href="https://github.com/pyparsing/pyparsing/wiki">pyparsing</a> wiki page</td>\'\n        # make_html_tags returns pyparsing expressions for the opening and\n        # closing tags as a 2-tuple\n        a, a_end = make_html_tags("A")\n        link_expr = a + SkipTo(a_end)("link_text") + a_end\n\n        for link in link_expr.search_string(text):\n            # attributes in the <A> tag (like "href" shown here) are\n            # also accessible as named results\n            print(link.link_text, \'->\', link.href)\n\n    prints::\n\n        pyparsing -> https://github.com/pyparsing/pyparsing/wiki\n    ')), Return(value=Call(func=Name(id='_makeTags', ctx=Load()), args=[Name(id='tag_str', ctx=Load()), Constant(value=False)], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='make_xml_tags', args=arguments(posonlyargs=[], args=[arg(arg='tag_str', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper to construct opening and closing tag expressions for XML,\n    given a tag name. Matches tags only in the given upper/lower case.\n\n    Example: similar to :class:`make_html_tags`\n    ')), Return(value=Call(func=Name(id='_makeTags', ctx=Load()), args=[Name(id='tag_str', ctx=Load()), Constant(value=True)], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), AnnAssign(target=Name(id='any_open_tag', ctx=Store()), annotation=Name(id='ParserElement', ctx=Load()), simple=1), AnnAssign(target=Name(id='any_close_tag', ctx=Store()), annotation=Name(id='ParserElement', ctx=Load()), simple=1), Assign(targets=[Tuple(elts=[Name(id='any_open_tag', ctx=Store()), Name(id='any_close_tag', ctx=Store())], ctx=Store())], value=Call(func=Name(id='make_html_tags', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Name(id='Word', ctx=Load()), args=[Name(id='alphas', ctx=Load()), BinOp(left=Name(id='alphanums', ctx=Load()), op=Add(), right=Constant(value='_:'))], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='any tag')], keywords=[])], keywords=[])), Assign(targets=[Name(id='_htmlEntityMap', ctx=Store())], value=DictComp(key=Call(func=Attribute(value=Name(id='k', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value=';')], keywords=[]), value=Name(id='v', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='html', ctx=Load()), attr='entities', ctx=Load()), attr='html5', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='common_html_entity', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value='&(?P<entity>'), op=Add(), right=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[Name(id='_htmlEntityMap', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=');'))], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='common HTML entity')], keywords=[])), FunctionDef(name='replace_html_entity', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper parser action to replace common HTML entities with their special characters')), Return(value=Call(func=Attribute(value=Name(id='_htmlEntityMap', ctx=Load()), attr='get', ctx=Load()), args=[Attribute(value=Name(id='t', ctx=Load()), attr='entity', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='OpAssoc', bases=[Name(id='Enum', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Enumeration of operator associativity\n    - used in constructing InfixNotationOperatorSpec for :class:`infix_notation`')), Assign(targets=[Name(id='LEFT', ctx=Store())], value=Constant(value=1)), Assign(targets=[Name(id='RIGHT', ctx=Store())], value=Constant(value=2))], decorator_list=[]), Assign(targets=[Name(id='InfixNotationOperatorArgType', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='ParserElement', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='InfixNotationOperatorSpec', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='InfixNotationOperatorArgType', ctx=Load()), Name(id='int', ctx=Load()), Name(id='OpAssoc', ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='ParseAction', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='InfixNotationOperatorArgType', ctx=Load()), Name(id='int', ctx=Load()), Name(id='OpAssoc', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='infix_notation', args=arguments(posonlyargs=[], args=[arg(arg='base_expr', annotation=Name(id='ParserElement', ctx=Load())), arg(arg='op_list', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InfixNotationOperatorSpec', ctx=Load()), ctx=Load())), arg(arg='lpar', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='rpar', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Call(func=Name(id='Suppress', ctx=Load()), args=[Constant(value='(')], keywords=[]), Call(func=Name(id='Suppress', ctx=Load()), args=[Constant(value=')')], keywords=[])]), body=[Expr(value=Constant(value="Helper method for constructing grammars of expressions made up of\n    operators working in a precedence hierarchy.  Operators may be unary\n    or binary, left- or right-associative.  Parse actions can also be\n    attached to operator expressions. The generated parser will also\n    recognize the use of parentheses to override operator precedences\n    (see example below).\n\n    Note: if you define a deep operator list, you may see performance\n    issues when using infix_notation. See\n    :class:`ParserElement.enable_packrat` for a mechanism to potentially\n    improve your parser performance.\n\n    Parameters:\n\n    - ``base_expr`` - expression representing the most basic operand to\n      be used in the expression\n    - ``op_list`` - list of tuples, one for each operator precedence level\n      in the expression grammar; each tuple is of the form ``(op_expr,\n      num_operands, right_left_assoc, (optional)parse_action)``, where:\n\n      - ``op_expr`` is the pyparsing expression for the operator; may also\n        be a string, which will be converted to a Literal; if ``num_operands``\n        is 3, ``op_expr`` is a tuple of two expressions, for the two\n        operators separating the 3 terms\n      - ``num_operands`` is the number of terms for this operator (must be 1,\n        2, or 3)\n      - ``right_left_assoc`` is the indicator whether the operator is right\n        or left associative, using the pyparsing-defined constants\n        ``OpAssoc.RIGHT`` and ``OpAssoc.LEFT``.\n      - ``parse_action`` is the parse action to be associated with\n        expressions matching this operator expression (the parse action\n        tuple member may be omitted); if the parse action is passed\n        a tuple or list of functions, this is equivalent to calling\n        ``set_parse_action(*fn)``\n        (:class:`ParserElement.set_parse_action`)\n    - ``lpar`` - expression for matching left-parentheses; if passed as a\n      str, then will be parsed as ``Suppress(lpar)``. If lpar is passed as\n      an expression (such as ``Literal('(')``), then it will be kept in\n      the parsed results, and grouped with them. (default= ``Suppress('(')``)\n    - ``rpar`` - expression for matching right-parentheses; if passed as a\n      str, then will be parsed as ``Suppress(rpar)``. If rpar is passed as\n      an expression (such as ``Literal(')')``), then it will be kept in\n      the parsed results, and grouped with them. (default= ``Suppress(')')``)\n\n    Example::\n\n        # simple example of four-function arithmetic with ints and\n        # variable names\n        integer = pyparsing_common.signed_integer\n        varname = pyparsing_common.identifier\n\n        arith_expr = infix_notation(integer | varname,\n            [\n            ('-', 1, OpAssoc.RIGHT),\n            (one_of('* /'), 2, OpAssoc.LEFT),\n            (one_of('+ -'), 2, OpAssoc.LEFT),\n            ])\n\n        arith_expr.run_tests('''\n            5+3*6\n            (5+3)*6\n            -2--11\n            ''', full_dump=False)\n\n    prints::\n\n        5+3*6\n        [[5, '+', [3, '*', 6]]]\n\n        (5+3)*6\n        [[[5, '+', 3], '*', 6]]\n\n        (5+x)*y\n        [[[5, '+', 'x'], '*', 'y']]\n\n        -2--11\n        [[['-', 2], '-', ['-', 11]]]\n    ")), ClassDef(name='_FB', bases=[Name(id='FollowedBy', ctx=Load())], keywords=[], body=[FunctionDef(name='parseImpl', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='instring'), arg(arg='loc'), arg(arg='doActions')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='expr', ctx=Load()), attr='try_parse', ctx=Load()), args=[Name(id='instring', ctx=Load()), Name(id='loc', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='loc', ctx=Load()), List(elts=[], ctx=Load())], ctx=Load()))], decorator_list=[])], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='_FB', ctx=Load()), attr='__name__', ctx=Store())], value=Constant(value='FollowedBy>')), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Name(id='Forward', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='lpar', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='lpar', ctx=Store())], value=Call(func=Name(id='Suppress', ctx=Load()), args=[Name(id='lpar', ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='rpar', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='rpar', ctx=Store())], value=Call(func=Name(id='Suppress', ctx=Load()), args=[Name(id='rpar', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='rpar', ctx=Load()), Name(id='Suppress', ctx=Load())], keywords=[]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='rpar', ctx=Load()), Name(id='Suppress', ctx=Load())], keywords=[])])), body=[Assign(targets=[Name(id='lastExpr', ctx=Store())], value=BinOp(left=Name(id='base_expr', ctx=Load()), op=BitOr(), right=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lpar', ctx=Load()), op=Add(), right=Name(id='ret', ctx=Load())), op=Add(), right=Name(id='rpar', ctx=Load()))], keywords=[])))], orelse=[Assign(targets=[Name(id='lastExpr', ctx=Store())], value=BinOp(left=Name(id='base_expr', ctx=Load()), op=BitOr(), right=BinOp(left=BinOp(left=Name(id='lpar', ctx=Load()), op=Add(), right=Name(id='ret', ctx=Load())), op=Add(), right=Name(id='rpar', ctx=Load()))))]), AnnAssign(target=Name(id='arity', ctx=Store()), annotation=Name(id='int', ctx=Load()), simple=1), AnnAssign(target=Name(id='rightLeftAssoc', ctx=Store()), annotation=Name(id='opAssoc', ctx=Load()), simple=1), AnnAssign(target=Name(id='pa', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='ParseAction', ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='opExpr1', ctx=Store()), annotation=Name(id='ParserElement', ctx=Load()), simple=1), AnnAssign(target=Name(id='opExpr2', ctx=Store()), annotation=Name(id='ParserElement', ctx=Load()), simple=1), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='operDef', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='op_list', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='opExpr', ctx=Store()), Name(id='arity', ctx=Store()), Name(id='rightLeftAssoc', ctx=Store()), Name(id='pa', ctx=Store())], ctx=Store())], value=Subscript(value=BinOp(left=Name(id='operDef', ctx=Load()), op=Add(), right=Tuple(elts=[Constant(value=None)], ctx=Load())), slice=Slice(upper=Constant(value=4)), ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='opExpr', ctx=Load()), Name(id='str_type', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opExpr', ctx=Store())], value=Call(func=Attribute(value=Name(id='ParserElement', ctx=Load()), attr='_literalStringClass', ctx=Load()), args=[Name(id='opExpr', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='opExpr', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='ParserElement', ctx=Load()), Name(id='opExpr', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='arity', ctx=Load()), ops=[Eq()], comparators=[Constant(value=3)]), body=[If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='opExpr', ctx=Load()), Tuple(elts=[Name(id='tuple', ctx=Load()), Name(id='list', ctx=Load())], ctx=Load())], keywords=[])), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='opExpr', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=2)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='if numterms=3, opExpr must be a tuple or list of two expressions')], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='opExpr1', ctx=Store()), Name(id='opExpr2', ctx=Store())], ctx=Store())], value=Name(id='opExpr', ctx=Load())), Assign(targets=[Name(id='term_name', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='opExpr1', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='opExpr2', ctx=Load()), conversion=-1), Constant(value=' term')]))], orelse=[Assign(targets=[Name(id='term_name', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='opExpr', ctx=Load()), conversion=-1), Constant(value=' term')]))]), If(test=UnaryOp(op=Not(), operand=Compare(left=Constant(value=1), ops=[LtE(), LtE()], comparators=[Name(id='arity', ctx=Load()), Constant(value=3)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='operator must be unary (1), binary (2), or ternary (3)')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='rightLeftAssoc', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Attribute(value=Name(id='OpAssoc', ctx=Load()), attr='LEFT', ctx=Load()), Attribute(value=Name(id='OpAssoc', ctx=Load()), attr='RIGHT', ctx=Load())], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='operator must indicate right or left associativity')], keywords=[]))], orelse=[]), AnnAssign(target=Name(id='thisExpr', ctx=Store()), annotation=Name(id='ParserElement', ctx=Load()), value=Call(func=Attribute(value=Call(func=Name(id='Forward', ctx=Load()), args=[], keywords=[]), attr='set_name', ctx=Load()), args=[Name(id='term_name', ctx=Load())], keywords=[]), simple=1), Assign(targets=[Name(id='thisExpr', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='cast', ctx=Load()), args=[Name(id='Forward', ctx=Load()), Name(id='thisExpr', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='rightLeftAssoc', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='OpAssoc', ctx=Load()), attr='LEFT', ctx=Load())]), body=[If(test=Compare(left=Name(id='arity', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='matchExpr', ctx=Store())], value=BinOp(left=Call(func=Name(id='_FB', ctx=Load()), args=[BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Name(id='opExpr', ctx=Load()))], keywords=[]), op=Add(), right=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Subscript(value=Name(id='opExpr', ctx=Load()), slice=Tuple(elts=[Constant(value=1), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))], keywords=[])))], orelse=[If(test=Compare(left=Name(id='arity', ctx=Load()), ops=[Eq()], comparators=[Constant(value=2)]), body=[If(test=Compare(left=Name(id='opExpr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='matchExpr', ctx=Store())], value=BinOp(left=Call(func=Name(id='_FB', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Name(id='opExpr', ctx=Load())), op=Add(), right=Name(id='lastExpr', ctx=Load()))], keywords=[]), op=Add(), right=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Subscript(value=BinOp(left=Name(id='opExpr', ctx=Load()), op=Add(), right=Name(id='lastExpr', ctx=Load())), slice=Tuple(elts=[Constant(value=1), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))], keywords=[])))], orelse=[Assign(targets=[Name(id='matchExpr', ctx=Store())], value=BinOp(left=Call(func=Name(id='_FB', ctx=Load()), args=[BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Name(id='lastExpr', ctx=Load()))], keywords=[]), op=Add(), right=Call(func=Name(id='Group', ctx=Load()), args=[Subscript(value=Name(id='lastExpr', ctx=Load()), slice=Tuple(elts=[Constant(value=2), Constant(value=Ellipsis)], ctx=Load()), ctx=Load())], keywords=[])))])], orelse=[If(test=Compare(left=Name(id='arity', ctx=Load()), ops=[Eq()], comparators=[Constant(value=3)]), body=[Assign(targets=[Name(id='matchExpr', ctx=Store())], value=BinOp(left=Call(func=Name(id='_FB', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Name(id='opExpr1', ctx=Load())), op=Add(), right=Name(id='lastExpr', ctx=Load())), op=Add(), right=Name(id='opExpr2', ctx=Load())), op=Add(), right=Name(id='lastExpr', ctx=Load()))], keywords=[]), op=Add(), right=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Call(func=Name(id='OneOrMore', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Name(id='opExpr1', ctx=Load()), op=Add(), right=Name(id='lastExpr', ctx=Load())), op=Add(), right=Name(id='opExpr2', ctx=Load())), op=Add(), right=Name(id='lastExpr', ctx=Load()))], keywords=[]))], keywords=[])))], orelse=[])])])], orelse=[If(test=Compare(left=Name(id='rightLeftAssoc', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='OpAssoc', ctx=Load()), attr='RIGHT', ctx=Load())]), body=[If(test=Compare(left=Name(id='arity', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='opExpr', ctx=Load()), Name(id='Opt', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='opExpr', ctx=Store())], value=Call(func=Name(id='Opt', ctx=Load()), args=[Name(id='opExpr', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='matchExpr', ctx=Store())], value=BinOp(left=Call(func=Name(id='_FB', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='opExpr', ctx=Load()), attr='expr', ctx=Load()), op=Add(), right=Name(id='thisExpr', ctx=Load()))], keywords=[]), op=Add(), right=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=Name(id='opExpr', ctx=Load()), op=Add(), right=Name(id='thisExpr', ctx=Load()))], keywords=[])))], orelse=[If(test=Compare(left=Name(id='arity', ctx=Load()), ops=[Eq()], comparators=[Constant(value=2)]), body=[If(test=Compare(left=Name(id='opExpr', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='matchExpr', ctx=Store())], value=BinOp(left=Call(func=Name(id='_FB', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Name(id='opExpr', ctx=Load())), op=Add(), right=Name(id='thisExpr', ctx=Load()))], keywords=[]), op=Add(), right=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Subscript(value=BinOp(left=Name(id='opExpr', ctx=Load()), op=Add(), right=Name(id='thisExpr', ctx=Load())), slice=Tuple(elts=[Constant(value=1), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))], keywords=[])))], orelse=[Assign(targets=[Name(id='matchExpr', ctx=Store())], value=BinOp(left=Call(func=Name(id='_FB', ctx=Load()), args=[BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Name(id='thisExpr', ctx=Load()))], keywords=[]), op=Add(), right=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Subscript(value=Name(id='thisExpr', ctx=Load()), slice=Tuple(elts=[Constant(value=1), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()))], keywords=[])))])], orelse=[If(test=Compare(left=Name(id='arity', ctx=Load()), ops=[Eq()], comparators=[Constant(value=3)]), body=[Assign(targets=[Name(id='matchExpr', ctx=Store())], value=BinOp(left=Call(func=Name(id='_FB', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Name(id='opExpr1', ctx=Load())), op=Add(), right=Name(id='thisExpr', ctx=Load())), op=Add(), right=Name(id='opExpr2', ctx=Load())), op=Add(), right=Name(id='thisExpr', ctx=Load()))], keywords=[]), op=Add(), right=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Name(id='lastExpr', ctx=Load()), op=Add(), right=Name(id='opExpr1', ctx=Load())), op=Add(), right=Name(id='thisExpr', ctx=Load())), op=Add(), right=Name(id='opExpr2', ctx=Load())), op=Add(), right=Name(id='thisExpr', ctx=Load()))], keywords=[])))], orelse=[])])])], orelse=[])]), If(test=Name(id='pa', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='pa', ctx=Load()), Tuple(elts=[Name(id='tuple', ctx=Load()), Name(id='list', ctx=Load())], ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='matchExpr', ctx=Load()), attr='set_parse_action', ctx=Load()), args=[Starred(value=Name(id='pa', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='matchExpr', ctx=Load()), attr='set_parse_action', ctx=Load()), args=[Name(id='pa', ctx=Load())], keywords=[]))])], orelse=[]), AugAssign(target=Name(id='thisExpr', ctx=Store()), op=LShift(), value=Call(func=Attribute(value=BinOp(left=Name(id='matchExpr', ctx=Load()), op=BitOr(), right=Name(id='lastExpr', ctx=Load())), attr='setName', ctx=Load()), args=[Name(id='term_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='lastExpr', ctx=Store())], value=Name(id='thisExpr', ctx=Load()))], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=LShift(), value=Name(id='lastExpr', ctx=Load())), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), FunctionDef(name='indentedBlock', args=arguments(posonlyargs=[], args=[arg(arg='blockStatementExpr'), arg(arg='indentStack'), arg(arg='indent'), arg(arg='backup_stacks')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), List(elts=[], ctx=Load())]), body=[Expr(value=Constant(value='\n    (DEPRECATED - use :class:`IndentedBlock` class instead)\n    Helper method for defining space-delimited indentation blocks,\n    such as those used to define block statements in Python source code.\n\n    Parameters:\n\n    - ``blockStatementExpr`` - expression defining syntax of statement that\n      is repeated within the indented block\n    - ``indentStack`` - list created by caller to manage indentation stack\n      (multiple ``statementWithIndentedBlock`` expressions within a single\n      grammar should share a common ``indentStack``)\n    - ``indent`` - boolean indicating whether block must be indented beyond\n      the current level; set to ``False`` for block of left-most statements\n      (default= ``True``)\n\n    A valid block must contain at least one ``blockStatement``.\n\n    (Note that indentedBlock uses internal parse actions which make it\n    incompatible with packrat parsing.)\n\n    Example::\n\n        data = \'\'\'\n        def A(z):\n          A1\n          B = 100\n          G = A2\n          A2\n          A3\n        B\n        def BB(a,b,c):\n          BB1\n          def BBA():\n            bba1\n            bba2\n            bba3\n        C\n        D\n        def spam(x,y):\n             def eggs(z):\n                 pass\n        \'\'\'\n\n\n        indentStack = [1]\n        stmt = Forward()\n\n        identifier = Word(alphas, alphanums)\n        funcDecl = ("def" + identifier + Group("(" + Opt(delimitedList(identifier)) + ")") + ":")\n        func_body = indentedBlock(stmt, indentStack)\n        funcDef = Group(funcDecl + func_body)\n\n        rvalue = Forward()\n        funcCall = Group(identifier + "(" + Opt(delimitedList(rvalue)) + ")")\n        rvalue << (funcCall | identifier | Word(nums))\n        assignment = Group(identifier + "=" + rvalue)\n        stmt << (funcDef | assignment | identifier)\n\n        module_body = stmt[1, ...]\n\n        parseTree = module_body.parseString(data)\n        parseTree.pprint()\n\n    prints::\n\n        [[\'def\',\n          \'A\',\n          [\'(\', \'z\', \')\'],\n          \':\',\n          [[\'A1\'], [[\'B\', \'=\', \'100\']], [[\'G\', \'=\', \'A2\']], [\'A2\'], [\'A3\']]],\n         \'B\',\n         [\'def\',\n          \'BB\',\n          [\'(\', \'a\', \'b\', \'c\', \')\'],\n          \':\',\n          [[\'BB1\'], [[\'def\', \'BBA\', [\'(\', \')\'], \':\', [[\'bba1\'], [\'bba2\'], [\'bba3\']]]]]],\n         \'C\',\n         \'D\',\n         [\'def\',\n          \'spam\',\n          [\'(\', \'x\', \'y\', \')\'],\n          \':\',\n          [[[\'def\', \'eggs\', [\'(\', \'z\', \')\'], \':\', [[\'pass\']]]]]]]\n    ')), Expr(value=Call(func=Attribute(value=Name(id='backup_stacks', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='indentStack', ctx=Load()), slice=Slice(), ctx=Load())], keywords=[])), FunctionDef(name='reset_stack', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Subscript(value=Name(id='indentStack', ctx=Load()), slice=Slice(), ctx=Store())], value=Subscript(value=Name(id='backup_stacks', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()))], decorator_list=[]), FunctionDef(name='checkPeerIndent', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='l', ctx=Load()), ops=[GtE()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[])]), body=[Return()], orelse=[]), Assign(targets=[Name(id='curCol', ctx=Store())], value=Call(func=Name(id='col', ctx=Load()), args=[Name(id='l', ctx=Load()), Name(id='s', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='curCol', ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Name(id='indentStack', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())]), body=[If(test=Compare(left=Name(id='curCol', ctx=Load()), ops=[Gt()], comparators=[Subscript(value=Name(id='indentStack', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), Constant(value='illegal nesting')], keywords=[]))], orelse=[]), Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), Constant(value='not a peer entry')], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='checkSubIndent', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='curCol', ctx=Store())], value=Call(func=Name(id='col', ctx=Load()), args=[Name(id='l', ctx=Load()), Name(id='s', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='curCol', ctx=Load()), ops=[Gt()], comparators=[Subscript(value=Name(id='indentStack', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='indentStack', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='curCol', ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), Constant(value='not a subentry')], keywords=[]))])], decorator_list=[]), FunctionDef(name='checkUnindent', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='l', ctx=Load()), ops=[GtE()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[])]), body=[Return()], orelse=[]), Assign(targets=[Name(id='curCol', ctx=Store())], value=Call(func=Name(id='col', ctx=Load()), args=[Name(id='l', ctx=Load()), Name(id='s', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Name(id='indentStack', ctx=Load()), Compare(left=Name(id='curCol', ctx=Load()), ops=[In()], comparators=[Name(id='indentStack', ctx=Load())])])), body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), Constant(value='not an unindent')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='curCol', ctx=Load()), ops=[Lt()], comparators=[Subscript(value=Name(id='indentStack', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='indentStack', ctx=Load()), attr='pop', ctx=Load()), args=[], keywords=[]))], orelse=[])], decorator_list=[]), Assign(targets=[Name(id='NL', ctx=Store())], value=Call(func=Name(id='OneOrMore', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='LineEnd', ctx=Load()), args=[], keywords=[]), attr='set_whitespace_chars', ctx=Load()), args=[Constant(value='\t ')], keywords=[]), attr='suppress', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='INDENT', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Attribute(value=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='checkSubIndent', ctx=Load())], keywords=[])), attr='set_name', ctx=Load()), args=[Constant(value='INDENT')], keywords=[])), Assign(targets=[Name(id='PEER', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='checkPeerIndent', ctx=Load())], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='')], keywords=[])), Assign(targets=[Name(id='UNDENT', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Empty', ctx=Load()), args=[], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='checkUnindent', ctx=Load())], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='UNINDENT')], keywords=[])), If(test=Name(id='indent', ctx=Load()), body=[Assign(targets=[Name(id='smExpr', ctx=Store())], value=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id='Opt', ctx=Load()), args=[Name(id='NL', ctx=Load())], keywords=[]), op=Add(), right=Name(id='INDENT', ctx=Load())), op=Add(), right=Call(func=Name(id='OneOrMore', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='PEER', ctx=Load()), op=Add(), right=Call(func=Name(id='Group', ctx=Load()), args=[Name(id='blockStatementExpr', ctx=Load())], keywords=[])), op=Add(), right=Call(func=Name(id='Opt', ctx=Load()), args=[Name(id='NL', ctx=Load())], keywords=[]))], keywords=[])), op=Add(), right=Name(id='UNDENT', ctx=Load()))], keywords=[]))], orelse=[Assign(targets=[Name(id='smExpr', ctx=Store())], value=Call(func=Name(id='Group', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Name(id='Opt', ctx=Load()), args=[Name(id='NL', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='OneOrMore', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='PEER', ctx=Load()), op=Add(), right=Call(func=Name(id='Group', ctx=Load()), args=[Name(id='blockStatementExpr', ctx=Load())], keywords=[])), op=Add(), right=Call(func=Name(id='Opt', ctx=Load()), args=[Name(id='NL', ctx=Load())], keywords=[]))], keywords=[])), op=Add(), right=Call(func=Name(id='Opt', ctx=Load()), args=[Name(id='UNDENT', ctx=Load())], keywords=[]))], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='smExpr', ctx=Load()), attr='add_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=IfExp(test=Name(id='backup_stacks', ctx=Load()), body=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='backup_stacks', ctx=Load()), attr='pop', ctx=Load()), args=[UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), Constant(value=None)]), orelse=Constant(value=None)))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='smExpr', ctx=Load()), attr='set_fail_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b'), arg(arg='c'), arg(arg='d')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='reset_stack', ctx=Load()), args=[], keywords=[]))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='blockStatementExpr', ctx=Load()), attr='ignore', ctx=Load()), args=[BinOp(left=Name(id='_bslash', ctx=Load()), op=Add(), right=Call(func=Name(id='LineEnd', ctx=Load()), args=[], keywords=[]))], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='smExpr', ctx=Load()), attr='set_name', ctx=Load()), args=[Constant(value='indented block')], keywords=[]))], decorator_list=[]), Assign(targets=[Name(id='c_style_comment', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[BinOp(left=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='/\\*(?:[^*]|\\*(?!/))*')], keywords=[]), op=Add(), right=Constant(value='*/'))], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='C style comment')], keywords=[])), Expr(value=Constant(value='Comment of the form ``/* ... */``')), Assign(targets=[Name(id='html_comment', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='<!--[\\s\\S]*?-->')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='HTML comment')], keywords=[])), Expr(value=Constant(value='Comment of the form ``<!-- ... -->``')), Assign(targets=[Name(id='rest_of_line', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='.*')], keywords=[]), attr='leave_whitespace', ctx=Load()), args=[], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='rest of line')], keywords=[])), Assign(targets=[Name(id='dbl_slash_comment', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='//(?:\\\\\\n|[^\\n])*')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='// comment')], keywords=[])), Expr(value=Constant(value='Comment of the form ``// ... (to end of line)``')), Assign(targets=[Name(id='cpp_style_comment', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='/\\*(?:[^*]|\\*(?!/))*')], keywords=[]), op=Add(), right=Constant(value='*/')), op=BitOr(), right=Name(id='dbl_slash_comment', ctx=Load()))], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='C++ style comment')], keywords=[])), Expr(value=Constant(value='Comment of either form :class:`c_style_comment` or :class:`dbl_slash_comment`')), Assign(targets=[Name(id='java_style_comment', ctx=Store())], value=Name(id='cpp_style_comment', ctx=Load())), Expr(value=Constant(value='Same as :class:`cpp_style_comment`')), Assign(targets=[Name(id='python_style_comment', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='#.*')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='Python style comment')], keywords=[])), Expr(value=Constant(value='Comment of the form ``# ... (to end of line)``')), AnnAssign(target=Name(id='_builtin_exprs', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='ParserElement', ctx=Load()), ctx=Load()), value=ListComp(elt=Name(id='v', ctx=Load()), generators=[comprehension(target=Name(id='v', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[], keywords=[]), attr='values', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='v', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])], is_async=0)]), simple=1), FunctionDef(name='delimited_list', args=arguments(posonlyargs=[], args=[arg(arg='expr', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='delim', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='ParserElement', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='combine', annotation=Name(id='bool', ctx=Load())), arg(arg='min', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='max', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='allow_trailing_delim', annotation=Name(id='bool', ctx=Load()))], kw_defaults=[Constant(value=False)], defaults=[Constant(value=','), Constant(value=False), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='(DEPRECATED - use :class:`DelimitedList` class)')), Return(value=Call(func=Name(id='DelimitedList', ctx=Load()), args=[Name(id='expr', ctx=Load()), Name(id='delim', ctx=Load()), Name(id='combine', ctx=Load()), Name(id='min', ctx=Load()), Name(id='max', ctx=Load())], keywords=[keyword(arg='allow_trailing_delim', value=Name(id='allow_trailing_delim', ctx=Load()))]))], decorator_list=[], returns=Name(id='ParserElement', ctx=Load())), Assign(targets=[Name(id='opAssoc', ctx=Store())], value=Name(id='OpAssoc', ctx=Load())), Assign(targets=[Name(id='anyOpenTag', ctx=Store())], value=Name(id='any_open_tag', ctx=Load())), Assign(targets=[Name(id='anyCloseTag', ctx=Store())], value=Name(id='any_close_tag', ctx=Load())), Assign(targets=[Name(id='commonHTMLEntity', ctx=Store())], value=Name(id='common_html_entity', ctx=Load())), Assign(targets=[Name(id='cStyleComment', ctx=Store())], value=Name(id='c_style_comment', ctx=Load())), Assign(targets=[Name(id='htmlComment', ctx=Store())], value=Name(id='html_comment', ctx=Load())), Assign(targets=[Name(id='restOfLine', ctx=Store())], value=Name(id='rest_of_line', ctx=Load())), Assign(targets=[Name(id='dblSlashComment', ctx=Store())], value=Name(id='dbl_slash_comment', ctx=Load())), Assign(targets=[Name(id='cppStyleComment', ctx=Store())], value=Name(id='cpp_style_comment', ctx=Load())), Assign(targets=[Name(id='javaStyleComment', ctx=Store())], value=Name(id='java_style_comment', ctx=Load())), Assign(targets=[Name(id='pythonStyleComment', ctx=Store())], value=Name(id='python_style_comment', ctx=Load())), FunctionDef(name='delimitedList', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='DelimitedList', ctx=Load())], keywords=[])]), FunctionDef(name='delimited_list', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='DelimitedList', ctx=Load())], keywords=[])]), FunctionDef(name='countedArray', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='counted_array', ctx=Load())], keywords=[])]), FunctionDef(name='matchPreviousLiteral', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='match_previous_literal', ctx=Load())], keywords=[])]), FunctionDef(name='matchPreviousExpr', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='match_previous_expr', ctx=Load())], keywords=[])]), FunctionDef(name='oneOf', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='one_of', ctx=Load())], keywords=[])]), FunctionDef(name='dictOf', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='dict_of', ctx=Load())], keywords=[])]), FunctionDef(name='originalTextFor', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='original_text_for', ctx=Load())], keywords=[])]), FunctionDef(name='nestedExpr', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='nested_expr', ctx=Load())], keywords=[])]), FunctionDef(name='makeHTMLTags', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='make_html_tags', ctx=Load())], keywords=[])]), FunctionDef(name='makeXMLTags', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='make_xml_tags', ctx=Load())], keywords=[])]), FunctionDef(name='replaceHTMLEntity', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='replace_html_entity', ctx=Load())], keywords=[])]), FunctionDef(name='infixNotation', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='infix_notation', ctx=Load())], keywords=[])])], type_ignores=[])