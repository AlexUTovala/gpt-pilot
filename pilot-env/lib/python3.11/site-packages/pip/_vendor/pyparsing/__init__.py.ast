Module(body=[Assign(targets=[Name(id='__doc__', ctx=Store())], value=Constant(value='\npyparsing module - Classes and methods to define and execute parsing grammars\n=============================================================================\n\nThe pyparsing module is an alternative approach to creating and\nexecuting simple grammars, vs. the traditional lex/yacc approach, or the\nuse of regular expressions.  With pyparsing, you don\'t need to learn\na new syntax for defining grammars or matching expressions - the parsing\nmodule provides a library of classes that you use to construct the\ngrammar directly in Python.\n\nHere is a program to parse "Hello, World!" (or any greeting of the form\n``"<salutation>, <addressee>!"``), built up using :class:`Word`,\n:class:`Literal`, and :class:`And` elements\n(the :meth:`\'+\'<ParserElement.__add__>` operators create :class:`And` expressions,\nand the strings are auto-converted to :class:`Literal` expressions)::\n\n    from pip._vendor.pyparsing import Word, alphas\n\n    # define grammar of a greeting\n    greet = Word(alphas) + "," + Word(alphas) + "!"\n\n    hello = "Hello, World!"\n    print(hello, "->", greet.parse_string(hello))\n\nThe program outputs the following::\n\n    Hello, World! -> [\'Hello\', \',\', \'World\', \'!\']\n\nThe Python representation of the grammar is quite readable, owing to the\nself-explanatory class names, and the use of :class:`\'+\'<And>`,\n:class:`\'|\'<MatchFirst>`, :class:`\'^\'<Or>` and :class:`\'&\'<Each>` operators.\n\nThe :class:`ParseResults` object returned from\n:class:`ParserElement.parse_string` can be\naccessed as a nested list, a dictionary, or an object with named\nattributes.\n\nThe pyparsing module handles some of the problems that are typically\nvexing when writing text parsers:\n\n  - extra or missing whitespace (the above program will also handle\n    "Hello,World!", "Hello  ,  World  !", etc.)\n  - quoted strings\n  - embedded comments\n\n\nGetting Started -\n-----------------\nVisit the classes :class:`ParserElement` and :class:`ParseResults` to\nsee the base classes that most other pyparsing\nclasses inherit from. Use the docstrings for examples of how to:\n\n - construct literal match expressions from :class:`Literal` and\n   :class:`CaselessLiteral` classes\n - construct character word-group expressions using the :class:`Word`\n   class\n - see how to create repetitive expressions using :class:`ZeroOrMore`\n   and :class:`OneOrMore` classes\n - use :class:`\'+\'<And>`, :class:`\'|\'<MatchFirst>`, :class:`\'^\'<Or>`,\n   and :class:`\'&\'<Each>` operators to combine simple expressions into\n   more complex ones\n - associate names with your parsed results using\n   :class:`ParserElement.set_results_name`\n - access the parsed data, which is returned as a :class:`ParseResults`\n   object\n - find some helpful expression short-cuts like :class:`DelimitedList`\n   and :class:`one_of`\n - find more useful common expressions in the :class:`pyparsing_common`\n   namespace class\n')), ImportFrom(module='typing', names=[alias(name='NamedTuple')], level=0), ClassDef(name='version_info', bases=[Name(id='NamedTuple', ctx=Load())], keywords=[], body=[AnnAssign(target=Name(id='major', ctx=Store()), annotation=Name(id='int', ctx=Load()), simple=1), AnnAssign(target=Name(id='minor', ctx=Store()), annotation=Name(id='int', ctx=Load()), simple=1), AnnAssign(target=Name(id='micro', ctx=Store()), annotation=Name(id='int', ctx=Load()), simple=1), AnnAssign(target=Name(id='releaselevel', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='serial', ctx=Store()), annotation=Name(id='int', ctx=Load()), simple=1), FunctionDef(name='__version__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='major', ctx=Load()), conversion=-1), Constant(value='.'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='minor', ctx=Load()), conversion=-1), Constant(value='.'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='micro', ctx=Load()), conversion=-1)]), op=Add(), right=Subscript(value=Tuple(elts=[JoinedStr(values=[FormattedValue(value=IfExp(test=Compare(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='releaselevel', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[Eq()], comparators=[Constant(value='c')]), body=Constant(value='r'), orelse=Constant(value='')), conversion=-1), FormattedValue(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='releaselevel', ctx=Load()), slice=Constant(value=0), ctx=Load()), conversion=-1), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='serial', ctx=Load()), conversion=-1)]), Constant(value='')], ctx=Load()), slice=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='releaselevel', ctx=Load()), ops=[Eq()], comparators=[Constant(value='final')]), ctx=Load())))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Name(id='__name__', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='__version__', ctx=Load()), conversion=-1), Constant(value=' / '), FormattedValue(value=Name(id='__version_time__', ctx=Load()), conversion=-1)]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Name(id='__name__', ctx=Load()), conversion=-1), Constant(value='.'), FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value='('), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Constant(value='{}={!r}'), attr='format', ctx=Load()), args=[Starred(value=Name(id='nv', ctx=Load()), ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='nv', ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_fields', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]), conversion=-1), Constant(value=')')]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='__version_info__', ctx=Store())], value=Call(func=Name(id='version_info', ctx=Load()), args=[Constant(value=3), Constant(value=1), Constant(value=0), Constant(value='final'), Constant(value=1)], keywords=[])), Assign(targets=[Name(id='__version_time__', ctx=Store())], value=Constant(value='18 Jun 2023 14:05 UTC')), Assign(targets=[Name(id='__version__', ctx=Store())], value=Attribute(value=Name(id='__version_info__', ctx=Load()), attr='__version__', ctx=Load())), Assign(targets=[Name(id='__versionTime__', ctx=Store())], value=Name(id='__version_time__', ctx=Load())), Assign(targets=[Name(id='__author__', ctx=Store())], value=Constant(value='Paul McGuire <ptmcg.gm+pyparsing@gmail.com>')), ImportFrom(module='util', names=[alias(name='*')], level=1), ImportFrom(module='exceptions', names=[alias(name='*')], level=1), ImportFrom(module='actions', names=[alias(name='*')], level=1), ImportFrom(module='core', names=[alias(name='__diag__'), alias(name='__compat__')], level=1), ImportFrom(module='results', names=[alias(name='*')], level=1), ImportFrom(module='core', names=[alias(name='*')], level=1), ImportFrom(module='core', names=[alias(name='_builtin_exprs', asname='core_builtin_exprs')], level=1), ImportFrom(module='helpers', names=[alias(name='*')], level=1), ImportFrom(module='helpers', names=[alias(name='_builtin_exprs', asname='helper_builtin_exprs')], level=1), ImportFrom(module='unicode', names=[alias(name='unicode_set'), alias(name='UnicodeRangeList'), alias(name='pyparsing_unicode', asname='unicode')], level=1), ImportFrom(module='testing', names=[alias(name='pyparsing_test', asname='testing')], level=1), ImportFrom(module='common', names=[alias(name='pyparsing_common', asname='common'), alias(name='_builtin_exprs', asname='common_builtin_exprs')], level=1), If(test=Compare(left=Constant(value='pyparsing_unicode'), ops=[NotIn()], comparators=[Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[])]), body=[Assign(targets=[Name(id='pyparsing_unicode', ctx=Store())], value=Name(id='unicode', ctx=Load()))], orelse=[]), If(test=Compare(left=Constant(value='pyparsing_common'), ops=[NotIn()], comparators=[Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[])]), body=[Assign(targets=[Name(id='pyparsing_common', ctx=Store())], value=Name(id='common', ctx=Load()))], orelse=[]), If(test=Compare(left=Constant(value='pyparsing_test'), ops=[NotIn()], comparators=[Call(func=Name(id='globals', ctx=Load()), args=[], keywords=[])]), body=[Assign(targets=[Name(id='pyparsing_test', ctx=Store())], value=Name(id='testing', ctx=Load()))], orelse=[]), AugAssign(target=Name(id='core_builtin_exprs', ctx=Store()), op=Add(), value=BinOp(left=Name(id='common_builtin_exprs', ctx=Load()), op=Add(), right=Name(id='helper_builtin_exprs', ctx=Load()))), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='__version__'), Constant(value='__version_time__'), Constant(value='__author__'), Constant(value='__compat__'), Constant(value='__diag__'), Constant(value='And'), Constant(value='AtLineStart'), Constant(value='AtStringStart'), Constant(value='CaselessKeyword'), Constant(value='CaselessLiteral'), Constant(value='CharsNotIn'), Constant(value='CloseMatch'), Constant(value='Combine'), Constant(value='DelimitedList'), Constant(value='Dict'), Constant(value='Each'), Constant(value='Empty'), Constant(value='FollowedBy'), Constant(value='Forward'), Constant(value='GoToColumn'), Constant(value='Group'), Constant(value='IndentedBlock'), Constant(value='Keyword'), Constant(value='LineEnd'), Constant(value='LineStart'), Constant(value='Literal'), Constant(value='Located'), Constant(value='PrecededBy'), Constant(value='MatchFirst'), Constant(value='NoMatch'), Constant(value='NotAny'), Constant(value='OneOrMore'), Constant(value='OnlyOnce'), Constant(value='OpAssoc'), Constant(value='Opt'), Constant(value='Optional'), Constant(value='Or'), Constant(value='ParseBaseException'), Constant(value='ParseElementEnhance'), Constant(value='ParseException'), Constant(value='ParseExpression'), Constant(value='ParseFatalException'), Constant(value='ParseResults'), Constant(value='ParseSyntaxException'), Constant(value='ParserElement'), Constant(value='PositionToken'), Constant(value='QuotedString'), Constant(value='RecursiveGrammarException'), Constant(value='Regex'), Constant(value='SkipTo'), Constant(value='StringEnd'), Constant(value='StringStart'), Constant(value='Suppress'), Constant(value='Token'), Constant(value='TokenConverter'), Constant(value='White'), Constant(value='Word'), Constant(value='WordEnd'), Constant(value='WordStart'), Constant(value='ZeroOrMore'), Constant(value='Char'), Constant(value='alphanums'), Constant(value='alphas'), Constant(value='alphas8bit'), Constant(value='any_close_tag'), Constant(value='any_open_tag'), Constant(value='autoname_elements'), Constant(value='c_style_comment'), Constant(value='col'), Constant(value='common_html_entity'), Constant(value='condition_as_parse_action'), Constant(value='counted_array'), Constant(value='cpp_style_comment'), Constant(value='dbl_quoted_string'), Constant(value='dbl_slash_comment'), Constant(value='delimited_list'), Constant(value='dict_of'), Constant(value='empty'), Constant(value='hexnums'), Constant(value='html_comment'), Constant(value='identchars'), Constant(value='identbodychars'), Constant(value='infix_notation'), Constant(value='java_style_comment'), Constant(value='line'), Constant(value='line_end'), Constant(value='line_start'), Constant(value='lineno'), Constant(value='make_html_tags'), Constant(value='make_xml_tags'), Constant(value='match_only_at_col'), Constant(value='match_previous_expr'), Constant(value='match_previous_literal'), Constant(value='nested_expr'), Constant(value='null_debug_action'), Constant(value='nums'), Constant(value='one_of'), Constant(value='original_text_for'), Constant(value='printables'), Constant(value='punc8bit'), Constant(value='pyparsing_common'), Constant(value='pyparsing_test'), Constant(value='pyparsing_unicode'), Constant(value='python_style_comment'), Constant(value='quoted_string'), Constant(value='remove_quotes'), Constant(value='replace_with'), Constant(value='replace_html_entity'), Constant(value='rest_of_line'), Constant(value='sgl_quoted_string'), Constant(value='srange'), Constant(value='string_end'), Constant(value='string_start'), Constant(value='token_map'), Constant(value='trace_parse_action'), Constant(value='ungroup'), Constant(value='unicode_set'), Constant(value='unicode_string'), Constant(value='with_attribute'), Constant(value='with_class'), Constant(value='__versionTime__'), Constant(value='anyCloseTag'), Constant(value='anyOpenTag'), Constant(value='cStyleComment'), Constant(value='commonHTMLEntity'), Constant(value='conditionAsParseAction'), Constant(value='countedArray'), Constant(value='cppStyleComment'), Constant(value='dblQuotedString'), Constant(value='dblSlashComment'), Constant(value='delimitedList'), Constant(value='dictOf'), Constant(value='htmlComment'), Constant(value='indentedBlock'), Constant(value='infixNotation'), Constant(value='javaStyleComment'), Constant(value='lineEnd'), Constant(value='lineStart'), Constant(value='locatedExpr'), Constant(value='makeHTMLTags'), Constant(value='makeXMLTags'), Constant(value='matchOnlyAtCol'), Constant(value='matchPreviousExpr'), Constant(value='matchPreviousLiteral'), Constant(value='nestedExpr'), Constant(value='nullDebugAction'), Constant(value='oneOf'), Constant(value='opAssoc'), Constant(value='originalTextFor'), Constant(value='pythonStyleComment'), Constant(value='quotedString'), Constant(value='removeQuotes'), Constant(value='replaceHTMLEntity'), Constant(value='replaceWith'), Constant(value='restOfLine'), Constant(value='sglQuotedString'), Constant(value='stringEnd'), Constant(value='stringStart'), Constant(value='tokenMap'), Constant(value='traceParseAction'), Constant(value='unicodeString'), Constant(value='withAttribute'), Constant(value='withClass')], ctx=Load()))], type_ignores=[])