Module(body=[Import(names=[alias(name='re')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='typing')]), ImportFrom(module='util', names=[alias(name='col'), alias(name='line'), alias(name='lineno'), alias(name='_collapse_string_to_ranges'), alias(name='replaced_by_pep8')], level=1), ImportFrom(module='unicode', names=[alias(name='pyparsing_unicode', asname='ppu')], level=1), ClassDef(name='ExceptionWordUnicode', bases=[Attribute(value=Name(id='ppu', ctx=Load()), attr='Latin1', ctx=Load()), Attribute(value=Name(id='ppu', ctx=Load()), attr='LatinA', ctx=Load()), Attribute(value=Name(id='ppu', ctx=Load()), attr='LatinB', ctx=Load()), Attribute(value=Name(id='ppu', ctx=Load()), attr='Greek', ctx=Load()), Attribute(value=Name(id='ppu', ctx=Load()), attr='Cyrillic', ctx=Load())], keywords=[], body=[Pass()], decorator_list=[]), Assign(targets=[Name(id='_extract_alphanums', ctx=Store())], value=Call(func=Name(id='_collapse_string_to_ranges', ctx=Load()), args=[Attribute(value=Name(id='ExceptionWordUnicode', ctx=Load()), attr='alphanums', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_exception_word_extractor', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value='(['), op=Add(), right=Name(id='_extract_alphanums', ctx=Load())), op=Add(), right=Constant(value=']{1,16})|.'))], keywords=[])), ClassDef(name='ParseBaseException', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='base exception class for all parsing runtime exceptions')), AnnAssign(target=Name(id='loc', ctx=Store()), annotation=Name(id='int', ctx=Load()), simple=1), AnnAssign(target=Name(id='msg', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='pstr', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='parser_element', ctx=Store()), annotation=Attribute(value=Name(id='typing', ctx=Load()), attr='Any', ctx=Load()), simple=1), AnnAssign(target=Name(id='args', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load()), Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), simple=1), Assign(targets=[Name(id='__slots__', ctx=Store())], value=Tuple(elts=[Constant(value='loc'), Constant(value='msg'), Constant(value='pstr'), Constant(value='parser_element'), Constant(value='args')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='pstr', annotation=Name(id='str', ctx=Load())), arg(arg='loc', annotation=Name(id='int', ctx=Load())), arg(arg='msg', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='elem')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=None), Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='loc', ctx=Store())], value=Name(id='loc', ctx=Load())), If(test=Compare(left=Name(id='msg', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Store())], value=Name(id='pstr', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pstr', ctx=Store())], value=Constant(value=''))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Store())], value=Name(id='msg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pstr', ctx=Store())], value=Name(id='pstr', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parser_element', ctx=Store())], value=Name(id='elem', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Store())], value=Tuple(elts=[Name(id='pstr', ctx=Load()), Name(id='loc', ctx=Load()), Name(id='msg', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='explain_exception', args=arguments(posonlyargs=[], args=[arg(arg='exc'), arg(arg='depth')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=16)]), body=[Expr(value=Constant(value="\n        Method to take an exception and translate the Python internal traceback into a list\n        of the pyparsing expressions that caused the exception to be raised.\n\n        Parameters:\n\n        - exc - exception raised during parsing (need not be a ParseException, in support\n          of Python exceptions that might be raised in a parse action)\n        - depth (default=16) - number of levels back in the stack trace to list expression\n          and function names; if None, the full stack trace names will be listed; if 0, only\n          the failing input line, marker, and exception string will be shown\n\n        Returns a multi-line string listing the ParserElements and/or function names in the\n        exception's stack trace.\n        ")), Import(names=[alias(name='inspect')]), ImportFrom(module='core', names=[alias(name='ParserElement')], level=1), If(test=Compare(left=Name(id='depth', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='depth', ctx=Store())], value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='getrecursionlimit', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='ret', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='exc', ctx=Load()), Name(id='ParseBaseException', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='exc', ctx=Load()), attr='line', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value=' '), op=Mult(), right=BinOp(left=Attribute(value=Name(id='exc', ctx=Load()), attr='column', ctx=Load()), op=Sub(), right=Constant(value=1))), op=Add(), right=Constant(value='^'))], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='exc', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='exc', ctx=Load()), conversion=-1)])], keywords=[])), If(test=Compare(left=Name(id='depth', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='callers', ctx=Store())], value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='getinnerframes', ctx=Load()), args=[Attribute(value=Name(id='exc', ctx=Load()), attr='__traceback__', ctx=Load())], keywords=[keyword(arg='context', value=Name(id='depth', ctx=Load()))])), Assign(targets=[Name(id='seen', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='ff', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Subscript(value=Name(id='callers', ctx=Load()), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='depth', ctx=Load()))), ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='frm', ctx=Store())], value=Subscript(value=Name(id='ff', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='f_self', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='frm', ctx=Load()), attr='f_locals', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='self'), Constant(value=None)], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='f_self', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='frm', ctx=Load()), attr='f_code', ctx=Load()), attr='co_name', ctx=Load()), attr='startswith', ctx=Load()), args=[Tuple(elts=[Constant(value='parseImpl'), Constant(value='_parseNoCache')], ctx=Load())], keywords=[])), body=[Continue()], orelse=[]), If(test=Compare(left=Call(func=Name(id='id', ctx=Load()), args=[Name(id='f_self', ctx=Load())], keywords=[]), ops=[In()], comparators=[Name(id='seen', ctx=Load())]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Call(func=Name(id='id', ctx=Load()), args=[Name(id='f_self', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='self_type', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='f_self', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self_type', ctx=Load()), attr='__module__', ctx=Load()), conversion=-1), Constant(value='.'), FormattedValue(value=Attribute(value=Name(id='self_type', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value=' - '), FormattedValue(value=Name(id='f_self', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[If(test=Compare(left=Name(id='f_self', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='self_type', ctx=Store())], value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='f_self', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self_type', ctx=Load()), attr='__module__', ctx=Load()), conversion=-1), Constant(value='.'), FormattedValue(value=Attribute(value=Name(id='self_type', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[Assign(targets=[Name(id='code', ctx=Store())], value=Attribute(value=Name(id='frm', ctx=Load()), attr='f_code', ctx=Load())), If(test=Compare(left=Attribute(value=Name(id='code', ctx=Load()), attr='co_name', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value='wrapper'), Constant(value='<module>')], ctx=Load())]), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='code', ctx=Load()), attr='co_name', ctx=Load())], keywords=[]))])]), AugAssign(target=Name(id='depth', ctx=Store()), op=Sub(), value=Constant(value=1)), If(test=UnaryOp(op=Not(), operand=Name(id='depth', ctx=Load())), body=[Break()], orelse=[])], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='ret', ctx=Load())], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_from_exception', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='pe')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        internal factory method to simplify creating one type of ParseException\n        from another - avoids having __init__ signature conflicts among subclasses\n        ')), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Attribute(value=Name(id='pe', ctx=Load()), attr='pstr', ctx=Load()), Attribute(value=Name(id='pe', ctx=Load()), attr='loc', ctx=Load()), Attribute(value=Name(id='pe', ctx=Load()), attr='msg', ctx=Load()), Attribute(value=Name(id='pe', ctx=Load()), attr='parser_element', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())]), FunctionDef(name='line', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the line of text where the exception occurred.\n        ')), Return(value=Call(func=Name(id='line', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='pstr', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='lineno', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the 1-based line number of text where the exception occurred.\n        ')), Return(value=Call(func=Name(id='lineno', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='pstr', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='col', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the 1-based column on the line of text where the exception occurred.\n        ')), Return(value=Call(func=Name(id='col', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='pstr', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='column', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the 1-based column on the line of text where the exception occurred.\n        ')), Return(value=Call(func=Name(id='col', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='loc', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='pstr', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='parserElement', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='parser_element', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='parserElement', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='elem')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parser_element', ctx=Store())], value=Name(id='elem', ctx=Load()))], decorator_list=[Attribute(value=Name(id='parserElement', ctx=Load()), attr='setter', ctx=Load())]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='pstr', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='loc', ctx=Load()), ops=[GtE()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pstr', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='foundstr', ctx=Store())], value=Constant(value=', found end of text'))], orelse=[Assign(targets=[Name(id='found_match', ctx=Store())], value=Call(func=Attribute(value=Name(id='_exception_word_extractor', ctx=Load()), attr='match', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='pstr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='loc', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='found_match', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='found', ctx=Store())], value=Call(func=Attribute(value=Name(id='found_match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=0)], keywords=[]))], orelse=[Assign(targets=[Name(id='found', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='pstr', ctx=Load()), slice=Slice(lower=Attribute(value=Name(id='self', ctx=Load()), attr='loc', ctx=Load()), upper=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='loc', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load()))]), Assign(targets=[Name(id='foundstr', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=Constant(value=', found %r'), op=Mod(), right=Name(id='found', ctx=Load())), attr='replace', ctx=Load()), args=[Constant(value='\\\\'), Constant(value='\\')], keywords=[]))])], orelse=[Assign(targets=[Name(id='foundstr', ctx=Store())], value=Constant(value=''))]), Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='foundstr', ctx=Load()), conversion=-1), Constant(value='  (at char '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='loc', ctx=Load()), conversion=-1), Constant(value='), (line:'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='lineno', ctx=Load()), conversion=-1), Constant(value=', col:'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='column', ctx=Load()), conversion=-1), Constant(value=')')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='mark_input_line', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='marker_string', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[arg(arg='markerString', annotation=Name(id='str', ctx=Load()))], kw_defaults=[Constant(value='>!<')], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        Extracts the exception line from the input string, and marks\n        the location of the exception with a special symbol.\n        ')), Assign(targets=[Name(id='markerString', ctx=Store())], value=IfExp(test=Compare(left=Name(id='marker_string', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='marker_string', ctx=Load()), orelse=Name(id='markerString', ctx=Load()))), Assign(targets=[Name(id='line_str', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='line', ctx=Load())), Assign(targets=[Name(id='line_column', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='column', ctx=Load()), op=Sub(), right=Constant(value=1))), If(test=Name(id='markerString', ctx=Load()), body=[Assign(targets=[Name(id='line_str', ctx=Store())], value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Tuple(elts=[Subscript(value=Name(id='line_str', ctx=Load()), slice=Slice(upper=Name(id='line_column', ctx=Load())), ctx=Load()), Name(id='markerString', ctx=Load()), Subscript(value=Name(id='line_str', ctx=Load()), slice=Slice(lower=Name(id='line_column', ctx=Load())), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='line_str', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='explain', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='depth')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=16)]), body=[Expr(value=Constant(value='\n        Method to translate the Python internal traceback into a list\n        of the pyparsing expressions that caused the exception to be raised.\n\n        Parameters:\n\n        - depth (default=16) - number of levels back in the stack trace to list expression\n          and function names; if None, the full stack trace names will be listed; if 0, only\n          the failing input line, marker, and exception string will be shown\n\n        Returns a multi-line string listing the ParserElements and/or function names in the\n        exception\'s stack trace.\n\n        Example::\n\n            expr = pp.Word(pp.nums) * 3\n            try:\n                expr.parse_string("123 456 A789")\n            except pp.ParseException as pe:\n                print(pe.explain(depth=0))\n\n        prints::\n\n            123 456 A789\n                    ^\n            ParseException: Expected W:(0-9), found \'A\'  (at char 8), (line:1, col:9)\n\n        Note: the diagnostic output will include string representations of the expressions\n        that failed to parse. These representations will be more helpful if you use `set_name` to\n        give identifiable names to your expressions. Otherwise they will use the default string\n        forms, which may be cryptic to read.\n\n        Note: pyparsing\'s default truncation of exception tracebacks may also truncate the\n        stack of expressions that are displayed in the ``explain`` output. To get the full listing\n        of parser expressions, you may have to set ``ParserElement.verbose_stacktrace = True``\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='explain_exception', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='depth', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='markInputline', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=Ellipsis))], decorator_list=[Call(func=Name(id='replaced_by_pep8', ctx=Load()), args=[Name(id='mark_input_line', ctx=Load())], keywords=[])])], decorator_list=[]), ClassDef(name='ParseException', bases=[Name(id='ParseBaseException', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Exception thrown when a parse expression doesn\'t match the input string\n\n    Example::\n\n        try:\n            Word(nums).set_name("integer").parse_string("ABC")\n        except ParseException as pe:\n            print(pe)\n            print("column: {}".format(pe.column))\n\n    prints::\n\n       Expected integer (at char 0), (line:1, col:1)\n        column: 1\n\n    '))], decorator_list=[]), ClassDef(name='ParseFatalException', bases=[Name(id='ParseBaseException', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    User-throwable exception thrown when inconsistent parse content\n    is found; stops all parsing immediately\n    '))], decorator_list=[]), ClassDef(name='ParseSyntaxException', bases=[Name(id='ParseFatalException', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Just like :class:`ParseFatalException`, but thrown internally\n    when an :class:`ErrorStop<And._ErrorStop>` ('-' operator) indicates\n    that parsing is to stop immediately because an unbacktrackable\n    syntax error has been found.\n    "))], decorator_list=[]), ClassDef(name='RecursiveGrammarException', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Exception thrown by :class:`ParserElement.validate` if the\n    grammar could be left-recursive; parser may need to enable\n    left recursion using :class:`ParserElement.enable_left_recursion<ParserElement.enable_left_recursion>`\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parseElementList')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='parseElementTrace', ctx=Store())], value=Name(id='parseElementList', ctx=Load()))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='RecursiveGrammarException: '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='parseElementTrace', ctx=Load()), conversion=-1)]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[])], type_ignores=[])