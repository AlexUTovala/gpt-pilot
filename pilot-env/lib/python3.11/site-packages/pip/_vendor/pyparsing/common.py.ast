Module(body=[ImportFrom(module='core', names=[alias(name='*')], level=1), ImportFrom(module='helpers', names=[alias(name='DelimitedList'), alias(name='any_open_tag'), alias(name='any_close_tag')], level=1), ImportFrom(module='datetime', names=[alias(name='datetime')], level=0), ClassDef(name='pyparsing_common', bases=[], keywords=[], body=[Expr(value=Constant(value="Here are some common low-level expressions that may be useful in\n    jump-starting parser development:\n\n    - numeric forms (:class:`integers<integer>`, :class:`reals<real>`,\n      :class:`scientific notation<sci_real>`)\n    - common :class:`programming identifiers<identifier>`\n    - network addresses (:class:`MAC<mac_address>`,\n      :class:`IPv4<ipv4_address>`, :class:`IPv6<ipv6_address>`)\n    - ISO8601 :class:`dates<iso8601_date>` and\n      :class:`datetime<iso8601_datetime>`\n    - :class:`UUID<uuid>`\n    - :class:`comma-separated list<comma_separated_list>`\n    - :class:`url`\n\n    Parse actions:\n\n    - :class:`convert_to_integer`\n    - :class:`convert_to_float`\n    - :class:`convert_to_date`\n    - :class:`convert_to_datetime`\n    - :class:`strip_html_tags`\n    - :class:`upcase_tokens`\n    - :class:`downcase_tokens`\n\n    Example::\n\n        pyparsing_common.number.run_tests('''\n            # any int or real number, returned as the appropriate type\n            100\n            -100\n            +100\n            3.14159\n            6.02e23\n            1e-12\n            ''')\n\n        pyparsing_common.fnumber.run_tests('''\n            # any int or real number, returned as float\n            100\n            -100\n            +100\n            3.14159\n            6.02e23\n            1e-12\n            ''')\n\n        pyparsing_common.hex_integer.run_tests('''\n            # hex numbers\n            100\n            FF\n            ''')\n\n        pyparsing_common.fraction.run_tests('''\n            # fractions\n            1/2\n            -3/4\n            ''')\n\n        pyparsing_common.mixed_integer.run_tests('''\n            # mixed fractions\n            1\n            1/2\n            -3/4\n            1-3/4\n            ''')\n\n        import uuid\n        pyparsing_common.uuid.set_parse_action(token_map(uuid.UUID))\n        pyparsing_common.uuid.run_tests('''\n            # uuid\n            12345678-1234-5678-1234-567812345678\n            ''')\n\n    prints::\n\n        # any int or real number, returned as the appropriate type\n        100\n        [100]\n\n        -100\n        [-100]\n\n        +100\n        [100]\n\n        3.14159\n        [3.14159]\n\n        6.02e23\n        [6.02e+23]\n\n        1e-12\n        [1e-12]\n\n        # any int or real number, returned as float\n        100\n        [100.0]\n\n        -100\n        [-100.0]\n\n        +100\n        [100.0]\n\n        3.14159\n        [3.14159]\n\n        6.02e23\n        [6.02e+23]\n\n        1e-12\n        [1e-12]\n\n        # hex numbers\n        100\n        [256]\n\n        FF\n        [255]\n\n        # fractions\n        1/2\n        [0.5]\n\n        -3/4\n        [-0.75]\n\n        # mixed fractions\n        1\n        [1]\n\n        1/2\n        [0.5]\n\n        -3/4\n        [-0.75]\n\n        1-3/4\n        [1.75]\n\n        # uuid\n        12345678-1234-5678-1234-567812345678\n        [UUID('12345678-1234-5678-1234-567812345678')]\n    ")), Assign(targets=[Name(id='convert_to_integer', ctx=Store())], value=Call(func=Name(id='token_map', ctx=Load()), args=[Name(id='int', ctx=Load())], keywords=[])), Expr(value=Constant(value='\n    Parse action for converting parsed integers to Python int\n    ')), Assign(targets=[Name(id='convert_to_float', ctx=Store())], value=Call(func=Name(id='token_map', ctx=Load()), args=[Name(id='float', ctx=Load())], keywords=[])), Expr(value=Constant(value='\n    Parse action for converting parsed numbers to Python float\n    ')), Assign(targets=[Name(id='integer', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Word', ctx=Load()), args=[Name(id='nums', ctx=Load())], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='integer')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='convert_to_integer', ctx=Load())], keywords=[])), Expr(value=Constant(value='expression that parses an unsigned integer, returns an int')), Assign(targets=[Name(id='hex_integer', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Word', ctx=Load()), args=[Name(id='hexnums', ctx=Load())], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='hex integer')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Call(func=Name(id='token_map', ctx=Load()), args=[Name(id='int', ctx=Load()), Constant(value=16)], keywords=[])], keywords=[])), Expr(value=Constant(value='expression that parses a hexadecimal integer, returns an int')), Assign(targets=[Name(id='signed_integer', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='[+-]?\\d+')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='signed integer')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='convert_to_integer', ctx=Load())], keywords=[])), Expr(value=Constant(value='expression that parses an integer with optional leading sign, returns an int')), Assign(targets=[Name(id='fraction', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=BinOp(left=Call(func=Attribute(value=Call(func=Name(id='signed_integer', ctx=Load()), args=[], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='convert_to_float', ctx=Load())], keywords=[]), op=Add(), right=Constant(value='/')), op=Add(), right=Call(func=Attribute(value=Call(func=Name(id='signed_integer', ctx=Load()), args=[], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='convert_to_float', ctx=Load())], keywords=[])), attr='set_name', ctx=Load()), args=[Constant(value='fraction')], keywords=[])), Expr(value=Constant(value='fractional expression of an integer divided by an integer, returns a float')), Expr(value=Call(func=Attribute(value=Name(id='fraction', ctx=Load()), attr='add_parse_action', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='tt')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=BinOp(left=Subscript(value=Name(id='tt', ctx=Load()), slice=Constant(value=0), ctx=Load()), op=Div(), right=Subscript(value=Name(id='tt', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())))], keywords=[])), Assign(targets=[Name(id='mixed_integer', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=Name(id='fraction', ctx=Load()), op=BitOr(), right=BinOp(left=Name(id='signed_integer', ctx=Load()), op=Add(), right=Call(func=Name(id='Opt', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Call(func=Name(id='Opt', ctx=Load()), args=[Constant(value='-')], keywords=[]), attr='suppress', ctx=Load()), args=[], keywords=[]), op=Add(), right=Name(id='fraction', ctx=Load()))], keywords=[]))), attr='set_name', ctx=Load()), args=[Constant(value='fraction or mixed integer-fraction')], keywords=[])), Expr(value=Constant(value="mixed integer of the form 'integer - fraction', with optional leading integer, returns float")), Expr(value=Call(func=Attribute(value=Name(id='mixed_integer', ctx=Load()), attr='add_parse_action', ctx=Load()), args=[Name(id='sum', ctx=Load())], keywords=[])), Assign(targets=[Name(id='real', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='[+-]?(?:\\d+\\.\\d*|\\.\\d+)')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='real number')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='convert_to_float', ctx=Load())], keywords=[])), Expr(value=Constant(value='expression that parses a floating point number and returns a float')), Assign(targets=[Name(id='sci_real', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='[+-]?(?:\\d+(?:[eE][+-]?\\d+)|(?:\\d+\\.\\d*|\\.\\d+)(?:[eE][+-]?\\d+)?)')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='real number with scientific notation')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='convert_to_float', ctx=Load())], keywords=[])), Expr(value=Constant(value='expression that parses a floating point number with optional\n    scientific notation and returns a float')), Assign(targets=[Name(id='number', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=BinOp(left=BinOp(left=Name(id='sci_real', ctx=Load()), op=BitOr(), right=Name(id='real', ctx=Load())), op=BitOr(), right=Name(id='signed_integer', ctx=Load())), attr='setName', ctx=Load()), args=[Constant(value='number')], keywords=[]), attr='streamline', ctx=Load()), args=[], keywords=[])), Expr(value=Constant(value='any numeric expression, returns the corresponding Python type')), Assign(targets=[Name(id='fnumber', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='[+-]?\\d+\\.?\\d*([eE][+-]?\\d+)?')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='fnumber')], keywords=[]), attr='set_parse_action', ctx=Load()), args=[Name(id='convert_to_float', ctx=Load())], keywords=[])), Expr(value=Constant(value='any int or real number, returned as float')), Assign(targets=[Name(id='identifier', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Word', ctx=Load()), args=[Name(id='identchars', ctx=Load()), Name(id='identbodychars', ctx=Load())], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='identifier')], keywords=[])), Expr(value=Constant(value="typical code identifier (leading alpha or '_', followed by 0 or more alphas, nums, or '_')")), Assign(targets=[Name(id='ipv4_address', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})){3}')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='IPv4 address')], keywords=[])), Expr(value=Constant(value='IPv4 address (``0.0.0.0 - 255.255.255.255``)')), Assign(targets=[Name(id='_ipv6_part', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='[0-9a-fA-F]{1,4}')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='hex_integer')], keywords=[])), Assign(targets=[Name(id='_full_ipv6_address', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=Name(id='_ipv6_part', ctx=Load()), op=Add(), right=BinOp(left=BinOp(left=Constant(value=':'), op=Add(), right=Name(id='_ipv6_part', ctx=Load())), op=Mult(), right=Constant(value=7))), attr='set_name', ctx=Load()), args=[Constant(value='full IPv6 address')], keywords=[])), Assign(targets=[Name(id='_short_ipv6_address', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=BinOp(left=Call(func=Name(id='Opt', ctx=Load()), args=[BinOp(left=Name(id='_ipv6_part', ctx=Load()), op=Add(), right=BinOp(left=BinOp(left=Constant(value=':'), op=Add(), right=Name(id='_ipv6_part', ctx=Load())), op=Mult(), right=Tuple(elts=[Constant(value=0), Constant(value=6)], ctx=Load())))], keywords=[]), op=Add(), right=Constant(value='::')), op=Add(), right=Call(func=Name(id='Opt', ctx=Load()), args=[BinOp(left=Name(id='_ipv6_part', ctx=Load()), op=Add(), right=BinOp(left=BinOp(left=Constant(value=':'), op=Add(), right=Name(id='_ipv6_part', ctx=Load())), op=Mult(), right=Tuple(elts=[Constant(value=0), Constant(value=6)], ctx=Load())))], keywords=[])), attr='set_name', ctx=Load()), args=[Constant(value='short IPv6 address')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='_short_ipv6_address', ctx=Load()), attr='add_condition', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Compare(left=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Constant(value=1), generators=[comprehension(target=Name(id='tt', ctx=Store()), iter=Name(id='t', ctx=Load()), ifs=[Call(func=Attribute(value=Attribute(value=Name(id='pyparsing_common', ctx=Load()), attr='_ipv6_part', ctx=Load()), attr='matches', ctx=Load()), args=[Name(id='tt', ctx=Load())], keywords=[])], is_async=0)])], keywords=[]), ops=[Lt()], comparators=[Constant(value=8)]))], keywords=[])), Assign(targets=[Name(id='_mixed_ipv6_address', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=Constant(value='::ffff:'), op=Add(), right=Name(id='ipv4_address', ctx=Load())), attr='set_name', ctx=Load()), args=[Constant(value='mixed IPv6 address')], keywords=[])), Assign(targets=[Name(id='ipv6_address', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[Call(func=Attribute(value=BinOp(left=BinOp(left=Name(id='_full_ipv6_address', ctx=Load()), op=BitOr(), right=Name(id='_mixed_ipv6_address', ctx=Load())), op=BitOr(), right=Name(id='_short_ipv6_address', ctx=Load())), attr='set_name', ctx=Load()), args=[Constant(value='IPv6 address')], keywords=[])], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='IPv6 address')], keywords=[])), Expr(value=Constant(value='IPv6 address (long, short, or mixed form)')), Assign(targets=[Name(id='mac_address', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='[0-9a-fA-F]{2}([:.-])[0-9a-fA-F]{2}(?:\\1[0-9a-fA-F]{2}){4}')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='MAC address')], keywords=[])), Expr(value=Constant(value="MAC address xx:xx:xx:xx:xx (may also have '-' or '.' delimiters)")), FunctionDef(name='convert_to_date', args=arguments(posonlyargs=[], args=[arg(arg='fmt', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='%Y-%m-%d')]), body=[Expr(value=Constant(value='\n        Helper to create a parse action for converting parsed date string to Python datetime.date\n\n        Params -\n        - fmt - format to be passed to datetime.strptime (default= ``"%Y-%m-%d"``)\n\n        Example::\n\n            date_expr = pyparsing_common.iso8601_date.copy()\n            date_expr.set_parse_action(pyparsing_common.convert_to_date())\n            print(date_expr.parse_string("1999-12-31"))\n\n        prints::\n\n            [datetime.date(1999, 12, 31)]\n        ')), FunctionDef(name='cvt_fn', args=arguments(posonlyargs=[], args=[arg(arg='ss'), arg(arg='ll'), arg(arg='tt')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='strptime', ctx=Load()), args=[Subscript(value=Name(id='tt', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='fmt', ctx=Load())], keywords=[]), attr='date', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='ve', body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='ss', ctx=Load()), Name(id='ll', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='ve', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), Return(value=Name(id='cvt_fn', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='convert_to_datetime', args=arguments(posonlyargs=[], args=[arg(arg='fmt', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='%Y-%m-%dT%H:%M:%S.%f')]), body=[Expr(value=Constant(value='Helper to create a parse action for converting parsed\n        datetime string to Python datetime.datetime\n\n        Params -\n        - fmt - format to be passed to datetime.strptime (default= ``"%Y-%m-%dT%H:%M:%S.%f"``)\n\n        Example::\n\n            dt_expr = pyparsing_common.iso8601_datetime.copy()\n            dt_expr.set_parse_action(pyparsing_common.convert_to_datetime())\n            print(dt_expr.parse_string("1999-12-31T23:59:59.999"))\n\n        prints::\n\n            [datetime.datetime(1999, 12, 31, 23, 59, 59, 999000)]\n        ')), FunctionDef(name='cvt_fn', args=arguments(posonlyargs=[], args=[arg(arg='s'), arg(arg='l'), arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Return(value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='strptime', ctx=Load()), args=[Subscript(value=Name(id='t', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='fmt', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='ve', body=[Raise(exc=Call(func=Name(id='ParseException', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='l', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='ve', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), Return(value=Name(id='cvt_fn', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), Assign(targets=[Name(id='iso8601_date', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='(?P<year>\\d{4})(?:-(?P<month>\\d\\d)(?:-(?P<day>\\d\\d))?)?')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='ISO8601 date')], keywords=[])), Expr(value=Constant(value='ISO8601 date (``yyyy-mm-dd``)')), Assign(targets=[Name(id='iso8601_datetime', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='(?P<year>\\d{4})-(?P<month>\\d\\d)-(?P<day>\\d\\d)[T ](?P<hour>\\d\\d):(?P<minute>\\d\\d)(:(?P<second>\\d\\d(\\.\\d*)?)?)?(?P<tz>Z|[+-]\\d\\d:?\\d\\d)?')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='ISO8601 datetime')], keywords=[])), Expr(value=Constant(value="ISO8601 datetime (``yyyy-mm-ddThh:mm:ss.s(Z|+-00:00)``) - trailing seconds, milliseconds, and timezone optional; accepts separating ``'T'`` or ``' '``")), Assign(targets=[Name(id='uuid', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[Constant(value='[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}')], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='UUID')], keywords=[])), Expr(value=Constant(value='UUID (``xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx``)')), Assign(targets=[Name(id='_html_stripper', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='any_open_tag', ctx=Load()), attr='suppress', ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Attribute(value=Name(id='any_close_tag', ctx=Load()), attr='suppress', ctx=Load()), args=[], keywords=[]))), FunctionDef(name='strip_html_tags', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Name(id='str', ctx=Load())), arg(arg='l', annotation=Name(id='int', ctx=Load())), arg(arg='tokens', annotation=Name(id='ParseResults', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parse action to remove HTML tags from web page HTML source\n\n        Example::\n\n            # strip HTML links from normal text\n            text = \'<td>More info at the <a href="https://github.com/pyparsing/pyparsing/wiki">pyparsing</a> wiki page</td>\'\n            td, td_end = make_html_tags("TD")\n            table_text = td + SkipTo(td_end).set_parse_action(pyparsing_common.strip_html_tags)("body") + td_end\n            print(table_text.parse_string(text).body)\n\n        Prints::\n\n            More info at the pyparsing wiki page\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='pyparsing_common', ctx=Load()), attr='_html_stripper', ctx=Load()), attr='transform_string', ctx=Load()), args=[Subscript(value=Name(id='tokens', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), Assign(targets=[Name(id='_commasepitem', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='Combine', ctx=Load()), args=[Call(func=Name(id='OneOrMore', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='Literal', ctx=Load()), args=[Constant(value=',')], keywords=[])), op=Add(), right=UnaryOp(op=Invert(), operand=Call(func=Name(id='LineEnd', ctx=Load()), args=[], keywords=[]))), op=Add(), right=Call(func=Name(id='Word', ctx=Load()), args=[Name(id='printables', ctx=Load())], keywords=[keyword(arg='exclude_chars', value=Constant(value=','))])), op=Add(), right=Call(func=Name(id='Opt', ctx=Load()), args=[BinOp(left=Call(func=Name(id='White', ctx=Load()), args=[Constant(value=' \t')], keywords=[]), op=Add(), right=UnaryOp(op=Invert(), operand=Call(func=Name(id='FollowedBy', ctx=Load()), args=[BinOp(left=Call(func=Name(id='LineEnd', ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Constant(value=','))], keywords=[])))], keywords=[]))], keywords=[])], keywords=[]), attr='streamline', ctx=Load()), args=[], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='commaItem')], keywords=[])), Assign(targets=[Name(id='comma_separated_list', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='DelimitedList', ctx=Load()), args=[Call(func=Name(id='Opt', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='quoted_string', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Name(id='_commasepitem', ctx=Load()))], keywords=[keyword(arg='default', value=Constant(value=''))])], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='comma separated list')], keywords=[])), Expr(value=Constant(value='Predefined expression of 1 or more printable words or quoted strings, separated by commas.')), Assign(targets=[Name(id='upcase_tokens', ctx=Store())], value=Call(func=Name(id='staticmethod', ctx=Load()), args=[Call(func=Name(id='token_map', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]))], keywords=[])], keywords=[])), Expr(value=Constant(value='Parse action to convert tokens to upper case.')), Assign(targets=[Name(id='downcase_tokens', ctx=Store())], value=Call(func=Name(id='staticmethod', ctx=Load()), args=[Call(func=Name(id='token_map', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='t')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]))], keywords=[])], keywords=[])), Expr(value=Constant(value='Parse action to convert tokens to lower case.')), Assign(targets=[Name(id='url', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='Regex', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value='(?P<url>'), op=Add(), right=Constant(value='(?:(?:(?P<scheme>https?|ftp):)?\\/\\/)')), op=Add(), right=Constant(value='(?:(?P<auth>\\S+(?::\\S*)?)@)?')), op=Add(), right=Constant(value='(?P<host>')), op=Add(), right=Constant(value='(?!(?:10|127)(?:\\.\\d{1,3}){3})')), op=Add(), right=Constant(value='(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})')), op=Add(), right=Constant(value='(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})')), op=Add(), right=Constant(value='(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])')), op=Add(), right=Constant(value='(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}')), op=Add(), right=Constant(value='(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))')), op=Add(), right=Constant(value='|')), op=Add(), right=Constant(value='(?:')), op=Add(), right=Constant(value='(?:')), op=Add(), right=Constant(value='[a-z0-9\\u00a1-\\uffff]')), op=Add(), right=Constant(value='[a-z0-9\\u00a1-\\uffff_-]{0,62}')), op=Add(), right=Constant(value=')?')), op=Add(), right=Constant(value='[a-z0-9\\u00a1-\\uffff]\\.')), op=Add(), right=Constant(value=')+')), op=Add(), right=Constant(value='(?:[a-z\\u00a1-\\uffff]{2,}\\.?)')), op=Add(), right=Constant(value=')')), op=Add(), right=Constant(value='(:(?P<port>\\d{2,5}))?')), op=Add(), right=Constant(value='(?P<path>\\/[^?# ]*)?')), op=Add(), right=Constant(value='(\\?(?P<query>[^#]*))?')), op=Add(), right=Constant(value='(#(?P<fragment>\\S*))?')), op=Add(), right=Constant(value=')'))], keywords=[]), attr='set_name', ctx=Load()), args=[Constant(value='url')], keywords=[])), Expr(value=Constant(value='URL (http/https/ftp scheme)')), Assign(targets=[Name(id='convertToInteger', ctx=Store())], value=Name(id='convert_to_integer', ctx=Load())), Expr(value=Constant(value='Deprecated - use :class:`convert_to_integer`')), Assign(targets=[Name(id='convertToFloat', ctx=Store())], value=Name(id='convert_to_float', ctx=Load())), Expr(value=Constant(value='Deprecated - use :class:`convert_to_float`')), Assign(targets=[Name(id='convertToDate', ctx=Store())], value=Name(id='convert_to_date', ctx=Load())), Expr(value=Constant(value='Deprecated - use :class:`convert_to_date`')), Assign(targets=[Name(id='convertToDatetime', ctx=Store())], value=Name(id='convert_to_datetime', ctx=Load())), Expr(value=Constant(value='Deprecated - use :class:`convert_to_datetime`')), Assign(targets=[Name(id='stripHTMLTags', ctx=Store())], value=Name(id='strip_html_tags', ctx=Load())), Expr(value=Constant(value='Deprecated - use :class:`strip_html_tags`')), Assign(targets=[Name(id='upcaseTokens', ctx=Store())], value=Name(id='upcase_tokens', ctx=Load())), Expr(value=Constant(value='Deprecated - use :class:`upcase_tokens`')), Assign(targets=[Name(id='downcaseTokens', ctx=Store())], value=Name(id='downcase_tokens', ctx=Load())), Expr(value=Constant(value='Deprecated - use :class:`downcase_tokens`'))], decorator_list=[]), Assign(targets=[Name(id='_builtin_exprs', ctx=Store())], value=ListComp(elt=Name(id='v', ctx=Load()), generators=[comprehension(target=Name(id='v', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Name(id='vars', ctx=Load()), args=[Name(id='pyparsing_common', ctx=Load())], keywords=[]), attr='values', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='v', ctx=Load()), Name(id='ParserElement', ctx=Load())], keywords=[])], is_async=0)]))], type_ignores=[])