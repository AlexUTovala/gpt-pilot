Module(body=[Expr(value=Constant(value='Routines related to PyPI, indexes')), Import(names=[alias(name='enum')]), Import(names=[alias(name='functools')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='re')]), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='FrozenSet'), alias(name='Iterable'), alias(name='List'), alias(name='Optional'), alias(name='Set'), alias(name='Tuple'), alias(name='Union')], level=0), ImportFrom(module='pip._vendor.packaging', names=[alias(name='specifiers')], level=0), ImportFrom(module='pip._vendor.packaging.tags', names=[alias(name='Tag')], level=0), ImportFrom(module='pip._vendor.packaging.utils', names=[alias(name='canonicalize_name')], level=0), ImportFrom(module='pip._vendor.packaging.version', names=[alias(name='_BaseVersion')], level=0), ImportFrom(module='pip._vendor.packaging.version', names=[alias(name='parse', asname='parse_version')], level=0), ImportFrom(module='pip._internal.exceptions', names=[alias(name='BestVersionAlreadyInstalled'), alias(name='DistributionNotFound'), alias(name='InvalidWheelFilename'), alias(name='UnsupportedWheel')], level=0), ImportFrom(module='pip._internal.index.collector', names=[alias(name='LinkCollector'), alias(name='parse_links')], level=0), ImportFrom(module='pip._internal.models.candidate', names=[alias(name='InstallationCandidate')], level=0), ImportFrom(module='pip._internal.models.format_control', names=[alias(name='FormatControl')], level=0), ImportFrom(module='pip._internal.models.link', names=[alias(name='Link')], level=0), ImportFrom(module='pip._internal.models.search_scope', names=[alias(name='SearchScope')], level=0), ImportFrom(module='pip._internal.models.selection_prefs', names=[alias(name='SelectionPreferences')], level=0), ImportFrom(module='pip._internal.models.target_python', names=[alias(name='TargetPython')], level=0), ImportFrom(module='pip._internal.models.wheel', names=[alias(name='Wheel')], level=0), ImportFrom(module='pip._internal.req', names=[alias(name='InstallRequirement')], level=0), ImportFrom(module='pip._internal.utils._log', names=[alias(name='getLogger')], level=0), ImportFrom(module='pip._internal.utils.filetypes', names=[alias(name='WHEEL_EXTENSION')], level=0), ImportFrom(module='pip._internal.utils.hashes', names=[alias(name='Hashes')], level=0), ImportFrom(module='pip._internal.utils.logging', names=[alias(name='indent_log')], level=0), ImportFrom(module='pip._internal.utils.misc', names=[alias(name='build_netloc')], level=0), ImportFrom(module='pip._internal.utils.packaging', names=[alias(name='check_requires_python')], level=0), ImportFrom(module='pip._internal.utils.unpacking', names=[alias(name='SUPPORTED_EXTENSIONS')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='pip._vendor.typing_extensions', names=[alias(name='TypeGuard')], level=0)], orelse=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='FormatControl'), Constant(value='BestCandidateResult'), Constant(value='PackageFinder')], ctx=Load())), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Name(id='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='BuildTag', ctx=Store())], value=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[], ctx=Load()), ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='CandidateSortingKey', ctx=Store())], value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='_BaseVersion', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), Name(id='BuildTag', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_check_link_requires_python', args=arguments(posonlyargs=[], args=[arg(arg='link', annotation=Name(id='Link', ctx=Load())), arg(arg='version_info', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='ignore_requires_python', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Return whether the given Python version is compatible with a link\'s\n    "Requires-Python" value.\n\n    :param version_info: A 3-tuple of ints representing the Python\n        major-minor-micro version to check.\n    :param ignore_requires_python: Whether to ignore the "Requires-Python"\n        value if the given Python version isn\'t compatible.\n    ')), Try(body=[Assign(targets=[Name(id='is_compatible', ctx=Store())], value=Call(func=Name(id='check_requires_python', ctx=Load()), args=[Attribute(value=Name(id='link', ctx=Load()), attr='requires_python', ctx=Load())], keywords=[keyword(arg='version_info', value=Name(id='version_info', ctx=Load()))]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='specifiers', ctx=Load()), attr='InvalidSpecifier', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Ignoring invalid Requires-Python (%r) for link: %s'), Attribute(value=Name(id='link', ctx=Load()), attr='requires_python', ctx=Load()), Name(id='link', ctx=Load())], keywords=[]))])], orelse=[If(test=UnaryOp(op=Not(), operand=Name(id='is_compatible', ctx=Load())), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='version_info', ctx=Load())], keywords=[])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='ignore_requires_python', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='verbose', ctx=Load()), args=[Constant(value='Link requires a different Python (%s not in: %r): %s'), Name(id='version', ctx=Load()), Attribute(value=Name(id='link', ctx=Load()), attr='requires_python', ctx=Load()), Name(id='link', ctx=Load())], keywords=[])), Return(value=Constant(value=False))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Ignoring failed Requires-Python check (%s not in: %r) for link: %s'), Name(id='version', ctx=Load()), Attribute(value=Name(id='link', ctx=Load()), attr='requires_python', ctx=Load()), Name(id='link', ctx=Load())], keywords=[]))], orelse=[])], finalbody=[]), Return(value=Constant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), ClassDef(name='LinkType', bases=[Attribute(value=Name(id='enum', ctx=Load()), attr='Enum', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='candidate', ctx=Store())], value=Call(func=Attribute(value=Name(id='enum', ctx=Load()), attr='auto', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='different_project', ctx=Store())], value=Call(func=Attribute(value=Name(id='enum', ctx=Load()), attr='auto', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='yanked', ctx=Store())], value=Call(func=Attribute(value=Name(id='enum', ctx=Load()), attr='auto', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='format_unsupported', ctx=Store())], value=Call(func=Attribute(value=Name(id='enum', ctx=Load()), attr='auto', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='format_invalid', ctx=Store())], value=Call(func=Attribute(value=Name(id='enum', ctx=Load()), attr='auto', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='platform_mismatch', ctx=Store())], value=Call(func=Attribute(value=Name(id='enum', ctx=Load()), attr='auto', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='requires_python_mismatch', ctx=Store())], value=Call(func=Attribute(value=Name(id='enum', ctx=Load()), attr='auto', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), ClassDef(name='LinkEvaluator', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Responsible for evaluating links for a particular project.\n    ')), Assign(targets=[Name(id='_py_version_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='-py([123]\\.?[0-9]?)$')], keywords=[])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_name', annotation=Name(id='str', ctx=Load())), arg(arg='canonical_name', annotation=Name(id='str', ctx=Load())), arg(arg='formats', annotation=Subscript(value=Name(id='FrozenSet', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='target_python', annotation=Name(id='TargetPython', ctx=Load())), arg(arg='allow_yanked', annotation=Name(id='bool', ctx=Load())), arg(arg='ignore_requires_python', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n        :param project_name: The user supplied package name.\n        :param canonical_name: The canonical package name.\n        :param formats: The formats allowed for this package. Should be a set\n            with \'binary\' or \'source\' or both in it.\n        :param target_python: The target Python interpreter to use when\n            evaluating link compatibility. This is used, for example, to\n            check wheel compatibility, as well as when checking the Python\n            version, e.g. the Python version embedded in a link filename\n            (or egg fragment) and against an HTML link\'s optional PEP 503\n            "data-requires-python" attribute.\n        :param allow_yanked: Whether files marked as yanked (in the sense\n            of PEP 592) are permitted to be candidates for install.\n        :param ignore_requires_python: Whether to ignore incompatible\n            PEP 503 "data-requires-python" values in HTML links. Defaults\n            to False.\n        ')), If(test=Compare(left=Name(id='ignore_requires_python', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='ignore_requires_python', ctx=Store())], value=Constant(value=False))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_allow_yanked', ctx=Store())], value=Name(id='allow_yanked', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_canonical_name', ctx=Store())], value=Name(id='canonical_name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ignore_requires_python', ctx=Store())], value=Name(id='ignore_requires_python', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_formats', ctx=Store())], value=Name(id='formats', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_target_python', ctx=Store())], value=Name(id='target_python', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Store())], value=Name(id='project_name', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='evaluate_link', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='link', annotation=Name(id='Link', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Determine whether a link is a candidate for installation.\n\n        :return: A tuple (result, detail), where *result* is an enum\n            representing whether the evaluation found a candidate, or the reason\n            why one is not found. If a candidate is found, *detail* will be the\n            candidate's version string; if one is not found, it contains the\n            reason the link fails to qualify.\n        ")), Assign(targets=[Name(id='version', ctx=Store())], value=Constant(value=None)), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='link', ctx=Load()), attr='is_yanked', ctx=Load()), UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_allow_yanked', ctx=Load()))]), body=[Assign(targets=[Name(id='reason', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='link', ctx=Load()), attr='yanked_reason', ctx=Load()), Constant(value='<none given>')])), Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='yanked', ctx=Load()), JoinedStr(values=[Constant(value='yanked for reason: '), FormattedValue(value=Name(id='reason', ctx=Load()), conversion=-1)])], ctx=Load()))], orelse=[]), If(test=Attribute(value=Name(id='link', ctx=Load()), attr='egg_fragment', ctx=Load()), body=[Assign(targets=[Name(id='egg_info', ctx=Store())], value=Attribute(value=Name(id='link', ctx=Load()), attr='egg_fragment', ctx=Load())), Assign(targets=[Name(id='ext', ctx=Store())], value=Attribute(value=Name(id='link', ctx=Load()), attr='ext', ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='egg_info', ctx=Store()), Name(id='ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='link', ctx=Load()), attr='splitext', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='ext', ctx=Load())), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='format_unsupported', ctx=Load()), Constant(value='not a file')], ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='ext', ctx=Load()), ops=[NotIn()], comparators=[Name(id='SUPPORTED_EXTENSIONS', ctx=Load())]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='format_unsupported', ctx=Load()), JoinedStr(values=[Constant(value='unsupported archive format: '), FormattedValue(value=Name(id='ext', ctx=Load()), conversion=-1)])], ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='binary'), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_formats', ctx=Load())]), Compare(left=Name(id='ext', ctx=Load()), ops=[Eq()], comparators=[Name(id='WHEEL_EXTENSION', ctx=Load())])]), body=[Assign(targets=[Name(id='reason', ctx=Store())], value=JoinedStr(values=[Constant(value='No binaries permitted for '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), conversion=-1)])), Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='format_unsupported', ctx=Load()), Name(id='reason', ctx=Load())], ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='macosx10'), ops=[In()], comparators=[Attribute(value=Name(id='link', ctx=Load()), attr='path', ctx=Load())]), Compare(left=Name(id='ext', ctx=Load()), ops=[Eq()], comparators=[Constant(value='.zip')])]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='format_unsupported', ctx=Load()), Constant(value='macosx10 one')], ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='ext', ctx=Load()), ops=[Eq()], comparators=[Name(id='WHEEL_EXTENSION', ctx=Load())]), body=[Try(body=[Assign(targets=[Name(id='wheel', ctx=Store())], value=Call(func=Name(id='Wheel', ctx=Load()), args=[Attribute(value=Name(id='link', ctx=Load()), attr='filename', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='InvalidWheelFilename', ctx=Load()), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='format_invalid', ctx=Load()), Constant(value='invalid wheel filename')], ctx=Load()))])], orelse=[], finalbody=[]), If(test=Compare(left=Call(func=Name(id='canonicalize_name', ctx=Load()), args=[Attribute(value=Name(id='wheel', ctx=Load()), attr='name', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_canonical_name', ctx=Load())]), body=[Assign(targets=[Name(id='reason', ctx=Store())], value=JoinedStr(values=[Constant(value='wrong project name (not '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), conversion=-1), Constant(value=')')])), Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='different_project', ctx=Load()), Name(id='reason', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='supported_tags', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_target_python', ctx=Load()), attr='get_unsorted_tags', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='wheel', ctx=Load()), attr='supported', ctx=Load()), args=[Name(id='supported_tags', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='file_tags', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='wheel', ctx=Load()), attr='get_formatted_file_tags', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='reason', ctx=Store())], value=JoinedStr(values=[Constant(value="none of the wheel's tags ("), FormattedValue(value=Name(id='file_tags', ctx=Load()), conversion=-1), Constant(value=') are compatible (run pip debug --verbose to show compatible tags)')])), Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='platform_mismatch', ctx=Load()), Name(id='reason', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='version', ctx=Store())], value=Attribute(value=Name(id='wheel', ctx=Load()), attr='version', ctx=Load()))], orelse=[])]), If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='source'), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_formats', ctx=Load())]), Compare(left=Name(id='ext', ctx=Load()), ops=[NotEq()], comparators=[Name(id='WHEEL_EXTENSION', ctx=Load())])]), body=[Assign(targets=[Name(id='reason', ctx=Store())], value=JoinedStr(values=[Constant(value='No sources permitted for '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), conversion=-1)])), Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='format_unsupported', ctx=Load()), Name(id='reason', ctx=Load())], ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='version', ctx=Load())), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Name(id='_extract_version_from_fragment', ctx=Load()), args=[Name(id='egg_info', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_canonical_name', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='version', ctx=Load())), body=[Assign(targets=[Name(id='reason', ctx=Store())], value=JoinedStr(values=[Constant(value='Missing project version for '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='project_name', ctx=Load()), conversion=-1)])), Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='format_invalid', ctx=Load()), Name(id='reason', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_py_version_re', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Assign(targets=[Name(id='version', ctx=Store())], value=Subscript(value=Name(id='version', ctx=Load()), slice=Slice(upper=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[])), ctx=Load())), Assign(targets=[Name(id='py_version', ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[])), If(test=Compare(left=Name(id='py_version', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_target_python', ctx=Load()), attr='py_version', ctx=Load())]), body=[Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='platform_mismatch', ctx=Load()), Constant(value='Python version is incorrect')], ctx=Load()))], orelse=[])], orelse=[]), Assign(targets=[Name(id='supports_python', ctx=Store())], value=Call(func=Name(id='_check_link_requires_python', ctx=Load()), args=[Name(id='link', ctx=Load())], keywords=[keyword(arg='version_info', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_target_python', ctx=Load()), attr='py_version_info', ctx=Load())), keyword(arg='ignore_requires_python', value=Attribute(value=Name(id='self', ctx=Load()), attr='_ignore_requires_python', ctx=Load()))])), If(test=UnaryOp(op=Not(), operand=Name(id='supports_python', ctx=Load())), body=[Assign(targets=[Name(id='reason', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='version', ctx=Load()), conversion=-1), Constant(value=' Requires-Python '), FormattedValue(value=Attribute(value=Name(id='link', ctx=Load()), attr='requires_python', ctx=Load()), conversion=-1)])), Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='requires_python_mismatch', ctx=Load()), Name(id='reason', ctx=Load())], ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Found link %s, version: %s'), Name(id='link', ctx=Load()), Name(id='version', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='candidate', ctx=Load()), Name(id='version', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='LinkType', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='filter_unallowed_hashes', args=arguments(posonlyargs=[], args=[arg(arg='candidates', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), arg(arg='hashes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Hashes', ctx=Load()), ctx=Load())), arg(arg='project_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Filter out candidates whose hashes aren't allowed, and return a new\n    list of candidates.\n\n    If at least one candidate has an allowed hash, then all candidates with\n    either an allowed hash or no hash specified are returned.  Otherwise,\n    the given candidates are returned.\n\n    Including the candidates with no hash specified when there is a match\n    allows a warning to be logged if there is a more preferred candidate\n    with no hash specified.  Returning all candidates in the case of no\n    matches lets pip report the hash of the candidate that would otherwise\n    have been installed (e.g. permitting the user to more easily update\n    their requirements file with the desired hash).\n    ")), If(test=UnaryOp(op=Not(), operand=Name(id='hashes', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Given no hashes to check %s links for project %r: discarding no candidates'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='candidates', ctx=Load())], keywords=[]), Name(id='project_name', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='candidates', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='matches_or_no_digest', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='non_matches', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='match_count', ctx=Store())], value=Constant(value=0)), For(target=Name(id='candidate', ctx=Store()), iter=Name(id='candidates', ctx=Load()), body=[Assign(targets=[Name(id='link', ctx=Store())], value=Attribute(value=Name(id='candidate', ctx=Load()), attr='link', ctx=Load())), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='link', ctx=Load()), attr='has_hash', ctx=Load())), body=[Pass()], orelse=[If(test=Call(func=Attribute(value=Name(id='link', ctx=Load()), attr='is_hash_allowed', ctx=Load()), args=[], keywords=[keyword(arg='hashes', value=Name(id='hashes', ctx=Load()))]), body=[AugAssign(target=Name(id='match_count', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='non_matches', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='candidate', ctx=Load())], keywords=[])), Continue()])]), Expr(value=Call(func=Attribute(value=Name(id='matches_or_no_digest', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='candidate', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='match_count', ctx=Load()), body=[Assign(targets=[Name(id='filtered', ctx=Store())], value=Name(id='matches_or_no_digest', ctx=Load()))], orelse=[Assign(targets=[Name(id='filtered', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='candidates', ctx=Load())], keywords=[]))]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='filtered', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='candidates', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='discard_message', ctx=Store())], value=Constant(value='discarding no candidates'))], orelse=[Assign(targets=[Name(id='discard_message', ctx=Store())], value=Call(func=Attribute(value=Constant(value='discarding {} non-matches:\n  {}'), attr='format', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='non_matches', ctx=Load())], keywords=[]), Call(func=Attribute(value=Constant(value='\n  '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='candidate', ctx=Load()), attr='link', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='candidate', ctx=Store()), iter=Name(id='non_matches', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Checked %s links for project %r against %s hashes (%s matches, %s no digest): %s'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='candidates', ctx=Load())], keywords=[]), Name(id='project_name', ctx=Load()), Attribute(value=Name(id='hashes', ctx=Load()), attr='digest_count', ctx=Load()), Name(id='match_count', ctx=Load()), BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='matches_or_no_digest', ctx=Load())], keywords=[]), op=Sub(), right=Name(id='match_count', ctx=Load())), Name(id='discard_message', ctx=Load())], keywords=[])), Return(value=Name(id='filtered', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), ClassDef(name='CandidatePreferences', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Encapsulates some of the preferences for filtering and sorting\n    InstallationCandidate objects.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prefer_binary', annotation=Name(id='bool', ctx=Load())), arg(arg='allow_all_prereleases', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value='\n        :param allow_all_prereleases: Whether to allow all pre-releases.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='allow_all_prereleases', ctx=Store())], value=Name(id='allow_all_prereleases', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='prefer_binary', ctx=Store())], value=Name(id='prefer_binary', ctx=Load()))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='BestCandidateResult', bases=[], keywords=[], body=[Expr(value=Constant(value="A collection of candidates, returned by `PackageFinder.find_best_candidate`.\n\n    This class is only intended to be instantiated by CandidateEvaluator's\n    `compute_best_candidate()` method.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='candidates', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), arg(arg='applicable_candidates', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), arg(arg='best_candidate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        :param candidates: A sequence of all available candidates found.\n        :param applicable_candidates: The applicable candidates.\n        :param best_candidate: The most preferred candidate found, or None\n            if no applicable candidates were found.\n        ')), Assert(test=Compare(left=Call(func=Name(id='set', ctx=Load()), args=[Name(id='applicable_candidates', ctx=Load())], keywords=[]), ops=[LtE()], comparators=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='candidates', ctx=Load())], keywords=[])])), If(test=Compare(left=Name(id='best_candidate', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assert(test=UnaryOp(op=Not(), operand=Name(id='applicable_candidates', ctx=Load())))], orelse=[Assert(test=Compare(left=Name(id='best_candidate', ctx=Load()), ops=[In()], comparators=[Name(id='applicable_candidates', ctx=Load())]))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_applicable_candidates', ctx=Store())], value=Name(id='applicable_candidates', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_candidates', ctx=Store())], value=Name(id='candidates', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='best_candidate', ctx=Store())], value=Name(id='best_candidate', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='iter_all', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterate through all candidates.')), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_candidates', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), FunctionDef(name='iter_applicable', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterate through the applicable candidates.')), Return(value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_applicable_candidates', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load()))], decorator_list=[]), ClassDef(name='CandidateEvaluator', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Responsible for filtering and sorting candidates for installation based\n    on what tags are valid.\n    ')), FunctionDef(name='create', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='project_name', annotation=Name(id='str', ctx=Load())), arg(arg='target_python', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='TargetPython', ctx=Load()), ctx=Load())), arg(arg='prefer_binary', annotation=Name(id='bool', ctx=Load())), arg(arg='allow_all_prereleases', annotation=Name(id='bool', ctx=Load())), arg(arg='specifier', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='specifiers', ctx=Load()), attr='BaseSpecifier', ctx=Load()), ctx=Load())), arg(arg='hashes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Hashes', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Create a CandidateEvaluator object.\n\n        :param target_python: The target Python interpreter to use when\n            checking compatibility. If None (the default), a TargetPython\n            object will be constructed from the running Python.\n        :param specifier: An optional object implementing `filter`\n            (e.g. `packaging.specifiers.SpecifierSet`) to filter applicable\n            versions.\n        :param hashes: An optional collection of allowed hashes.\n        ')), If(test=Compare(left=Name(id='target_python', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='target_python', ctx=Store())], value=Call(func=Name(id='TargetPython', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='specifier', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='specifier', ctx=Store())], value=Call(func=Attribute(value=Name(id='specifiers', ctx=Load()), attr='SpecifierSet', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='supported_tags', ctx=Store())], value=Call(func=Attribute(value=Name(id='target_python', ctx=Load()), attr='get_sorted_tags', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[], keywords=[keyword(arg='project_name', value=Name(id='project_name', ctx=Load())), keyword(arg='supported_tags', value=Name(id='supported_tags', ctx=Load())), keyword(arg='specifier', value=Name(id='specifier', ctx=Load())), keyword(arg='prefer_binary', value=Name(id='prefer_binary', ctx=Load())), keyword(arg='allow_all_prereleases', value=Name(id='allow_all_prereleases', ctx=Load())), keyword(arg='hashes', value=Name(id='hashes', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='CandidateEvaluator')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_name', annotation=Name(id='str', ctx=Load())), arg(arg='supported_tags', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Tag', ctx=Load()), ctx=Load())), arg(arg='specifier', annotation=Attribute(value=Name(id='specifiers', ctx=Load()), attr='BaseSpecifier', ctx=Load())), arg(arg='prefer_binary', annotation=Name(id='bool', ctx=Load())), arg(arg='allow_all_prereleases', annotation=Name(id='bool', ctx=Load())), arg(arg='hashes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Hashes', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='\n        :param supported_tags: The PEP 425 tags supported by the target\n            Python in order of preference (most preferred first).\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_allow_all_prereleases', ctx=Store())], value=Name(id='allow_all_prereleases', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_hashes', ctx=Store())], value=Name(id='hashes', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_prefer_binary', ctx=Store())], value=Name(id='prefer_binary', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_project_name', ctx=Store())], value=Name(id='project_name', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_specifier', ctx=Store())], value=Name(id='specifier', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_supported_tags', ctx=Store())], value=Name(id='supported_tags', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_wheel_tag_preferences', ctx=Store())], value=DictComp(key=Name(id='tag', ctx=Load()), value=Name(id='idx', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='tag', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='supported_tags', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_applicable_candidates', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='candidates', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the applicable candidates from a list of candidates.\n        ')), Assign(targets=[Name(id='allow_prereleases', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_allow_all_prereleases', ctx=Load()), Constant(value=None)])), Assign(targets=[Name(id='specifier', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_specifier', ctx=Load())), Assign(targets=[Name(id='versions', ctx=Store())], value=SetComp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='v', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='v', ctx=Store()), iter=Call(func=Attribute(value=Name(id='specifier', ctx=Load()), attr='filter', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='c', ctx=Load()), attr='version', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='c', ctx=Store()), iter=Name(id='candidates', ctx=Load()), ifs=[], is_async=0)])], keywords=[keyword(arg='prereleases', value=Name(id='allow_prereleases', ctx=Load()))]), ifs=[], is_async=0)])), Assign(targets=[Name(id='applicable_candidates', ctx=Store())], value=ListComp(elt=Name(id='c', ctx=Load()), generators=[comprehension(target=Name(id='c', ctx=Store()), iter=Name(id='candidates', ctx=Load()), ifs=[Compare(left=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='c', ctx=Load()), attr='version', ctx=Load())], keywords=[]), ops=[In()], comparators=[Name(id='versions', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='filtered_applicable_candidates', ctx=Store())], value=Call(func=Name(id='filter_unallowed_hashes', ctx=Load()), args=[], keywords=[keyword(arg='candidates', value=Name(id='applicable_candidates', ctx=Load())), keyword(arg='hashes', value=Attribute(value=Name(id='self', ctx=Load()), attr='_hashes', ctx=Load())), keyword(arg='project_name', value=Attribute(value=Name(id='self', ctx=Load()), attr='_project_name', ctx=Load()))])), Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='filtered_applicable_candidates', ctx=Load())], keywords=[keyword(arg='key', value=Attribute(value=Name(id='self', ctx=Load()), attr='_sort_key', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), FunctionDef(name='_sort_key', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='candidate', annotation=Name(id='InstallationCandidate', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Function to pass as the `key` argument to a call to sorted() to sort\n        InstallationCandidates by preference.\n\n        Returns a tuple such that tuples sorting as greater using Python's\n        default comparison operator are more preferred.\n\n        The preference is as follows:\n\n        First and foremost, candidates with allowed (matching) hashes are\n        always preferred over candidates without matching hashes. This is\n        because e.g. if the only candidate with an allowed hash is yanked,\n        we still want to use that candidate.\n\n        Second, excepting hash considerations, candidates that have been\n        yanked (in the sense of PEP 592) are always less preferred than\n        candidates that haven't been yanked. Then:\n\n        If not finding wheels, they are sorted by version only.\n        If finding wheels, then the sort order is by version, then:\n          1. existing installs\n          2. wheels ordered via Wheel.support_index_min(self._supported_tags)\n          3. source archives\n        If prefer_binary was set, then all wheels are sorted above sources.\n\n        Note: it was considered to embed this logic into the Link\n              comparison operators, but then different sdist links\n              with the same version, would have to be considered equal\n        ")), Assign(targets=[Name(id='valid_tags', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_supported_tags', ctx=Load())), Assign(targets=[Name(id='support_num', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='valid_tags', ctx=Load())], keywords=[])), AnnAssign(target=Name(id='build_tag', ctx=Store()), annotation=Name(id='BuildTag', ctx=Load()), value=Tuple(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='binary_preference', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='link', ctx=Store())], value=Attribute(value=Name(id='candidate', ctx=Load()), attr='link', ctx=Load())), If(test=Attribute(value=Name(id='link', ctx=Load()), attr='is_wheel', ctx=Load()), body=[Assign(targets=[Name(id='wheel', ctx=Store())], value=Call(func=Name(id='Wheel', ctx=Load()), args=[Attribute(value=Name(id='link', ctx=Load()), attr='filename', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Name(id='pri', ctx=Store())], value=UnaryOp(op=USub(), operand=Call(func=Attribute(value=Name(id='wheel', ctx=Load()), attr='find_most_preferred_tag', ctx=Load()), args=[Name(id='valid_tags', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_wheel_tag_preferences', ctx=Load())], keywords=[])))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='UnsupportedWheel', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="{} is not a supported wheel for this platform. It can't be sorted."), attr='format', ctx=Load()), args=[Attribute(value=Name(id='wheel', ctx=Load()), attr='filename', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_prefer_binary', ctx=Load()), body=[Assign(targets=[Name(id='binary_preference', ctx=Store())], value=Constant(value=1))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='wheel', ctx=Load()), attr='build_tag', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Constant(value='^(\\d+)(.*)$'), Attribute(value=Name(id='wheel', ctx=Load()), attr='build_tag', ctx=Load())], keywords=[])), Assert(test=Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), msg=Constant(value='guaranteed by filename validation')), Assign(targets=[Name(id='build_tag_groups', ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='build_tag', ctx=Store())], value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Subscript(value=Name(id='build_tag_groups', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), Subscript(value=Name(id='build_tag_groups', ctx=Load()), slice=Constant(value=1), ctx=Load())], ctx=Load()))], orelse=[])], orelse=[Assign(targets=[Name(id='pri', ctx=Store())], value=UnaryOp(op=USub(), operand=Name(id='support_num', ctx=Load())))]), Assign(targets=[Name(id='has_allowed_hash', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='link', ctx=Load()), attr='is_hash_allowed', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_hashes', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='yank_value', ctx=Store())], value=BinOp(left=UnaryOp(op=USub(), operand=Constant(value=1)), op=Mult(), right=Call(func=Name(id='int', ctx=Load()), args=[Attribute(value=Name(id='link', ctx=Load()), attr='is_yanked', ctx=Load())], keywords=[]))), Return(value=Tuple(elts=[Name(id='has_allowed_hash', ctx=Load()), Name(id='yank_value', ctx=Load()), Name(id='binary_preference', ctx=Load()), Attribute(value=Name(id='candidate', ctx=Load()), attr='version', ctx=Load()), Name(id='pri', ctx=Load()), Name(id='build_tag', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Name(id='CandidateSortingKey', ctx=Load())), FunctionDef(name='sort_best_candidate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='candidates', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Return the best candidate per the instance's sort order, or None if\n        no candidate is acceptable.\n        ")), If(test=UnaryOp(op=Not(), operand=Name(id='candidates', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='best_candidate', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Name(id='candidates', ctx=Load())], keywords=[keyword(arg='key', value=Attribute(value=Name(id='self', ctx=Load()), attr='_sort_key', ctx=Load()))])), Return(value=Name(id='best_candidate', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), FunctionDef(name='compute_best_candidate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='candidates', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Compute and return a `BestCandidateResult` instance.\n        ')), Assign(targets=[Name(id='applicable_candidates', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_applicable_candidates', ctx=Load()), args=[Name(id='candidates', ctx=Load())], keywords=[])), Assign(targets=[Name(id='best_candidate', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='sort_best_candidate', ctx=Load()), args=[Name(id='applicable_candidates', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='BestCandidateResult', ctx=Load()), args=[Name(id='candidates', ctx=Load())], keywords=[keyword(arg='applicable_candidates', value=Name(id='applicable_candidates', ctx=Load())), keyword(arg='best_candidate', value=Name(id='best_candidate', ctx=Load()))]))], decorator_list=[], returns=Name(id='BestCandidateResult', ctx=Load()))], decorator_list=[]), ClassDef(name='PackageFinder', bases=[], keywords=[], body=[Expr(value=Constant(value="This finds packages.\n\n    This is meant to match easy_install's technique for looking for\n    packages, by reading pages and looking for appropriate links.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='link_collector', annotation=Name(id='LinkCollector', ctx=Load())), arg(arg='target_python', annotation=Name(id='TargetPython', ctx=Load())), arg(arg='allow_yanked', annotation=Name(id='bool', ctx=Load())), arg(arg='format_control', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='FormatControl', ctx=Load()), ctx=Load())), arg(arg='candidate_prefs', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CandidatePreferences', ctx=Load()), ctx=Load())), arg(arg='ignore_requires_python', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='\n        This constructor is primarily meant to be used by the create() class\n        method and from tests.\n\n        :param format_control: A FormatControl object, used to control\n            the selection of source packages / binary packages when consulting\n            the index and links.\n        :param candidate_prefs: Options to use when creating a\n            CandidateEvaluator object.\n        ')), If(test=Compare(left=Name(id='candidate_prefs', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='candidate_prefs', ctx=Store())], value=Call(func=Name(id='CandidatePreferences', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='format_control', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='format_control', ctx=Load()), Call(func=Name(id='FormatControl', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])], keywords=[])])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_allow_yanked', ctx=Store())], value=Name(id='allow_yanked', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_candidate_prefs', ctx=Store())], value=Name(id='candidate_prefs', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ignore_requires_python', ctx=Store())], value=Name(id='ignore_requires_python', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_link_collector', ctx=Store())], value=Name(id='link_collector', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_target_python', ctx=Store())], value=Name(id='target_python', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='format_control', ctx=Store())], value=Name(id='format_control', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_logged_links', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Link', ctx=Load()), Name(id='LinkType', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='create', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='link_collector', annotation=Name(id='LinkCollector', ctx=Load())), arg(arg='selection_prefs', annotation=Name(id='SelectionPreferences', ctx=Load())), arg(arg='target_python', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='TargetPython', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Create a PackageFinder.\n\n        :param selection_prefs: The candidate selection preferences, as a\n            SelectionPreferences object.\n        :param target_python: The target Python interpreter to use when\n            checking compatibility. If None (the default), a TargetPython\n            object will be constructed from the running Python.\n        ')), If(test=Compare(left=Name(id='target_python', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='target_python', ctx=Store())], value=Call(func=Name(id='TargetPython', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='candidate_prefs', ctx=Store())], value=Call(func=Name(id='CandidatePreferences', ctx=Load()), args=[], keywords=[keyword(arg='prefer_binary', value=Attribute(value=Name(id='selection_prefs', ctx=Load()), attr='prefer_binary', ctx=Load())), keyword(arg='allow_all_prereleases', value=Attribute(value=Name(id='selection_prefs', ctx=Load()), attr='allow_all_prereleases', ctx=Load()))])), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[], keywords=[keyword(arg='candidate_prefs', value=Name(id='candidate_prefs', ctx=Load())), keyword(arg='link_collector', value=Name(id='link_collector', ctx=Load())), keyword(arg='target_python', value=Name(id='target_python', ctx=Load())), keyword(arg='allow_yanked', value=Attribute(value=Name(id='selection_prefs', ctx=Load()), attr='allow_yanked', ctx=Load())), keyword(arg='format_control', value=Attribute(value=Name(id='selection_prefs', ctx=Load()), attr='format_control', ctx=Load())), keyword(arg='ignore_requires_python', value=Attribute(value=Name(id='selection_prefs', ctx=Load()), attr='ignore_requires_python', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='PackageFinder')), FunctionDef(name='target_python', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_target_python', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='TargetPython', ctx=Load())), FunctionDef(name='search_scope', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_link_collector', ctx=Load()), attr='search_scope', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='SearchScope', ctx=Load())), FunctionDef(name='search_scope', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='search_scope', annotation=Name(id='SearchScope', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_link_collector', ctx=Load()), attr='search_scope', ctx=Store())], value=Name(id='search_scope', ctx=Load()))], decorator_list=[Attribute(value=Name(id='search_scope', ctx=Load()), attr='setter', ctx=Load())], returns=Constant(value=None)), FunctionDef(name='find_links', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_link_collector', ctx=Load()), attr='find_links', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='index_urls', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='search_scope', ctx=Load()), attr='index_urls', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='trusted_hosts', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='host_port', ctx=Store()), iter=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_link_collector', ctx=Load()), attr='session', ctx=Load()), attr='pip_trusted_origins', ctx=Load()), body=[Expr(value=Yield(value=Call(func=Name(id='build_netloc', ctx=Load()), args=[Starred(value=Name(id='host_port', ctx=Load()), ctx=Load())], keywords=[])))], orelse=[])], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='allow_all_prereleases', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_candidate_prefs', ctx=Load()), attr='allow_all_prereleases', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='set_allow_all_prereleases', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_candidate_prefs', ctx=Load()), attr='allow_all_prereleases', ctx=Store())], value=Constant(value=True))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='prefer_binary', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_candidate_prefs', ctx=Load()), attr='prefer_binary', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='set_prefer_binary', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_candidate_prefs', ctx=Load()), attr='prefer_binary', ctx=Store())], value=Constant(value=True))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='requires_python_skipped_reasons', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='reasons', ctx=Store())], value=SetComp(elt=Name(id='detail', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='_', ctx=Store()), Name(id='result', ctx=Store()), Name(id='detail', ctx=Store())], ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_logged_links', ctx=Load()), ifs=[Compare(left=Name(id='result', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='requires_python_mismatch', ctx=Load())])], is_async=0)])), Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='reasons', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='make_link_evaluator', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='canonical_name', ctx=Store())], value=Call(func=Name(id='canonicalize_name', ctx=Load()), args=[Name(id='project_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='formats', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='format_control', ctx=Load()), attr='get_allowed_formats', ctx=Load()), args=[Name(id='canonical_name', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='LinkEvaluator', ctx=Load()), args=[], keywords=[keyword(arg='project_name', value=Name(id='project_name', ctx=Load())), keyword(arg='canonical_name', value=Name(id='canonical_name', ctx=Load())), keyword(arg='formats', value=Name(id='formats', ctx=Load())), keyword(arg='target_python', value=Attribute(value=Name(id='self', ctx=Load()), attr='_target_python', ctx=Load())), keyword(arg='allow_yanked', value=Attribute(value=Name(id='self', ctx=Load()), attr='_allow_yanked', ctx=Load())), keyword(arg='ignore_requires_python', value=Attribute(value=Name(id='self', ctx=Load()), attr='_ignore_requires_python', ctx=Load()))]))], decorator_list=[], returns=Name(id='LinkEvaluator', ctx=Load())), FunctionDef(name='_sort_links', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='links', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Link', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Returns elements of links in order, non-egg links first, egg links\n        second, while eliminating duplicates\n        ')), Assign(targets=[Tuple(elts=[Name(id='eggs', ctx=Store()), Name(id='no_eggs', ctx=Store())], ctx=Store())], value=Tuple(elts=[List(elts=[], ctx=Load()), List(elts=[], ctx=Load())], ctx=Load())), AnnAssign(target=Name(id='seen', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='Link', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), For(target=Name(id='link', ctx=Store()), iter=Name(id='links', ctx=Load()), body=[If(test=Compare(left=Name(id='link', ctx=Load()), ops=[NotIn()], comparators=[Name(id='seen', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='seen', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='link', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='link', ctx=Load()), attr='egg_fragment', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='eggs', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='link', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='no_eggs', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='link', ctx=Load())], keywords=[]))])], orelse=[])], orelse=[]), Return(value=BinOp(left=Name(id='no_eggs', ctx=Load()), op=Add(), right=Name(id='eggs', ctx=Load())))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Link', ctx=Load()), ctx=Load())), FunctionDef(name='_log_skipped_link', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='link', annotation=Name(id='Link', ctx=Load())), arg(arg='result', annotation=Name(id='LinkType', ctx=Load())), arg(arg='detail', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='entry', ctx=Store())], value=Tuple(elts=[Name(id='link', ctx=Load()), Name(id='result', ctx=Load()), Name(id='detail', ctx=Load())], ctx=Load())), If(test=Compare(left=Name(id='entry', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_logged_links', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Skipping link: %s: %s'), Name(id='detail', ctx=Load()), Name(id='link', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_logged_links', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='entry', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_install_candidate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='link_evaluator', annotation=Name(id='LinkEvaluator', ctx=Load())), arg(arg='link', annotation=Name(id='Link', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        If the link is a candidate for install, convert it to an\n        InstallationCandidate and return it. Otherwise, return None.\n        ')), Assign(targets=[Tuple(elts=[Name(id='result', ctx=Store()), Name(id='detail', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='link_evaluator', ctx=Load()), attr='evaluate_link', ctx=Load()), args=[Name(id='link', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='result', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='LinkType', ctx=Load()), attr='candidate', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log_skipped_link', ctx=Load()), args=[Name(id='link', ctx=Load()), Name(id='result', ctx=Load()), Name(id='detail', ctx=Load())], keywords=[])), Return(value=Constant(value=None))], orelse=[]), Return(value=Call(func=Name(id='InstallationCandidate', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='link_evaluator', ctx=Load()), attr='project_name', ctx=Load())), keyword(arg='link', value=Name(id='link', ctx=Load())), keyword(arg='version', value=Name(id='detail', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), FunctionDef(name='evaluate_links', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='link_evaluator', annotation=Name(id='LinkEvaluator', ctx=Load())), arg(arg='links', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Link', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Convert links that are candidates to InstallationCandidate objects.\n        ')), Assign(targets=[Name(id='candidates', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='link', ctx=Store()), iter=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_sort_links', ctx=Load()), args=[Name(id='links', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='candidate', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_install_candidate', ctx=Load()), args=[Name(id='link_evaluator', ctx=Load()), Name(id='link', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='candidate', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='candidates', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='candidate', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='candidates', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), FunctionDef(name='process_project_url', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_url', annotation=Name(id='Link', ctx=Load())), arg(arg='link_evaluator', annotation=Name(id='LinkEvaluator', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Fetching project page and analyzing links: %s'), Name(id='project_url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='index_response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_link_collector', ctx=Load()), attr='fetch_response', ctx=Load()), args=[Name(id='project_url', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='index_response', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='page_links', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='parse_links', ctx=Load()), args=[Name(id='index_response', ctx=Load())], keywords=[])], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='indent_log', ctx=Load()), args=[], keywords=[]))], body=[Assign(targets=[Name(id='package_links', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_links', ctx=Load()), args=[Name(id='link_evaluator', ctx=Load())], keywords=[keyword(arg='links', value=Name(id='page_links', ctx=Load()))]))]), Return(value=Name(id='package_links', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), FunctionDef(name='find_all_candidates', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find all available InstallationCandidate for project_name\n\n        This checks index_urls and find_links.\n        All versions found are returned as an InstallationCandidate list.\n\n        See LinkEvaluator.evaluate_link() for details on which files\n        are accepted.\n        ')), Assign(targets=[Name(id='link_evaluator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_link_evaluator', ctx=Load()), args=[Name(id='project_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='collected_sources', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_link_collector', ctx=Load()), attr='collect_sources', ctx=Load()), args=[], keywords=[keyword(arg='project_name', value=Name(id='project_name', ctx=Load())), keyword(arg='candidates_from_page', value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partial', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='process_project_url', ctx=Load())], keywords=[keyword(arg='link_evaluator', value=Name(id='link_evaluator', ctx=Load()))]))])), Assign(targets=[Name(id='page_candidates_it', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='source', ctx=Load()), attr='page_candidates', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='sources', ctx=Store()), iter=Name(id='collected_sources', ctx=Load()), ifs=[], is_async=0), comprehension(target=Name(id='source', ctx=Store()), iter=Name(id='sources', ctx=Load()), ifs=[Compare(left=Name(id='source', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])], is_async=0)])], keywords=[])), Assign(targets=[Name(id='page_candidates', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Name(id='page_candidates_it', ctx=Load())], keywords=[])), Assign(targets=[Name(id='file_links_it', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), attr='from_iterable', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='source', ctx=Load()), attr='file_links', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='sources', ctx=Store()), iter=Name(id='collected_sources', ctx=Load()), ifs=[], is_async=0), comprehension(target=Name(id='source', ctx=Store()), iter=Name(id='sources', ctx=Load()), ifs=[Compare(left=Name(id='source', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])], is_async=0)])], keywords=[])), Assign(targets=[Name(id='file_candidates', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_links', ctx=Load()), args=[Name(id='link_evaluator', ctx=Load()), Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='file_links_it', ctx=Load())], keywords=[keyword(arg='reverse', value=Constant(value=True))])], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='DEBUG', ctx=Load())], keywords=[]), Name(id='file_candidates', ctx=Load())]), body=[Assign(targets=[Name(id='paths', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='candidate', ctx=Store()), iter=Name(id='file_candidates', ctx=Load()), body=[Assert(test=Attribute(value=Attribute(value=Name(id='candidate', ctx=Load()), attr='link', ctx=Load()), attr='url', ctx=Load())), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='paths', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='candidate', ctx=Load()), attr='link', ctx=Load()), attr='file_path', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='paths', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='candidate', ctx=Load()), attr='link', ctx=Load()), attr='url', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Local files found: %s'), Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='paths', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=BinOp(left=Name(id='file_candidates', ctx=Load()), op=Add(), right=Name(id='page_candidates', ctx=Load())))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='lru_cache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=None))])], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load())), FunctionDef(name='make_candidate_evaluator', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_name', annotation=Name(id='str', ctx=Load())), arg(arg='specifier', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='specifiers', ctx=Load()), attr='BaseSpecifier', ctx=Load()), ctx=Load())), arg(arg='hashes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Hashes', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Create a CandidateEvaluator object to use.')), Assign(targets=[Name(id='candidate_prefs', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_candidate_prefs', ctx=Load())), Return(value=Call(func=Attribute(value=Name(id='CandidateEvaluator', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='project_name', value=Name(id='project_name', ctx=Load())), keyword(arg='target_python', value=Attribute(value=Name(id='self', ctx=Load()), attr='_target_python', ctx=Load())), keyword(arg='prefer_binary', value=Attribute(value=Name(id='candidate_prefs', ctx=Load()), attr='prefer_binary', ctx=Load())), keyword(arg='allow_all_prereleases', value=Attribute(value=Name(id='candidate_prefs', ctx=Load()), attr='allow_all_prereleases', ctx=Load())), keyword(arg='specifier', value=Name(id='specifier', ctx=Load())), keyword(arg='hashes', value=Name(id='hashes', ctx=Load()))]))], decorator_list=[], returns=Name(id='CandidateEvaluator', ctx=Load())), FunctionDef(name='find_best_candidate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='project_name', annotation=Name(id='str', ctx=Load())), arg(arg='specifier', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='specifiers', ctx=Load()), attr='BaseSpecifier', ctx=Load()), ctx=Load())), arg(arg='hashes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Hashes', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Find matches for the given project and specifier.\n\n        :param specifier: An optional object implementing `filter`\n            (e.g. `packaging.specifiers.SpecifierSet`) to filter applicable\n            versions.\n\n        :return: A `BestCandidateResult` instance.\n        ')), Assign(targets=[Name(id='candidates', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='find_all_candidates', ctx=Load()), args=[Name(id='project_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='candidate_evaluator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_candidate_evaluator', ctx=Load()), args=[], keywords=[keyword(arg='project_name', value=Name(id='project_name', ctx=Load())), keyword(arg='specifier', value=Name(id='specifier', ctx=Load())), keyword(arg='hashes', value=Name(id='hashes', ctx=Load()))])), Return(value=Call(func=Attribute(value=Name(id='candidate_evaluator', ctx=Load()), attr='compute_best_candidate', ctx=Load()), args=[Name(id='candidates', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='lru_cache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=None))])], returns=Name(id='BestCandidateResult', ctx=Load())), FunctionDef(name='find_requirement', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req', annotation=Name(id='InstallRequirement', ctx=Load())), arg(arg='upgrade', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Try to find a Link matching req\n\n        Expects req, an InstallRequirement and upgrade, a boolean\n        Returns a InstallationCandidate if found,\n        Raises DistributionNotFound or BestVersionAlreadyInstalled otherwise\n        ')), Assign(targets=[Name(id='hashes', ctx=Store())], value=Call(func=Attribute(value=Name(id='req', ctx=Load()), attr='hashes', ctx=Load()), args=[], keywords=[keyword(arg='trust_internet', value=Constant(value=False))])), Assign(targets=[Name(id='best_candidate_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='find_best_candidate', ctx=Load()), args=[Attribute(value=Name(id='req', ctx=Load()), attr='name', ctx=Load())], keywords=[keyword(arg='specifier', value=Attribute(value=Name(id='req', ctx=Load()), attr='specifier', ctx=Load())), keyword(arg='hashes', value=Name(id='hashes', ctx=Load()))])), Assign(targets=[Name(id='best_candidate', ctx=Store())], value=Attribute(value=Name(id='best_candidate_result', ctx=Load()), attr='best_candidate', ctx=Load())), AnnAssign(target=Name(id='installed_version', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_BaseVersion', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), If(test=Compare(left=Attribute(value=Name(id='req', ctx=Load()), attr='satisfied_by', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='installed_version', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='req', ctx=Load()), attr='satisfied_by', ctx=Load()), attr='version', ctx=Load()))], orelse=[]), FunctionDef(name='_format_versions', args=arguments(posonlyargs=[], args=[arg(arg='cand_iter', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[SetComp(elt=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='c', ctx=Load()), attr='version', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='c', ctx=Store()), iter=Name(id='cand_iter', ctx=Load()), ifs=[], is_async=0)])], keywords=[keyword(arg='key', value=Name(id='parse_version', ctx=Load()))])], keywords=[]), Constant(value='none')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='installed_version', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='best_candidate', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='critical', ctx=Load()), args=[Constant(value='Could not find a version that satisfies the requirement %s (from versions: %s)'), Name(id='req', ctx=Load()), Call(func=Name(id='_format_versions', ctx=Load()), args=[Call(func=Attribute(value=Name(id='best_candidate_result', ctx=Load()), attr='iter_all', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Raise(exc=Call(func=Name(id='DistributionNotFound', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='No matching distribution found for {}'), attr='format', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), FunctionDef(name='_should_install_candidate', args=arguments(posonlyargs=[], args=[arg(arg='candidate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='installed_version', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=True))], orelse=[]), If(test=Compare(left=Name(id='best_candidate', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Compare(left=Attribute(value=Name(id='best_candidate', ctx=Load()), attr='version', ctx=Load()), ops=[Gt()], comparators=[Name(id='installed_version', ctx=Load())]))], decorator_list=[], returns=Constant(value='TypeGuard[InstallationCandidate]')), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Name(id='upgrade', ctx=Load())), Compare(left=Name(id='installed_version', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[If(test=Call(func=Name(id='_should_install_candidate', ctx=Load()), args=[Name(id='best_candidate', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Existing installed version (%s) satisfies requirement (most up-to-date version is %s)'), Name(id='installed_version', ctx=Load()), Attribute(value=Name(id='best_candidate', ctx=Load()), attr='version', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Existing installed version (%s) is most up-to-date and satisfies requirement'), Name(id='installed_version', ctx=Load())], keywords=[]))]), Return(value=Constant(value=None))], orelse=[]), If(test=Call(func=Name(id='_should_install_candidate', ctx=Load()), args=[Name(id='best_candidate', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Using version %s (newest of versions: %s)'), Attribute(value=Name(id='best_candidate', ctx=Load()), attr='version', ctx=Load()), Call(func=Name(id='_format_versions', ctx=Load()), args=[Call(func=Attribute(value=Name(id='best_candidate_result', ctx=Load()), attr='iter_applicable', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Return(value=Name(id='best_candidate', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Installed version (%s) is most up-to-date (past versions: %s)'), Name(id='installed_version', ctx=Load()), Call(func=Name(id='_format_versions', ctx=Load()), args=[Call(func=Attribute(value=Name(id='best_candidate_result', ctx=Load()), attr='iter_applicable', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Raise(exc=Name(id='BestVersionAlreadyInstalled', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='InstallationCandidate', ctx=Load()), ctx=Load()))], decorator_list=[]), FunctionDef(name='_find_name_version_sep', args=arguments(posonlyargs=[], args=[arg(arg='fragment', annotation=Name(id='str', ctx=Load())), arg(arg='canonical_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Find the separator\'s index based on the package\'s canonical name.\n\n    :param fragment: A <package>+<version> filename "fragment" (stem) or\n        egg fragment.\n    :param canonical_name: The package\'s canonical name.\n\n    This function is needed since the canonicalized name does not necessarily\n    have the same length as the egg info\'s name part. An example::\n\n    >>> fragment = \'foo__bar-1.0\'\n    >>> canonical_name = \'foo-bar\'\n    >>> _find_name_version_sep(fragment, canonical_name)\n    8\n    ')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='c', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='fragment', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='c', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='-')]), body=[Continue()], orelse=[]), If(test=Compare(left=Call(func=Name(id='canonicalize_name', ctx=Load()), args=[Subscript(value=Name(id='fragment', ctx=Load()), slice=Slice(upper=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Name(id='canonical_name', ctx=Load())]), body=[Return(value=Name(id='i', ctx=Load()))], orelse=[])], orelse=[]), Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='fragment', ctx=Load()), conversion=-1), Constant(value=' does not match '), FormattedValue(value=Name(id='canonical_name', ctx=Load()), conversion=-1)])], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='_extract_version_from_fragment', args=arguments(posonlyargs=[], args=[arg(arg='fragment', annotation=Name(id='str', ctx=Load())), arg(arg='canonical_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parse the version string from a <package>+<version> filename\n    "fragment" (stem) or egg fragment.\n\n    :param fragment: The string to parse. E.g. foo-2.1\n    :param canonical_name: The canonicalized name of the package this\n        belongs to.\n    ')), Try(body=[Assign(targets=[Name(id='version_start', ctx=Store())], value=BinOp(left=Call(func=Name(id='_find_name_version_sep', ctx=Load()), args=[Name(id='fragment', ctx=Load()), Name(id='canonical_name', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=1)))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=Constant(value=None))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='version', ctx=Store())], value=Subscript(value=Name(id='fragment', ctx=Load()), slice=Slice(lower=Name(id='version_start', ctx=Load())), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Name(id='version', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Return(value=Name(id='version', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], type_ignores=[])