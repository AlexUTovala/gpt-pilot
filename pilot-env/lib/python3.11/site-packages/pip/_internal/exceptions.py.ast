Module(body=[Expr(value=Constant(value='Exceptions used throughout package.\n\nThis module MUST NOT try to import from anything within `pip._internal` to\noperate. This is expected to be importable from any/all files within the\nsubpackage and, thus, should not depend on them.\n')), Import(names=[alias(name='configparser')]), Import(names=[alias(name='contextlib')]), Import(names=[alias(name='locale')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='pathlib')]), Import(names=[alias(name='re')]), Import(names=[alias(name='sys')]), ImportFrom(module='itertools', names=[alias(name='chain'), alias(name='groupby'), alias(name='repeat')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Dict'), alias(name='Iterator'), alias(name='List'), alias(name='Optional'), alias(name='Union')], level=0), ImportFrom(module='pip._vendor.requests.models', names=[alias(name='Request'), alias(name='Response')], level=0), ImportFrom(module='pip._vendor.rich.console', names=[alias(name='Console'), alias(name='ConsoleOptions'), alias(name='RenderResult')], level=0), ImportFrom(module='pip._vendor.rich.markup', names=[alias(name='escape')], level=0), ImportFrom(module='pip._vendor.rich.text', names=[alias(name='Text')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='hashlib', names=[alias(name='_Hash')], level=0), ImportFrom(module='typing', names=[alias(name='Literal')], level=0), ImportFrom(module='pip._internal.metadata', names=[alias(name='BaseDistribution')], level=0), ImportFrom(module='pip._internal.req.req_install', names=[alias(name='InstallRequirement')], level=0)], orelse=[]), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), FunctionDef(name='_is_kebab_case', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Constant(value='^[a-z]+(-[a-z]+)*$'), Name(id='s', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_prefix_with_indent', args=arguments(posonlyargs=[], args=[arg(arg='s', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Text', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='console', annotation=Name(id='Console', ctx=Load()))], kwonlyargs=[arg(arg='prefix', annotation=Name(id='str', ctx=Load())), arg(arg='indent', annotation=Name(id='str', ctx=Load()))], kw_defaults=[None, None], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='s', ctx=Load()), Name(id='Text', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Name(id='s', ctx=Load()))], orelse=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='render_str', ctx=Load()), args=[Name(id='s', ctx=Load())], keywords=[]))]), Return(value=BinOp(left=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='render_str', ctx=Load()), args=[Name(id='prefix', ctx=Load())], keywords=[keyword(arg='overflow', value=Constant(value='ignore'))]), op=Add(), right=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='console', ctx=Load()), attr='render_str', ctx=Load()), args=[JoinedStr(values=[Constant(value='\n'), FormattedValue(value=Name(id='indent', ctx=Load()), conversion=-1)])], keywords=[keyword(arg='overflow', value=Constant(value='ignore'))]), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[keyword(arg='allow_blank', value=Constant(value=True))])], keywords=[])))], decorator_list=[], returns=Name(id='Text', ctx=Load())), ClassDef(name='PipError', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The base pip error.'))], decorator_list=[]), ClassDef(name='DiagnosticPipError', bases=[Name(id='PipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='An error, that presents diagnostic information to the user.\n\n    This contains a bunch of logic, to enable pretty presentation of our error\n    messages. Each error gets a unique reference. Each error can also include\n    additional context, a hint and/or a note -- which are presented with the\n    main error message in a consistent style.\n\n    This is adapted from the error output styling in `sphinx-theme-builder`.\n    ')), AnnAssign(target=Name(id='reference', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[arg(arg='kind', annotation=Constant(value='Literal["error", "warning"]')), arg(arg='reference', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='message', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Text', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Text', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='hint_stmt', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Text', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='note_stmt', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Text', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='link', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kw_defaults=[Constant(value='error'), Constant(value=None), None, None, None, Constant(value=None), Constant(value=None)], defaults=[]), body=[If(test=Compare(left=Name(id='reference', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assert(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='reference')], keywords=[]), msg=Constant(value='error reference not provided!')), Assign(targets=[Name(id='reference', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='reference', ctx=Load()))], orelse=[]), Assert(test=Call(func=Name(id='_is_kebab_case', ctx=Load()), args=[Name(id='reference', ctx=Load())], keywords=[]), msg=Constant(value='error reference must be kebab-case!')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kind', ctx=Store())], value=Name(id='kind', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='reference', ctx=Store())], value=Name(id='reference', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='message', ctx=Store())], value=Name(id='message', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='context', ctx=Store())], value=Name(id='context', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='note_stmt', ctx=Store())], value=Name(id='note_stmt', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='hint_stmt', ctx=Store())], value=Name(id='hint_stmt', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='link', ctx=Store())], value=Name(id='link', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[JoinedStr(values=[Constant(value='<'), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='reference', ctx=Load()), conversion=-1), Constant(value='>')])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<'), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value='(reference='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='reference', ctx=Load()), conversion=114), Constant(value=', message='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='message', ctx=Load()), conversion=114), Constant(value=', context='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='context', ctx=Load()), conversion=114), Constant(value=', note_stmt='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='note_stmt', ctx=Load()), conversion=114), Constant(value=', hint_stmt='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='hint_stmt', ctx=Load()), conversion=114), Constant(value=')>')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__rich_console__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='console', annotation=Name(id='Console', ctx=Load())), arg(arg='options', annotation=Name(id='ConsoleOptions', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='colour', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='kind', ctx=Load()), ops=[Eq()], comparators=[Constant(value='error')]), body=Constant(value='red'), orelse=Constant(value='yellow'))), Expr(value=Yield(value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Name(id='colour', ctx=Load()), conversion=-1), Constant(value=' bold]'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='kind', ctx=Load()), conversion=-1), Constant(value='[/]: [bold]'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='reference', ctx=Load()), conversion=-1), Constant(value='[/]')]))), Expr(value=Yield(value=Constant(value=''))), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='options', ctx=Load()), attr='ascii_only', ctx=Load())), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='context', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Call(func=Name(id='_prefix_with_indent', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='message', ctx=Load()), Name(id='console', ctx=Load())], keywords=[keyword(arg='prefix', value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Name(id='colour', ctx=Load()), conversion=-1), Constant(value=']×[/] ')])), keyword(arg='indent', value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Name(id='colour', ctx=Load()), conversion=-1), Constant(value=']│[/] ')]))]))), Expr(value=Yield(value=Call(func=Name(id='_prefix_with_indent', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='context', ctx=Load()), Name(id='console', ctx=Load())], keywords=[keyword(arg='prefix', value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Name(id='colour', ctx=Load()), conversion=-1), Constant(value=']╰─>[/] ')])), keyword(arg='indent', value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Name(id='colour', ctx=Load()), conversion=-1), Constant(value=']   [/] ')]))])))], orelse=[Expr(value=Yield(value=Call(func=Name(id='_prefix_with_indent', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='message', ctx=Load()), Name(id='console', ctx=Load())], keywords=[keyword(arg='prefix', value=Constant(value='[red]×[/] ')), keyword(arg='indent', value=Constant(value='  '))])))])], orelse=[Expr(value=Yield(value=Attribute(value=Name(id='self', ctx=Load()), attr='message', ctx=Load()))), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='context', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Constant(value=''))), Expr(value=Yield(value=Attribute(value=Name(id='self', ctx=Load()), attr='context', ctx=Load())))], orelse=[])]), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='note_stmt', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='hint_stmt', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Expr(value=Yield(value=Constant(value='')))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='note_stmt', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Call(func=Name(id='_prefix_with_indent', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='note_stmt', ctx=Load()), Name(id='console', ctx=Load())], keywords=[keyword(arg='prefix', value=Constant(value='[magenta bold]note[/]: ')), keyword(arg='indent', value=Constant(value='      '))])))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='hint_stmt', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Call(func=Name(id='_prefix_with_indent', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='hint_stmt', ctx=Load()), Name(id='console', ctx=Load())], keywords=[keyword(arg='prefix', value=Constant(value='[cyan bold]hint[/]: ')), keyword(arg='indent', value=Constant(value='      '))])))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='link', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=Constant(value=''))), Expr(value=Yield(value=JoinedStr(values=[Constant(value='Link: '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='link', ctx=Load()), conversion=-1)])))], orelse=[])], decorator_list=[], returns=Name(id='RenderResult', ctx=Load()))], decorator_list=[]), ClassDef(name='ConfigurationError', bases=[Name(id='PipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='General exception in configuration'))], decorator_list=[]), ClassDef(name='InstallationError', bases=[Name(id='PipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='General exception during installation'))], decorator_list=[]), ClassDef(name='UninstallationError', bases=[Name(id='PipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='General exception during uninstallation'))], decorator_list=[]), ClassDef(name='MissingPyProjectBuildRequires', bases=[Name(id='DiagnosticPipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised when pyproject.toml has `build-system`, but no `build-system.requires`.')), Assign(targets=[Name(id='reference', ctx=Store())], value=Constant(value='missing-pyproject-build-system-requires')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[arg(arg='package', annotation=Name(id='str', ctx=Load()))], kw_defaults=[None], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='message', value=JoinedStr(values=[Constant(value='Can not process '), FormattedValue(value=Call(func=Name(id='escape', ctx=Load()), args=[Name(id='package', ctx=Load())], keywords=[]), conversion=-1)])), keyword(arg='context', value=Call(func=Name(id='Text', ctx=Load()), args=[Constant(value='This package has an invalid pyproject.toml file.\nThe [build-system] table is missing the mandatory `requires` key.')], keywords=[])), keyword(arg='note_stmt', value=Constant(value='This is an issue with the package mentioned above, not pip.')), keyword(arg='hint_stmt', value=Call(func=Name(id='Text', ctx=Load()), args=[Constant(value='See PEP 518 for the detailed specification.')], keywords=[]))]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='InvalidPyProjectBuildRequires', bases=[Name(id='DiagnosticPipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised when pyproject.toml an invalid `build-system.requires`.')), Assign(targets=[Name(id='reference', ctx=Store())], value=Constant(value='invalid-pyproject-build-system-requires')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[arg(arg='package', annotation=Name(id='str', ctx=Load())), arg(arg='reason', annotation=Name(id='str', ctx=Load()))], kw_defaults=[None, None], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='message', value=JoinedStr(values=[Constant(value='Can not process '), FormattedValue(value=Call(func=Name(id='escape', ctx=Load()), args=[Name(id='package', ctx=Load())], keywords=[]), conversion=-1)])), keyword(arg='context', value=Call(func=Name(id='Text', ctx=Load()), args=[JoinedStr(values=[Constant(value='This package has an invalid `build-system.requires` key in pyproject.toml.\n'), FormattedValue(value=Name(id='reason', ctx=Load()), conversion=-1)])], keywords=[])), keyword(arg='note_stmt', value=Constant(value='This is an issue with the package mentioned above, not pip.')), keyword(arg='hint_stmt', value=Call(func=Name(id='Text', ctx=Load()), args=[Constant(value='See PEP 518 for the detailed specification.')], keywords=[]))]))], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='NoneMetadataError', bases=[Name(id='PipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised when accessing a Distribution\'s "METADATA" or "PKG-INFO".\n\n    This signifies an inconsistency, when the Distribution claims to have\n    the metadata file (if not, raise ``FileNotFoundError`` instead), but is\n    not actually able to produce its content. This may be due to permission\n    errors.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dist', annotation=Constant(value='BaseDistribution')), arg(arg='metadata_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        :param dist: A Distribution object.\n        :param metadata_name: The name of the metadata being accessed\n            (can be "METADATA" or "PKG-INFO").\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Store())], value=Name(id='dist', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='metadata_name', ctx=Store())], value=Name(id='metadata_name', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='None {} metadata found for distribution: {}'), attr='format', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='metadata_name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='dist', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='UserInstallationInvalid', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A --user install is requested on an environment without user site.')), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='User base directory is not specified'))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='InvalidSchemeCombination', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='before', ctx=Store())], value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='a', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=JoinedStr(values=[Constant(value='Cannot set '), FormattedValue(value=Name(id='before', ctx=Load()), conversion=-1), Constant(value=' and '), FormattedValue(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='args', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), conversion=-1), Constant(value=' together')]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='DistributionNotFound', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised when a distribution cannot be found to satisfy a requirement'))], decorator_list=[]), ClassDef(name='RequirementsFileParseError', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised when a general error occurs parsing a requirements file line.'))], decorator_list=[]), ClassDef(name='BestVersionAlreadyInstalled', bases=[Name(id='PipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised when the most up-to-date version of a package is already\n    installed.'))], decorator_list=[]), ClassDef(name='BadCommand', bases=[Name(id='PipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised when virtualenv or a command is not found'))], decorator_list=[]), ClassDef(name='CommandError', bases=[Name(id='PipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Raised when there is an error in command-line arguments'))], decorator_list=[]), ClassDef(name='PreviousBuildDirError', bases=[Name(id='PipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Raised when there's a previous conflicting build directory"))], decorator_list=[]), ClassDef(name='NetworkConnectionError', bases=[Name(id='PipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='HTTP connection error')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='error_msg', annotation=Name(id='str', ctx=Load())), arg(arg='response', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Response', ctx=Load()), ctx=Load())), arg(arg='request', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Request', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='\n        Initialize NetworkConnectionError with  `request` and `response`\n        objects.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='response', ctx=Store())], value=Name(id='response', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='request', ctx=Store())], value=Name(id='request', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='error_msg', ctx=Store())], value=Name(id='error_msg', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='response', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='request', ctx=Load())), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='response', ctx=Load()), Constant(value='request')], keywords=[])]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='request', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='response', ctx=Load()), attr='request', ctx=Load()))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='error_msg', ctx=Load()), Name(id='response', ctx=Load()), Name(id='request', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='error_msg', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='InvalidWheelFilename', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Invalid wheel filename.'))], decorator_list=[]), ClassDef(name='UnsupportedWheel', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Unsupported wheel.'))], decorator_list=[]), ClassDef(name='InvalidWheel', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Invalid (e.g. corrupt) wheel.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load())), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Store())], value=Name(id='location', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Name(id='name', ctx=Load()))], decorator_list=[]), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value="Wheel '"), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value="' located at "), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='location', ctx=Load()), conversion=-1), Constant(value=' is invalid.')]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='MetadataInconsistent', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Built metadata contains inconsistent information.\n\n    This is raised when the metadata contains values (e.g. name and version)\n    that do not match the information previously obtained from sdist filename,\n    user-supplied ``#egg=`` value, or an install requirement name.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ireq', annotation=Constant(value='InstallRequirement')), arg(arg='field', annotation=Name(id='str', ctx=Load())), arg(arg='f_val', annotation=Name(id='str', ctx=Load())), arg(arg='m_val', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ireq', ctx=Store())], value=Name(id='ireq', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='field', ctx=Store())], value=Name(id='field', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='f_val', ctx=Store())], value=Name(id='f_val', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='m_val', ctx=Store())], value=Name(id='m_val', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='Requested '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='ireq', ctx=Load()), conversion=-1), Constant(value=' has inconsistent '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='field', ctx=Load()), conversion=-1), Constant(value=': expected '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='f_val', ctx=Load()), conversion=114), Constant(value=', but metadata has '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='m_val', ctx=Load()), conversion=114)]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='InstallationSubprocessError', bases=[Name(id='DiagnosticPipError', ctx=Load()), Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A subprocess call failed.')), Assign(targets=[Name(id='reference', ctx=Store())], value=Constant(value='subprocess-exited-with-error')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[arg(arg='command_description', annotation=Name(id='str', ctx=Load())), arg(arg='exit_code', annotation=Name(id='int', ctx=Load())), arg(arg='output_lines', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], kw_defaults=[None, None, None], defaults=[]), body=[If(test=Compare(left=Name(id='output_lines', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='output_prompt', ctx=Store())], value=Call(func=Name(id='Text', ctx=Load()), args=[Constant(value='See above for output.')], keywords=[]))], orelse=[Assign(targets=[Name(id='output_prompt', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='Text', ctx=Load()), attr='from_markup', ctx=Load()), args=[JoinedStr(values=[Constant(value='[red]['), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='output_lines', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' lines of output][/]\n')])], keywords=[]), op=Add(), right=Call(func=Name(id='Text', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='output_lines', ctx=Load())], keywords=[])], keywords=[])), op=Add(), right=Call(func=Attribute(value=Name(id='Text', ctx=Load()), attr='from_markup', ctx=Load()), args=[Constant(value='[red]\\[end of output][/]')], keywords=[])))]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='message', value=JoinedStr(values=[Constant(value='[green]'), FormattedValue(value=Call(func=Name(id='escape', ctx=Load()), args=[Name(id='command_description', ctx=Load())], keywords=[]), conversion=-1), Constant(value='[/] did not run successfully.\nexit code: '), FormattedValue(value=Name(id='exit_code', ctx=Load()), conversion=-1)])), keyword(arg='context', value=Name(id='output_prompt', ctx=Load())), keyword(arg='hint_stmt', value=Constant(value=None)), keyword(arg='note_stmt', value=Constant(value='This error originates from a subprocess, and is likely not a problem with pip.'))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='command_description', ctx=Store())], value=Name(id='command_description', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='exit_code', ctx=Store())], value=Name(id='exit_code', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='command_description', ctx=Load()), conversion=-1), Constant(value=' exited with '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='exit_code', ctx=Load()), conversion=-1)]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='MetadataGenerationFailed', bases=[Name(id='InstallationSubprocessError', ctx=Load()), Name(id='InstallationError', ctx=Load())], keywords=[], body=[Assign(targets=[Name(id='reference', ctx=Store())], value=Constant(value='metadata-generation-failed')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[arg(arg='package_details', annotation=Name(id='str', ctx=Load()))], kw_defaults=[None], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='InstallationSubprocessError', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='message', value=Constant(value='Encountered error while generating package metadata.')), keyword(arg='context', value=Call(func=Name(id='escape', ctx=Load()), args=[Name(id='package_details', ctx=Load())], keywords=[])), keyword(arg='hint_stmt', value=Constant(value='See above for details.')), keyword(arg='note_stmt', value=Constant(value='This is an issue with the package mentioned above, not pip.'))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='metadata generation failed'))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='HashErrors', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Multiple HashError instances rolled into one for reporting')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='HashError'), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='append', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='error', annotation=Constant(value='HashError'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='error', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='lines', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='e')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Attribute(value=Name(id='e', ctx=Load()), attr='order', ctx=Load())))])), For(target=Tuple(elts=[Name(id='cls', ctx=Store()), Name(id='errors_of_cls', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='groupby', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='e')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Attribute(value=Name(id='e', ctx=Load()), attr='__class__', ctx=Load()))], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='head', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='extend', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='e', ctx=Load()), attr='body', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Name(id='errors_of_cls', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), If(test=Name(id='lines', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Constant(value=''))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='bool', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='errors', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='HashError', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    A failure to verify a package against known-good hashes\n\n    :cvar order: An int sorting hash exception classes by difficulty of\n        recovery (lower being harder), so the user doesn't bother fretting\n        about unpinned packages when he has deeper issues, like VCS\n        dependencies, to deal with. Also keeps error reports in a\n        deterministic order.\n    :cvar head: A section heading for display above potentially many\n        exceptions of this kind\n    :ivar req: The InstallRequirement that triggered this error. This is\n        pasted on after the exception is instantiated, because it's not\n        typically available earlier.\n\n    ")), AnnAssign(target=Name(id='req', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='InstallRequirement'), ctx=Load()), value=Constant(value=None), simple=1), Assign(targets=[Name(id='head', ctx=Store())], value=Constant(value='')), AnnAssign(target=Name(id='order', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=UnaryOp(op=USub(), operand=Constant(value=1)), simple=1), FunctionDef(name='body', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return a summary of me for display under the heading.\n\n        This default implementation simply prints a description of the\n        triggering requirement.\n\n        :param req: The InstallRequirement that provoked this error, with\n            its link already populated by the resolver's _populate_link().\n\n        ")), Return(value=JoinedStr(values=[Constant(value='    '), FormattedValue(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_requirement_name', ctx=Load()), args=[], keywords=[]), conversion=-1)]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='head', ctx=Load()), conversion=-1), Constant(value='\n'), FormattedValue(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='body', ctx=Load()), args=[], keywords=[]), conversion=-1)]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_requirement_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a description of the requirement that triggered me.\n\n        This default implementation returns long description of the req, with\n        line numbers\n\n        ')), Return(value=IfExp(test=Attribute(value=Name(id='self', ctx=Load()), attr='req', ctx=Load()), body=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='req', ctx=Load())], keywords=[]), orelse=Constant(value='unknown package')))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='VcsHashUnsupported', bases=[Name(id='HashError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="A hash was provided for a version-control-system-based requirement, but\n    we don't have a method for hashing those.")), Assign(targets=[Name(id='order', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='head', ctx=Store())], value=Constant(value="Can't verify hashes for these requirements because we don't have a way to hash version control repositories:"))], decorator_list=[]), ClassDef(name='DirectoryUrlHashUnsupported', bases=[Name(id='HashError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="A hash was provided for a version-control-system-based requirement, but\n    we don't have a method for hashing those.")), Assign(targets=[Name(id='order', ctx=Store())], value=Constant(value=1)), Assign(targets=[Name(id='head', ctx=Store())], value=Constant(value="Can't verify hashes for these file:// requirements because they point to directories:"))], decorator_list=[]), ClassDef(name='HashMissing', bases=[Name(id='HashError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A hash was needed for a requirement but is absent.')), Assign(targets=[Name(id='order', ctx=Store())], value=Constant(value=2)), Assign(targets=[Name(id='head', ctx=Store())], value=Constant(value='Hashes are required in --require-hashes mode, but they are missing from some requirements. Here is a list of those requirements along with the hashes their downloaded archives actually had. Add lines like these to your requirements files to prevent tampering. (If you did not enable --require-hashes manually, note that it turns on automatically when any package has a hash.)')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='gotten_hash', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        :param gotten_hash: The hash of the (possibly malicious) archive we\n            just downloaded\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gotten_hash', ctx=Store())], value=Name(id='gotten_hash', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='body', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='pip._internal.utils.hashes', names=[alias(name='FAVORITE_HASH')], level=0), Assign(targets=[Name(id='package', ctx=Store())], value=Constant(value=None)), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='req', ctx=Load()), body=[Assign(targets=[Name(id='package', ctx=Store())], value=IfExp(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='req', ctx=Load()), attr='is_direct', ctx=Load()), body=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='req', ctx=Load()), attr='original_link', ctx=Load()), orelse=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='req', ctx=Load()), Constant(value='req'), Constant(value=None)], keywords=[])))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='    {} --hash={}:{}'), attr='format', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='package', ctx=Load()), Constant(value='unknown package')]), Name(id='FAVORITE_HASH', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='gotten_hash', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='HashUnpinned', bases=[Name(id='HashError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A requirement had a hash specified but was not pinned to a specific\n    version.')), Assign(targets=[Name(id='order', ctx=Store())], value=Constant(value=3)), Assign(targets=[Name(id='head', ctx=Store())], value=Constant(value='In --require-hashes mode, all requirements must have their versions pinned with ==. These do not:'))], decorator_list=[]), ClassDef(name='HashMismatch', bases=[Name(id='HashError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Distribution file hash values don't match.\n\n    :ivar package_name: The name of the package that triggered the hash\n        mismatch. Feel free to write to this after the exception is raise to\n        improve its error message.\n\n    ")), Assign(targets=[Name(id='order', ctx=Store())], value=Constant(value=4)), Assign(targets=[Name(id='head', ctx=Store())], value=Constant(value='THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS FILE. If you have updated the package versions, please update the hashes. Otherwise, examine the package contents carefully; someone may have tampered with them.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='allowed', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='gots', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='_Hash')], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        :param allowed: A dict of algorithm names pointing to lists of allowed\n            hex digests\n        :param gots: A dict of algorithm names pointing to hashes we\n            actually got from the files under suspicion\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='allowed', ctx=Store())], value=Name(id='allowed', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gots', ctx=Store())], value=Name(id='gots', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='body', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='    {}:\n{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_requirement_name', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_hash_comparison', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_hash_comparison', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a comparison of actual and expected hash values.\n\n        Example::\n\n               Expected sha256 abcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcde\n                            or 123451234512345123451234512345123451234512345\n                    Got        bcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdef\n\n        ')), FunctionDef(name='hash_then_or', args=arguments(posonlyargs=[], args=[arg(arg='hash_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='chain', ctx=Load()), args=[List(elts=[Name(id='hash_name', ctx=Load())], ctx=Load()), Call(func=Name(id='repeat', ctx=Load()), args=[Constant(value='    or')], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value='chain[str]')), AnnAssign(target=Name(id='lines', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Tuple(elts=[Name(id='hash_name', ctx=Store()), Name(id='expecteds', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='allowed', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='prefix', ctx=Store())], value=Call(func=Name(id='hash_then_or', ctx=Load()), args=[Name(id='hash_name', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='extend', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Constant(value='        Expected {} {}'), attr='format', ctx=Load()), args=[Call(func=Name(id='next', ctx=Load()), args=[Name(id='prefix', ctx=Load())], keywords=[]), Name(id='e', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Name(id='expecteds', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='             Got        {}\n'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='gots', ctx=Load()), slice=Name(id='hash_name', ctx=Load()), ctx=Load()), attr='hexdigest', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), ClassDef(name='UnsupportedPythonVersion', bases=[Name(id='InstallationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Unsupported python version according to Requires-Python package\n    metadata.'))], decorator_list=[]), ClassDef(name='ConfigurationFileCouldNotBeLoaded', bases=[Name(id='ConfigurationError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='When there are errors while loading a configuration file')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='reason', annotation=Name(id='str', ctx=Load())), arg(arg='fname', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='error', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='configparser', ctx=Load()), attr='Error', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='could not be loaded'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='error', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='reason', ctx=Store())], value=Name(id='reason', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fname', ctx=Store())], value=Name(id='fname', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='error', ctx=Store())], value=Name(id='error', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='fname', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='message_part', ctx=Store())], value=JoinedStr(values=[Constant(value=' in '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='fname', ctx=Load()), conversion=-1), Constant(value='.')]))], orelse=[Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='error', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='message_part', ctx=Store())], value=JoinedStr(values=[Constant(value='.\n'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='error', ctx=Load()), conversion=-1), Constant(value='\n')]))]), Return(value=JoinedStr(values=[Constant(value='Configuration file '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='reason', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='message_part', ctx=Load()), conversion=-1)]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='_DEFAULT_EXTERNALLY_MANAGED_ERROR', ctx=Store())], value=JoinedStr(values=[Constant(value='The Python environment under '), FormattedValue(value=Attribute(value=Name(id='sys', ctx=Load()), attr='prefix', ctx=Load()), conversion=-1), Constant(value=' is managed externally, and may not be\nmanipulated by the user. Please use specific tooling from the distributor of\nthe Python installation to interact with this environment instead.\n')])), ClassDef(name='ExternallyManagedEnvironment', bases=[Name(id='DiagnosticPipError', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='The current environment is externally managed.\n\n    This is raised when the current environment is externally managed, as\n    defined by `PEP 668`_. The ``EXTERNALLY-MANAGED`` configuration is checked\n    and displayed when the error is bubbled up to the user.\n\n    :param error: The error message read from ``EXTERNALLY-MANAGED``.\n    ')), Assign(targets=[Name(id='reference', ctx=Store())], value=Constant(value='externally-managed-environment')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='error', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='error', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='context', ctx=Store())], value=Call(func=Name(id='Text', ctx=Load()), args=[Name(id='_DEFAULT_EXTERNALLY_MANAGED_ERROR', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='context', ctx=Store())], value=Call(func=Name(id='Text', ctx=Load()), args=[Name(id='error', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='message', value=Constant(value='This environment is externally managed')), keyword(arg='context', value=Name(id='context', ctx=Load())), keyword(arg='note_stmt', value=Constant(value='If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.')), keyword(arg='hint_stmt', value=Call(func=Name(id='Text', ctx=Load()), args=[Constant(value='See PEP 668 for the detailed specification.')], keywords=[]))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_iter_externally_managed_error_keys', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='category', ctx=Store())], value=Attribute(value=Name(id='locale', ctx=Load()), attr='LC_MESSAGES', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), body=[AnnAssign(target=Name(id='lang', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1)])], orelse=[Assign(targets=[Tuple(elts=[Name(id='lang', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='locale', ctx=Load()), attr='getlocale', ctx=Load()), args=[Name(id='category', ctx=Load())], keywords=[]))], finalbody=[]), If(test=Compare(left=Name(id='lang', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Yield(value=JoinedStr(values=[Constant(value='Error-'), FormattedValue(value=Name(id='lang', ctx=Load()), conversion=-1)]))), For(target=Name(id='sep', ctx=Store()), iter=Tuple(elts=[Constant(value='-'), Constant(value='_')], ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='before', ctx=Store()), Name(id='found', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='lang', ctx=Load()), attr='partition', ctx=Load()), args=[Name(id='sep', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='found', ctx=Load())), body=[Continue()], orelse=[]), Expr(value=Yield(value=JoinedStr(values=[Constant(value='Error-'), FormattedValue(value=Name(id='before', ctx=Load()), conversion=-1)])))], orelse=[])], orelse=[]), Expr(value=Yield(value=Constant(value='Error')))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='from_config', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='config', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='pathlib', ctx=Load()), attr='Path', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parser', ctx=Store())], value=Call(func=Attribute(value=Name(id='configparser', ctx=Load()), attr='ConfigParser', ctx=Load()), args=[], keywords=[keyword(arg='interpolation', value=Constant(value=None))])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='read', ctx=Load()), args=[Name(id='config', ctx=Load())], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))])), Assign(targets=[Name(id='section', ctx=Store())], value=Subscript(value=Name(id='parser', ctx=Load()), slice=Constant(value='externally-managed'), ctx=Load())), For(target=Name(id='key', ctx=Store()), iter=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='_iter_externally_managed_error_keys', ctx=Load()), args=[], keywords=[]), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='contextlib', ctx=Load()), attr='suppress', ctx=Load()), args=[Name(id='KeyError', ctx=Load())], keywords=[]))], body=[Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Subscript(value=Name(id='section', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())], keywords=[]))])], orelse=[])], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Pass()]), ExceptHandler(type=Tuple(elts=[Name(id='OSError', ctx=Load()), Name(id='UnicodeDecodeError', ctx=Load()), Attribute(value=Name(id='configparser', ctx=Load()), attr='ParsingError', ctx=Load())], ctx=Load()), body=[ImportFrom(module='pip._internal.utils._log', names=[alias(name='VERBOSE')], level=0), Assign(targets=[Name(id='exc_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Name(id='VERBOSE', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Failed to read %s'), Name(id='config', ctx=Load())], keywords=[keyword(arg='exc_info', value=Name(id='exc_info', ctx=Load()))]))])], orelse=[], finalbody=[]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Constant(value=None)], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Constant(value='ExternallyManagedEnvironment'))], decorator_list=[])], type_ignores=[])