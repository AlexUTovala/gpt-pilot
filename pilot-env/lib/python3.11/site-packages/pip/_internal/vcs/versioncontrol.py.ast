Module(body=[Expr(value=Constant(value='Handles all VCS (version control) support')), Import(names=[alias(name='logging')]), Import(names=[alias(name='os')]), Import(names=[alias(name='shutil')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='urllib.parse')]), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Any'), alias(name='Dict'), alias(name='Iterable'), alias(name='Iterator'), alias(name='List'), alias(name='Mapping'), alias(name='Optional'), alias(name='Tuple'), alias(name='Type'), alias(name='Union')], level=0), ImportFrom(module='pip._internal.cli.spinners', names=[alias(name='SpinnerInterface')], level=0), ImportFrom(module='pip._internal.exceptions', names=[alias(name='BadCommand'), alias(name='InstallationError')], level=0), ImportFrom(module='pip._internal.utils.misc', names=[alias(name='HiddenText'), alias(name='ask_path_exists'), alias(name='backup_dir'), alias(name='display_path'), alias(name='hide_url'), alias(name='hide_value'), alias(name='is_installable_dir'), alias(name='rmtree')], level=0), ImportFrom(module='pip._internal.utils.subprocess', names=[alias(name='CommandArgs'), alias(name='call_subprocess'), alias(name='format_command_args'), alias(name='make_command')], level=0), ImportFrom(module='pip._internal.utils.urls', names=[alias(name='get_url_scheme')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='typing', names=[alias(name='Literal')], level=0)], orelse=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='vcs')], ctx=Load())), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='AuthInfo', ctx=Store())], value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='is_url', args=arguments(posonlyargs=[], args=[arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return true if the name looks like a URL.\n    ')), Assign(targets=[Name(id='scheme', ctx=Store())], value=Call(func=Name(id='get_url_scheme', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='scheme', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Compare(left=Name(id='scheme', ctx=Load()), ops=[In()], comparators=[BinOp(left=List(elts=[Constant(value='http'), Constant(value='https'), Constant(value='file'), Constant(value='ftp')], ctx=Load()), op=Add(), right=Attribute(value=Name(id='vcs', ctx=Load()), attr='all_schemes', ctx=Load()))]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='make_vcs_requirement_url', args=arguments(posonlyargs=[], args=[arg(arg='repo_url', annotation=Name(id='str', ctx=Load())), arg(arg='rev', annotation=Name(id='str', ctx=Load())), arg(arg='project_name', annotation=Name(id='str', ctx=Load())), arg(arg='subdir', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Return the URL for a VCS requirement.\n\n    Args:\n      repo_url: the remote VCS url, with any needed VCS prefix (e.g. "git+").\n      project_name: the (unescaped) project name.\n    ')), Assign(targets=[Name(id='egg_project_name', ctx=Store())], value=Call(func=Attribute(value=Name(id='project_name', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='_')], keywords=[])), Assign(targets=[Name(id='req', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='repo_url', ctx=Load()), conversion=-1), Constant(value='@'), FormattedValue(value=Name(id='rev', ctx=Load()), conversion=-1), Constant(value='#egg='), FormattedValue(value=Name(id='egg_project_name', ctx=Load()), conversion=-1)])), If(test=Name(id='subdir', ctx=Load()), body=[AugAssign(target=Name(id='req', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='&subdirectory='), FormattedValue(value=Name(id='subdir', ctx=Load()), conversion=-1)]))], orelse=[]), Return(value=Name(id='req', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='find_path_to_project_root_from_repo_root', args=arguments(posonlyargs=[], args=[arg(arg='location', annotation=Name(id='str', ctx=Load())), arg(arg='repo_root', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Find the the Python project's root by searching up the filesystem from\n    `location`. Return the path to project root relative to `repo_root`.\n    Return None if the project root is `repo_root`, or cannot be found.\n    ")), Assign(targets=[Name(id='orig_location', ctx=Store())], value=Name(id='location', ctx=Load())), While(test=UnaryOp(op=Not(), operand=Call(func=Name(id='is_installable_dir', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='last_location', ctx=Store())], value=Name(id='location', ctx=Load())), Assign(targets=[Name(id='location', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='location', ctx=Load()), ops=[Eq()], comparators=[Name(id='last_location', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Could not find a Python project for directory %s (tried all parent directories)'), Name(id='orig_location', ctx=Load())], keywords=[])), Return(value=Constant(value=None))], orelse=[])], orelse=[]), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='samefile', ctx=Load()), args=[Name(id='repo_root', ctx=Load()), Name(id='location', ctx=Load())], keywords=[]), body=[Return(value=Constant(value=None))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='relpath', ctx=Load()), args=[Name(id='location', ctx=Load()), Name(id='repo_root', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), ClassDef(name='RemoteNotFoundError', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[Pass()], decorator_list=[]), ClassDef(name='RemoteNotValidError', bases=[Name(id='Exception', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='url', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='url', ctx=Store())], value=Name(id='url', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='RevOptions', bases=[], keywords=[], body=[Expr(value=Constant(value='\n    Encapsulates a VCS-specific revision to install, along with any VCS\n    install options.\n\n    Instances of this class should be treated as if immutable.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='vc_class', annotation=Subscript(value=Name(id='Type', ctx=Load()), slice=Constant(value='VersionControl'), ctx=Load())), arg(arg='rev', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='extra_args', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CommandArgs', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='\n        Args:\n          vc_class: a VersionControl subclass.\n          rev: the name of the revision to install.\n          extra_args: a list of extra options.\n        ')), If(test=Compare(left=Name(id='extra_args', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='extra_args', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='extra_args', ctx=Store())], value=Name(id='extra_args', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='rev', ctx=Store())], value=Name(id='rev', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='vc_class', ctx=Store())], value=Name(id='vc_class', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='branch_name', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<RevOptions '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='vc_class', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value=': rev='), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='rev', ctx=Load()), conversion=114), Constant(value='>')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='arg_rev', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='rev', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='vc_class', ctx=Load()), attr='default_arg_rev', ctx=Load()))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='rev', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='to_args', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the VCS-specific command arguments.\n        ')), AnnAssign(target=Name(id='args', ctx=Store()), annotation=Name(id='CommandArgs', ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='rev', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='arg_rev', ctx=Load())), If(test=Compare(left=Name(id='rev', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='args', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='vc_class', ctx=Load()), attr='get_base_rev_args', ctx=Load()), args=[Name(id='rev', ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Name(id='args', ctx=Store()), op=Add(), value=Attribute(value=Name(id='self', ctx=Load()), attr='extra_args', ctx=Load())), Return(value=Name(id='args', ctx=Load()))], decorator_list=[], returns=Name(id='CommandArgs', ctx=Load())), FunctionDef(name='to_display', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='rev', ctx=Load())), body=[Return(value=Constant(value=''))], orelse=[]), Return(value=JoinedStr(values=[Constant(value=' (to revision '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='rev', ctx=Load()), conversion=-1), Constant(value=')')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='make_new', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='rev', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Make a copy of the current instance, but with a new rev.\n\n        Args:\n          rev: the name of the revision for the new object.\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='vc_class', ctx=Load()), attr='make_rev_options', ctx=Load()), args=[Name(id='rev', ctx=Load())], keywords=[keyword(arg='extra_args', value=Attribute(value=Name(id='self', ctx=Load()), attr='extra_args', ctx=Load()))]))], decorator_list=[], returns=Constant(value='RevOptions'))], decorator_list=[]), ClassDef(name='VcsSupport', bases=[], keywords=[], body=[AnnAssign(target=Name(id='_registry', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='VersionControl')], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=1), Assign(targets=[Name(id='schemes', ctx=Store())], value=List(elts=[Constant(value='ssh'), Constant(value='git'), Constant(value='hg'), Constant(value='bzr'), Constant(value='sftp'), Constant(value='svn')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='uses_netloc', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='schemes', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_registry', ctx=Load()), attr='__iter__', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='backends', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_registry', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Constant(value='VersionControl'), ctx=Load())), FunctionDef(name='dirnames', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=ListComp(elt=Attribute(value=Name(id='backend', ctx=Load()), attr='dirname', ctx=Load()), generators=[comprehension(target=Name(id='backend', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='backends', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='all_schemes', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AnnAssign(target=Name(id='schemes', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), For(target=Name(id='backend', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='backends', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='schemes', ctx=Load()), attr='extend', ctx=Load()), args=[Attribute(value=Name(id='backend', ctx=Load()), attr='schemes', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='schemes', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='register', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='cls', annotation=Subscript(value=Name(id='Type', ctx=Load()), slice=Constant(value='VersionControl'), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='name')], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Cannot register VCS %s'), Attribute(value=Name(id='cls', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), Return()], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='cls', ctx=Load()), attr='name', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_registry', ctx=Load())]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_registry', ctx=Load()), slice=Attribute(value=Name(id='cls', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='cls', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Registered VCS backend: %s'), Attribute(value=Name(id='cls', ctx=Load()), attr='name', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='unregister', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_registry', ctx=Load())]), body=[Delete(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_registry', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Del())])], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_backend_for_dir', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a VersionControl object if a repository of that type is found\n        at the given directory.\n        ')), Assign(targets=[Name(id='vcs_backends', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='vcs_backend', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_registry', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='repo_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='vcs_backend', ctx=Load()), attr='get_repository_root', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='repo_path', ctx=Load())), body=[Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Determine that %s uses VCS: %s'), Name(id='location', ctx=Load()), Attribute(value=Name(id='vcs_backend', ctx=Load()), attr='name', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='vcs_backends', ctx=Load()), slice=Name(id='repo_path', ctx=Load()), ctx=Store())], value=Name(id='vcs_backend', ctx=Load()))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='vcs_backends', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='inner_most_repo_path', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Name(id='vcs_backends', ctx=Load())], keywords=[keyword(arg='key', value=Name(id='len', ctx=Load()))])), Return(value=Subscript(value=Name(id='vcs_backends', ctx=Load()), slice=Name(id='inner_most_repo_path', ctx=Load()), ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='VersionControl'), ctx=Load())), FunctionDef(name='get_backend_for_scheme', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='scheme', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a VersionControl object or None.\n        ')), For(target=Name(id='vcs_backend', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_registry', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='scheme', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='vcs_backend', ctx=Load()), attr='schemes', ctx=Load())]), body=[Return(value=Name(id='vcs_backend', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='VersionControl'), ctx=Load())), FunctionDef(name='get_backend', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return a VersionControl object or None.\n        ')), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_registry', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='VersionControl'), ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='vcs', ctx=Store())], value=Call(func=Name(id='VcsSupport', ctx=Load()), args=[], keywords=[])), ClassDef(name='VersionControl', bases=[], keywords=[], body=[Assign(targets=[Name(id='name', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='dirname', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='repo_name', ctx=Store())], value=Constant(value='')), AnnAssign(target=Name(id='schemes', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), value=Tuple(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='unset_environ', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), value=Tuple(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='default_arg_rev', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), FunctionDef(name='should_add_vcs_url_prefix', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='remote_url', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return whether the vcs prefix (e.g. "git+") should be added to a\n        repository\'s remote url when used in a requirement.\n        ')), Return(value=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='remote_url', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value=':')])], keywords=[])))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='get_subdirectory', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the path to Python project root, relative to the repo root.\n        Return None if the project root is in the repo root.\n        ')), Return(value=Constant(value=None))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='get_requirement_revision', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='repo_dir', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the revision string that should be used in a requirement.\n        ')), Return(value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='get_revision', ctx=Load()), args=[Name(id='repo_dir', ctx=Load())], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='get_src_requirement', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='repo_dir', annotation=Name(id='str', ctx=Load())), arg(arg='project_name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the requirement string to use to redownload the files\n        currently at the given repository directory.\n\n        Args:\n          project_name: the (unescaped) project name.\n\n        The return value has a form similar to the following:\n\n            {repository_url}@{revision}#egg={project_name}\n        ')), Assign(targets=[Name(id='repo_url', ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='get_remote_url', ctx=Load()), args=[Name(id='repo_dir', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='should_add_vcs_url_prefix', ctx=Load()), args=[Name(id='repo_url', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='repo_url', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value='+'), FormattedValue(value=Name(id='repo_url', ctx=Load()), conversion=-1)]))], orelse=[]), Assign(targets=[Name(id='revision', ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='get_requirement_revision', ctx=Load()), args=[Name(id='repo_dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='subdir', ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='get_subdirectory', ctx=Load()), args=[Name(id='repo_dir', ctx=Load())], keywords=[])), Assign(targets=[Name(id='req', ctx=Store())], value=Call(func=Name(id='make_vcs_requirement_url', ctx=Load()), args=[Name(id='repo_url', ctx=Load()), Name(id='revision', ctx=Load()), Name(id='project_name', ctx=Load())], keywords=[keyword(arg='subdir', value=Name(id='subdir', ctx=Load()))])), Return(value=Name(id='req', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='get_base_rev_args', args=arguments(posonlyargs=[], args=[arg(arg='rev', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the base revision arguments for a vcs command.\n\n        Args:\n          rev: the name of a revision to install.  Cannot be None.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='is_immutable_rev_checkout', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='url', annotation=Name(id='str', ctx=Load())), arg(arg='dest', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return true if the commit hash checked out at dest matches\n        the revision in url.\n\n        Always return False, if the VCS does not support immutable commit\n        hashes.\n\n        This method does not check if there are local uncommitted changes\n        in dest after checkout, as pip currently has no use case for that.\n        ')), Return(value=Constant(value=False))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='make_rev_options', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='rev', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='extra_args', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='CommandArgs', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='\n        Return a RevOptions object.\n\n        Args:\n          rev: the name of a revision to install.\n          extra_args: a list of extra options.\n        ')), Return(value=Call(func=Name(id='RevOptions', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='rev', ctx=Load())], keywords=[keyword(arg='extra_args', value=Name(id='extra_args', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='RevOptions', ctx=Load())), FunctionDef(name='_is_local_repository', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='repo', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        posix absolute paths start with os.path.sep,\n        win32 ones start with drive (like c:\\folder)\n        ')), Assign(targets=[Tuple(elts=[Name(id='drive', ctx=Store()), Name(id='tail', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitdrive', ctx=Load()), args=[Name(id='repo', ctx=Load())], keywords=[])), Return(value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='repo', ctx=Load()), attr='startswith', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='sep', ctx=Load())], keywords=[]), Call(func=Name(id='bool', ctx=Load()), args=[Name(id='drive', ctx=Load())], keywords=[])]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='get_netloc_and_auth', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='netloc', annotation=Name(id='str', ctx=Load())), arg(arg='scheme', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Parse the repository URL's netloc, and return the new netloc to use\n        along with auth information.\n\n        Args:\n          netloc: the original repository URL netloc.\n          scheme: the repository URL's scheme without the vcs prefix.\n\n        This is mainly for the Subversion class to override, so that auth\n        information can be provided via the --username and --password options\n        instead of through the URL.  For other subclasses like Git without\n        such an option, auth information must stay in the URL.\n\n        Returns: (netloc, (username, password)).\n        ")), Return(value=Tuple(elts=[Name(id='netloc', ctx=Load()), Tuple(elts=[Constant(value=None), Constant(value=None)], ctx=Load())], ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='get_url_rev_and_auth', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='url', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Parse the repository URL to use, and return the URL, revision,\n        and auth info to use.\n\n        Returns: (url, rev, (username, password)).\n        ')), Assign(targets=[Tuple(elts=[Name(id='scheme', ctx=Store()), Name(id='netloc', ctx=Store()), Name(id='path', ctx=Store()), Name(id='query', ctx=Store()), Name(id='frag', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='urlsplit', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), If(test=Compare(left=Constant(value='+'), ops=[NotIn()], comparators=[Name(id='scheme', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Sorry, {!r} is a malformed VCS url. The format is <vcs>+<protocol>://<url>, e.g. svn+http://myrepo/svn/MyApp#egg=MyApp'), attr='format', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='scheme', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='scheme', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='+'), Constant(value=1)], keywords=[]), slice=Constant(value=1), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='netloc', ctx=Store()), Name(id='user_pass', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='get_netloc_and_auth', ctx=Load()), args=[Name(id='netloc', ctx=Load()), Name(id='scheme', ctx=Load())], keywords=[])), Assign(targets=[Name(id='rev', ctx=Store())], value=Constant(value=None)), If(test=Compare(left=Constant(value='@'), ops=[In()], comparators=[Name(id='path', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='path', ctx=Store()), Name(id='rev', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='path', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='@'), Constant(value=1)], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='rev', ctx=Load())), body=[Raise(exc=Call(func=Name(id='InstallationError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='The URL {!r} has an empty revision (after @) which is not supported. Include a revision after @ or remove @ from the URL.'), attr='format', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='url', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='urlunsplit', ctx=Load()), args=[Tuple(elts=[Name(id='scheme', ctx=Load()), Name(id='netloc', ctx=Load()), Name(id='path', ctx=Load()), Name(id='query', ctx=Load()), Constant(value='')], ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='url', ctx=Load()), Name(id='rev', ctx=Load()), Name(id='user_pass', ctx=Load())], ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='AuthInfo', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='make_rev_args', args=arguments(posonlyargs=[], args=[arg(arg='username', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='password', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='HiddenText', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the RevOptions "extra arguments" to use in obtain().\n        ')), Return(value=List(elts=[], ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='CommandArgs', ctx=Load())), FunctionDef(name='get_url_rev_options', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='url', annotation=Name(id='HiddenText', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the URL and RevOptions object to use in obtain(),\n        as a tuple (url, rev_options).\n        ')), Assign(targets=[Tuple(elts=[Name(id='secret_url', ctx=Store()), Name(id='rev', ctx=Store()), Name(id='user_pass', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_url_rev_and_auth', ctx=Load()), args=[Attribute(value=Name(id='url', ctx=Load()), attr='secret', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='username', ctx=Store()), Name(id='secret_password', ctx=Store())], ctx=Store())], value=Name(id='user_pass', ctx=Load())), AnnAssign(target=Name(id='password', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='HiddenText', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), If(test=Compare(left=Name(id='secret_password', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='password', ctx=Store())], value=Call(func=Name(id='hide_value', ctx=Load()), args=[Name(id='secret_password', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='extra_args', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_rev_args', ctx=Load()), args=[Name(id='username', ctx=Load()), Name(id='password', ctx=Load())], keywords=[])), Assign(targets=[Name(id='rev_options', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='make_rev_options', ctx=Load()), args=[Name(id='rev', ctx=Load())], keywords=[keyword(arg='extra_args', value=Name(id='extra_args', ctx=Load()))])), Return(value=Tuple(elts=[Call(func=Name(id='hide_url', ctx=Load()), args=[Name(id='secret_url', ctx=Load())], keywords=[]), Name(id='rev_options', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='HiddenText', ctx=Load()), Name(id='RevOptions', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='normalize_url', args=arguments(posonlyargs=[], args=[arg(arg='url', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Normalize a URL for comparison by unquoting it and removing any\n        trailing slash.\n        ')), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='unquote', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[]), attr='rstrip', ctx=Load()), args=[Constant(value='/')], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='compare_urls', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='url1', annotation=Name(id='str', ctx=Load())), arg(arg='url2', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Compare two repo URLs for identity, ignoring incidental differences.\n        ')), Return(value=Compare(left=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='normalize_url', ctx=Load()), args=[Name(id='url1', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='normalize_url', ctx=Load()), args=[Name(id='url2', ctx=Load())], keywords=[])]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='fetch_new', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dest', annotation=Name(id='str', ctx=Load())), arg(arg='url', annotation=Name(id='HiddenText', ctx=Load())), arg(arg='rev_options', annotation=Name(id='RevOptions', ctx=Load())), arg(arg='verbosity', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Fetch a revision from a repository, in the case that this is the\n        first fetch from the repository.\n\n        Args:\n          dest: the directory to fetch the repository to.\n          rev_options: a RevOptions object.\n          verbosity: verbosity level.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='switch', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dest', annotation=Name(id='str', ctx=Load())), arg(arg='url', annotation=Name(id='HiddenText', ctx=Load())), arg(arg='rev_options', annotation=Name(id='RevOptions', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Switch the repo at ``dest`` to point to ``URL``.\n\n        Args:\n          rev_options: a RevOptions object.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='update', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dest', annotation=Name(id='str', ctx=Load())), arg(arg='url', annotation=Name(id='HiddenText', ctx=Load())), arg(arg='rev_options', annotation=Name(id='RevOptions', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Update an already-existing repo to the given ``rev_options``.\n\n        Args:\n          rev_options: a RevOptions object.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='is_commit_id_equal', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='dest', annotation=Name(id='str', ctx=Load())), arg(arg='name', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return whether the id of the current commit equals the given name.\n\n        Args:\n          dest: the repository directory.\n          name: a string name.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='obtain', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='dest', annotation=Name(id='str', ctx=Load())), arg(arg='url', annotation=Name(id='HiddenText', ctx=Load())), arg(arg='verbosity', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Install or update in editable mode the package represented by this\n        VersionControl object.\n\n        :param dest: the repository directory in which to install or update.\n        :param url: the repository URL starting with a vcs prefix.\n        :param verbosity: verbosity level.\n        ')), Assign(targets=[Tuple(elts=[Name(id='url', ctx=Store()), Name(id='rev_options', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_url_rev_options', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='fetch_new', ctx=Load()), args=[Name(id='dest', ctx=Load()), Name(id='url', ctx=Load()), Name(id='rev_options', ctx=Load())], keywords=[keyword(arg='verbosity', value=Name(id='verbosity', ctx=Load()))])), Return()], orelse=[]), Assign(targets=[Name(id='rev_display', ctx=Store())], value=Call(func=Attribute(value=Name(id='rev_options', ctx=Load()), attr='to_display', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_repository_directory', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='existing_url', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_remote_url', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compare_urls', ctx=Load()), args=[Name(id='existing_url', ctx=Load()), Attribute(value=Name(id='url', ctx=Load()), attr='secret', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='%s in %s exists, and has correct URL (%s)'), Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='repo_name', ctx=Load()), attr='title', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='display_path', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[]), Name(id='url', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_commit_id_equal', ctx=Load()), args=[Name(id='dest', ctx=Load()), Attribute(value=Name(id='rev_options', ctx=Load()), attr='rev', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Constant(value='Updating %s %s%s'), Call(func=Name(id='display_path', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='repo_name', ctx=Load()), Name(id='rev_display', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='dest', ctx=Load()), Name(id='url', ctx=Load()), Name(id='rev_options', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Constant(value='Skipping because already up-to-date.')], keywords=[]))]), Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='%s %s in %s exists with URL %s'), Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='repo_name', ctx=Load()), Call(func=Name(id='display_path', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[]), Name(id='existing_url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prompt', ctx=Store())], value=Tuple(elts=[Constant(value='(s)witch, (i)gnore, (w)ipe, (b)ackup '), Tuple(elts=[Constant(value='s'), Constant(value='i'), Constant(value='w'), Constant(value='b')], ctx=Load())], ctx=Load()))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Directory %s already exists, and is not a %s %s.'), Name(id='dest', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='repo_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prompt', ctx=Store())], value=Tuple(elts=[Constant(value='(i)gnore, (w)ipe, (b)ackup '), Tuple(elts=[Constant(value='i'), Constant(value='w'), Constant(value='b')], ctx=Load())], ctx=Load()))]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='The plan is to install the %s repository %s'), Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Name(id='ask_path_exists', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='What to do?  {}'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='prompt', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[]), Subscript(value=Name(id='prompt', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='response', ctx=Load()), ops=[Eq()], comparators=[Constant(value='a')]), body=[Expr(value=Call(func=Attribute(value=Name(id='sys', ctx=Load()), attr='exit', ctx=Load()), args=[UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='response', ctx=Load()), ops=[Eq()], comparators=[Constant(value='w')]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Deleting %s'), Call(func=Name(id='display_path', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='rmtree', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='fetch_new', ctx=Load()), args=[Name(id='dest', ctx=Load()), Name(id='url', ctx=Load()), Name(id='rev_options', ctx=Load())], keywords=[keyword(arg='verbosity', value=Name(id='verbosity', ctx=Load()))])), Return()], orelse=[]), If(test=Compare(left=Name(id='response', ctx=Load()), ops=[Eq()], comparators=[Constant(value='b')]), body=[Assign(targets=[Name(id='dest_dir', ctx=Store())], value=Call(func=Name(id='backup_dir', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Backing up %s to %s'), Call(func=Name(id='display_path', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[]), Name(id='dest_dir', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='move', ctx=Load()), args=[Name(id='dest', ctx=Load()), Name(id='dest_dir', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='fetch_new', ctx=Load()), args=[Name(id='dest', ctx=Load()), Name(id='url', ctx=Load()), Name(id='rev_options', ctx=Load())], keywords=[keyword(arg='verbosity', value=Name(id='verbosity', ctx=Load()))])), Return()], orelse=[]), If(test=Compare(left=Name(id='response', ctx=Load()), ops=[Eq()], comparators=[Constant(value='s')]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Constant(value='Switching %s %s to %s%s'), Attribute(value=Name(id='self', ctx=Load()), attr='repo_name', ctx=Load()), Call(func=Name(id='display_path', ctx=Load()), args=[Name(id='dest', ctx=Load())], keywords=[]), Name(id='url', ctx=Load()), Name(id='rev_display', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='switch', ctx=Load()), args=[Name(id='dest', ctx=Load()), Name(id='url', ctx=Load()), Name(id='rev_options', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='unpack', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='location', annotation=Name(id='str', ctx=Load())), arg(arg='url', annotation=Name(id='HiddenText', ctx=Load())), arg(arg='verbosity', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Clean up current location and download the url repository\n        (and vcs infos) into location\n\n        :param url: the repository URL starting with a vcs prefix.\n        :param verbosity: verbosity level.\n        ')), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='rmtree', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='obtain', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[keyword(arg='url', value=Name(id='url', ctx=Load())), keyword(arg='verbosity', value=Name(id='verbosity', ctx=Load()))]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_remote_url', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the url used at location\n\n        Raises RemoteNotFoundError if the repository does not have a remote\n        url configured.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='get_revision', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the current commit id of the files at the given location.\n        ')), Raise(exc=Name(id='NotImplementedError', ctx=Load()))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='run_command', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='cmd', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), Name(id='CommandArgs', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='show_stdout', annotation=Name(id='bool', ctx=Load())), arg(arg='cwd', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='on_returncode', annotation=Constant(value='Literal["raise", "warn", "ignore"]')), arg(arg='extra_ok_returncodes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='command_desc', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='extra_environ', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='spinner', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='SpinnerInterface', ctx=Load()), ctx=Load())), arg(arg='log_failed_cmd', annotation=Name(id='bool', ctx=Load())), arg(arg='stdout_only', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=None), Constant(value='raise'), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=False)]), body=[Expr(value=Constant(value='\n        Run a VCS subcommand\n        This is simply a wrapper around call_subprocess that adds the VCS\n        command name, and checks that the VCS is available\n        ')), Assign(targets=[Name(id='cmd', ctx=Store())], value=Call(func=Name(id='make_command', ctx=Load()), args=[Attribute(value=Name(id='cls', ctx=Load()), attr='name', ctx=Load()), Starred(value=Name(id='cmd', ctx=Load()), ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='command_desc', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='command_desc', ctx=Store())], value=Call(func=Name(id='format_command_args', ctx=Load()), args=[Name(id='cmd', ctx=Load())], keywords=[]))], orelse=[]), Try(body=[Return(value=Call(func=Name(id='call_subprocess', ctx=Load()), args=[Name(id='cmd', ctx=Load()), Name(id='show_stdout', ctx=Load()), Name(id='cwd', ctx=Load())], keywords=[keyword(arg='on_returncode', value=Name(id='on_returncode', ctx=Load())), keyword(arg='extra_ok_returncodes', value=Name(id='extra_ok_returncodes', ctx=Load())), keyword(arg='command_desc', value=Name(id='command_desc', ctx=Load())), keyword(arg='extra_environ', value=Name(id='extra_environ', ctx=Load())), keyword(arg='unset_environ', value=Attribute(value=Name(id='cls', ctx=Load()), attr='unset_environ', ctx=Load())), keyword(arg='spinner', value=Name(id='spinner', ctx=Load())), keyword(arg='log_failed_cmd', value=Name(id='log_failed_cmd', ctx=Load())), keyword(arg='stdout_only', value=Name(id='stdout_only', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='BadCommand', ctx=Load()), args=[JoinedStr(values=[Constant(value='Cannot find command '), FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='name', ctx=Load()), conversion=114), Constant(value=' - do you have '), FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='name', ctx=Load()), conversion=114), Constant(value=' installed and in your PATH?')])], keywords=[]))]), ExceptHandler(type=Name(id='PermissionError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='BadCommand', ctx=Load()), args=[JoinedStr(values=[Constant(value='No permission to execute '), FormattedValue(value=Attribute(value=Name(id='cls', ctx=Load()), attr='name', ctx=Load()), conversion=114), Constant(value=' - install it locally, globally (ask admin), or check your PATH. See possible solutions at https://pip.pypa.io/en/latest/reference/pip_freeze/#fixing-permission-denied.')])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='is_repository_directory', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return whether a directory path is a repository directory.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Checking in %s for %s (%s)...'), Name(id='path', ctx=Load()), Attribute(value=Name(id='cls', ctx=Load()), attr='dirname', ctx=Load()), Attribute(value=Name(id='cls', ctx=Load()), attr='name', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='path', ctx=Load()), Attribute(value=Name(id='cls', ctx=Load()), attr='dirname', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='get_repository_root', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='location', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return the "root" (top-level) directory controlled by the vcs,\n        or `None` if the directory is not in any.\n\n        It is meant to be overridden to implement smarter detection\n        mechanisms for specific vcs.\n\n        This can do more than is_repository_directory() alone. For\n        example, the Git override checks that Git is actually available.\n        ')), If(test=Call(func=Attribute(value=Name(id='cls', ctx=Load()), attr='is_repository_directory', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[]), body=[Return(value=Name(id='location', ctx=Load()))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])