Module(body=[Import(names=[alias(name='collections')]), Import(names=[alias(name='math')]), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Dict'), alias(name='Iterable'), alias(name='Iterator'), alias(name='Mapping'), alias(name='Sequence'), alias(name='TypeVar'), alias(name='Union')], level=0), ImportFrom(module='pip._vendor.resolvelib.providers', names=[alias(name='AbstractProvider')], level=0), ImportFrom(module='base', names=[alias(name='Candidate'), alias(name='Constraint'), alias(name='Requirement')], level=1), ImportFrom(module='candidates', names=[alias(name='REQUIRES_PYTHON_IDENTIFIER')], level=1), ImportFrom(module='factory', names=[alias(name='Factory')], level=1), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='pip._vendor.resolvelib.providers', names=[alias(name='Preference')], level=0), ImportFrom(module='pip._vendor.resolvelib.resolvers', names=[alias(name='RequirementInformation')], level=0), Assign(targets=[Name(id='PreferenceInformation', ctx=Store())], value=Subscript(value=Name(id='RequirementInformation', ctx=Load()), slice=Tuple(elts=[Name(id='Requirement', ctx=Load()), Name(id='Candidate', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='_ProviderBase', ctx=Store())], value=Subscript(value=Name(id='AbstractProvider', ctx=Load()), slice=Tuple(elts=[Name(id='Requirement', ctx=Load()), Name(id='Candidate', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()))], orelse=[Assign(targets=[Name(id='_ProviderBase', ctx=Store())], value=Name(id='AbstractProvider', ctx=Load()))]), Assign(targets=[Name(id='D', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='D')], keywords=[])), Assign(targets=[Name(id='V', ctx=Store())], value=Call(func=Name(id='TypeVar', ctx=Load()), args=[Constant(value='V')], keywords=[])), FunctionDef(name='_get_with_identifier', args=arguments(posonlyargs=[], args=[arg(arg='mapping', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='V', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='identifier', annotation=Name(id='str', ctx=Load())), arg(arg='default', annotation=Name(id='D', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get item from a package name lookup mapping with a resolver identifier.\n\n    This extra logic is needed when the target mapping is keyed by package\n    name, which cannot be directly looked up with an identifier (which may\n    contain requested extras). Additional logic is added to also look up a value\n    by "cleaning up" the extras from the identifier.\n    ')), If(test=Compare(left=Name(id='identifier', ctx=Load()), ops=[In()], comparators=[Name(id='mapping', ctx=Load())]), body=[Return(value=Subscript(value=Name(id='mapping', ctx=Load()), slice=Name(id='identifier', ctx=Load()), ctx=Load()))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='open_bracket', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='identifier', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value='[')], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='open_bracket', ctx=Load()), Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Name(id='mapping', ctx=Load())])]), body=[Return(value=Subscript(value=Name(id='mapping', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()))], orelse=[]), Return(value=Name(id='default', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='D', ctx=Load()), Name(id='V', ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name='PipProvider', bases=[Name(id='_ProviderBase', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Pip's provider implementation for resolvelib.\n\n    :params constraints: A mapping of constraints specified by the user. Keys\n        are canonicalized project names.\n    :params ignore_dependencies: Whether the user specified ``--no-deps``.\n    :params upgrade_strategy: The user-specified upgrade strategy.\n    :params user_requested: A set of canonicalized package names that the user\n        supplied for pip to install/upgrade.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='factory', annotation=Name(id='Factory', ctx=Load())), arg(arg='constraints', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Constraint', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='ignore_dependencies', annotation=Name(id='bool', ctx=Load())), arg(arg='upgrade_strategy', annotation=Name(id='str', ctx=Load())), arg(arg='user_requested', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factory', ctx=Store())], value=Name(id='factory', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_constraints', ctx=Store())], value=Name(id='constraints', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ignore_dependencies', ctx=Store())], value=Name(id='ignore_dependencies', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_upgrade_strategy', ctx=Store())], value=Name(id='upgrade_strategy', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_user_requested', ctx=Store())], value=Name(id='user_requested', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_known_depths', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='collections', ctx=Load()), attr='defaultdict', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Attribute(value=Name(id='math', ctx=Load()), attr='inf', ctx=Load()))], keywords=[]), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='identify', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requirement_or_candidate', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='Requirement', ctx=Load()), Name(id='Candidate', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='requirement_or_candidate', ctx=Load()), attr='name', ctx=Load()))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='get_preference', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='identifier', annotation=Name(id='str', ctx=Load())), arg(arg='resolutions', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Candidate', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='candidates', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Candidate', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='information', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Iterable', ctx=Load()), slice=Constant(value='PreferenceInformation'), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='backtrack_causes', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Constant(value='PreferenceInformation'), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Produce a sort key for given requirement based on preference.\n\n        The lower the return value is, the more preferred this group of\n        arguments is.\n\n        Currently pip considers the following in order:\n\n        * Prefer if any of the known requirements is "direct", e.g. points to an\n          explicit URL.\n        * If equal, prefer if any requirement is "pinned", i.e. contains\n          operator ``===`` or ``==``.\n        * If equal, calculate an approximate "depth" and resolve requirements\n          closer to the user-specified requirements first. If the depth cannot\n          by determined (eg: due to no matching parents), it is considered\n          infinite.\n        * Order user-specified requirements by the order they are specified.\n        * If equal, prefers "non-free" requirements, i.e. contains at least one\n          operator, such as ``>=`` or ``<``.\n        * If equal, order alphabetically for consistency (helps debuggability).\n        ')), Try(body=[Expr(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Subscript(value=Name(id='information', ctx=Load()), slice=Name(id='identifier', ctx=Load()), ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Assign(targets=[Name(id='has_information', ctx=Store())], value=Constant(value=False))])], orelse=[Assign(targets=[Name(id='has_information', ctx=Store())], value=Constant(value=True))], finalbody=[]), If(test=Name(id='has_information', ctx=Load()), body=[Assign(targets=[Name(id='lookups', ctx=Store())], value=GeneratorExp(elt=Call(func=Attribute(value=Name(id='r', ctx=Load()), attr='get_candidate_lookup', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='r', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store()), iter=Subscript(value=Name(id='information', ctx=Load()), slice=Name(id='identifier', ctx=Load()), ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Tuple(elts=[Name(id='candidate', ctx=Store()), Name(id='ireqs', ctx=Store())], ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Starred(value=Name(id='lookups', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='candidate', ctx=Store()), Name(id='ireqs', ctx=Store())], ctx=Store())], value=Tuple(elts=[Constant(value=None), Tuple(elts=[], ctx=Load())], ctx=Load()))]), Assign(targets=[Name(id='operators', ctx=Store())], value=ListComp(elt=Attribute(value=Name(id='specifier', ctx=Load()), attr='operator', ctx=Load()), generators=[comprehension(target=Name(id='specifier_set', ctx=Store()), iter=GeneratorExp(elt=Attribute(value=Name(id='ireq', ctx=Load()), attr='specifier', ctx=Load()), generators=[comprehension(target=Name(id='ireq', ctx=Store()), iter=Name(id='ireqs', ctx=Load()), ifs=[Name(id='ireq', ctx=Load())], is_async=0)]), ifs=[], is_async=0), comprehension(target=Name(id='specifier', ctx=Store()), iter=Name(id='specifier_set', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='direct', ctx=Store())], value=Compare(left=Name(id='candidate', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='pinned', ctx=Store())], value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Subscript(value=Name(id='op', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), ops=[Eq()], comparators=[Constant(value='==')]), generators=[comprehension(target=Name(id='op', ctx=Store()), iter=Name(id='operators', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Name(id='unfree', ctx=Store())], value=Call(func=Name(id='bool', ctx=Load()), args=[Name(id='operators', ctx=Load())], keywords=[])), Try(body=[AnnAssign(target=Name(id='requested_order', ctx=Store()), annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load()), value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_user_requested', ctx=Load()), slice=Name(id='identifier', ctx=Load()), ctx=Load()), simple=1)], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Assign(targets=[Name(id='requested_order', ctx=Store())], value=Attribute(value=Name(id='math', ctx=Load()), attr='inf', ctx=Load())), If(test=Name(id='has_information', ctx=Load()), body=[Assign(targets=[Name(id='parent_depths', ctx=Store())], value=GeneratorExp(elt=IfExp(test=Compare(left=Name(id='parent', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_known_depths', ctx=Load()), slice=Attribute(value=Name(id='parent', ctx=Load()), attr='name', ctx=Load()), ctx=Load()), orelse=Constant(value=0.0)), generators=[comprehension(target=Tuple(elts=[Name(id='_', ctx=Store()), Name(id='parent', ctx=Store())], ctx=Store()), iter=Subscript(value=Name(id='information', ctx=Load()), slice=Name(id='identifier', ctx=Load()), ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='inferred_depth', ctx=Store())], value=BinOp(left=Call(func=Name(id='min', ctx=Load()), args=[GeneratorExp(elt=Name(id='d', ctx=Load()), generators=[comprehension(target=Name(id='d', ctx=Store()), iter=Name(id='parent_depths', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), op=Add(), right=Constant(value=1.0)))], orelse=[Assign(targets=[Name(id='inferred_depth', ctx=Store())], value=Attribute(value=Name(id='math', ctx=Load()), attr='inf', ctx=Load()))])])], orelse=[Assign(targets=[Name(id='inferred_depth', ctx=Store())], value=Constant(value=1.0))], finalbody=[]), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_known_depths', ctx=Load()), slice=Name(id='identifier', ctx=Load()), ctx=Store())], value=Name(id='inferred_depth', ctx=Load())), Assign(targets=[Name(id='requested_order', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_user_requested', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='identifier', ctx=Load()), Attribute(value=Name(id='math', ctx=Load()), attr='inf', ctx=Load())], keywords=[])), Assign(targets=[Name(id='requires_python', ctx=Store())], value=Compare(left=Name(id='identifier', ctx=Load()), ops=[Eq()], comparators=[Name(id='REQUIRES_PYTHON_IDENTIFIER', ctx=Load())])), Assign(targets=[Name(id='backtrack_cause', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='is_backtrack_cause', ctx=Load()), args=[Name(id='identifier', ctx=Load()), Name(id='backtrack_causes', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[UnaryOp(op=Not(), operand=Name(id='requires_python', ctx=Load())), UnaryOp(op=Not(), operand=Name(id='direct', ctx=Load())), UnaryOp(op=Not(), operand=Name(id='pinned', ctx=Load())), UnaryOp(op=Not(), operand=Name(id='backtrack_cause', ctx=Load())), Name(id='inferred_depth', ctx=Load()), Name(id='requested_order', ctx=Load()), UnaryOp(op=Not(), operand=Name(id='unfree', ctx=Load())), Name(id='identifier', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Constant(value='Preference')), FunctionDef(name='find_matches', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='identifier', annotation=Name(id='str', ctx=Load())), arg(arg='requirements', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Requirement', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='incompatibilities', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Candidate', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='_eligible_for_upgrade', args=arguments(posonlyargs=[], args=[arg(arg='identifier', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Are upgrades allowed for this project?\n\n            This checks the upgrade strategy, and whether the project was one\n            that the user specified in the command line, in order to decide\n            whether we should upgrade if there\'s a newer version available.\n\n            (Note that we don\'t need access to the `--upgrade` flag, because\n            an upgrade strategy of "to-satisfy-only" means that `--upgrade`\n            was not specified).\n            ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_upgrade_strategy', ctx=Load()), ops=[Eq()], comparators=[Constant(value='eager')]), body=[Return(value=Constant(value=True))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_upgrade_strategy', ctx=Load()), ops=[Eq()], comparators=[Constant(value='only-if-needed')]), body=[Assign(targets=[Name(id='user_order', ctx=Store())], value=Call(func=Name(id='_get_with_identifier', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_user_requested', ctx=Load()), Name(id='identifier', ctx=Load())], keywords=[keyword(arg='default', value=Constant(value=None))])), Return(value=Compare(left=Name(id='user_order', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]))], orelse=[])]), Return(value=Constant(value=False))], decorator_list=[], returns=Name(id='bool', ctx=Load())), Assign(targets=[Name(id='constraint', ctx=Store())], value=Call(func=Name(id='_get_with_identifier', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_constraints', ctx=Load()), Name(id='identifier', ctx=Load())], keywords=[keyword(arg='default', value=Call(func=Attribute(value=Name(id='Constraint', ctx=Load()), attr='empty', ctx=Load()), args=[], keywords=[]))])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_factory', ctx=Load()), attr='find_candidates', ctx=Load()), args=[], keywords=[keyword(arg='identifier', value=Name(id='identifier', ctx=Load())), keyword(arg='requirements', value=Name(id='requirements', ctx=Load())), keyword(arg='constraint', value=Name(id='constraint', ctx=Load())), keyword(arg='prefers_installed', value=UnaryOp(op=Not(), operand=Call(func=Name(id='_eligible_for_upgrade', ctx=Load()), args=[Name(id='identifier', ctx=Load())], keywords=[]))), keyword(arg='incompatibilities', value=Name(id='incompatibilities', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Candidate', ctx=Load()), ctx=Load())), FunctionDef(name='is_satisfied_by', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requirement', annotation=Name(id='Requirement', ctx=Load())), arg(arg='candidate', annotation=Name(id='Candidate', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='requirement', ctx=Load()), attr='is_satisfied_by', ctx=Load()), args=[Name(id='candidate', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='get_dependencies', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='candidate', annotation=Name(id='Candidate', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='with_requires', ctx=Store())], value=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_ignore_dependencies', ctx=Load()))), Return(value=ListComp(elt=Name(id='r', ctx=Load()), generators=[comprehension(target=Name(id='r', ctx=Store()), iter=Call(func=Attribute(value=Name(id='candidate', ctx=Load()), attr='iter_dependencies', ctx=Load()), args=[Name(id='with_requires', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='r', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='Requirement', ctx=Load()), ctx=Load())), FunctionDef(name='is_backtrack_cause', args=arguments(posonlyargs=[], args=[arg(arg='identifier', annotation=Name(id='str', ctx=Load())), arg(arg='backtrack_causes', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Constant(value='PreferenceInformation'), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[For(target=Name(id='backtrack_cause', ctx=Store()), iter=Name(id='backtrack_causes', ctx=Load()), body=[If(test=Compare(left=Name(id='identifier', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Attribute(value=Name(id='backtrack_cause', ctx=Load()), attr='requirement', ctx=Load()), attr='name', ctx=Load())]), body=[Return(value=Constant(value=True))], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='backtrack_cause', ctx=Load()), attr='parent', ctx=Load()), Compare(left=Name(id='identifier', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Attribute(value=Name(id='backtrack_cause', ctx=Load()), attr='parent', ctx=Load()), attr='name', ctx=Load())])]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Constant(value=False))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[])], type_ignores=[])