Module(body=[Expr(value=Constant(value='Utilities to lazily create and visit candidates found.\n\nCreating and visiting a candidate is a *very* costly operation. It involves\nfetching, extracting, potentially building modules from source, and verifying\ndistribution metadata. It is therefore crucial for performance to keep\neverything here lazy all the way down, so we only touch candidates that we\nabsolutely need, and not "download the world" when we only need one version of\nsomething.\n')), Import(names=[alias(name='functools')]), ImportFrom(module='collections.abc', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Any'), alias(name='Callable'), alias(name='Iterator'), alias(name='Optional'), alias(name='Set'), alias(name='Tuple')], level=0), ImportFrom(module='pip._vendor.packaging.version', names=[alias(name='_BaseVersion')], level=0), ImportFrom(module='base', names=[alias(name='Candidate')], level=1), Assign(targets=[Name(id='IndexCandidateInfo', ctx=Store())], value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='_BaseVersion', ctx=Load()), Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Candidate', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[Assign(targets=[Name(id='SequenceCandidate', ctx=Store())], value=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='Candidate', ctx=Load()), ctx=Load()))], orelse=[Assign(targets=[Name(id='SequenceCandidate', ctx=Store())], value=Name(id='Sequence', ctx=Load()))]), FunctionDef(name='_iter_built', args=arguments(posonlyargs=[], args=[arg(arg='infos', annotation=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='IndexCandidateInfo', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterator for ``FoundCandidates``.\n\n    This iterator is used when the package is not already installed. Candidates\n    from index come later in their normal ordering.\n    ')), AnnAssign(target=Name(id='versions_found', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='_BaseVersion', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='version', ctx=Store()), Name(id='func', ctx=Store())], ctx=Store()), iter=Name(id='infos', ctx=Load()), body=[If(test=Compare(left=Name(id='version', ctx=Load()), ops=[In()], comparators=[Name(id='versions_found', ctx=Load())]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='candidate', ctx=Store())], value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='candidate', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Continue()], orelse=[]), Expr(value=Yield(value=Name(id='candidate', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='versions_found', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Candidate', ctx=Load()), ctx=Load())), FunctionDef(name='_iter_built_with_prepended', args=arguments(posonlyargs=[], args=[arg(arg='installed', annotation=Name(id='Candidate', ctx=Load())), arg(arg='infos', annotation=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='IndexCandidateInfo', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterator for ``FoundCandidates``.\n\n    This iterator is used when the resolver prefers the already-installed\n    candidate and NOT to upgrade. The installed candidate is therefore\n    always yielded first, and candidates from index come later in their\n    normal ordering, except skipped when the version is already installed.\n    ')), Expr(value=Yield(value=Name(id='installed', ctx=Load()))), AnnAssign(target=Name(id='versions_found', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='_BaseVersion', ctx=Load()), ctx=Load()), value=Set(elts=[Attribute(value=Name(id='installed', ctx=Load()), attr='version', ctx=Load())]), simple=1), For(target=Tuple(elts=[Name(id='version', ctx=Store()), Name(id='func', ctx=Store())], ctx=Store()), iter=Name(id='infos', ctx=Load()), body=[If(test=Compare(left=Name(id='version', ctx=Load()), ops=[In()], comparators=[Name(id='versions_found', ctx=Load())]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='candidate', ctx=Store())], value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='candidate', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Continue()], orelse=[]), Expr(value=Yield(value=Name(id='candidate', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='versions_found', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Candidate', ctx=Load()), ctx=Load())), FunctionDef(name='_iter_built_with_inserted', args=arguments(posonlyargs=[], args=[arg(arg='installed', annotation=Name(id='Candidate', ctx=Load())), arg(arg='infos', annotation=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='IndexCandidateInfo', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Iterator for ``FoundCandidates``.\n\n    This iterator is used when the resolver prefers to upgrade an\n    already-installed package. Candidates from index are returned in their\n    normal ordering, except replaced when the version is already installed.\n\n    The implementation iterates through and yields other candidates, inserting\n    the installed candidate exactly once before we start yielding older or\n    equivalent candidates, or after all other candidates if they are all newer.\n    ')), AnnAssign(target=Name(id='versions_found', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='_BaseVersion', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='version', ctx=Store()), Name(id='func', ctx=Store())], ctx=Store()), iter=Name(id='infos', ctx=Load()), body=[If(test=Compare(left=Name(id='version', ctx=Load()), ops=[In()], comparators=[Name(id='versions_found', ctx=Load())]), body=[Continue()], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='installed', ctx=Load()), attr='version', ctx=Load()), ops=[GtE()], comparators=[Name(id='version', ctx=Load())]), body=[Expr(value=Yield(value=Name(id='installed', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='versions_found', ctx=Load()), attr='add', ctx=Load()), args=[Attribute(value=Name(id='installed', ctx=Load()), attr='version', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='candidate', ctx=Store())], value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='candidate', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Continue()], orelse=[]), Expr(value=Yield(value=Name(id='candidate', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='versions_found', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='version', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='installed', ctx=Load()), attr='version', ctx=Load()), ops=[NotIn()], comparators=[Name(id='versions_found', ctx=Load())]), body=[Expr(value=Yield(value=Name(id='installed', ctx=Load())))], orelse=[])], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Candidate', ctx=Load()), ctx=Load())), ClassDef(name='FoundCandidates', bases=[Name(id='SequenceCandidate', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A lazy sequence to provide candidates to the resolver.\n\n    The intended usage is to return this from `find_matches()` so the resolver\n    can iterate through the sequence multiple times, but only access the index\n    page when remote packages are actually needed. This improve performances\n    when suitable candidates are already installed on disk.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='get_infos', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[], ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='IndexCandidateInfo', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='installed', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Candidate', ctx=Load()), ctx=Load())), arg(arg='prefers_installed', annotation=Name(id='bool', ctx=Load())), arg(arg='incompatible_ids', annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_get_infos', ctx=Store())], value=Name(id='get_infos', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_installed', ctx=Store())], value=Name(id='installed', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_prefers_installed', ctx=Store())], value=Name(id='prefers_installed', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_incompatible_ids', ctx=Store())], value=Name(id='incompatible_ids', ctx=Load()))], decorator_list=[]), FunctionDef(name='__getitem__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='index', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value="don't do this")], keywords=[]))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='__iter__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='infos', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_infos', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='_installed', ctx=Load())), body=[Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='_iter_built', ctx=Load()), args=[Name(id='infos', ctx=Load())], keywords=[]))], orelse=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_prefers_installed', ctx=Load()), body=[Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='_iter_built_with_prepended', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_installed', ctx=Load()), Name(id='infos', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='_iter_built_with_inserted', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_installed', ctx=Load()), Name(id='infos', ctx=Load())], keywords=[]))])]), Return(value=GeneratorExp(elt=Name(id='c', ctx=Load()), generators=[comprehension(target=Name(id='c', ctx=Store()), iter=Name(id='iterator', ctx=Load()), ifs=[Compare(left=Call(func=Name(id='id', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_incompatible_ids', ctx=Load())])], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Name(id='Candidate', ctx=Load()), ctx=Load())), FunctionDef(name='__len__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value="don't do this")], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='__bool__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='_prefers_installed', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_installed', ctx=Load())]), body=[Return(value=Constant(value=True))], orelse=[]), Return(value=Call(func=Name(id='any', ctx=Load()), args=[Name(id='self', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='lru_cache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=1))])], returns=Name(id='bool', ctx=Load()))], decorator_list=[])], type_ignores=[])