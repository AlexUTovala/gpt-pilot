Module(body=[Expr(value=Constant(value='Dependency Resolution\n\nThe dependency resolution in pip is performed as follows:\n\nfor top-level requirements:\n    a. only one spec allowed per project, regardless of conflicts or not.\n       otherwise a "double requirement" exception is raised\n    b. they override sub-dependency requirements.\nfor sub-dependencies\n    a. "first found, wins" (where the order is breadth first)\n')), Import(names=[alias(name='logging')]), Import(names=[alias(name='sys')]), ImportFrom(module='collections', names=[alias(name='defaultdict')], level=0), ImportFrom(module='itertools', names=[alias(name='chain')], level=0), ImportFrom(module='typing', names=[alias(name='DefaultDict'), alias(name='Iterable'), alias(name='List'), alias(name='Optional'), alias(name='Set'), alias(name='Tuple')], level=0), ImportFrom(module='pip._vendor.packaging', names=[alias(name='specifiers')], level=0), ImportFrom(module='pip._vendor.packaging.requirements', names=[alias(name='Requirement')], level=0), ImportFrom(module='pip._internal.cache', names=[alias(name='WheelCache')], level=0), ImportFrom(module='pip._internal.exceptions', names=[alias(name='BestVersionAlreadyInstalled'), alias(name='DistributionNotFound'), alias(name='HashError'), alias(name='HashErrors'), alias(name='InstallationError'), alias(name='NoneMetadataError'), alias(name='UnsupportedPythonVersion')], level=0), ImportFrom(module='pip._internal.index.package_finder', names=[alias(name='PackageFinder')], level=0), ImportFrom(module='pip._internal.metadata', names=[alias(name='BaseDistribution')], level=0), ImportFrom(module='pip._internal.models.link', names=[alias(name='Link')], level=0), ImportFrom(module='pip._internal.models.wheel', names=[alias(name='Wheel')], level=0), ImportFrom(module='pip._internal.operations.prepare', names=[alias(name='RequirementPreparer')], level=0), ImportFrom(module='pip._internal.req.req_install', names=[alias(name='InstallRequirement'), alias(name='check_invalid_constraint_type')], level=0), ImportFrom(module='pip._internal.req.req_set', names=[alias(name='RequirementSet')], level=0), ImportFrom(module='pip._internal.resolution.base', names=[alias(name='BaseResolver'), alias(name='InstallRequirementProvider')], level=0), ImportFrom(module='pip._internal.utils', names=[alias(name='compatibility_tags')], level=0), ImportFrom(module='pip._internal.utils.compatibility_tags', names=[alias(name='get_supported')], level=0), ImportFrom(module='pip._internal.utils.direct_url_helpers', names=[alias(name='direct_url_from_link')], level=0), ImportFrom(module='pip._internal.utils.logging', names=[alias(name='indent_log')], level=0), ImportFrom(module='pip._internal.utils.misc', names=[alias(name='normalize_version_info')], level=0), ImportFrom(module='pip._internal.utils.packaging', names=[alias(name='check_requires_python')], level=0), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='DiscoveredDependencies', ctx=Store())], value=Subscript(value=Name(id='DefaultDict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_check_dist_requires_python', args=arguments(posonlyargs=[], args=[arg(arg='dist', annotation=Name(id='BaseDistribution', ctx=Load())), arg(arg='version_info', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='ignore_requires_python', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Check whether the given Python version is compatible with a distribution\'s\n    "Requires-Python" value.\n\n    :param version_info: A 3-tuple of ints representing the Python\n        major-minor-micro version to check.\n    :param ignore_requires_python: Whether to ignore the "Requires-Python"\n        value if the given Python version isn\'t compatible.\n\n    :raises UnsupportedPythonVersion: When the given Python version isn\'t\n        compatible.\n    ')), Try(body=[Assign(targets=[Name(id='requires_python', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='requires_python', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='NoneMetadataError', ctx=Load()), args=[Name(id='dist', ctx=Load()), Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[])], keywords=[]))])], orelse=[], finalbody=[]), Try(body=[Assign(targets=[Name(id='is_compatible', ctx=Store())], value=Call(func=Name(id='check_requires_python', ctx=Load()), args=[Name(id='requires_python', ctx=Load())], keywords=[keyword(arg='version_info', value=Name(id='version_info', ctx=Load()))]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='specifiers', ctx=Load()), attr='InvalidSpecifier', ctx=Load()), name='exc', body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value='Package %r has an invalid Requires-Python: %s'), Attribute(value=Name(id='dist', ctx=Load()), attr='raw_name', ctx=Load()), Name(id='exc', ctx=Load())], keywords=[])), Return()])], orelse=[], finalbody=[]), If(test=Name(id='is_compatible', ctx=Load()), body=[Return()], orelse=[]), Assign(targets=[Name(id='version', ctx=Store())], value=Call(func=Attribute(value=Constant(value='.'), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='version_info', ctx=Load())], keywords=[])], keywords=[])), If(test=Name(id='ignore_requires_python', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Ignoring failed Requires-Python check for package %r: %s not in %r'), Attribute(value=Name(id='dist', ctx=Load()), attr='raw_name', ctx=Load()), Name(id='version', ctx=Load()), Name(id='requires_python', ctx=Load())], keywords=[])), Return()], orelse=[]), Raise(exc=Call(func=Name(id='UnsupportedPythonVersion', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Package {!r} requires a different Python: {} not in {!r}'), attr='format', ctx=Load()), args=[Attribute(value=Name(id='dist', ctx=Load()), attr='raw_name', ctx=Load()), Name(id='version', ctx=Load()), Name(id='requires_python', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Constant(value=None)), ClassDef(name='Resolver', bases=[Name(id='BaseResolver', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Resolves which packages need to be installed/uninstalled to perform     the requested operation without breaking the requirements of any package.\n    ')), Assign(targets=[Name(id='_allowed_strategies', ctx=Store())], value=Set(elts=[Constant(value='eager'), Constant(value='only-if-needed'), Constant(value='to-satisfy-only')])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='preparer', annotation=Name(id='RequirementPreparer', ctx=Load())), arg(arg='finder', annotation=Name(id='PackageFinder', ctx=Load())), arg(arg='wheel_cache', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='WheelCache', ctx=Load()), ctx=Load())), arg(arg='make_install_req', annotation=Name(id='InstallRequirementProvider', ctx=Load())), arg(arg='use_user_site', annotation=Name(id='bool', ctx=Load())), arg(arg='ignore_dependencies', annotation=Name(id='bool', ctx=Load())), arg(arg='ignore_installed', annotation=Name(id='bool', ctx=Load())), arg(arg='ignore_requires_python', annotation=Name(id='bool', ctx=Load())), arg(arg='force_reinstall', annotation=Name(id='bool', ctx=Load())), arg(arg='upgrade_strategy', annotation=Name(id='str', ctx=Load())), arg(arg='py_version_info', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Constant(value=Ellipsis)], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assert(test=Compare(left=Name(id='upgrade_strategy', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_allowed_strategies', ctx=Load())])), If(test=Compare(left=Name(id='py_version_info', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='py_version_info', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), slice=Slice(upper=Constant(value=3)), ctx=Load()))], orelse=[Assign(targets=[Name(id='py_version_info', ctx=Store())], value=Call(func=Name(id='normalize_version_info', ctx=Load()), args=[Name(id='py_version_info', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_py_version_info', ctx=Store())], value=Name(id='py_version_info', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='preparer', ctx=Store())], value=Name(id='preparer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='finder', ctx=Store())], value=Name(id='finder', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='wheel_cache', ctx=Store())], value=Name(id='wheel_cache', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='upgrade_strategy', ctx=Store())], value=Name(id='upgrade_strategy', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='force_reinstall', ctx=Store())], value=Name(id='force_reinstall', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ignore_dependencies', ctx=Store())], value=Name(id='ignore_dependencies', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ignore_installed', ctx=Store())], value=Name(id='ignore_installed', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ignore_requires_python', ctx=Store())], value=Name(id='ignore_requires_python', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='use_user_site', ctx=Store())], value=Name(id='use_user_site', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_make_install_req', ctx=Store())], value=Name(id='make_install_req', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_discovered_dependencies', ctx=Store()), annotation=Name(id='DiscoveredDependencies', ctx=Load()), value=Call(func=Name(id='defaultdict', ctx=Load()), args=[Name(id='list', ctx=Load())], keywords=[]), simple=0)], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='resolve', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='root_reqs', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load())), arg(arg='check_supported_wheels', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Resolve what operations need to be done\n\n        As a side-effect of this method, the packages (and their dependencies)\n        are downloaded, unpacked and prepared for installation. This\n        preparation is done by ``pip.operations.prepare``.\n\n        Once PyPI has static dependency metadata available, it would be\n        possible to move the preparation to become a step separated from\n        dependency resolution.\n        ')), Assign(targets=[Name(id='requirement_set', ctx=Store())], value=Call(func=Name(id='RequirementSet', ctx=Load()), args=[], keywords=[keyword(arg='check_supported_wheels', value=Name(id='check_supported_wheels', ctx=Load()))])), For(target=Name(id='req', ctx=Store()), iter=Name(id='root_reqs', ctx=Load()), body=[If(test=Attribute(value=Name(id='req', ctx=Load()), attr='constraint', ctx=Load()), body=[Expr(value=Call(func=Name(id='check_invalid_constraint_type', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_requirement_to_set', ctx=Load()), args=[Name(id='requirement_set', ctx=Load()), Name(id='req', ctx=Load())], keywords=[]))], orelse=[]), AnnAssign(target=Name(id='discovered_reqs', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), Assign(targets=[Name(id='hash_errors', ctx=Store())], value=Call(func=Name(id='HashErrors', ctx=Load()), args=[], keywords=[])), For(target=Name(id='req', ctx=Store()), iter=Call(func=Name(id='chain', ctx=Load()), args=[Attribute(value=Name(id='requirement_set', ctx=Load()), attr='all_requirements', ctx=Load()), Name(id='discovered_reqs', ctx=Load())], keywords=[]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='discovered_reqs', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_resolve_one', ctx=Load()), args=[Name(id='requirement_set', ctx=Load()), Name(id='req', ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='HashError', ctx=Load()), name='exc', body=[Assign(targets=[Attribute(value=Name(id='exc', ctx=Load()), attr='req', ctx=Store())], value=Name(id='req', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='hash_errors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='exc', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], orelse=[]), If(test=Name(id='hash_errors', ctx=Load()), body=[Raise(exc=Name(id='hash_errors', ctx=Load()))], orelse=[]), Return(value=Name(id='requirement_set', ctx=Load()))], decorator_list=[], returns=Name(id='RequirementSet', ctx=Load())), FunctionDef(name='_add_requirement_to_set', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requirement_set', annotation=Name(id='RequirementSet', ctx=Load())), arg(arg='install_req', annotation=Name(id='InstallRequirement', ctx=Load())), arg(arg='parent_req_name', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='extras_requested', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Add install_req as a requirement to install.\n\n        :param parent_req_name: The name of the requirement that needed this\n            added. The name is used because when multiple unnamed requirements\n            resolve to the same name, we could otherwise end up with dependency\n            links that point outside the Requirements set. parent_req must\n            already be added. Note that None implies that this is a user\n            supplied requirement, vs an inferred one.\n        :param extras_requested: an iterable of extras used to evaluate the\n            environment markers.\n        :return: Additional requirements to scan. That is either [] if\n            the requirement is not applicable, or [install_req] if the\n            requirement is applicable and has just been added.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='install_req', ctx=Load()), attr='match_markers', ctx=Load()), args=[Name(id='extras_requested', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Constant(value="Ignoring %s: markers '%s' don't match your environment"), Attribute(value=Name(id='install_req', ctx=Load()), attr='name', ctx=Load()), Attribute(value=Name(id='install_req', ctx=Load()), attr='markers', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[List(elts=[], ctx=Load()), Constant(value=None)], ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='install_req', ctx=Load()), attr='link', ctx=Load()), Attribute(value=Attribute(value=Name(id='install_req', ctx=Load()), attr='link', ctx=Load()), attr='is_wheel', ctx=Load())]), body=[Assign(targets=[Name(id='wheel', ctx=Store())], value=Call(func=Name(id='Wheel', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='install_req', ctx=Load()), attr='link', ctx=Load()), attr='filename', ctx=Load())], keywords=[])), Assign(targets=[Name(id='tags', ctx=Store())], value=Call(func=Attribute(value=Name(id='compatibility_tags', ctx=Load()), attr='get_supported', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Attribute(value=Name(id='requirement_set', ctx=Load()), attr='check_supported_wheels', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='wheel', ctx=Load()), attr='supported', ctx=Load()), args=[Name(id='tags', ctx=Load())], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='InstallationError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{} is not a supported wheel on this platform.'), attr='format', ctx=Load()), args=[Attribute(value=Name(id='wheel', ctx=Load()), attr='filename', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Assert(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='install_req', ctx=Load()), attr='user_supplied', ctx=Load())), Compare(left=Name(id='parent_req_name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), msg=Constant(value="a user supplied req shouldn't have a parent")), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='install_req', ctx=Load()), attr='name', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='requirement_set', ctx=Load()), attr='add_unnamed_requirement', ctx=Load()), args=[Name(id='install_req', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[List(elts=[Name(id='install_req', ctx=Load())], ctx=Load()), Constant(value=None)], ctx=Load()))], orelse=[]), Try(body=[AnnAssign(target=Name(id='existing_req', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='requirement_set', ctx=Load()), attr='get_requirement', ctx=Load()), args=[Attribute(value=Name(id='install_req', ctx=Load()), attr='name', ctx=Load())], keywords=[]), simple=1)], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Assign(targets=[Name(id='existing_req', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='has_conflicting_requirement', ctx=Store())], value=BoolOp(op=And(), values=[Compare(left=Name(id='parent_req_name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Name(id='existing_req', ctx=Load()), UnaryOp(op=Not(), operand=Attribute(value=Name(id='existing_req', ctx=Load()), attr='constraint', ctx=Load())), Compare(left=Attribute(value=Name(id='existing_req', ctx=Load()), attr='extras', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='install_req', ctx=Load()), attr='extras', ctx=Load())]), Attribute(value=Name(id='existing_req', ctx=Load()), attr='req', ctx=Load()), Attribute(value=Name(id='install_req', ctx=Load()), attr='req', ctx=Load()), Compare(left=Attribute(value=Attribute(value=Name(id='existing_req', ctx=Load()), attr='req', ctx=Load()), attr='specifier', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='install_req', ctx=Load()), attr='req', ctx=Load()), attr='specifier', ctx=Load())])])), If(test=Name(id='has_conflicting_requirement', ctx=Load()), body=[Raise(exc=Call(func=Name(id='InstallationError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Double requirement given: {} (already in {}, name={!r})'), attr='format', ctx=Load()), args=[Name(id='install_req', ctx=Load()), Name(id='existing_req', ctx=Load()), Attribute(value=Name(id='install_req', ctx=Load()), attr='name', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='existing_req', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='requirement_set', ctx=Load()), attr='add_named_requirement', ctx=Load()), args=[Name(id='install_req', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[List(elts=[Name(id='install_req', ctx=Load())], ctx=Load()), Name(id='install_req', ctx=Load())], ctx=Load()))], orelse=[]), If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='install_req', ctx=Load()), attr='constraint', ctx=Load()), UnaryOp(op=Not(), operand=Attribute(value=Name(id='existing_req', ctx=Load()), attr='constraint', ctx=Load()))]), body=[Return(value=Tuple(elts=[List(elts=[], ctx=Load()), Name(id='existing_req', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='does_not_satisfy_constraint', ctx=Store())], value=BoolOp(op=And(), values=[Attribute(value=Name(id='install_req', ctx=Load()), attr='link', ctx=Load()), UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Attribute(value=Name(id='existing_req', ctx=Load()), attr='link', ctx=Load()), Compare(left=Attribute(value=Attribute(value=Name(id='install_req', ctx=Load()), attr='link', ctx=Load()), attr='path', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Attribute(value=Name(id='existing_req', ctx=Load()), attr='link', ctx=Load()), attr='path', ctx=Load())])]))])), If(test=Name(id='does_not_satisfy_constraint', ctx=Load()), body=[Raise(exc=Call(func=Name(id='InstallationError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="Could not satisfy constraints for '{}': installation from path or url cannot be constrained to a version"), attr='format', ctx=Load()), args=[Attribute(value=Name(id='install_req', ctx=Load()), attr='name', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='existing_req', ctx=Load()), attr='constraint', ctx=Store())], value=Constant(value=False)), If(test=Attribute(value=Name(id='install_req', ctx=Load()), attr='user_supplied', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='existing_req', ctx=Load()), attr='user_supplied', ctx=Store())], value=Constant(value=True))], orelse=[]), Assign(targets=[Attribute(value=Name(id='existing_req', ctx=Load()), attr='extras', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[BinOp(left=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='existing_req', ctx=Load()), attr='extras', ctx=Load())], keywords=[]), op=BitOr(), right=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='install_req', ctx=Load()), attr='extras', ctx=Load())], keywords=[]))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Setting %s extras to: %s'), Name(id='existing_req', ctx=Load()), Attribute(value=Name(id='existing_req', ctx=Load()), attr='extras', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[List(elts=[Name(id='existing_req', ctx=Load())], ctx=Load()), Name(id='existing_req', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_is_upgrade_allowed', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req', annotation=Name(id='InstallRequirement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='upgrade_strategy', ctx=Load()), ops=[Eq()], comparators=[Constant(value='to-satisfy-only')]), body=[Return(value=Constant(value=False))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='upgrade_strategy', ctx=Load()), ops=[Eq()], comparators=[Constant(value='eager')]), body=[Return(value=Constant(value=True))], orelse=[Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='upgrade_strategy', ctx=Load()), ops=[Eq()], comparators=[Constant(value='only-if-needed')])), Return(value=BoolOp(op=Or(), values=[Attribute(value=Name(id='req', ctx=Load()), attr='user_supplied', ctx=Load()), Attribute(value=Name(id='req', ctx=Load()), attr='constraint', ctx=Load())]))])])], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_set_req_to_reinstall', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req', annotation=Name(id='InstallRequirement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Set a requirement to be installed.\n        ')), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='use_user_site', ctx=Load())), Attribute(value=Attribute(value=Name(id='req', ctx=Load()), attr='satisfied_by', ctx=Load()), attr='in_usersite', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='req', ctx=Load()), attr='should_reinstall', ctx=Store())], value=Constant(value=True))], orelse=[]), Assign(targets=[Attribute(value=Name(id='req', ctx=Load()), attr='satisfied_by', ctx=Store())], value=Constant(value=None))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_check_skip_installed', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req_to_install', annotation=Name(id='InstallRequirement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Check if req_to_install should be skipped.\n\n        This will check if the req is installed, and whether we should upgrade\n        or reinstall it, taking into account all the relevant user options.\n\n        After calling this req_to_install will only have satisfied_by set to\n        None if the req_to_install is to be upgraded/reinstalled etc. Any\n        other value will be a dist recording the current thing installed that\n        satisfies the requirement.\n\n        Note that for vcs urls and the like we can't assess skipping in this\n        routine - we simply identify that we need to pull the thing down,\n        then later on it is pulled down and introspected to assess upgrade/\n        reinstalls etc.\n\n        :return: A text reason for why it was skipped, or None.\n        ")), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='ignore_installed', ctx=Load()), body=[Return(value=Constant(value=None))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='req_to_install', ctx=Load()), attr='check_if_exists', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='use_user_site', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='req_to_install', ctx=Load()), attr='satisfied_by', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='force_reinstall', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_set_req_to_reinstall', ctx=Load()), args=[Name(id='req_to_install', ctx=Load())], keywords=[])), Return(value=Constant(value=None))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_is_upgrade_allowed', ctx=Load()), args=[Name(id='req_to_install', ctx=Load())], keywords=[])), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='upgrade_strategy', ctx=Load()), ops=[Eq()], comparators=[Constant(value='only-if-needed')]), body=[Return(value=Constant(value='already satisfied, skipping upgrade'))], orelse=[]), Return(value=Constant(value='already satisfied'))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='req_to_install', ctx=Load()), attr='link', ctx=Load())), body=[Try(body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='finder', ctx=Load()), attr='find_requirement', ctx=Load()), args=[Name(id='req_to_install', ctx=Load())], keywords=[keyword(arg='upgrade', value=Constant(value=True))]))], handlers=[ExceptHandler(type=Name(id='BestVersionAlreadyInstalled', ctx=Load()), body=[Return(value=Constant(value='already up-to-date'))]), ExceptHandler(type=Name(id='DistributionNotFound', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_set_req_to_reinstall', ctx=Load()), args=[Name(id='req_to_install', ctx=Load())], keywords=[])), Return(value=Constant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='_find_requirement_link', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req', annotation=Name(id='InstallRequirement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='upgrade', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_is_upgrade_allowed', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[])), Assign(targets=[Name(id='best_candidate', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='finder', ctx=Load()), attr='find_requirement', ctx=Load()), args=[Name(id='req', ctx=Load()), Name(id='upgrade', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='best_candidate', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='link', ctx=Store())], value=Attribute(value=Name(id='best_candidate', ctx=Load()), attr='link', ctx=Load())), If(test=Attribute(value=Name(id='link', ctx=Load()), attr='is_yanked', ctx=Load()), body=[Assign(targets=[Name(id='reason', ctx=Store())], value=BoolOp(op=Or(), values=[Attribute(value=Name(id='link', ctx=Load()), attr='yanked_reason', ctx=Load()), Constant(value='<none given>')])), Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Attribute(value=Constant(value='The candidate selected for download or install is a yanked version: {candidate}\nReason for being yanked: {reason}'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='candidate', value=Name(id='best_candidate', ctx=Load())), keyword(arg='reason', value=Name(id='reason', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Name(id='msg', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='link', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Link', ctx=Load()), ctx=Load())), FunctionDef(name='_populate_link', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req', annotation=Name(id='InstallRequirement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Ensure that if a link can be found for this, that it is found.\n\n        Note that req.link may still be None - if the requirement is already\n        installed and not needed to be upgraded based on the return value of\n        _is_upgrade_allowed().\n\n        If preparer.require_hashes is True, don't use the wheel cache, because\n        cached wheels, always built locally, have different hashes than the\n        files downloaded from the index server and thus throw false hash\n        mismatches. Furthermore, cached wheels at present have undeterministic\n        contents due to file modification times.\n        ")), If(test=Compare(left=Attribute(value=Name(id='req', ctx=Load()), attr='link', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='req', ctx=Load()), attr='link', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_requirement_link', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='wheel_cache', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='preparer', ctx=Load()), attr='require_hashes', ctx=Load())]), body=[Return()], orelse=[]), Assign(targets=[Name(id='cache_entry', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='wheel_cache', ctx=Load()), attr='get_cache_entry', ctx=Load()), args=[], keywords=[keyword(arg='link', value=Attribute(value=Name(id='req', ctx=Load()), attr='link', ctx=Load())), keyword(arg='package_name', value=Attribute(value=Name(id='req', ctx=Load()), attr='name', ctx=Load())), keyword(arg='supported_tags', value=Call(func=Name(id='get_supported', ctx=Load()), args=[], keywords=[]))])), If(test=Compare(left=Name(id='cache_entry', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Using cached wheel link: %s'), Attribute(value=Name(id='cache_entry', ctx=Load()), attr='link', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='req', ctx=Load()), attr='link', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='req', ctx=Load()), attr='original_link', ctx=Load())]), Attribute(value=Name(id='cache_entry', ctx=Load()), attr='persistent', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='req', ctx=Load()), attr='cached_wheel_source_link', ctx=Store())], value=Attribute(value=Name(id='req', ctx=Load()), attr='link', ctx=Load()))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='cache_entry', ctx=Load()), attr='origin', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='req', ctx=Load()), attr='download_info', ctx=Store())], value=Attribute(value=Name(id='cache_entry', ctx=Load()), attr='origin', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='req', ctx=Load()), attr='download_info', ctx=Store())], value=Call(func=Name(id='direct_url_from_link', ctx=Load()), args=[Attribute(value=Name(id='req', ctx=Load()), attr='link', ctx=Load())], keywords=[keyword(arg='link_is_in_wheel_cache', value=Attribute(value=Name(id='cache_entry', ctx=Load()), attr='persistent', ctx=Load()))]))]), Assign(targets=[Attribute(value=Name(id='req', ctx=Load()), attr='link', ctx=Store())], value=Attribute(value=Name(id='cache_entry', ctx=Load()), attr='link', ctx=Load()))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='_get_dist_for', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req', annotation=Name(id='InstallRequirement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Takes a InstallRequirement and returns a single AbstractDist         representing a prepared variant of the same.\n        ')), If(test=Attribute(value=Name(id='req', ctx=Load()), attr='editable', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='preparer', ctx=Load()), attr='prepare_editable_requirement', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[]))], orelse=[]), Assert(test=Compare(left=Attribute(value=Name(id='req', ctx=Load()), attr='satisfied_by', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])), Assign(targets=[Name(id='skip_reason', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_skip_installed', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='req', ctx=Load()), attr='satisfied_by', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='preparer', ctx=Load()), attr='prepare_installed_requirement', ctx=Load()), args=[Name(id='req', ctx=Load()), Name(id='skip_reason', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_populate_link', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[])), Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='preparer', ctx=Load()), attr='prepare_linked_requirement', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='ignore_installed', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='req', ctx=Load()), attr='check_if_exists', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='use_user_site', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Name(id='req', ctx=Load()), attr='satisfied_by', ctx=Load()), body=[Assign(targets=[Name(id='should_modify', ctx=Store())], value=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='upgrade_strategy', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='to-satisfy-only')]), Attribute(value=Name(id='self', ctx=Load()), attr='force_reinstall', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ignore_installed', ctx=Load()), Compare(left=Attribute(value=Attribute(value=Name(id='req', ctx=Load()), attr='link', ctx=Load()), attr='scheme', ctx=Load()), ops=[Eq()], comparators=[Constant(value='file')])])), If(test=Name(id='should_modify', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_set_req_to_reinstall', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Constant(value='Requirement already satisfied (use --upgrade to upgrade): %s'), Name(id='req', ctx=Load())], keywords=[]))])], orelse=[]), Return(value=Name(id='dist', ctx=Load()))], decorator_list=[], returns=Name(id='BaseDistribution', ctx=Load())), FunctionDef(name='_resolve_one', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requirement_set', annotation=Name(id='RequirementSet', ctx=Load())), arg(arg='req_to_install', annotation=Name(id='InstallRequirement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Prepare a single requirements file.\n\n        :return: A list of additional InstallRequirements to also install.\n        ')), If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='req_to_install', ctx=Load()), attr='constraint', ctx=Load()), Attribute(value=Name(id='req_to_install', ctx=Load()), attr='prepared', ctx=Load())]), body=[Return(value=List(elts=[], ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='req_to_install', ctx=Load()), attr='prepared', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='dist', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_dist_for', ctx=Load()), args=[Name(id='req_to_install', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_check_dist_requires_python', ctx=Load()), args=[Name(id='dist', ctx=Load())], keywords=[keyword(arg='version_info', value=Attribute(value=Name(id='self', ctx=Load()), attr='_py_version_info', ctx=Load())), keyword(arg='ignore_requires_python', value=Attribute(value=Name(id='self', ctx=Load()), attr='ignore_requires_python', ctx=Load()))])), AnnAssign(target=Name(id='more_reqs', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), FunctionDef(name='add_req', args=arguments(posonlyargs=[], args=[arg(arg='subreq', annotation=Name(id='Requirement', ctx=Load())), arg(arg='extras_requested', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='sub_install_req', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_install_req', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Name(id='subreq', ctx=Load())], keywords=[]), Name(id='req_to_install', ctx=Load())], keywords=[])), Assign(targets=[Name(id='parent_req_name', ctx=Store())], value=Attribute(value=Name(id='req_to_install', ctx=Load()), attr='name', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='to_scan_again', ctx=Store()), Name(id='add_to_parent', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_requirement_to_set', ctx=Load()), args=[Name(id='requirement_set', ctx=Load()), Name(id='sub_install_req', ctx=Load())], keywords=[keyword(arg='parent_req_name', value=Name(id='parent_req_name', ctx=Load())), keyword(arg='extras_requested', value=Name(id='extras_requested', ctx=Load()))])), If(test=BoolOp(op=And(), values=[Name(id='parent_req_name', ctx=Load()), Name(id='add_to_parent', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_discovered_dependencies', ctx=Load()), slice=Name(id='parent_req_name', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Name(id='add_to_parent', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='more_reqs', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='to_scan_again', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), With(items=[withitem(context_expr=Call(func=Name(id='indent_log', ctx=Load()), args=[], keywords=[]))], body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='requirement_set', ctx=Load()), attr='has_requirement', ctx=Load()), args=[Attribute(value=Name(id='req_to_install', ctx=Load()), attr='name', ctx=Load())], keywords=[])), body=[Assert(test=Attribute(value=Name(id='req_to_install', ctx=Load()), attr='user_supplied', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_requirement_to_set', ctx=Load()), args=[Name(id='requirement_set', ctx=Load()), Name(id='req_to_install', ctx=Load())], keywords=[keyword(arg='parent_req_name', value=Constant(value=None))]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='self', ctx=Load()), attr='ignore_dependencies', ctx=Load())), body=[If(test=Attribute(value=Name(id='req_to_install', ctx=Load()), attr='extras', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Installing extra requirements: %r'), Call(func=Attribute(value=Constant(value=','), attr='join', ctx=Load()), args=[Attribute(value=Name(id='req_to_install', ctx=Load()), attr='extras', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='missing_requested', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[BinOp(left=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='req_to_install', ctx=Load()), attr='extras', ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='iter_provided_extras', ctx=Load()), args=[], keywords=[])], keywords=[]))], keywords=[])), For(target=Name(id='missing', ctx=Store()), iter=Name(id='missing_requested', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Constant(value="%s %s does not provide the extra '%s'"), Attribute(value=Name(id='dist', ctx=Load()), attr='raw_name', ctx=Load()), Attribute(value=Name(id='dist', ctx=Load()), attr='version', ctx=Load()), Name(id='missing', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='available_requested', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[BinOp(left=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='iter_provided_extras', ctx=Load()), args=[], keywords=[])], keywords=[]), op=BitAnd(), right=Call(func=Name(id='set', ctx=Load()), args=[Attribute(value=Name(id='req_to_install', ctx=Load()), attr='extras', ctx=Load())], keywords=[]))], keywords=[])), For(target=Name(id='subreq', ctx=Store()), iter=Call(func=Attribute(value=Name(id='dist', ctx=Load()), attr='iter_dependencies', ctx=Load()), args=[Name(id='available_requested', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='add_req', ctx=Load()), args=[Name(id='subreq', ctx=Load())], keywords=[keyword(arg='extras_requested', value=Name(id='available_requested', ctx=Load()))]))], orelse=[])], orelse=[])]), Return(value=Name(id='more_reqs', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load())), FunctionDef(name='get_installation_order', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='req_set', annotation=Name(id='RequirementSet', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create the installation order.\n\n        The installation order is topological - requirements are installed\n        before the requiring thing. We break cycles at an arbitrary point,\n        and make no other guarantees.\n        ')), Assign(targets=[Name(id='order', ctx=Store())], value=List(elts=[], ctx=Load())), AnnAssign(target=Name(id='ordered_reqs', ctx=Store()), annotation=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), FunctionDef(name='schedule', args=arguments(posonlyargs=[], args=[arg(arg='req', annotation=Name(id='InstallRequirement', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Attribute(value=Name(id='req', ctx=Load()), attr='satisfied_by', ctx=Load()), Compare(left=Name(id='req', ctx=Load()), ops=[In()], comparators=[Name(id='ordered_reqs', ctx=Load())])]), body=[Return()], orelse=[]), If(test=Attribute(value=Name(id='req', ctx=Load()), attr='constraint', ctx=Load()), body=[Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='ordered_reqs', ctx=Load()), attr='add', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[])), For(target=Name(id='dep', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_discovered_dependencies', ctx=Load()), slice=Attribute(value=Name(id='req', ctx=Load()), attr='name', ctx=Load()), ctx=Load()), body=[Expr(value=Call(func=Name(id='schedule', ctx=Load()), args=[Name(id='dep', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='order', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='req', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), For(target=Name(id='install_req', ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='req_set', ctx=Load()), attr='requirements', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id='schedule', ctx=Load()), args=[Name(id='install_req', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='order', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='InstallRequirement', ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])