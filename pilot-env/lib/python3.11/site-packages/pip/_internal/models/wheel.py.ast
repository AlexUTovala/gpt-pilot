Module(body=[Expr(value=Constant(value='Represents a wheel file and provides access to the various parts of the\nname that have meaning.\n')), Import(names=[alias(name='re')]), ImportFrom(module='typing', names=[alias(name='Dict'), alias(name='Iterable'), alias(name='List')], level=0), ImportFrom(module='pip._vendor.packaging.tags', names=[alias(name='Tag')], level=0), ImportFrom(module='pip._internal.exceptions', names=[alias(name='InvalidWheelFilename')], level=0), ClassDef(name='Wheel', bases=[], keywords=[], body=[Expr(value=Constant(value='A wheel file')), Assign(targets=[Name(id='wheel_file_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^(?P<namever>(?P<name>[^\\s-]+?)-(?P<ver>[^\\s-]*?))\n        ((-(?P<build>\\d[^-]*?))?-(?P<pyver>[^\\s-]+?)-(?P<abi>[^\\s-]+?)-(?P<plat>[^\\s-]+?)\n        \\.whl|\\.dist-info)$'), Attribute(value=Name(id='re', ctx=Load()), attr='VERBOSE', ctx=Load())], keywords=[])), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='filename', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        :raises InvalidWheelFilename: when the filename is invalid for a wheel\n        ')), Assign(targets=[Name(id='wheel_info', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='wheel_file_re', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='wheel_info', ctx=Load())), body=[Raise(exc=Call(func=Name(id='InvalidWheelFilename', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='filename', ctx=Load()), conversion=-1), Constant(value=' is not a valid wheel filename.')])], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='filename', ctx=Store())], value=Name(id='filename', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='wheel_info', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='name')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='_'), Constant(value='-')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='version', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='wheel_info', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='ver')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='_'), Constant(value='-')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='build_tag', ctx=Store())], value=Call(func=Attribute(value=Name(id='wheel_info', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='build')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pyversions', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='wheel_info', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='pyver')], keywords=[]), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='abis', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='wheel_info', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='abi')], keywords=[]), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='plats', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='wheel_info', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value='plat')], keywords=[]), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='file_tags', ctx=Store())], value=SetComp(elt=Call(func=Name(id='Tag', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load()), Name(id='z', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='pyversions', ctx=Load()), ifs=[], is_async=0), comprehension(target=Name(id='y', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='abis', ctx=Load()), ifs=[], is_async=0), comprehension(target=Name(id='z', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='plats', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_formatted_file_tags', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the wheel's tags as a sorted list of strings.")), Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='str', ctx=Load()), args=[Name(id='tag', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='tag', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='file_tags', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='support_index_min', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tags', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Tag', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the lowest index that one of the wheel's file_tag combinations\n        achieves in the given list of supported tags.\n\n        For example, if there are 8 supported tags and one of the file tags\n        is first in the list, then return 0.\n\n        :param tags: the PEP 425 tags to check the wheel against, in order\n            with most preferred first.\n\n        :raises ValueError: If none of the wheel's file tags match one of\n            the supported tags.\n        ")), Try(body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[GeneratorExp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='t', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='tags', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='t', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='file_tags', ctx=Load())])], is_async=0)])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='StopIteration', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='find_most_preferred_tag', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tags', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='Tag', ctx=Load()), ctx=Load())), arg(arg='tag_to_priority', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='Tag', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Return the priority of the most preferred tag that one of the wheel's file\n        tag combinations achieves in the given list of supported tags using the given\n        tag_to_priority mapping, where lower priorities are more-preferred.\n\n        This is used in place of support_index_min in some cases in order to avoid\n        an expensive linear scan of a large list of tags.\n\n        :param tags: the PEP 425 tags to check the wheel against.\n        :param tag_to_priority: a mapping from tag to priority of that tag, where\n            lower is more preferred.\n\n        :raises ValueError: If none of the wheel's file tags match one of\n            the supported tags.\n        ")), Return(value=Call(func=Name(id='min', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='tag_to_priority', ctx=Load()), slice=Name(id='tag', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='tag', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='file_tags', ctx=Load()), ifs=[Compare(left=Name(id='tag', ctx=Load()), ops=[In()], comparators=[Name(id='tag_to_priority', ctx=Load())])], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='int', ctx=Load())), FunctionDef(name='supported', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='tags', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='Tag', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return whether the wheel is compatible with one of the given tags.\n\n        :param tags: the PEP 425 tags to check the wheel against.\n        ')), Return(value=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='file_tags', ctx=Load()), attr='isdisjoint', ctx=Load()), args=[Name(id='tags', ctx=Load())], keywords=[])))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[])], type_ignores=[])