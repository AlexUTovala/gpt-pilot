Module(body=[Import(names=[alias(name='functools')]), Import(names=[alias(name='itertools')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='os')]), Import(names=[alias(name='posixpath')]), Import(names=[alias(name='re')]), Import(names=[alias(name='urllib.parse')]), ImportFrom(module='dataclasses', names=[alias(name='dataclass')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING'), alias(name='Any'), alias(name='Dict'), alias(name='List'), alias(name='Mapping'), alias(name='NamedTuple'), alias(name='Optional'), alias(name='Tuple'), alias(name='Union')], level=0), ImportFrom(module='pip._internal.utils.deprecation', names=[alias(name='deprecated')], level=0), ImportFrom(module='pip._internal.utils.filetypes', names=[alias(name='WHEEL_EXTENSION')], level=0), ImportFrom(module='pip._internal.utils.hashes', names=[alias(name='Hashes')], level=0), ImportFrom(module='pip._internal.utils.misc', names=[alias(name='pairwise'), alias(name='redact_auth_from_url'), alias(name='split_auth_from_netloc'), alias(name='splitext')], level=0), ImportFrom(module='pip._internal.utils.models', names=[alias(name='KeyBasedCompareMixin')], level=0), ImportFrom(module='pip._internal.utils.urls', names=[alias(name='path_to_url'), alias(name='url_to_path')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='pip._internal.index.collector', names=[alias(name='IndexContent')], level=0)], orelse=[]), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='_SUPPORTED_HASHES', ctx=Store())], value=Tuple(elts=[Constant(value='sha512'), Constant(value='sha384'), Constant(value='sha256'), Constant(value='sha224'), Constant(value='sha1'), Constant(value='md5')], ctx=Load())), ClassDef(name='LinkHash', bases=[], keywords=[], body=[Expr(value=Constant(value='Links to content may have embedded hash values. This class parses those.\n\n    `name` must be any member of `_SUPPORTED_HASHES`.\n\n    This class can be converted to and from `ArchiveInfo`. While ArchiveInfo intends to\n    be JSON-serializable to conform to PEP 610, this class contains the logic for\n    parsing a hash name and value for correctness, and then checking whether that hash\n    conforms to a schema with `.is_hash_allowed()`.')), AnnAssign(target=Name(id='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='value', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), Assign(targets=[Name(id='_hash_url_fragment_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='[#&]({choices})=([^&]*)'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='choices', value=Call(func=Attribute(value=Constant(value='|'), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='hash_name', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='hash_name', ctx=Store()), iter=Name(id='_SUPPORTED_HASHES', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))])], keywords=[])), FunctionDef(name='__post_init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assert(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), ops=[In()], comparators=[Name(id='_SUPPORTED_HASHES', ctx=Load())]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='find_hash_url_fragment', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='url', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Search a string for a checksum algorithm name and encoded output value.')), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='cls', ctx=Load()), attr='_hash_url_fragment_re', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='match', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='name', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load()), Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='lru_cache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=None))])], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='LinkHash'), ctx=Load())), FunctionDef(name='as_dict', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Dict(keys=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], values=[Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load())]))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='as_hashes', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a Hashes instance which checks only for the current hash.')), Return(value=Call(func=Name(id='Hashes', ctx=Load()), args=[Dict(keys=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], values=[List(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load())], ctx=Load())])], keywords=[]))], decorator_list=[], returns=Name(id='Hashes', ctx=Load())), FunctionDef(name='is_hash_allowed', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='hashes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Hashes', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return True if the current hash is allowed by `hashes`.\n        ')), If(test=Compare(left=Name(id='hashes', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='hashes', ctx=Load()), attr='is_hash_allowed', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load())], keywords=[keyword(arg='hex_digest', value=Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load()))]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[keyword(arg='frozen', value=Constant(value=True))])]), ClassDef(name='MetadataFile', bases=[], keywords=[], body=[Expr(value=Constant(value='Information about a core metadata file associated with a distribution.')), AnnAssign(target=Name(id='hashes', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), simple=1), FunctionDef(name='__post_init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='hashes', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assert(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Name(id='_SUPPORTED_HASHES', ctx=Load())]), generators=[comprehension(target=Name(id='name', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='hashes', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[keyword(arg='frozen', value=Constant(value=True))])]), FunctionDef(name='supported_hashes', args=arguments(posonlyargs=[], args=[arg(arg='hashes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='hashes', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='hashes', ctx=Store())], value=DictComp(key=Name(id='n', ctx=Load()), value=Name(id='v', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='n', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='hashes', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Compare(left=Name(id='n', ctx=Load()), ops=[In()], comparators=[Name(id='_SUPPORTED_HASHES', ctx=Load())])], is_async=0)])), If(test=UnaryOp(op=Not(), operand=Name(id='hashes', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Return(value=Name(id='hashes', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), FunctionDef(name='_clean_url_path_part', args=arguments(posonlyargs=[], args=[arg(arg='part', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Clean a "part" of a URL path (i.e. after splitting on "@" characters).\n    ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='quote', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='unquote', ctx=Load()), args=[Name(id='part', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_clean_file_url_path', args=arguments(posonlyargs=[], args=[arg(arg='part', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Clean the first part of a URL path that corresponds to a local\n    filesystem path (i.e. the first part after splitting on "@" characters).\n    ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='request', ctx=Load()), attr='pathname2url', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='request', ctx=Load()), attr='url2pathname', ctx=Load()), args=[Name(id='part', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), Assign(targets=[Name(id='_reserved_chars_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='(@|%2F)'), Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load())], keywords=[])), FunctionDef(name='_clean_url_path', args=arguments(posonlyargs=[], args=[arg(arg='path', annotation=Name(id='str', ctx=Load())), arg(arg='is_local_path', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Clean the path portion of a URL.\n    ')), If(test=Name(id='is_local_path', ctx=Load()), body=[Assign(targets=[Name(id='clean_func', ctx=Store())], value=Name(id='_clean_file_url_path', ctx=Load()))], orelse=[Assign(targets=[Name(id='clean_func', ctx=Store())], value=Name(id='_clean_url_path_part', ctx=Load()))]), Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='_reserved_chars_re', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cleaned_parts', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='to_clean', ctx=Store()), Name(id='reserved', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='pairwise', ctx=Load()), args=[Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='chain', ctx=Load()), args=[Name(id='parts', ctx=Load()), List(elts=[Constant(value='')], ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='cleaned_parts', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='clean_func', ctx=Load()), args=[Name(id='to_clean', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cleaned_parts', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reserved', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='cleaned_parts', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='_ensure_quoted_url', args=arguments(posonlyargs=[], args=[arg(arg='url', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Make sure a link is fully quoted.\n    For example, if \' \' occurs in the URL, it will be replaced with "%20",\n    and without double-quoting other characters.\n    ')), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='urlparse', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='is_local_path', ctx=Store())], value=UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='netloc', ctx=Load()))), Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Name(id='_clean_url_path', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='path', ctx=Load())], keywords=[keyword(arg='is_local_path', value=Name(id='is_local_path', ctx=Load()))])), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='urlunparse', ctx=Load()), args=[Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='_replace', ctx=Load()), args=[], keywords=[keyword(arg='path', value=Name(id='path', ctx=Load()))])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load())), ClassDef(name='Link', bases=[Name(id='KeyBasedCompareMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Represents a parsed link from a Package Index's simple URL")), Assign(targets=[Name(id='__slots__', ctx=Store())], value=List(elts=[Constant(value='_parsed_url'), Constant(value='_url'), Constant(value='_hashes'), Constant(value='comes_from'), Constant(value='requires_python'), Constant(value='yanked_reason'), Constant(value='metadata_file_data'), Constant(value='cache_link_parsing'), Constant(value='egg_fragment')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='url', annotation=Name(id='str', ctx=Load())), arg(arg='comes_from', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Constant(value='IndexContent')], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='requires_python', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='yanked_reason', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='metadata_file_data', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='MetadataFile', ctx=Load()), ctx=Load())), arg(arg='cache_link_parsing', annotation=Name(id='bool', ctx=Load())), arg(arg='hashes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=None)]), body=[Expr(value=Constant(value='\n        :param url: url of the resource pointed to (href of the link)\n        :param comes_from: instance of IndexContent where the link was found,\n            or string.\n        :param requires_python: String containing the `Requires-Python`\n            metadata field, specified in PEP 345. This may be specified by\n            a data-requires-python attribute in the HTML link tag, as\n            described in PEP 503.\n        :param yanked_reason: the reason the file has been yanked, if the\n            file has been yanked, or None if the file hasn\'t been yanked.\n            This is the value of the "data-yanked" attribute, if present, in\n            a simple repository HTML link. If the file has been yanked but\n            no reason was provided, this should be the empty string. See\n            PEP 592 for more information and the specification.\n        :param metadata_file_data: the metadata attached to the file, or None if\n            no such metadata is provided. This argument, if not None, indicates\n            that a separate metadata file exists, and also optionally supplies\n            hashes for that file.\n        :param cache_link_parsing: A flag that is used elsewhere to determine\n            whether resources retrieved from this link should be cached. PyPI\n            URLs should generally have this set to False, for example.\n        :param hashes: A mapping of hash names to digests to allow us to\n            determine the validity of a download.\n        ')), If(test=Call(func=Attribute(value=Name(id='url', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='\\\\')], keywords=[]), body=[Assign(targets=[Name(id='url', ctx=Store())], value=Call(func=Name(id='path_to_url', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_url', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='urlsplit', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_url', ctx=Store())], value=Name(id='url', ctx=Load())), Assign(targets=[Name(id='link_hash', ctx=Store())], value=Call(func=Attribute(value=Name(id='LinkHash', ctx=Load()), attr='find_hash_url_fragment', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='hashes_from_link', ctx=Store())], value=IfExp(test=Compare(left=Name(id='link_hash', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Dict(keys=[], values=[]), orelse=Call(func=Attribute(value=Name(id='link_hash', ctx=Load()), attr='as_dict', ctx=Load()), args=[], keywords=[]))), If(test=Compare(left=Name(id='hashes', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_hashes', ctx=Store())], value=Name(id='hashes_from_link', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_hashes', ctx=Store())], value=Dict(keys=[None, None], values=[Name(id='hashes', ctx=Load()), Name(id='hashes_from_link', ctx=Load())]))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='comes_from', ctx=Store())], value=Name(id='comes_from', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='requires_python', ctx=Store())], value=IfExp(test=Name(id='requires_python', ctx=Load()), body=Name(id='requires_python', ctx=Load()), orelse=Constant(value=None))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='yanked_reason', ctx=Store())], value=Name(id='yanked_reason', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='metadata_file_data', ctx=Store())], value=Name(id='metadata_file_data', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Name(id='url', ctx=Load())), keyword(arg='defining_class', value=Name(id='Link', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='cache_link_parsing', ctx=Store())], value=Name(id='cache_link_parsing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='egg_fragment', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_egg_fragment', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='from_json', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='file_data', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='page_url', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Convert an pypi json document from a simple repository page into a Link.\n        ')), Assign(targets=[Name(id='file_url', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='url')], keywords=[])), If(test=Compare(left=Name(id='file_url', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='url', ctx=Store())], value=Call(func=Name(id='_ensure_quoted_url', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='urljoin', ctx=Load()), args=[Name(id='page_url', ctx=Load()), Name(id='file_url', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='pyrequire', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='requires-python')], keywords=[])), Assign(targets=[Name(id='yanked_reason', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='yanked')], keywords=[])), Assign(targets=[Name(id='hashes', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='hashes'), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Name(id='metadata_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='core-metadata')], keywords=[])), If(test=Compare(left=Name(id='metadata_info', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='metadata_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='dist-info-metadata')], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='metadata_info', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='metadata_file_data', ctx=Store())], value=Call(func=Name(id='MetadataFile', ctx=Load()), args=[Call(func=Name(id='supported_hashes', ctx=Load()), args=[Name(id='metadata_info', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=Name(id='metadata_info', ctx=Load()), body=[Assign(targets=[Name(id='metadata_file_data', ctx=Store())], value=Call(func=Name(id='MetadataFile', ctx=Load()), args=[Constant(value=None)], keywords=[]))], orelse=[Assign(targets=[Name(id='metadata_file_data', ctx=Store())], value=Constant(value=None))])]), If(test=BoolOp(op=And(), values=[Name(id='yanked_reason', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='yanked_reason', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]))]), body=[Assign(targets=[Name(id='yanked_reason', ctx=Store())], value=Constant(value=''))], orelse=[If(test=UnaryOp(op=Not(), operand=Name(id='yanked_reason', ctx=Load())), body=[Assign(targets=[Name(id='yanked_reason', ctx=Store())], value=Constant(value=None))], orelse=[])]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='comes_from', value=Name(id='page_url', ctx=Load())), keyword(arg='requires_python', value=Name(id='pyrequire', ctx=Load())), keyword(arg='yanked_reason', value=Name(id='yanked_reason', ctx=Load())), keyword(arg='hashes', value=Name(id='hashes', ctx=Load())), keyword(arg='metadata_file_data', value=Name(id='metadata_file_data', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='Link'), ctx=Load())), FunctionDef(name='from_element', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='anchor_attribs', annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='page_url', annotation=Name(id='str', ctx=Load())), arg(arg='base_url', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Convert an anchor element's attributes in a simple repository page to a Link.\n        ")), Assign(targets=[Name(id='href', ctx=Store())], value=Call(func=Attribute(value=Name(id='anchor_attribs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='href')], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='href', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='url', ctx=Store())], value=Call(func=Name(id='_ensure_quoted_url', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='urljoin', ctx=Load()), args=[Name(id='base_url', ctx=Load()), Name(id='href', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='pyrequire', ctx=Store())], value=Call(func=Attribute(value=Name(id='anchor_attribs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='data-requires-python')], keywords=[])), Assign(targets=[Name(id='yanked_reason', ctx=Store())], value=Call(func=Attribute(value=Name(id='anchor_attribs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='data-yanked')], keywords=[])), Assign(targets=[Name(id='metadata_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='anchor_attribs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='data-core-metadata')], keywords=[])), If(test=Compare(left=Name(id='metadata_info', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='metadata_info', ctx=Store())], value=Call(func=Attribute(value=Name(id='anchor_attribs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='data-dist-info-metadata')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='metadata_info', ctx=Load()), ops=[Eq()], comparators=[Constant(value='true')]), body=[Assign(targets=[Name(id='metadata_file_data', ctx=Store())], value=Call(func=Name(id='MetadataFile', ctx=Load()), args=[Constant(value=None)], keywords=[]))], orelse=[If(test=Compare(left=Name(id='metadata_info', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='metadata_file_data', ctx=Store())], value=Constant(value=None))], orelse=[Assign(targets=[Tuple(elts=[Name(id='hashname', ctx=Store()), Name(id='sep', ctx=Store()), Name(id='hashval', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata_info', ctx=Load()), attr='partition', ctx=Load()), args=[Constant(value='=')], keywords=[])), If(test=Compare(left=Name(id='sep', ctx=Load()), ops=[Eq()], comparators=[Constant(value='=')]), body=[Assign(targets=[Name(id='metadata_file_data', ctx=Store())], value=Call(func=Name(id='MetadataFile', ctx=Load()), args=[Call(func=Name(id='supported_hashes', ctx=Load()), args=[Dict(keys=[Name(id='hashname', ctx=Load())], values=[Name(id='hashval', ctx=Load())])], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Index returned invalid data-dist-info-metadata value: %s'), Name(id='metadata_info', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata_file_data', ctx=Store())], value=Call(func=Name(id='MetadataFile', ctx=Load()), args=[Constant(value=None)], keywords=[]))])])]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='comes_from', value=Name(id='page_url', ctx=Load())), keyword(arg='requires_python', value=Name(id='pyrequire', ctx=Load())), keyword(arg='yanked_reason', value=Name(id='yanked_reason', ctx=Load())), keyword(arg='metadata_file_data', value=Name(id='metadata_file_data', ctx=Load()))]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='Link'), ctx=Load())), FunctionDef(name='__str__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='requires_python', ctx=Load()), body=[Assign(targets=[Name(id='rp', ctx=Store())], value=JoinedStr(values=[Constant(value=' (requires-python:'), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='requires_python', ctx=Load()), conversion=-1), Constant(value=')')]))], orelse=[Assign(targets=[Name(id='rp', ctx=Store())], value=Constant(value=''))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='comes_from', ctx=Load()), body=[Return(value=Call(func=Attribute(value=Constant(value='{} (from {}){}'), attr='format', ctx=Load()), args=[Call(func=Name(id='redact_auth_from_url', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_url', ctx=Load())], keywords=[]), Attribute(value=Name(id='self', ctx=Load()), attr='comes_from', ctx=Load()), Name(id='rp', ctx=Load())], keywords=[]))], orelse=[Return(value=Call(func=Name(id='redact_auth_from_url', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_url', ctx=Load())], keywords=[])], keywords=[]))])], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<Link '), FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value='>')]))], decorator_list=[], returns=Name(id='str', ctx=Load())), FunctionDef(name='url', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_url', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='filename', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='/')], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='name', ctx=Load())), body=[Assign(targets=[Tuple(elts=[Name(id='netloc', ctx=Store()), Name(id='user_pass', ctx=Store())], ctx=Store())], value=Call(func=Name(id='split_auth_from_netloc', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='netloc', ctx=Load())], keywords=[])), Return(value=Name(id='netloc', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='unquote', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Assert(test=Name(id='name', ctx=Load()), msg=JoinedStr(values=[Constant(value='URL '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='_url', ctx=Load()), conversion=114), Constant(value=' produced no filename')])), Return(value=Name(id='name', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='file_path', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='url_to_path', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='url', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='scheme', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_url', ctx=Load()), attr='scheme', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='netloc', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        This can contain auth information.\n        ')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_url', ctx=Load()), attr='netloc', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='path', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='unquote', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_url', ctx=Load()), attr='path', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='splitext', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='splitext', ctx=Load()), args=[Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='basename', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='path', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='/')], keywords=[])], keywords=[])], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='ext', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='splitext', ctx=Load()), args=[], keywords=[]), slice=Constant(value=1), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='url_without_fragment', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Tuple(elts=[Name(id='scheme', ctx=Store()), Name(id='netloc', ctx=Store()), Name(id='path', ctx=Store()), Name(id='query', ctx=Store()), Name(id='fragment', ctx=Store())], ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_parsed_url', ctx=Load())), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='urlunsplit', ctx=Load()), args=[Tuple(elts=[Name(id='scheme', ctx=Load()), Name(id='netloc', ctx=Load()), Name(id='path', ctx=Load()), Name(id='query', ctx=Load()), Constant(value='')], ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), Assign(targets=[Name(id='_egg_fragment_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='[#&]egg=([^&]*)')], keywords=[])), Assign(targets=[Name(id='_project_name_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$'), Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load())], keywords=[])), FunctionDef(name='_egg_fragment', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_egg_fragment_re', ctx=Load()), attr='search', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_url', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='match', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='project_name', ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_project_name_re', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='project_name', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Name(id='deprecated', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=JoinedStr(values=[FormattedValue(value=Name(id='self', ctx=Load()), conversion=-1), Constant(value=' contains an egg fragment with a non-PEP 508 name')])), keyword(arg='replacement', value=Constant(value='to use the req @ url syntax, and remove the egg fragment')), keyword(arg='gone_in', value=Constant(value='25.0')), keyword(arg='issue', value=Constant(value=11617))]))], orelse=[]), Return(value=Name(id='project_name', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='_subdirectory_fragment_re', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='[#&]subdirectory=([^&]*)')], keywords=[])), FunctionDef(name='subdirectory_fragment', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_subdirectory_fragment_re', ctx=Load()), attr='search', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_url', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='match', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='metadata_link', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return a link to the associated core metadata file (if any).')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='metadata_file_data', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='metadata_url', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='url_without_fragment', ctx=Load()), conversion=-1), Constant(value='.metadata')])), If(test=Compare(left=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata_file_data', ctx=Load()), attr='hashes', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='Link', ctx=Load()), args=[Name(id='metadata_url', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='Link', ctx=Load()), args=[Name(id='metadata_url', ctx=Load())], keywords=[keyword(arg='hashes', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='metadata_file_data', ctx=Load()), attr='hashes', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Constant(value='Link'), ctx=Load())), FunctionDef(name='as_hashes', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='Hashes', ctx=Load()), args=[DictComp(key=Name(id='k', ctx=Load()), value=List(elts=[Name(id='v', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hashes', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='Hashes', ctx=Load())), FunctionDef(name='hash', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hashes', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]), Constant(value=None)], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='hash_name', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_hashes', ctx=Load())], keywords=[]), Constant(value=None)], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='show_url', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='posixpath', ctx=Load()), attr='basename', ctx=Load()), args=[Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_url', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='#'), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='?'), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='is_file', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='scheme', ctx=Load()), ops=[Eq()], comparators=[Constant(value='file')]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='is_existing_dir', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BoolOp(op=And(), values=[Attribute(value=Name(id='self', ctx=Load()), attr='is_file', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='file_path', ctx=Load())], keywords=[])]))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='is_wheel', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ext', ctx=Load()), ops=[Eq()], comparators=[Name(id='WHEEL_EXTENSION', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='is_vcs', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='pip._internal.vcs', names=[alias(name='vcs')], level=0), Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='scheme', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='vcs', ctx=Load()), attr='all_schemes', ctx=Load())]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='is_yanked', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='yanked_reason', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='has_hash', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='bool', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_hashes', ctx=Load())], keywords=[]))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='is_hash_allowed', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='hashes', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Hashes', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Return True if the link has a hash and it is allowed by `hashes`.\n        ')), If(test=Compare(left=Name(id='hashes', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=False))], orelse=[]), Return(value=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='hashes', ctx=Load()), attr='is_hash_allowed', ctx=Load()), args=[Name(id='k', ctx=Load()), Name(id='v', ctx=Load())], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_hashes', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='_CleanResult', bases=[Name(id='NamedTuple', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Convert link for equivalency check.\n\n    This is used in the resolver to check whether two URL-specified requirements\n    likely point to the same distribution and can be considered equivalent. This\n    equivalency logic avoids comparing URLs literally, which can be too strict\n    (e.g. "a=1&b=2" vs "b=2&a=1") and produce conflicts unexpecting to users.\n\n    Currently this does three things:\n\n    1. Drop the basic auth part. This is technically wrong since a server can\n       serve different content based on auth, but if it does that, it is even\n       impossible to guarantee two URLs without auth are equivalent, since\n       the user can input different auth information when prompted. So the\n       practical solution is to assume the auth doesn\'t affect the response.\n    2. Parse the query to avoid the ordering issue. Note that ordering under the\n       same key in the query are NOT cleaned; i.e. "a=1&a=2" and "a=2&a=1" are\n       still considered different.\n    3. Explicitly drop most of the fragment part, except ``subdirectory=`` and\n       hash values, since it should have no impact the downloaded content. Note\n       that this drops the "egg=" part historically used to denote the requested\n       project (and extras), which is wrong in the strictest sense, but too many\n       people are supplying it inconsistently to cause superfluous resolution\n       conflicts, so we choose to also ignore them.\n    ')), AnnAssign(target=Name(id='parsed', ctx=Store()), annotation=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='SplitResult', ctx=Load()), simple=1), AnnAssign(target=Name(id='query', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), simple=1), AnnAssign(target=Name(id='subdirectory', ctx=Store()), annotation=Name(id='str', ctx=Load()), simple=1), AnnAssign(target=Name(id='hashes', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), simple=1)], decorator_list=[]), FunctionDef(name='_clean_link', args=arguments(posonlyargs=[], args=[arg(arg='link', annotation=Name(id='Link', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='parsed', ctx=Store())], value=Attribute(value=Name(id='link', ctx=Load()), attr='_parsed_url', ctx=Load())), Assign(targets=[Name(id='netloc', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='parsed', ctx=Load()), attr='netloc', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='@'), Constant(value=1)], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='parsed', ctx=Load()), attr='scheme', ctx=Load()), ops=[Eq()], comparators=[Constant(value='file')]), UnaryOp(op=Not(), operand=Name(id='netloc', ctx=Load()))]), body=[Assign(targets=[Name(id='netloc', ctx=Store())], value=Constant(value='localhost'))], orelse=[]), Assign(targets=[Name(id='fragment', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='parse_qs', ctx=Load()), args=[Attribute(value=Name(id='parsed', ctx=Load()), attr='fragment', ctx=Load())], keywords=[])), If(test=Compare(left=Constant(value='egg'), ops=[In()], comparators=[Name(id='fragment', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Constant(value='Ignoring egg= fragment in %s'), Name(id='link', ctx=Load())], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Name(id='subdirectory', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='fragment', ctx=Load()), slice=Constant(value='subdirectory'), ctx=Load()), slice=Constant(value=0), ctx=Load()))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='IndexError', ctx=Load()), Name(id='KeyError', ctx=Load())], ctx=Load()), body=[Assign(targets=[Name(id='subdirectory', ctx=Store())], value=Constant(value=''))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='hashes', ctx=Store())], value=DictComp(key=Name(id='k', ctx=Load()), value=Subscript(value=Subscript(value=Name(id='fragment', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Load()), slice=Constant(value=0), ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Name(id='_SUPPORTED_HASHES', ctx=Load()), ifs=[Compare(left=Name(id='k', ctx=Load()), ops=[In()], comparators=[Name(id='fragment', ctx=Load())])], is_async=0)])), Return(value=Call(func=Name(id='_CleanResult', ctx=Load()), args=[], keywords=[keyword(arg='parsed', value=Call(func=Attribute(value=Name(id='parsed', ctx=Load()), attr='_replace', ctx=Load()), args=[], keywords=[keyword(arg='netloc', value=Name(id='netloc', ctx=Load())), keyword(arg='query', value=Constant(value='')), keyword(arg='fragment', value=Constant(value=''))])), keyword(arg='query', value=Call(func=Attribute(value=Attribute(value=Name(id='urllib', ctx=Load()), attr='parse', ctx=Load()), attr='parse_qs', ctx=Load()), args=[Attribute(value=Name(id='parsed', ctx=Load()), attr='query', ctx=Load())], keywords=[])), keyword(arg='subdirectory', value=Name(id='subdirectory', ctx=Load())), keyword(arg='hashes', value=Name(id='hashes', ctx=Load()))]))], decorator_list=[], returns=Name(id='_CleanResult', ctx=Load())), FunctionDef(name='links_equivalent', args=arguments(posonlyargs=[], args=[arg(arg='link1', annotation=Name(id='Link', ctx=Load())), arg(arg='link2', annotation=Name(id='Link', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Compare(left=Call(func=Name(id='_clean_link', ctx=Load()), args=[Name(id='link1', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='_clean_link', ctx=Load()), args=[Name(id='link2', ctx=Load())], keywords=[])]))], decorator_list=[Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='lru_cache', ctx=Load()), args=[], keywords=[keyword(arg='maxsize', value=Constant(value=None))])], returns=Name(id='bool', ctx=Load()))], type_ignores=[])