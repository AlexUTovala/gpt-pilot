Module(body=[Expr(value=Constant(value='\nThese are keyword-only APIs that call `attr.s` and `attr.ib` with different\ndefault values.\n')), ImportFrom(module='functools', names=[alias(name='partial')], level=0), ImportFrom(names=[alias(name='setters')], level=1), ImportFrom(module='_funcs', names=[alias(name='asdict', asname='_asdict')], level=1), ImportFrom(module='_funcs', names=[alias(name='astuple', asname='_astuple')], level=1), ImportFrom(module='_make', names=[alias(name='NOTHING'), alias(name='_frozen_setattrs'), alias(name='_ng_default_on_setattr'), alias(name='attrib'), alias(name='attrs')], level=1), ImportFrom(module='exceptions', names=[alias(name='UnannotatedAttributeError')], level=1), FunctionDef(name='define', args=arguments(posonlyargs=[], args=[arg(arg='maybe_cls')], kwonlyargs=[arg(arg='these'), arg(arg='repr'), arg(arg='unsafe_hash'), arg(arg='hash'), arg(arg='init'), arg(arg='slots'), arg(arg='frozen'), arg(arg='weakref_slot'), arg(arg='str'), arg(arg='auto_attribs'), arg(arg='kw_only'), arg(arg='cache_hash'), arg(arg='auto_exc'), arg(arg='eq'), arg(arg='order'), arg(arg='auto_detect'), arg(arg='getstate_setstate'), arg(arg='on_setattr'), arg(arg='field_transformer'), arg(arg='match_args')], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=False), Constant(value=True), Constant(value=False), Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=True), Constant(value=None), Constant(value=False), Constant(value=True), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True)], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Define an *attrs* class.\n\n    Differences to the classic `attr.s` that it uses underneath:\n\n    - Automatically detect whether or not *auto_attribs* should be `True` (c.f.\n      *auto_attribs* parameter).\n    - If *frozen* is `False`, run converters and validators when setting an\n      attribute by default.\n    - *slots=True*\n\n      .. caution::\n\n         Usually this has only upsides and few visible effects in everyday\n         programming. But it *can* lead to some suprising behaviors, so please\n         make sure to read :term:`slotted classes`.\n    - *auto_exc=True*\n    - *auto_detect=True*\n    - *order=False*\n    - Some options that were only relevant on Python 2 or were kept around for\n      backwards-compatibility have been removed.\n\n    Please note that these are all defaults and you can change them as you\n    wish.\n\n    :param Optional[bool] auto_attribs: If set to `True` or `False`, it behaves\n       exactly like `attr.s`. If left `None`, `attr.s` will try to guess:\n\n       1. If any attributes are annotated and no unannotated `attrs.fields`\\ s\n          are found, it assumes *auto_attribs=True*.\n       2. Otherwise it assumes *auto_attribs=False* and tries to collect\n          `attrs.fields`\\ s.\n\n    For now, please refer to `attr.s` for the rest of the parameters.\n\n    .. versionadded:: 20.1.0\n    .. versionchanged:: 21.3.0 Converters are also run ``on_setattr``.\n    .. versionadded:: 22.2.0\n       *unsafe_hash* as an alias for *hash* (for :pep:`681` compliance).\n    ')), FunctionDef(name='do_it', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='auto_attribs')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='maybe_cls', value=Name(id='cls', ctx=Load())), keyword(arg='these', value=Name(id='these', ctx=Load())), keyword(arg='repr', value=Name(id='repr', ctx=Load())), keyword(arg='hash', value=Name(id='hash', ctx=Load())), keyword(arg='unsafe_hash', value=Name(id='unsafe_hash', ctx=Load())), keyword(arg='init', value=Name(id='init', ctx=Load())), keyword(arg='slots', value=Name(id='slots', ctx=Load())), keyword(arg='frozen', value=Name(id='frozen', ctx=Load())), keyword(arg='weakref_slot', value=Name(id='weakref_slot', ctx=Load())), keyword(arg='str', value=Name(id='str', ctx=Load())), keyword(arg='auto_attribs', value=Name(id='auto_attribs', ctx=Load())), keyword(arg='kw_only', value=Name(id='kw_only', ctx=Load())), keyword(arg='cache_hash', value=Name(id='cache_hash', ctx=Load())), keyword(arg='auto_exc', value=Name(id='auto_exc', ctx=Load())), keyword(arg='eq', value=Name(id='eq', ctx=Load())), keyword(arg='order', value=Name(id='order', ctx=Load())), keyword(arg='auto_detect', value=Name(id='auto_detect', ctx=Load())), keyword(arg='collect_by_mro', value=Constant(value=True)), keyword(arg='getstate_setstate', value=Name(id='getstate_setstate', ctx=Load())), keyword(arg='on_setattr', value=Name(id='on_setattr', ctx=Load())), keyword(arg='field_transformer', value=Name(id='field_transformer', ctx=Load())), keyword(arg='match_args', value=Name(id='match_args', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='wrap', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Making this a wrapper ensures this code runs during class creation.\n\n        We also ensure that frozen-ness of classes is inherited.\n        ')), Nonlocal(names=['frozen', 'on_setattr']), Assign(targets=[Name(id='had_on_setattr', ctx=Store())], value=Compare(left=Name(id='on_setattr', ctx=Load()), ops=[NotIn()], comparators=[Tuple(elts=[Constant(value=None), Attribute(value=Name(id='setters', ctx=Load()), attr='NO_OP', ctx=Load())], ctx=Load())])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='frozen', ctx=Load()), ops=[Is()], comparators=[Constant(value=False)]), Compare(left=Name(id='on_setattr', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Name(id='on_setattr', ctx=Store())], value=Name(id='_ng_default_on_setattr', ctx=Load()))], orelse=[]), For(target=Name(id='base_cls', ctx=Store()), iter=Attribute(value=Name(id='cls', ctx=Load()), attr='__bases__', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='base_cls', ctx=Load()), attr='__setattr__', ctx=Load()), ops=[Is()], comparators=[Name(id='_frozen_setattrs', ctx=Load())]), body=[If(test=Name(id='had_on_setattr', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Frozen classes can't use on_setattr (frozen-ness was inherited).")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='on_setattr', ctx=Store())], value=Attribute(value=Name(id='setters', ctx=Load()), attr='NO_OP', ctx=Load())), Break()], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='auto_attribs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Name(id='do_it', ctx=Load()), args=[Name(id='cls', ctx=Load()), Name(id='auto_attribs', ctx=Load())], keywords=[]))], orelse=[]), Try(body=[Return(value=Call(func=Name(id='do_it', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value=True)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='UnannotatedAttributeError', ctx=Load()), body=[Return(value=Call(func=Name(id='do_it', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value=False)], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), If(test=Compare(left=Name(id='maybe_cls', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='wrap', ctx=Load()))], orelse=[Return(value=Call(func=Name(id='wrap', ctx=Load()), args=[Name(id='maybe_cls', ctx=Load())], keywords=[]))])], decorator_list=[]), Assign(targets=[Name(id='mutable', ctx=Store())], value=Name(id='define', ctx=Load())), Assign(targets=[Name(id='frozen', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='define', ctx=Load())], keywords=[keyword(arg='frozen', value=Constant(value=True)), keyword(arg='on_setattr', value=Constant(value=None))])), FunctionDef(name='field', args=arguments(posonlyargs=[], args=[], kwonlyargs=[arg(arg='default'), arg(arg='validator'), arg(arg='repr'), arg(arg='hash'), arg(arg='init'), arg(arg='metadata'), arg(arg='type'), arg(arg='converter'), arg(arg='factory'), arg(arg='kw_only'), arg(arg='eq'), arg(arg='order'), arg(arg='on_setattr'), arg(arg='alias')], kw_defaults=[Name(id='NOTHING', ctx=Load()), Constant(value=None), Constant(value=True), Constant(value=None), Constant(value=True), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value='\n    Identical to `attr.ib`, except keyword-only and with some arguments\n    removed.\n\n    .. versionadded:: 23.1.0\n       The *type* parameter has been re-added; mostly for\n       {func}`attrs.make_class`. Please note that type checkers ignore this\n       metadata.\n    .. versionadded:: 20.1.0\n    ')), Return(value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[keyword(arg='default', value=Name(id='default', ctx=Load())), keyword(arg='validator', value=Name(id='validator', ctx=Load())), keyword(arg='repr', value=Name(id='repr', ctx=Load())), keyword(arg='hash', value=Name(id='hash', ctx=Load())), keyword(arg='init', value=Name(id='init', ctx=Load())), keyword(arg='metadata', value=Name(id='metadata', ctx=Load())), keyword(arg='type', value=Name(id='type', ctx=Load())), keyword(arg='converter', value=Name(id='converter', ctx=Load())), keyword(arg='factory', value=Name(id='factory', ctx=Load())), keyword(arg='kw_only', value=Name(id='kw_only', ctx=Load())), keyword(arg='eq', value=Name(id='eq', ctx=Load())), keyword(arg='order', value=Name(id='order', ctx=Load())), keyword(arg='on_setattr', value=Name(id='on_setattr', ctx=Load())), keyword(arg='alias', value=Name(id='alias', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='asdict', args=arguments(posonlyargs=[], args=[arg(arg='inst')], kwonlyargs=[arg(arg='recurse'), arg(arg='filter'), arg(arg='value_serializer')], kw_defaults=[Constant(value=True), Constant(value=None), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value='\n    Same as `attr.asdict`, except that collections types are always retained\n    and dict is always used as *dict_factory*.\n\n    .. versionadded:: 21.3.0\n    ')), Return(value=Call(func=Name(id='_asdict', ctx=Load()), args=[], keywords=[keyword(arg='inst', value=Name(id='inst', ctx=Load())), keyword(arg='recurse', value=Name(id='recurse', ctx=Load())), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='value_serializer', value=Name(id='value_serializer', ctx=Load())), keyword(arg='retain_collection_types', value=Constant(value=True))]))], decorator_list=[]), FunctionDef(name='astuple', args=arguments(posonlyargs=[], args=[arg(arg='inst')], kwonlyargs=[arg(arg='recurse'), arg(arg='filter')], kw_defaults=[Constant(value=True), Constant(value=None)], defaults=[]), body=[Expr(value=Constant(value='\n    Same as `attr.astuple`, except that collections types are always retained\n    and `tuple` is always used as the *tuple_factory*.\n\n    .. versionadded:: 21.3.0\n    ')), Return(value=Call(func=Name(id='_astuple', ctx=Load()), args=[], keywords=[keyword(arg='inst', value=Name(id='inst', ctx=Load())), keyword(arg='recurse', value=Name(id='recurse', ctx=Load())), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='retain_collection_types', value=Constant(value=True))]))], decorator_list=[])], type_ignores=[])