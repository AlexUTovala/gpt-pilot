Module(body=[Expr(value=Constant(value='\nCommonly useful validators.\n')), Import(names=[alias(name='operator')]), Import(names=[alias(name='re')]), ImportFrom(module='contextlib', names=[alias(name='contextmanager')], level=0), ImportFrom(module='re', names=[alias(name='Pattern')], level=0), ImportFrom(module='_config', names=[alias(name='get_run_validators'), alias(name='set_run_validators')], level=1), ImportFrom(module='_make', names=[alias(name='_AndValidator'), alias(name='and_'), alias(name='attrib'), alias(name='attrs')], level=1), ImportFrom(module='converters', names=[alias(name='default_if_none')], level=1), ImportFrom(module='exceptions', names=[alias(name='NotCallableError')], level=1), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='and_'), Constant(value='deep_iterable'), Constant(value='deep_mapping'), Constant(value='disabled'), Constant(value='ge'), Constant(value='get_disabled'), Constant(value='gt'), Constant(value='in_'), Constant(value='instance_of'), Constant(value='is_callable'), Constant(value='le'), Constant(value='lt'), Constant(value='matches_re'), Constant(value='max_len'), Constant(value='min_len'), Constant(value='not_'), Constant(value='optional'), Constant(value='provides'), Constant(value='set_disabled')], ctx=Load())), FunctionDef(name='set_disabled', args=arguments(posonlyargs=[], args=[arg(arg='disabled')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Globally disable or enable running validators.\n\n    By default, they are run.\n\n    :param disabled: If ``True``, disable running all validators.\n    :type disabled: bool\n\n    .. warning::\n\n        This function is not thread-safe!\n\n    .. versionadded:: 21.3.0\n    ')), Expr(value=Call(func=Name(id='set_run_validators', ctx=Load()), args=[UnaryOp(op=Not(), operand=Name(id='disabled', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='get_disabled', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return a bool indicating whether validators are currently disabled or not.\n\n    :return: ``True`` if validators are currently disabled.\n    :rtype: bool\n\n    .. versionadded:: 21.3.0\n    ')), Return(value=UnaryOp(op=Not(), operand=Call(func=Name(id='get_run_validators', ctx=Load()), args=[], keywords=[])))], decorator_list=[]), FunctionDef(name='disabled', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Context manager that disables running validators within its context.\n\n    .. warning::\n\n        This context manager is not thread-safe!\n\n    .. versionadded:: 21.3.0\n    ')), Expr(value=Call(func=Name(id='set_run_validators', ctx=Load()), args=[Constant(value=False)], keywords=[])), Try(body=[Expr(value=Yield())], handlers=[], orelse=[], finalbody=[Expr(value=Call(func=Name(id='set_run_validators', ctx=Load()), args=[Constant(value=True)], keywords=[]))])], decorator_list=[Name(id='contextmanager', ctx=Load())]), ClassDef(name='_InstanceOfValidator', bases=[], keywords=[], body=[Assign(targets=[Name(id='type', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        We use a callable class to be able to change the ``__repr__``.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="'{name}' must be {type!r} (got {value!r} that is a {actual!r})."), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='attr', ctx=Load()), attr='name', ctx=Load())), keyword(arg='type', value=Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Load())), keyword(arg='actual', value=Attribute(value=Name(id='value', ctx=Load()), attr='__class__', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load()))]), Name(id='attr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<instance_of validator for type {type!r}>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='type', value=Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='slots', value=Constant(value=True)), keyword(arg='hash', value=Constant(value=True))])]), FunctionDef(name='instance_of', args=arguments(posonlyargs=[], args=[arg(arg='type')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    A validator that raises a `TypeError` if the initializer is called\n    with a wrong type for this particular attribute (checks are performed using\n    `isinstance` therefore it's also valid to pass a tuple of types).\n\n    :param type: The type to check for.\n    :type type: type or tuple of type\n\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attrs.Attribute`), the expected type, and the value it\n        got.\n    ")), Return(value=Call(func=Name(id='_InstanceOfValidator', ctx=Load()), args=[Name(id='type', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_MatchesReValidator', bases=[], keywords=[], body=[Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='match_func', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        We use a callable class to be able to change the ``__repr__``.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='match_func', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="'{name}' must match regex {pattern!r} ({value!r} doesn't)"), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='attr', ctx=Load()), attr='name', ctx=Load())), keyword(arg='pattern', value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()), attr='pattern', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load()))]), Name(id='attr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<matches_re validator for pattern {pattern!r}>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='pattern', value=Attribute(value=Name(id='self', ctx=Load()), attr='pattern', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='frozen', value=Constant(value=True)), keyword(arg='slots', value=Constant(value=True))])]), FunctionDef(name='matches_re', args=arguments(posonlyargs=[], args=[arg(arg='regex'), arg(arg='flags'), arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value="\n    A validator that raises `ValueError` if the initializer is called\n    with a string that doesn't match *regex*.\n\n    :param regex: a regex string or precompiled pattern to match against\n    :param int flags: flags that will be passed to the underlying re function\n        (default 0)\n    :param callable func: which underlying `re` function to call. Valid options\n        are `re.fullmatch`, `re.search`, and `re.match`; the default ``None``\n        means `re.fullmatch`. For performance reasons, the pattern is always\n        precompiled using `re.compile`.\n\n    .. versionadded:: 19.2.0\n    .. versionchanged:: 21.3.0 *regex* can be a pre-compiled pattern.\n    ")), Assign(targets=[Name(id='valid_funcs', ctx=Store())], value=Tuple(elts=[Attribute(value=Name(id='re', ctx=Load()), attr='fullmatch', ctx=Load()), Constant(value=None), Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load())], ctx=Load())), If(test=Compare(left=Name(id='func', ctx=Load()), ops=[NotIn()], comparators=[Name(id='valid_funcs', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="'func' must be one of {}."), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Name(id='e', ctx=Load()), Attribute(value=Name(id='e', ctx=Load()), attr='__name__', ctx=Load())]), Constant(value='None')]), generators=[comprehension(target=Name(id='e', ctx=Store()), iter=Call(func=Name(id='set', ctx=Load()), args=[Name(id='valid_funcs', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='regex', ctx=Load()), Name(id='Pattern', ctx=Load())], keywords=[]), body=[If(test=Name(id='flags', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="'flags' can only be used with a string pattern; pass flags to re.compile() instead")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='pattern', ctx=Store())], value=Name(id='regex', ctx=Load()))], orelse=[Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='regex', ctx=Load()), Name(id='flags', ctx=Load())], keywords=[]))]), If(test=Compare(left=Name(id='func', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load())]), body=[Assign(targets=[Name(id='match_func', ctx=Store())], value=Attribute(value=Name(id='pattern', ctx=Load()), attr='match', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='func', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load())]), body=[Assign(targets=[Name(id='match_func', ctx=Store())], value=Attribute(value=Name(id='pattern', ctx=Load()), attr='search', ctx=Load()))], orelse=[Assign(targets=[Name(id='match_func', ctx=Store())], value=Attribute(value=Name(id='pattern', ctx=Load()), attr='fullmatch', ctx=Load()))])]), Return(value=Call(func=Name(id='_MatchesReValidator', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Name(id='match_func', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_ProvidesValidator', bases=[], keywords=[], body=[Assign(targets=[Name(id='interface', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        We use a callable class to be able to change the ``__repr__``.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='interface', ctx=Load()), attr='providedBy', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="'{name}' must provide {interface!r} which {value!r} doesn't."), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='attr', ctx=Load()), attr='name', ctx=Load())), keyword(arg='interface', value=Attribute(value=Name(id='self', ctx=Load()), attr='interface', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load()))]), Name(id='attr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='interface', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<provides validator for interface {interface!r}>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='interface', value=Attribute(value=Name(id='self', ctx=Load()), attr='interface', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='slots', value=Constant(value=True)), keyword(arg='hash', value=Constant(value=True))])]), FunctionDef(name='provides', args=arguments(posonlyargs=[], args=[arg(arg='interface')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A validator that raises a `TypeError` if the initializer is called\n    with an object that does not provide the requested *interface* (checks are\n    performed using ``interface.providedBy(value)`` (see `zope.interface\n    <https://zopeinterface.readthedocs.io/en/latest/>`_).\n\n    :param interface: The interface to check for.\n    :type interface: ``zope.interface.Interface``\n\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attrs.Attribute`), the expected interface, and the\n        value it got.\n\n    .. deprecated:: 23.1.0\n    ')), Import(names=[alias(name='warnings')]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value="attrs's zope-interface support is deprecated and will be removed in, or after, April 2024."), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))])), Return(value=Call(func=Name(id='_ProvidesValidator', ctx=Load()), args=[Name(id='interface', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_OptionalValidator', bases=[], keywords=[], body=[Assign(targets=[Name(id='validator', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='validator', ctx=Load()), args=[Name(id='inst', ctx=Load()), Name(id='attr', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<optional validator for {what} or None>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='what', value=Call(func=Name(id='repr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='validator', ctx=Load())], keywords=[]))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='slots', value=Constant(value=True)), keyword(arg='hash', value=Constant(value=True))])]), FunctionDef(name='optional', args=arguments(posonlyargs=[], args=[arg(arg='validator')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A validator that makes an attribute optional.  An optional attribute is one\n    which can be set to ``None`` in addition to satisfying the requirements of\n    the sub-validator.\n\n    :param Callable | tuple[Callable] | list[Callable] validator: A validator\n        (or validators) that is used for non-``None`` values.\n\n    .. versionadded:: 15.1.0\n    .. versionchanged:: 17.1.0 *validator* can be a list of validators.\n    .. versionchanged:: 23.1.0 *validator* can also be a tuple of validators.\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='validator', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[]), body=[Return(value=Call(func=Name(id='_OptionalValidator', ctx=Load()), args=[Call(func=Name(id='_AndValidator', ctx=Load()), args=[Name(id='validator', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='_OptionalValidator', ctx=Load()), args=[Name(id='validator', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_InValidator', bases=[], keywords=[], body=[Assign(targets=[Name(id='options', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='in_options', ctx=Store())], value=Compare(left=Name(id='value', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Load())]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Assign(targets=[Name(id='in_options', ctx=Store())], value=Constant(value=False))])], orelse=[], finalbody=[]), If(test=UnaryOp(op=Not(), operand=Name(id='in_options', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="'{name}' must be in {options!r} (got {value!r})"), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='attr', ctx=Load()), attr='name', ctx=Load())), keyword(arg='options', value=Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load()))]), Name(id='attr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<in_ validator with options {options!r}>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='options', value=Attribute(value=Name(id='self', ctx=Load()), attr='options', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='slots', value=Constant(value=True)), keyword(arg='hash', value=Constant(value=True))])]), FunctionDef(name='in_', args=arguments(posonlyargs=[], args=[arg(arg='options')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A validator that raises a `ValueError` if the initializer is called\n    with a value that does not belong in the options provided.  The check is\n    performed using ``value in options``.\n\n    :param options: Allowed options.\n    :type options: list, tuple, `enum.Enum`, ...\n\n    :raises ValueError: With a human readable error message, the attribute (of\n       type `attrs.Attribute`), the expected options, and the value it\n       got.\n\n    .. versionadded:: 17.1.0\n    .. versionchanged:: 22.1.0\n       The ValueError was incomplete until now and only contained the human\n       readable error message. Now it contains all the information that has\n       been promised since 17.1.0.\n    ')), Return(value=Call(func=Name(id='_InValidator', ctx=Load()), args=[Name(id='options', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_IsCallableValidator', bases=[], keywords=[], body=[FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        We use a callable class to be able to change the ``__repr__``.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='message', ctx=Store())], value=Constant(value="'{name}' must be callable (got {value!r} that is a {actual!r}).")), Raise(exc=Call(func=Name(id='NotCallableError', ctx=Load()), args=[], keywords=[keyword(arg='msg', value=Call(func=Attribute(value=Name(id='message', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='attr', ctx=Load()), attr='name', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load())), keyword(arg='actual', value=Attribute(value=Name(id='value', ctx=Load()), attr='__class__', ctx=Load()))])), keyword(arg='value', value=Name(id='value', ctx=Load()))]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Constant(value='<is_callable validator>'))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='slots', value=Constant(value=False)), keyword(arg='hash', value=Constant(value=True))])]), FunctionDef(name='is_callable', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A validator that raises a `attrs.exceptions.NotCallableError` if the\n    initializer is called with a value for this particular attribute\n    that is not callable.\n\n    .. versionadded:: 19.1.0\n\n    :raises attrs.exceptions.NotCallableError: With a human readable error\n        message containing the attribute (`attrs.Attribute`) name,\n        and the value it got.\n    ')), Return(value=Call(func=Name(id='_IsCallableValidator', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), ClassDef(name='_DeepIterable', bases=[], keywords=[], body=[Assign(targets=[Name(id='member_validator', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[keyword(arg='validator', value=Call(func=Name(id='is_callable', ctx=Load()), args=[], keywords=[]))])), Assign(targets=[Name(id='iterable_validator', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[keyword(arg='default', value=Constant(value=None)), keyword(arg='validator', value=Call(func=Name(id='optional', ctx=Load()), args=[Call(func=Name(id='is_callable', ctx=Load()), args=[], keywords=[])], keywords=[]))])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        We use a callable class to be able to change the ``__repr__``.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='iterable_validator', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='iterable_validator', ctx=Load()), args=[Name(id='inst', ctx=Load()), Name(id='attr', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='member', ctx=Store()), iter=Name(id='value', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='member_validator', ctx=Load()), args=[Name(id='inst', ctx=Load()), Name(id='attr', ctx=Load()), Name(id='member', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='iterable_identifier', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='iterable_validator', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Constant(value=''), orelse=JoinedStr(values=[Constant(value=' '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='iterable_validator', ctx=Load()), conversion=114)]))), Return(value=Call(func=Attribute(value=Constant(value='<deep_iterable validator for{iterable_identifier} iterables of {member!r}>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='iterable_identifier', value=Name(id='iterable_identifier', ctx=Load())), keyword(arg='member', value=Attribute(value=Name(id='self', ctx=Load()), attr='member_validator', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='slots', value=Constant(value=True)), keyword(arg='hash', value=Constant(value=True))])]), FunctionDef(name='deep_iterable', args=arguments(posonlyargs=[], args=[arg(arg='member_validator'), arg(arg='iterable_validator')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    A validator that performs deep validation of an iterable.\n\n    :param member_validator: Validator(s) to apply to iterable members\n    :param iterable_validator: Validator to apply to iterable itself\n        (optional)\n\n    .. versionadded:: 19.1.0\n\n    :raises TypeError: if any sub-validators fail\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='member_validator', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Name(id='tuple', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='member_validator', ctx=Store())], value=Call(func=Name(id='and_', ctx=Load()), args=[Starred(value=Name(id='member_validator', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='_DeepIterable', ctx=Load()), args=[Name(id='member_validator', ctx=Load()), Name(id='iterable_validator', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_DeepMapping', bases=[], keywords=[], body=[Assign(targets=[Name(id='key_validator', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[keyword(arg='validator', value=Call(func=Name(id='is_callable', ctx=Load()), args=[], keywords=[]))])), Assign(targets=[Name(id='value_validator', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[keyword(arg='validator', value=Call(func=Name(id='is_callable', ctx=Load()), args=[], keywords=[]))])), Assign(targets=[Name(id='mapping_validator', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[keyword(arg='default', value=Constant(value=None)), keyword(arg='validator', value=Call(func=Name(id='optional', ctx=Load()), args=[Call(func=Name(id='is_callable', ctx=Load()), args=[], keywords=[])], keywords=[]))])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        We use a callable class to be able to change the ``__repr__``.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='mapping_validator', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='mapping_validator', ctx=Load()), args=[Name(id='inst', ctx=Load()), Name(id='attr', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='key', ctx=Store()), iter=Name(id='value', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='key_validator', ctx=Load()), args=[Name(id='inst', ctx=Load()), Name(id='attr', ctx=Load()), Name(id='key', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='value_validator', ctx=Load()), args=[Name(id='inst', ctx=Load()), Name(id='attr', ctx=Load()), Subscript(value=Name(id='value', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<deep_mapping validator for objects mapping {key!r} to {value!r}>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Attribute(value=Name(id='self', ctx=Load()), attr='key_validator', ctx=Load())), keyword(arg='value', value=Attribute(value=Name(id='self', ctx=Load()), attr='value_validator', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='slots', value=Constant(value=True)), keyword(arg='hash', value=Constant(value=True))])]), FunctionDef(name='deep_mapping', args=arguments(posonlyargs=[], args=[arg(arg='key_validator'), arg(arg='value_validator'), arg(arg='mapping_validator')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    A validator that performs deep validation of a dictionary.\n\n    :param key_validator: Validator to apply to dictionary keys\n    :param value_validator: Validator to apply to dictionary values\n    :param mapping_validator: Validator to apply to top-level mapping\n        attribute (optional)\n\n    .. versionadded:: 19.1.0\n\n    :raises TypeError: if any sub-validators fail\n    ')), Return(value=Call(func=Name(id='_DeepMapping', ctx=Load()), args=[Name(id='key_validator', ctx=Load()), Name(id='value_validator', ctx=Load()), Name(id='mapping_validator', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_NumberValidator', bases=[], keywords=[], body=[Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='compare_op', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='compare_func', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        We use a callable class to be able to change the ``__repr__``.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compare_func', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='bound', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="'{name}' must be {op} {bound}: {value}"), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='attr', ctx=Load()), attr='name', ctx=Load())), keyword(arg='op', value=Attribute(value=Name(id='self', ctx=Load()), attr='compare_op', ctx=Load())), keyword(arg='bound', value=Attribute(value=Name(id='self', ctx=Load()), attr='bound', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load()))])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<Validator for x {op} {bound}>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='op', value=Attribute(value=Name(id='self', ctx=Load()), attr='compare_op', ctx=Load())), keyword(arg='bound', value=Attribute(value=Name(id='self', ctx=Load()), attr='bound', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='frozen', value=Constant(value=True)), keyword(arg='slots', value=Constant(value=True))])]), FunctionDef(name='lt', args=arguments(posonlyargs=[], args=[arg(arg='val')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A validator that raises `ValueError` if the initializer is called\n    with a number larger or equal to *val*.\n\n    :param val: Exclusive upper bound for values\n\n    .. versionadded:: 21.3.0\n    ')), Return(value=Call(func=Name(id='_NumberValidator', ctx=Load()), args=[Name(id='val', ctx=Load()), Constant(value='<'), Attribute(value=Name(id='operator', ctx=Load()), attr='lt', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='le', args=arguments(posonlyargs=[], args=[arg(arg='val')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A validator that raises `ValueError` if the initializer is called\n    with a number greater than *val*.\n\n    :param val: Inclusive upper bound for values\n\n    .. versionadded:: 21.3.0\n    ')), Return(value=Call(func=Name(id='_NumberValidator', ctx=Load()), args=[Name(id='val', ctx=Load()), Constant(value='<='), Attribute(value=Name(id='operator', ctx=Load()), attr='le', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='ge', args=arguments(posonlyargs=[], args=[arg(arg='val')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A validator that raises `ValueError` if the initializer is called\n    with a number smaller than *val*.\n\n    :param val: Inclusive lower bound for values\n\n    .. versionadded:: 21.3.0\n    ')), Return(value=Call(func=Name(id='_NumberValidator', ctx=Load()), args=[Name(id='val', ctx=Load()), Constant(value='>='), Attribute(value=Name(id='operator', ctx=Load()), attr='ge', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='gt', args=arguments(posonlyargs=[], args=[arg(arg='val')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A validator that raises `ValueError` if the initializer is called\n    with a number smaller or equal to *val*.\n\n    :param val: Exclusive lower bound for values\n\n    .. versionadded:: 21.3.0\n    ')), Return(value=Call(func=Name(id='_NumberValidator', ctx=Load()), args=[Name(id='val', ctx=Load()), Constant(value='>'), Attribute(value=Name(id='operator', ctx=Load()), attr='gt', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_MaxLengthValidator', bases=[], keywords=[], body=[Assign(targets=[Name(id='max_length', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        We use a callable class to be able to change the ``__repr__``.\n        ')), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='max_length', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="Length of '{name}' must be <= {max}: {len}"), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='attr', ctx=Load()), attr='name', ctx=Load())), keyword(arg='max', value=Attribute(value=Name(id='self', ctx=Load()), attr='max_length', ctx=Load())), keyword(arg='len', value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<max_len validator for '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='max_length', ctx=Load()), conversion=-1), Constant(value='>')]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='frozen', value=Constant(value=True)), keyword(arg='slots', value=Constant(value=True))])]), FunctionDef(name='max_len', args=arguments(posonlyargs=[], args=[arg(arg='length')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A validator that raises `ValueError` if the initializer is called\n    with a string or iterable that is longer than *length*.\n\n    :param int length: Maximum length of the string or iterable\n\n    .. versionadded:: 21.3.0\n    ')), Return(value=Call(func=Name(id='_MaxLengthValidator', ctx=Load()), args=[Name(id='length', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_MinLengthValidator', bases=[], keywords=[], body=[Assign(targets=[Name(id='min_length', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        We use a callable class to be able to change the ``__repr__``.\n        ')), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='min_length', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="Length of '{name}' must be => {min}: {len}"), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='attr', ctx=Load()), attr='name', ctx=Load())), keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='min_length', ctx=Load())), keyword(arg='len', value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=JoinedStr(values=[Constant(value='<min_len validator for '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='min_length', ctx=Load()), conversion=-1), Constant(value='>')]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='frozen', value=Constant(value=True)), keyword(arg='slots', value=Constant(value=True))])]), FunctionDef(name='min_len', args=arguments(posonlyargs=[], args=[arg(arg='length')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    A validator that raises `ValueError` if the initializer is called\n    with a string or iterable that is shorter than *length*.\n\n    :param int length: Minimum length of the string or iterable\n\n    .. versionadded:: 22.1.0\n    ')), Return(value=Call(func=Name(id='_MinLengthValidator', ctx=Load()), args=[Name(id='length', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_SubclassOfValidator', bases=[], keywords=[], body=[Assign(targets=[Name(id='type', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        We use a callable class to be able to change the ``__repr__``.\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='issubclass', ctx=Load()), args=[Name(id='value', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value="'{name}' must be a subclass of {type!r} (got {value!r})."), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Attribute(value=Name(id='attr', ctx=Load()), attr='name', ctx=Load())), keyword(arg='type', value=Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Load())), keyword(arg='value', value=Name(id='value', ctx=Load()))]), Name(id='attr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<subclass_of validator for type {type!r}>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='type', value=Attribute(value=Name(id='self', ctx=Load()), attr='type', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='slots', value=Constant(value=True)), keyword(arg='hash', value=Constant(value=True))])]), FunctionDef(name='_subclass_of', args=arguments(posonlyargs=[], args=[arg(arg='type')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    A validator that raises a `TypeError` if the initializer is called\n    with a wrong type for this particular attribute (checks are performed using\n    `issubclass` therefore it's also valid to pass a tuple of types).\n\n    :param type: The type to check for.\n    :type type: type or tuple of types\n\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attrs.Attribute`), the expected type, and the value it\n        got.\n    ")), Return(value=Call(func=Name(id='_SubclassOfValidator', ctx=Load()), args=[Name(id='type', ctx=Load())], keywords=[]))], decorator_list=[]), ClassDef(name='_NotValidator', bases=[], keywords=[], body=[Assign(targets=[Name(id='validator', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='msg', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[keyword(arg='converter', value=Call(func=Name(id='default_if_none', ctx=Load()), args=[Constant(value="not_ validator child '{validator!r}' did not raise a captured error")], keywords=[]))])), Assign(targets=[Name(id='exc_types', ctx=Store())], value=Call(func=Name(id='attrib', ctx=Load()), args=[], keywords=[keyword(arg='validator', value=Call(func=Name(id='deep_iterable', ctx=Load()), args=[], keywords=[keyword(arg='member_validator', value=Call(func=Name(id='_subclass_of', ctx=Load()), args=[Name(id='Exception', ctx=Load())], keywords=[])), keyword(arg='iterable_validator', value=Call(func=Name(id='instance_of', ctx=Load()), args=[Name(id='tuple', ctx=Load())], keywords=[]))]))])), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='inst'), arg(arg='attr'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='validator', ctx=Load()), args=[Name(id='inst', ctx=Load()), Name(id='attr', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='self', ctx=Load()), attr='exc_types', ctx=Load()), body=[Pass()])], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='msg', ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='validator', value=Attribute(value=Name(id='self', ctx=Load()), attr='validator', ctx=Load())), keyword(arg='exc_types', value=Attribute(value=Name(id='self', ctx=Load()), attr='exc_types', ctx=Load()))]), Name(id='attr', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='validator', ctx=Load()), Name(id='value', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='exc_types', ctx=Load())], keywords=[]))], finalbody=[])], decorator_list=[]), FunctionDef(name='__repr__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Call(func=Attribute(value=Constant(value='<not_ validator wrapping {what!r}, capturing {exc_types!r}>'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='what', value=Attribute(value=Name(id='self', ctx=Load()), attr='validator', ctx=Load())), keyword(arg='exc_types', value=Attribute(value=Name(id='self', ctx=Load()), attr='exc_types', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='attrs', ctx=Load()), args=[], keywords=[keyword(arg='repr', value=Constant(value=False)), keyword(arg='slots', value=Constant(value=True)), keyword(arg='hash', value=Constant(value=True))])]), FunctionDef(name='not_', args=arguments(posonlyargs=[], args=[arg(arg='validator')], kwonlyargs=[arg(arg='msg'), arg(arg='exc_types')], kw_defaults=[Constant(value=None), Tuple(elts=[Name(id='ValueError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load())], defaults=[]), body=[Expr(value=Constant(value="\n    A validator that wraps and logically 'inverts' the validator passed to it.\n    It will raise a `ValueError` if the provided validator *doesn't* raise a\n    `ValueError` or `TypeError` (by default), and will suppress the exception\n    if the provided validator *does*.\n\n    Intended to be used with existing validators to compose logic without\n    needing to create inverted variants, for example, ``not_(in_(...))``.\n\n    :param validator: A validator to be logically inverted.\n    :param msg: Message to raise if validator fails.\n        Formatted with keys ``exc_types`` and ``validator``.\n    :type msg: str\n    :param exc_types: Exception type(s) to capture.\n        Other types raised by child validators will not be intercepted and\n        pass through.\n\n    :raises ValueError: With a human readable error message,\n        the attribute (of type `attrs.Attribute`),\n        the validator that failed to raise an exception,\n        the value it got,\n        and the expected exception types.\n\n    .. versionadded:: 22.2.0\n    ")), Try(body=[Assign(targets=[Name(id='exc_types', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Name(id='exc_types', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Assign(targets=[Name(id='exc_types', ctx=Store())], value=Tuple(elts=[Name(id='exc_types', ctx=Load())], ctx=Load()))])], orelse=[], finalbody=[]), Return(value=Call(func=Name(id='_NotValidator', ctx=Load()), args=[Name(id='validator', ctx=Load()), Name(id='msg', ctx=Load()), Name(id='exc_types', ctx=Load())], keywords=[]))], decorator_list=[])], type_ignores=[])