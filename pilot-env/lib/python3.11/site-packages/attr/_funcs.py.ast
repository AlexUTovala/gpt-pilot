Module(body=[Import(names=[alias(name='copy')]), ImportFrom(module='_compat', names=[alias(name='PY_3_9_PLUS'), alias(name='get_generic_base')], level=1), ImportFrom(module='_make', names=[alias(name='NOTHING'), alias(name='_obj_setattr'), alias(name='fields')], level=1), ImportFrom(module='exceptions', names=[alias(name='AttrsAttributeNotFoundError')], level=1), FunctionDef(name='asdict', args=arguments(posonlyargs=[], args=[arg(arg='inst'), arg(arg='recurse'), arg(arg='filter'), arg(arg='dict_factory'), arg(arg='retain_collection_types'), arg(arg='value_serializer')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=None), Name(id='dict', ctx=Load()), Constant(value=False), Constant(value=None)]), body=[Expr(value=Constant(value='\n    Return the *attrs* attribute values of *inst* as a dict.\n\n    Optionally recurse into other *attrs*-decorated classes.\n\n    :param inst: Instance of an *attrs*-decorated class.\n    :param bool recurse: Recurse into classes that are also\n        *attrs*-decorated.\n    :param callable filter: A callable whose return code determines whether an\n        attribute or element is included (``True``) or dropped (``False``).  Is\n        called with the `attrs.Attribute` as the first argument and the\n        value as the second argument.\n    :param callable dict_factory: A callable to produce dictionaries from.  For\n        example, to produce ordered dictionaries instead of normal Python\n        dictionaries, pass in ``collections.OrderedDict``.\n    :param bool retain_collection_types: Do not convert to ``list`` when\n        encountering an attribute whose type is ``tuple`` or ``set``.  Only\n        meaningful if ``recurse`` is ``True``.\n    :param Optional[callable] value_serializer: A hook that is called for every\n        attribute or dict key/value.  It receives the current instance, field\n        and value and must return the (updated) value.  The hook is run *after*\n        the optional *filter* has been applied.\n\n    :rtype: return type of *dict_factory*\n\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    ..  versionadded:: 16.0.0 *dict_factory*\n    ..  versionadded:: 16.1.0 *retain_collection_types*\n    ..  versionadded:: 20.3.0 *value_serializer*\n    ..  versionadded:: 21.3.0 If a dict has a collection for a key, it is\n        serialized as a tuple.\n    ')), Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Name(id='fields', ctx=Load()), args=[Attribute(value=Name(id='inst', ctx=Load()), attr='__class__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Name(id='dict_factory', ctx=Load()), args=[], keywords=[])), For(target=Name(id='a', ctx=Store()), iter=Name(id='attrs', ctx=Load()), body=[Assign(targets=[Name(id='v', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='inst', ctx=Load()), Attribute(value=Name(id='a', ctx=Load()), attr='name', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='filter', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Name(id='filter', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='v', ctx=Load())], keywords=[]))]), body=[Continue()], orelse=[]), If(test=Compare(left=Name(id='value_serializer', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='v', ctx=Store())], value=Call(func=Name(id='value_serializer', ctx=Load()), args=[Name(id='inst', ctx=Load()), Name(id='a', ctx=Load()), Name(id='v', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='recurse', ctx=Load()), ops=[Is()], comparators=[Constant(value=True)]), body=[If(test=Call(func=Name(id='has', ctx=Load()), args=[Attribute(value=Name(id='v', ctx=Load()), attr='__class__', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='rv', ctx=Load()), slice=Attribute(value=Name(id='a', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='asdict', ctx=Load()), args=[Name(id='v', ctx=Load())], keywords=[keyword(arg='recurse', value=Constant(value=True)), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='dict_factory', value=Name(id='dict_factory', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain_collection_types', ctx=Load())), keyword(arg='value_serializer', value=Name(id='value_serializer', ctx=Load()))]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='v', ctx=Load()), Tuple(elts=[Name(id='tuple', ctx=Load()), Name(id='list', ctx=Load()), Name(id='set', ctx=Load()), Name(id='frozenset', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='cf', ctx=Store())], value=IfExp(test=Compare(left=Name(id='retain_collection_types', ctx=Load()), ops=[Is()], comparators=[Constant(value=True)]), body=Attribute(value=Name(id='v', ctx=Load()), attr='__class__', ctx=Load()), orelse=Name(id='list', ctx=Load()))), Assign(targets=[Subscript(value=Name(id='rv', ctx=Load()), slice=Attribute(value=Name(id='a', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='cf', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='_asdict_anything', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[keyword(arg='is_key', value=Constant(value=False)), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='dict_factory', value=Name(id='dict_factory', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain_collection_types', ctx=Load())), keyword(arg='value_serializer', value=Name(id='value_serializer', ctx=Load()))]), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Name(id='v', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='v', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='df', ctx=Store())], value=Name(id='dict_factory', ctx=Load())), Assign(targets=[Subscript(value=Name(id='rv', ctx=Load()), slice=Attribute(value=Name(id='a', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='df', ctx=Load()), args=[GeneratorExp(elt=Tuple(elts=[Call(func=Name(id='_asdict_anything', ctx=Load()), args=[Name(id='kk', ctx=Load())], keywords=[keyword(arg='is_key', value=Constant(value=True)), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='dict_factory', value=Name(id='df', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain_collection_types', ctx=Load())), keyword(arg='value_serializer', value=Name(id='value_serializer', ctx=Load()))]), Call(func=Name(id='_asdict_anything', ctx=Load()), args=[Name(id='vv', ctx=Load())], keywords=[keyword(arg='is_key', value=Constant(value=False)), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='dict_factory', value=Name(id='df', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain_collection_types', ctx=Load())), keyword(arg='value_serializer', value=Name(id='value_serializer', ctx=Load()))])], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='kk', ctx=Store()), Name(id='vv', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='v', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assign(targets=[Subscript(value=Name(id='rv', ctx=Load()), slice=Attribute(value=Name(id='a', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Name(id='v', ctx=Load()))])])])], orelse=[Assign(targets=[Subscript(value=Name(id='rv', ctx=Load()), slice=Attribute(value=Name(id='a', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Name(id='v', ctx=Load()))])], orelse=[]), Return(value=Name(id='rv', ctx=Load()))], decorator_list=[]), FunctionDef(name='_asdict_anything', args=arguments(posonlyargs=[], args=[arg(arg='val'), arg(arg='is_key'), arg(arg='filter'), arg(arg='dict_factory'), arg(arg='retain_collection_types'), arg(arg='value_serializer')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    ``asdict`` only works on attrs instances, this works on anything.\n    ')), If(test=Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='val', ctx=Load()), attr='__class__', ctx=Load()), Constant(value='__attrs_attrs__'), Constant(value=None)], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Name(id='asdict', ctx=Load()), args=[Name(id='val', ctx=Load())], keywords=[keyword(arg='recurse', value=Constant(value=True)), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='dict_factory', value=Name(id='dict_factory', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain_collection_types', ctx=Load())), keyword(arg='value_serializer', value=Name(id='value_serializer', ctx=Load()))]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='val', ctx=Load()), Tuple(elts=[Name(id='tuple', ctx=Load()), Name(id='list', ctx=Load()), Name(id='set', ctx=Load()), Name(id='frozenset', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='retain_collection_types', ctx=Load()), ops=[Is()], comparators=[Constant(value=True)]), body=[Assign(targets=[Name(id='cf', ctx=Store())], value=Attribute(value=Name(id='val', ctx=Load()), attr='__class__', ctx=Load()))], orelse=[If(test=Name(id='is_key', ctx=Load()), body=[Assign(targets=[Name(id='cf', ctx=Store())], value=Name(id='tuple', ctx=Load()))], orelse=[Assign(targets=[Name(id='cf', ctx=Store())], value=Name(id='list', ctx=Load()))])]), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Name(id='cf', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='_asdict_anything', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[keyword(arg='is_key', value=Constant(value=False)), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='dict_factory', value=Name(id='dict_factory', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain_collection_types', ctx=Load())), keyword(arg='value_serializer', value=Name(id='value_serializer', ctx=Load()))]), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Name(id='val', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='val', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='df', ctx=Store())], value=Name(id='dict_factory', ctx=Load())), Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Name(id='df', ctx=Load()), args=[GeneratorExp(elt=Tuple(elts=[Call(func=Name(id='_asdict_anything', ctx=Load()), args=[Name(id='kk', ctx=Load())], keywords=[keyword(arg='is_key', value=Constant(value=True)), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='dict_factory', value=Name(id='df', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain_collection_types', ctx=Load())), keyword(arg='value_serializer', value=Name(id='value_serializer', ctx=Load()))]), Call(func=Name(id='_asdict_anything', ctx=Load()), args=[Name(id='vv', ctx=Load())], keywords=[keyword(arg='is_key', value=Constant(value=False)), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='dict_factory', value=Name(id='df', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain_collection_types', ctx=Load())), keyword(arg='value_serializer', value=Name(id='value_serializer', ctx=Load()))])], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='kk', ctx=Store()), Name(id='vv', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='val', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]))], orelse=[Assign(targets=[Name(id='rv', ctx=Store())], value=Name(id='val', ctx=Load())), If(test=Compare(left=Name(id='value_serializer', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='rv', ctx=Store())], value=Call(func=Name(id='value_serializer', ctx=Load()), args=[Constant(value=None), Constant(value=None), Name(id='rv', ctx=Load())], keywords=[]))], orelse=[])])])]), Return(value=Name(id='rv', ctx=Load()))], decorator_list=[]), FunctionDef(name='astuple', args=arguments(posonlyargs=[], args=[arg(arg='inst'), arg(arg='recurse'), arg(arg='filter'), arg(arg='tuple_factory'), arg(arg='retain_collection_types')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True), Constant(value=None), Name(id='tuple', ctx=Load()), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Return the *attrs* attribute values of *inst* as a tuple.\n\n    Optionally recurse into other *attrs*-decorated classes.\n\n    :param inst: Instance of an *attrs*-decorated class.\n    :param bool recurse: Recurse into classes that are also\n        *attrs*-decorated.\n    :param callable filter: A callable whose return code determines whether an\n        attribute or element is included (``True``) or dropped (``False``).  Is\n        called with the `attrs.Attribute` as the first argument and the\n        value as the second argument.\n    :param callable tuple_factory: A callable to produce tuples from.  For\n        example, to produce lists instead of tuples.\n    :param bool retain_collection_types: Do not convert to ``list``\n        or ``dict`` when encountering an attribute which type is\n        ``tuple``, ``dict`` or ``set``.  Only meaningful if ``recurse`` is\n        ``True``.\n\n    :rtype: return type of *tuple_factory*\n\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    ..  versionadded:: 16.2.0\n    ')), Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Name(id='fields', ctx=Load()), args=[Attribute(value=Name(id='inst', ctx=Load()), attr='__class__', ctx=Load())], keywords=[])), Assign(targets=[Name(id='rv', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='retain', ctx=Store())], value=Name(id='retain_collection_types', ctx=Load())), For(target=Name(id='a', ctx=Store()), iter=Name(id='attrs', ctx=Load()), body=[Assign(targets=[Name(id='v', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='inst', ctx=Load()), Attribute(value=Name(id='a', ctx=Load()), attr='name', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='filter', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), UnaryOp(op=Not(), operand=Call(func=Name(id='filter', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='v', ctx=Load())], keywords=[]))]), body=[Continue()], orelse=[]), If(test=Compare(left=Name(id='recurse', ctx=Load()), ops=[Is()], comparators=[Constant(value=True)]), body=[If(test=Call(func=Name(id='has', ctx=Load()), args=[Attribute(value=Name(id='v', ctx=Load()), attr='__class__', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='astuple', ctx=Load()), args=[Name(id='v', ctx=Load())], keywords=[keyword(arg='recurse', value=Constant(value=True)), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='tuple_factory', value=Name(id='tuple_factory', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain', ctx=Load()))])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='v', ctx=Load()), Tuple(elts=[Name(id='tuple', ctx=Load()), Name(id='list', ctx=Load()), Name(id='set', ctx=Load()), Name(id='frozenset', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='cf', ctx=Store())], value=IfExp(test=Compare(left=Name(id='retain', ctx=Load()), ops=[Is()], comparators=[Constant(value=True)]), body=Attribute(value=Name(id='v', ctx=Load()), attr='__class__', ctx=Load()), orelse=Name(id='list', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='cf', ctx=Load()), args=[ListComp(elt=IfExp(test=Call(func=Name(id='has', ctx=Load()), args=[Attribute(value=Name(id='j', ctx=Load()), attr='__class__', ctx=Load())], keywords=[]), body=Call(func=Name(id='astuple', ctx=Load()), args=[Name(id='j', ctx=Load())], keywords=[keyword(arg='recurse', value=Constant(value=True)), keyword(arg='filter', value=Name(id='filter', ctx=Load())), keyword(arg='tuple_factory', value=Name(id='tuple_factory', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain', ctx=Load()))]), orelse=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Name(id='v', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='v', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='df', ctx=Store())], value=IfExp(test=Compare(left=Name(id='retain', ctx=Load()), ops=[Is()], comparators=[Constant(value=True)]), body=Attribute(value=Name(id='v', ctx=Load()), attr='__class__', ctx=Load()), orelse=Name(id='dict', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='df', ctx=Load()), args=[GeneratorExp(elt=Tuple(elts=[IfExp(test=Call(func=Name(id='has', ctx=Load()), args=[Attribute(value=Name(id='kk', ctx=Load()), attr='__class__', ctx=Load())], keywords=[]), body=Call(func=Name(id='astuple', ctx=Load()), args=[Name(id='kk', ctx=Load())], keywords=[keyword(arg='tuple_factory', value=Name(id='tuple_factory', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain', ctx=Load()))]), orelse=Name(id='kk', ctx=Load())), IfExp(test=Call(func=Name(id='has', ctx=Load()), args=[Attribute(value=Name(id='vv', ctx=Load()), attr='__class__', ctx=Load())], keywords=[]), body=Call(func=Name(id='astuple', ctx=Load()), args=[Name(id='vv', ctx=Load())], keywords=[keyword(arg='tuple_factory', value=Name(id='tuple_factory', ctx=Load())), keyword(arg='retain_collection_types', value=Name(id='retain', ctx=Load()))]), orelse=Name(id='vv', ctx=Load()))], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='kk', ctx=Store()), Name(id='vv', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='v', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='v', ctx=Load())], keywords=[]))])])])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='rv', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='v', ctx=Load())], keywords=[]))])], orelse=[]), Return(value=IfExp(test=Compare(left=Name(id='tuple_factory', ctx=Load()), ops=[Is()], comparators=[Name(id='list', ctx=Load())]), body=Name(id='rv', ctx=Load()), orelse=Call(func=Name(id='tuple_factory', ctx=Load()), args=[Name(id='rv', ctx=Load())], keywords=[])))], decorator_list=[]), FunctionDef(name='has', args=arguments(posonlyargs=[], args=[arg(arg='cls')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Check whether *cls* is a class with *attrs* attributes.\n\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n\n    :rtype: bool\n    ')), Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='__attrs_attrs__'), Constant(value=None)], keywords=[])), If(test=Compare(left=Name(id='attrs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=True))], orelse=[]), Assign(targets=[Name(id='generic_base', ctx=Store())], value=Call(func=Name(id='get_generic_base', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='generic_base', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='generic_attrs', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='generic_base', ctx=Load()), Constant(value='__attrs_attrs__'), Constant(value=None)], keywords=[])), If(test=Compare(left=Name(id='generic_attrs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__attrs_attrs__', ctx=Store())], value=Name(id='generic_attrs', ctx=Load()))], orelse=[]), Return(value=Compare(left=Name(id='generic_attrs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]))], orelse=[]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='assoc', args=arguments(posonlyargs=[], args=[arg(arg='inst')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='changes'), defaults=[]), body=[Expr(value=Constant(value="\n    Copy *inst* and apply *changes*.\n\n    This is different from `evolve` that applies the changes to the arguments\n    that create the new instance.\n\n    `evolve`'s behavior is preferable, but there are `edge cases`_ where it\n    doesn't work. Therefore `assoc` is deprecated, but will not be removed.\n\n    .. _`edge cases`: https://github.com/python-attrs/attrs/issues/251\n\n    :param inst: Instance of a class with *attrs* attributes.\n    :param changes: Keyword changes in the new copy.\n\n    :return: A copy of inst with *changes* incorporated.\n\n    :raise attrs.exceptions.AttrsAttributeNotFoundError: If *attr_name*\n        couldn't be found on *cls*.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    ..  deprecated:: 17.1.0\n        Use `attrs.evolve` instead if you can.\n        This function will not be removed du to the slightly different approach\n        compared to `attrs.evolve`.\n    ")), Assign(targets=[Name(id='new', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='copy', ctx=Load()), args=[Name(id='inst', ctx=Load())], keywords=[])), Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Name(id='fields', ctx=Load()), args=[Attribute(value=Name(id='inst', ctx=Load()), attr='__class__', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='changes', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='attrs', ctx=Load()), Name(id='k', ctx=Load()), Name(id='NOTHING', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Is()], comparators=[Name(id='NOTHING', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='AttrsAttributeNotFoundError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='k', ctx=Load()), conversion=-1), Constant(value=' is not an attrs attribute on '), FormattedValue(value=Attribute(value=Name(id='new', ctx=Load()), attr='__class__', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='_obj_setattr', ctx=Load()), args=[Name(id='new', ctx=Load()), Name(id='k', ctx=Load()), Name(id='v', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='new', ctx=Load()))], decorator_list=[]), FunctionDef(name='evolve', args=arguments(posonlyargs=[], args=[], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='changes'), defaults=[]), body=[Expr(value=Constant(value="\n    Create a new instance, based on the first positional argument with\n    *changes* applied.\n\n    :param inst: Instance of a class with *attrs* attributes.\n    :param changes: Keyword changes in the new copy.\n\n    :return: A copy of inst with *changes* incorporated.\n\n    :raise TypeError: If *attr_name* couldn't be found in the class\n        ``__init__``.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    .. versionadded:: 17.1.0\n    .. deprecated:: 23.1.0\n       It is now deprecated to pass the instance using the keyword argument\n       *inst*. It will raise a warning until at least April 2024, after which\n       it will become an error. Always pass the instance as a positional\n       argument.\n    ")), If(test=Name(id='args', ctx=Load()), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='inst', ctx=Store())], ctx=Store())], value=Name(id='args', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='evolve() takes 1 positional argument, but '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='args', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' were given')])], keywords=[]), cause=Constant(value=None))])], orelse=[], finalbody=[])], orelse=[Try(body=[Assign(targets=[Name(id='inst', ctx=Store())], value=Call(func=Attribute(value=Name(id='changes', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='inst')], keywords=[]))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="evolve() missing 1 required positional argument: 'inst'")], keywords=[]), cause=Constant(value=None))])], orelse=[], finalbody=[]), Import(names=[alias(name='warnings')]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='Passing the instance per keyword argument is deprecated and will stop working in, or after, April 2024.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Constant(value=2))]))]), Assign(targets=[Name(id='cls', ctx=Store())], value=Attribute(value=Name(id='inst', ctx=Load()), attr='__class__', ctx=Load())), Assign(targets=[Name(id='attrs', ctx=Store())], value=Call(func=Name(id='fields', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[])), For(target=Name(id='a', ctx=Store()), iter=Name(id='attrs', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='a', ctx=Load()), attr='init', ctx=Load())), body=[Continue()], orelse=[]), Assign(targets=[Name(id='attr_name', ctx=Store())], value=Attribute(value=Name(id='a', ctx=Load()), attr='name', ctx=Load())), Assign(targets=[Name(id='init_name', ctx=Store())], value=Attribute(value=Name(id='a', ctx=Load()), attr='alias', ctx=Load())), If(test=Compare(left=Name(id='init_name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='changes', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='changes', ctx=Load()), slice=Name(id='init_name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='inst', ctx=Load()), Name(id='attr_name', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='cls', ctx=Load()), args=[], keywords=[keyword(value=Name(id='changes', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='resolve_types', args=arguments(posonlyargs=[], args=[arg(arg='cls'), arg(arg='globalns'), arg(arg='localns'), arg(arg='attribs'), arg(arg='include_extras')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True)]), body=[Expr(value=Constant(value="\n    Resolve any strings and forward annotations in type annotations.\n\n    This is only required if you need concrete types in `Attribute`'s *type*\n    field. In other words, you don't need to resolve your types if you only\n    use them for static type checking.\n\n    With no arguments, names will be looked up in the module in which the class\n    was created. If this is not what you want, e.g. if the name only exists\n    inside a method, you may pass *globalns* or *localns* to specify other\n    dictionaries in which to look up these names. See the docs of\n    `typing.get_type_hints` for more details.\n\n    :param type cls: Class to resolve.\n    :param Optional[dict] globalns: Dictionary containing global variables.\n    :param Optional[dict] localns: Dictionary containing local variables.\n    :param Optional[list] attribs: List of attribs for the given class.\n        This is necessary when calling from inside a ``field_transformer``\n        since *cls* is not an *attrs* class yet.\n    :param bool include_extras: Resolve more accurately, if possible.\n        Pass ``include_extras`` to ``typing.get_hints``, if supported by the\n        typing module. On supported Python versions (3.9+), this resolves the\n        types more accurately.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class and you didn't pass any attribs.\n    :raise NameError: If types cannot be resolved because of missing variables.\n\n    :returns: *cls* so you can use this function also as a class decorator.\n        Please note that you have to apply it **after** `attrs.define`. That\n        means the decorator has to come in the line **before** `attrs.define`.\n\n    ..  versionadded:: 20.1.0\n    ..  versionadded:: 21.1.0 *attribs*\n    ..  versionadded:: 23.1.0 *include_extras*\n\n    ")), If(test=Compare(left=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='cls', ctx=Load()), Constant(value='__attrs_types_resolved__'), Constant(value=None)], keywords=[]), ops=[NotEq()], comparators=[Name(id='cls', ctx=Load())]), body=[Import(names=[alias(name='typing')]), Assign(targets=[Name(id='kwargs', ctx=Store())], value=Dict(keys=[Constant(value='globalns'), Constant(value='localns')], values=[Name(id='globalns', ctx=Load()), Name(id='localns', ctx=Load())])), If(test=Name(id='PY_3_9_PLUS', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='include_extras'), ctx=Store())], value=Name(id='include_extras', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='hints', ctx=Store())], value=Call(func=Attribute(value=Name(id='typing', ctx=Load()), attr='get_type_hints', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), For(target=Name(id='field', ctx=Store()), iter=IfExp(test=Compare(left=Name(id='attribs', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Call(func=Name(id='fields', ctx=Load()), args=[Name(id='cls', ctx=Load())], keywords=[]), orelse=Name(id='attribs', ctx=Load())), body=[If(test=Compare(left=Attribute(value=Name(id='field', ctx=Load()), attr='name', ctx=Load()), ops=[In()], comparators=[Name(id='hints', ctx=Load())]), body=[Expr(value=Call(func=Name(id='_obj_setattr', ctx=Load()), args=[Name(id='field', ctx=Load()), Constant(value='type'), Subscript(value=Name(id='hints', ctx=Load()), slice=Attribute(value=Name(id='field', ctx=Load()), attr='name', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='cls', ctx=Load()), attr='__attrs_types_resolved__', ctx=Store())], value=Name(id='cls', ctx=Load()))], orelse=[]), Return(value=Name(id='cls', ctx=Load()))], decorator_list=[])], type_ignores=[])