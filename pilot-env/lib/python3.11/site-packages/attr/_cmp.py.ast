Module(body=[Import(names=[alias(name='functools')]), Import(names=[alias(name='types')]), ImportFrom(module='_make', names=[alias(name='_make_ne')], level=1), Assign(targets=[Name(id='_operation_names', ctx=Store())], value=Dict(keys=[Constant(value='eq'), Constant(value='lt'), Constant(value='le'), Constant(value='gt'), Constant(value='ge')], values=[Constant(value='=='), Constant(value='<'), Constant(value='<='), Constant(value='>'), Constant(value='>=')])), FunctionDef(name='cmp_using', args=arguments(posonlyargs=[], args=[arg(arg='eq'), arg(arg='lt'), arg(arg='le'), arg(arg='gt'), arg(arg='ge'), arg(arg='require_same_type'), arg(arg='class_name')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value='Comparable')]), body=[Expr(value=Constant(value="\n    Create a class that can be passed into `attrs.field`'s ``eq``, ``order``,\n    and ``cmp`` arguments to customize field comparison.\n\n    The resulting class will have a full set of ordering methods if at least\n    one of ``{lt, le, gt, ge}`` and ``eq``  are provided.\n\n    :param Optional[callable] eq: `callable` used to evaluate equality of two\n        objects.\n    :param Optional[callable] lt: `callable` used to evaluate whether one\n        object is less than another object.\n    :param Optional[callable] le: `callable` used to evaluate whether one\n        object is less than or equal to another object.\n    :param Optional[callable] gt: `callable` used to evaluate whether one\n        object is greater than another object.\n    :param Optional[callable] ge: `callable` used to evaluate whether one\n        object is greater than or equal to another object.\n\n    :param bool require_same_type: When `True`, equality and ordering methods\n        will return `NotImplemented` if objects are not of the same type.\n\n    :param Optional[str] class_name: Name of class. Defaults to 'Comparable'.\n\n    See `comparison` for more details.\n\n    .. versionadded:: 21.1.0\n    ")), Assign(targets=[Name(id='body', ctx=Store())], value=Dict(keys=[Constant(value='__slots__'), Constant(value='__init__'), Constant(value='_requirements'), Constant(value='_is_comparable_to')], values=[List(elts=[Constant(value='value')], ctx=Load()), Call(func=Name(id='_make_init', ctx=Load()), args=[], keywords=[]), List(elts=[], ctx=Load()), Name(id='_is_comparable_to', ctx=Load())])), Assign(targets=[Name(id='num_order_functions', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='has_eq_function', ctx=Store())], value=Constant(value=False)), If(test=Compare(left=Name(id='eq', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='has_eq_function', ctx=Store())], value=Constant(value=True)), Assign(targets=[Subscript(value=Name(id='body', ctx=Load()), slice=Constant(value='__eq__'), ctx=Store())], value=Call(func=Name(id='_make_operator', ctx=Load()), args=[Constant(value='eq'), Name(id='eq', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='body', ctx=Load()), slice=Constant(value='__ne__'), ctx=Store())], value=Call(func=Name(id='_make_ne', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='lt', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='num_order_functions', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Subscript(value=Name(id='body', ctx=Load()), slice=Constant(value='__lt__'), ctx=Store())], value=Call(func=Name(id='_make_operator', ctx=Load()), args=[Constant(value='lt'), Name(id='lt', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='le', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='num_order_functions', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Subscript(value=Name(id='body', ctx=Load()), slice=Constant(value='__le__'), ctx=Store())], value=Call(func=Name(id='_make_operator', ctx=Load()), args=[Constant(value='le'), Name(id='le', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='gt', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='num_order_functions', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Subscript(value=Name(id='body', ctx=Load()), slice=Constant(value='__gt__'), ctx=Store())], value=Call(func=Name(id='_make_operator', ctx=Load()), args=[Constant(value='gt'), Name(id='gt', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='ge', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='num_order_functions', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Subscript(value=Name(id='body', ctx=Load()), slice=Constant(value='__ge__'), ctx=Store())], value=Call(func=Name(id='_make_operator', ctx=Load()), args=[Constant(value='ge'), Name(id='ge', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='type_', ctx=Store())], value=Call(func=Attribute(value=Name(id='types', ctx=Load()), attr='new_class', ctx=Load()), args=[Name(id='class_name', ctx=Load()), Tuple(elts=[Name(id='object', ctx=Load())], ctx=Load()), Dict(keys=[], values=[]), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='ns')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='ns', ctx=Load()), attr='update', ctx=Load()), args=[Name(id='body', ctx=Load())], keywords=[]))], keywords=[])), If(test=Name(id='require_same_type', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='type_', ctx=Load()), attr='_requirements', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='_check_same_type', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value=0), ops=[Lt(), Lt()], comparators=[Name(id='num_order_functions', ctx=Load()), Constant(value=4)]), body=[If(test=UnaryOp(op=Not(), operand=Name(id='has_eq_function', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='eq must be define is order to complete ordering from lt, le, gt, ge.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='type_', ctx=Store())], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='total_ordering', ctx=Load()), args=[Name(id='type_', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='type_', ctx=Load()))], decorator_list=[]), FunctionDef(name='_make_init', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Create __init__ method.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Initialize object with *value*.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[]), Return(value=Name(id='__init__', ctx=Load()))], decorator_list=[]), FunctionDef(name='_make_operator', args=arguments(posonlyargs=[], args=[arg(arg='name'), arg(arg='func')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Create operator method.\n    ')), FunctionDef(name='method', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_is_comparable_to', ctx=Load()), args=[Name(id='other', ctx=Load())], keywords=[])), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='func', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load()), Attribute(value=Name(id='other', ctx=Load()), attr='value', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='result', ctx=Load()), ops=[Is()], comparators=[Name(id='NotImplemented', ctx=Load())]), body=[Return(value=Name(id='NotImplemented', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='method', ctx=Load()), attr='__name__', ctx=Store())], value=JoinedStr(values=[Constant(value='__'), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='__')])), Assign(targets=[Attribute(value=Name(id='method', ctx=Load()), attr='__doc__', ctx=Store())], value=JoinedStr(values=[Constant(value='Return a '), FormattedValue(value=Subscript(value=Name(id='_operation_names', ctx=Load()), slice=Name(id='name', ctx=Load()), ctx=Load()), conversion=-1), Constant(value=' b.  Computed by attrs.')])), Return(value=Name(id='method', ctx=Load()))], decorator_list=[]), FunctionDef(name='_is_comparable_to', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Check whether `other` is comparable to `self`.\n    ')), For(target=Name(id='func', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_requirements', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='func', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='other', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=False))], orelse=[])], orelse=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='_check_same_type', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='other')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Return True if *self* and *other* are of the same type, False otherwise.\n    ')), Return(value=Compare(left=Attribute(value=Attribute(value=Name(id='other', ctx=Load()), attr='value', ctx=Load()), attr='__class__', ctx=Load()), ops=[Is()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='value', ctx=Load()), attr='__class__', ctx=Load())]))], decorator_list=[])], type_ignores=[])